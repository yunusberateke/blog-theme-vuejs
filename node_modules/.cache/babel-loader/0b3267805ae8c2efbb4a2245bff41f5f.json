{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi51cmwudG8tanNvbi5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL3JhbmdlCiAqLwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBUcmVlV2Fsa2VyIGZyb20gJy4vdHJlZXdhbGtlcic7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgY29tcGFyZUFycmF5cyBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9jb21wYXJlYXJyYXlzJzsKLyoqCiAqIFJlcHJlc2VudHMgYSByYW5nZSBpbiB0aGUgbW9kZWwgdHJlZS4KICoKICogQSByYW5nZSBpcyBkZWZpbmVkIGJ5IGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNzdGFydH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlI2VuZH0KICogcG9zaXRpb25zLgogKgogKiBZb3UgY2FuIGNyZWF0ZSByYW5nZSBpbnN0YW5jZXMgdmlhIGl0cyBjb25zdHJ1Y3RvciBvciB0aGUgYGNyZWF0ZVJhbmdlKigpYCBmYWN0b3J5IG1ldGhvZHMgb2YKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfS4KICovCgp2YXIgUmFuZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYSByYW5nZSBzcGFubmluZyBmcm9tIGBzdGFydGAgcG9zaXRpb24gdG8gYGVuZGAgcG9zaXRpb24uCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHN0YXJ0IFN0YXJ0IHBvc2l0aW9uLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gW2VuZF0gRW5kIHBvc2l0aW9uLiBJZiBub3Qgc2V0LCByYW5nZSB3aWxsIGJlIGNvbGxhcHNlZCBhdCBgc3RhcnRgIHBvc2l0aW9uLgogICAqLwogIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0KSB7CiAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZSk7CgogICAgLyoqCiAgICAgKiBTdGFydCBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KICAgIHRoaXMuc3RhcnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQoc3RhcnQpOwogICAgLyoqCiAgICAgKiBFbmQgcG9zaXRpb24uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICovCgogICAgdGhpcy5lbmQgPSBlbmQgPyBQb3NpdGlvbi5fY3JlYXRlQXQoZW5kKSA6IFBvc2l0aW9uLl9jcmVhdGVBdChzdGFydCk7IC8vIElmIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQsIHRyZWF0IGluIGEgc2ltaWxhciB3YXkgYXMgYSBwb3NpdGlvbiBhbmQgc2V0IGl0cyBib3VuZGFyaWVzIHN0aWNraW5lc3MgdG8gJ3RvTm9uZScuCiAgICAvLyBJbiBvdGhlciBjYXNlLCBtYWtlIHRoZSBib3VuZGFyaWVzIHN0aWNrIHRvIHRoZSAiaW5zaWRlIiBvZiB0aGUgcmFuZ2UuCgogICAgdGhpcy5zdGFydC5zdGlja2luZXNzID0gdGhpcy5pc0NvbGxhcHNlZCA/ICd0b05vbmUnIDogJ3RvTmV4dCc7CiAgICB0aGlzLmVuZC5zdGlja2luZXNzID0gdGhpcy5pc0NvbGxhcHNlZCA/ICd0b05vbmUnIDogJ3RvUHJldmlvdXMnOwogIH0KICAvKioKICAgKiBJdGVyYWJsZSBpbnRlcmZhY2UuCiAgICoKICAgKiBJdGVyYXRlcyBvdmVyIGFsbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gaXRlbXN9IHRoYXQgYXJlIGluIHRoaXMgcmFuZ2UgYW5kIHJldHVybnMKICAgKiB0aGVtIHRvZ2V0aGVyIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBsaWtlIGxlbmd0aCBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbnN9LAogICAqIGdyb3VwZWQgYXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9LgogICAqIEl0IGl0ZXJhdGVzIG92ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHRwcm94eX5UZXh0UHJveHkgdGV4dCBjb250ZW50c30gdGhhdCBhcmUgaW5zaWRlIHRoZSByYW5nZQogICAqIGFuZCBhbGwgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH1zIHRoYXQgYXJlIGVudGVyZWQgaW50byB3aGVuIGl0ZXJhdGluZyBvdmVyIHRoaXMgcmFuZ2UuCiAgICoKICAgKiBUaGlzIGl0ZXJhdG9yIHVzZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSB3aXRoIGBib3VuZGFyaWVzYCBzZXQgdG8gdGhpcyByYW5nZQogICAqIGFuZCBgaWdub3JlRWxlbWVudEVuZGAgb3B0aW9uIHNldCB0byBgdHJ1ZWAuCiAgICoKICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWU+fQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFJhbmdlLCBbewogICAga2V5OiBTeW1ib2wuaXRlcmF0b3IsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkgewogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0KSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKG5ldyBUcmVlV2Fsa2VyKHsKICAgICAgICAgICAgICAgIGJvdW5kYXJpZXM6IHRoaXMsCiAgICAgICAgICAgICAgICBpZ25vcmVFbGVtZW50RW5kOiB0cnVlCiAgICAgICAgICAgICAgfSksICJ0MCIsIDEpOwoKICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCB2YWx1ZSwgdGhpcyk7CiAgICB9KQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgdGhhdCBpcyBpZiB7QGxpbmsgI3N0YXJ0fSBhbmQKICAgICAqIHtAbGluayAjZW5kfSBwb3NpdGlvbnMgYXJlIGVxdWFsLgogICAgICoKICAgICAqIEB0eXBlIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQ29sbGFwc2VkIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5zdGFydC5pc0VxdWFsKHRoaXMuZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgcmFuZ2UgaXMgZmxhdCwgdGhhdCBpcyBpZiB7QGxpbmsgI3N0YXJ0fSBwb3NpdGlvbiBhbmQKICAgICAqIHtAbGluayAjZW5kfSBwb3NpdGlvbiBhcmUgaW4gdGhlIHNhbWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50fS4KICAgICAqCiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0ZsYXQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHZhciBzdGFydFBhcmVudFBhdGggPSB0aGlzLnN0YXJ0LmdldFBhcmVudFBhdGgoKTsKICAgICAgdmFyIGVuZFBhcmVudFBhdGggPSB0aGlzLmVuZC5nZXRQYXJlbnRQYXRoKCk7CiAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKHN0YXJ0UGFyZW50UGF0aCwgZW5kUGFyZW50UGF0aCkgPT0gJ3NhbWUnOwogICAgfQogICAgLyoqCiAgICAgKiBSYW5nZSByb290IGVsZW1lbnQuCiAgICAgKgogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICovCgogIH0sIHsKICAgIGtleTogInJvb3QiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnJvb3Q7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcmFuZ2UgY29udGFpbnMgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSBpcyBjb250YWluZWQKICAgICAqIGluIHRoaXMgcmFuZ2UsYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29udGFpbnNQb3NpdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb3NpdGlvbihwb3NpdGlvbikgewogICAgICByZXR1cm4gcG9zaXRpb24uaXNBZnRlcih0aGlzLnN0YXJ0KSAmJiBwb3NpdGlvbi5pc0JlZm9yZSh0aGlzLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcmFuZ2UgY29udGFpbnMgZ2l2ZW4ge0BsaW5rIH5SYW5nZSByYW5nZX0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNoZWNrLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9ZmFsc2VdIFdoZXRoZXIgdGhlIGNoZWNrIGlzIGxvb3NlIG9yIHN0cmljdC4gSWYgdGhlIGNoZWNrIGlzIHN0cmljdCAoYGZhbHNlYCksIGNvbXBhcmVkIHJhbmdlIGNhbm5vdAogICAgICogc3RhcnQgb3IgZW5kIGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIHRoaXMgcmFuZ2UgYm91bmRhcmllcy4gSWYgdGhlIGNoZWNrIGlzIGxvb3NlIChgdHJ1ZWApLCBjb21wYXJlZCByYW5nZSBjYW4gc3RhcnQsIGVuZCBvcgogICAgICogZXZlbiBiZSBlcXVhbCB0byB0aGlzIHJhbmdlLiBOb3RlIHRoYXQgY29sbGFwc2VkIHJhbmdlcyBhcmUgYWx3YXlzIGNvbXBhcmVkIGluIHN0cmljdCBtb2RlLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiB7QGxpbmsgflJhbmdlIHJhbmdlfSBib3VuZGFyaWVzIGFyZSBjb250YWluZWQgYnkgdGhpcyByYW5nZSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29udGFpbnNSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNSYW5nZShvdGhlclJhbmdlKSB7CiAgICAgIHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7CgogICAgICBpZiAob3RoZXJSYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICAgIGxvb3NlID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciBjb250YWluc1N0YXJ0ID0gdGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2Uuc3RhcnQpIHx8IGxvb3NlICYmIHRoaXMuc3RhcnQuaXNFcXVhbChvdGhlclJhbmdlLnN0YXJ0KTsKICAgICAgdmFyIGNvbnRhaW5zRW5kID0gdGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2UuZW5kKSB8fCBsb29zZSAmJiB0aGlzLmVuZC5pc0VxdWFsKG90aGVyUmFuZ2UuZW5kKTsKICAgICAgcmV0dXJuIGNvbnRhaW5zU3RhcnQgJiYgY29udGFpbnNFbmQ7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXMgaW5zaWRlIHRoaXMgcmFuZ2UuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBNb2RlbCBpdGVtIHRvIGNoZWNrLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNvbnRhaW5zSXRlbSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNJdGVtKGl0ZW0pIHsKICAgICAgdmFyIHBvcyA9IFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSk7CgogICAgICByZXR1cm4gdGhpcy5jb250YWluc1Bvc2l0aW9uKHBvcykgfHwgdGhpcy5zdGFydC5pc0VxdWFsKHBvcyk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbi4KICAgICAqCiAgICAgKgkJcmFuZ2UuaXMoICdyYW5nZScgKTsgLy8gLT4gdHJ1ZQogICAgICoJCXJhbmdlLmlzKCAnbW9kZWw6cmFuZ2UnICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJcmFuZ2UuaXMoICd2aWV3OnJhbmdlJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXJhbmdlLmlzKCAnZG9jdW1lbnRTZWxlY3Rpb24nICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI2lzIENoZWNrIHRoZSBlbnRpcmUgbGlzdCBvZiBtb2RlbCBvYmplY3RzfSB3aGljaCBpbXBsZW1lbnQgdGhlIGBpcygpYCBtZXRob2QuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUKICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpcyh0eXBlKSB7CiAgICAgIHJldHVybiB0eXBlID09PSAncmFuZ2UnIHx8IHR5cGUgPT09ICdtb2RlbDpyYW5nZSc7CiAgICB9CiAgICAvKioKICAgICAqIFR3byByYW5nZXMgYXJlIGVxdWFsIGlmIHRoZWlyIHtAbGluayAjc3RhcnR9IGFuZCB7QGxpbmsgI2VuZH0gcG9zaXRpb25zIGFyZSBlcXVhbC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gY29tcGFyZSB3aXRoLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiByYW5nZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0VxdWFsIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG90aGVyUmFuZ2UpIHsKICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuaXNFcXVhbChvdGhlclJhbmdlLnN0YXJ0KSAmJiB0aGlzLmVuZC5pc0VxdWFsKG90aGVyUmFuZ2UuZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIGFuZCByZXR1cm5zIHdoZXRoZXIgdGhpcyByYW5nZSBpbnRlcnNlY3RzIHdpdGggZ2l2ZW4gcmFuZ2UuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgcmFuZ2VzIGludGVyc2VjdCwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNJbnRlcnNlY3RpbmciLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW50ZXJzZWN0aW5nKG90aGVyUmFuZ2UpIHsKICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuaXNCZWZvcmUob3RoZXJSYW5nZS5lbmQpICYmIHRoaXMuZW5kLmlzQWZ0ZXIob3RoZXJSYW5nZS5zdGFydCk7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIHdoaWNoIHBhcnQocykgb2YgdGhpcyB7QGxpbmsgflJhbmdlIHJhbmdlfSBpcyBub3QgYSBwYXJ0IG9mIGdpdmVuIHtAbGluayB+UmFuZ2UgcmFuZ2V9LgogICAgICogUmV0dXJuZWQgYXJyYXkgY29udGFpbnMgemVybywgb25lIG9yIHR3byB7QGxpbmsgflJhbmdlIHJhbmdlc30uCiAgICAgKgogICAgICogRXhhbXBsZXM6CiAgICAgKgogICAgICoJCWxldCByYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDIsIDcgXSApLAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDQsIDAsIDEgXSApCiAgICAgKgkJKTsKICAgICAqCQlsZXQgb3RoZXJSYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDEgXSApLCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDUgXSApICk7CiAgICAgKgkJbGV0IHRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0RGlmZmVyZW5jZSggb3RoZXJSYW5nZSApOwogICAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyBubyByYW5nZXMgYmVjYXVzZSBgb3RoZXJSYW5nZWAgY29udGFpbnMgYHJhbmdlYAogICAgICoKICAgICAqCQlvdGhlclJhbmdlID0gbW9kZWwuY3JlYXRlUmFuZ2UoIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMSBdICksIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMyBdICkgKTsKICAgICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldERpZmZlcmVuY2UoIG90aGVyUmFuZ2UgKTsKICAgICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgb25lIHJhbmdlOiBmcm9tIFsgMyBdIHRvIFsgNCwgMCwgMSBdCiAgICAgKgogICAgICoJCW90aGVyUmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAzIF0gKSwgbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyA0IF0gKSApOwogICAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0RGlmZmVyZW5jZSggb3RoZXJSYW5nZSApOwogICAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyB0d28gcmFuZ2VzOiBmcm9tIFsgMiwgNyBdIHRvIFsgMyBdIGFuZCBmcm9tIFsgNCBdIHRvIFsgNCwgMCwgMSBdCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGRpZmZlcmVudGlhdGUgYWdhaW5zdC4KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcmFuZ2VzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldERpZmZlcmVuY2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpZmZlcmVuY2Uob3RoZXJSYW5nZSkgewogICAgICB2YXIgcmFuZ2VzID0gW107CgogICAgICBpZiAodGhpcy5pc0ludGVyc2VjdGluZyhvdGhlclJhbmdlKSkgewogICAgICAgIC8vIFJhbmdlcyBpbnRlcnNlY3QuCiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLnN0YXJ0KSkgewogICAgICAgICAgLy8gR2l2ZW4gcmFuZ2Ugc3RhcnQgaXMgaW5zaWRlIHRoaXMgcmFuZ2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvCiAgICAgICAgICAvLyBhZGQgc2hydW5rZW4gcmFuZ2UgLSBmcm9tIHRoZSBzdGFydCB0byB0aGUgbWlkZGxlIG9mIHRoaXMgcmFuZ2UuCiAgICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UodGhpcy5zdGFydCwgb3RoZXJSYW5nZS5zdGFydCkpOwogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLmVuZCkpIHsKICAgICAgICAgIC8vIEdpdmVuIHJhbmdlIGVuZCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8KICAgICAgICAgIC8vIGFkZCBzaHJ1bmtlbiByYW5nZSAtIGZyb20gdGhlIG1pZGRsZSBvZiB0aGlzIHJhbmdlIHRvIHRoZSBlbmQuCiAgICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2Uob3RoZXJSYW5nZS5lbmQsIHRoaXMuZW5kKSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIC8vIFJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCByZXR1cm4gdGhlIG9yaWdpbmFsIHJhbmdlLgogICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkpOwogICAgICB9CgogICAgICByZXR1cm4gcmFuZ2VzOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGludGVyc2VjdGlvbiBvZiB0aGlzIHtAbGluayB+UmFuZ2UgcmFuZ2V9IGFuZCBnaXZlbiB7QGxpbmsgflJhbmdlIHJhbmdlfS4KICAgICAqIEludGVyc2VjdGlvbiBpcyBhIGNvbW1vbiBwYXJ0IG9mIGJvdGggb2YgdGhvc2UgcmFuZ2VzLiBJZiByYW5nZXMgaGFzIG5vIGNvbW1vbiBwYXJ0LCByZXR1cm5zIGBudWxsYC4KICAgICAqCiAgICAgKiBFeGFtcGxlczoKICAgICAqCiAgICAgKgkJbGV0IHJhbmdlID0gbW9kZWwuY3JlYXRlUmFuZ2UoCiAgICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMiwgNyBdICksCiAgICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgNCwgMCwgMSBdICkKICAgICAqCQkpOwogICAgICoJCWxldCBvdGhlclJhbmdlID0gbW9kZWwuY3JlYXRlUmFuZ2UoIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMSBdICksIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMiBdICkgKTsKICAgICAqCQlsZXQgdHJhbnNmb3JtZWQgPSByYW5nZS5nZXRJbnRlcnNlY3Rpb24oIG90aGVyUmFuZ2UgKTsgLy8gbnVsbCAtIHJhbmdlcyBoYXZlIG5vIGNvbW1vbiBwYXJ0CiAgICAgKgogICAgICoJCW90aGVyUmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAzIF0gKSwgbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyA1IF0gKSApOwogICAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0SW50ZXJzZWN0aW9uKCBvdGhlclJhbmdlICk7IC8vIHJhbmdlIGZyb20gWyAzIF0gdG8gWyA0LCAwLCAxIF0KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9IEEgY29tbW9uIHBhcnQgb2YgZ2l2ZW4gcmFuZ2VzIG9yIGBudWxsYCBpZiByYW5nZXMgaGF2ZSBubyBjb21tb24gcGFydC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRJbnRlcnNlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihvdGhlclJhbmdlKSB7CiAgICAgIGlmICh0aGlzLmlzSW50ZXJzZWN0aW5nKG90aGVyUmFuZ2UpKSB7CiAgICAgICAgLy8gUmFuZ2VzIGludGVyc2VjdCwgc28gYSBjb21tb24gcmFuZ2Ugd2lsbCBiZSByZXR1cm5lZC4KICAgICAgICAvLyBBdCBtb3N0LCBpdCB3aWxsIGJlIHNhbWUgYXMgdGhpcyByYW5nZS4KICAgICAgICB2YXIgY29tbW9uUmFuZ2VTdGFydCA9IHRoaXMuc3RhcnQ7CiAgICAgICAgdmFyIGNvbW1vblJhbmdlRW5kID0gdGhpcy5lbmQ7CgogICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5zdGFydCkpIHsKICAgICAgICAgIC8vIEdpdmVuIHJhbmdlIHN0YXJ0IGlzIGluc2lkZSB0aGlzIHJhbmdlLiBUaGlzIG1lYW5zIHRoYU50IHdlIGhhdmUgdG8KICAgICAgICAgIC8vIHNocmluayBjb21tb24gcmFuZ2UgdG8gdGhlIGdpdmVuIHJhbmdlIHN0YXJ0LgogICAgICAgICAgY29tbW9uUmFuZ2VTdGFydCA9IG90aGVyUmFuZ2Uuc3RhcnQ7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2UuZW5kKSkgewogICAgICAgICAgLy8gR2l2ZW4gcmFuZ2UgZW5kIGlzIGluc2lkZSB0aGlzIHJhbmdlLiBUaGlzIG1lYW5zIHRoYXQgd2UgaGF2ZSB0bwogICAgICAgICAgLy8gc2hyaW5rIGNvbW1vbiByYW5nZSB0byB0aGUgZ2l2ZW4gcmFuZ2UgZW5kLgogICAgICAgICAgY29tbW9uUmFuZ2VFbmQgPSBvdGhlclJhbmdlLmVuZDsKICAgICAgICB9CgogICAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tbW9uUmFuZ2VTdGFydCwgY29tbW9uUmFuZ2VFbmQpOwogICAgICB9IC8vIFJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCBzbyB0aGV5IGRvIG5vdCBoYXZlIGNvbW1vbiBwYXJ0LgoKCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgcmFuZ2UgY3JlYXRlZCBieSBqb2luaW5nIHRoaXMge0BsaW5rIH5SYW5nZSByYW5nZX0gd2l0aCB0aGUgZ2l2ZW4ge0BsaW5rIH5SYW5nZSByYW5nZX0uCiAgICAgKiBJZiByYW5nZXMgaGF2ZSBubyBjb21tb24gcGFydCwgcmV0dXJucyBgbnVsbGAuCiAgICAgKgogICAgICogRXhhbXBsZXM6CiAgICAgKgogICAgICoJCWxldCByYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDIsIDcgXSApLAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDQsIDAsIDEgXSApCiAgICAgKgkJKTsKICAgICAqCQlsZXQgb3RoZXJSYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDEgXSApLAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDIgXSApCiAgICAJICoJCSk7CiAgICAgKgkJbGV0IHRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0Sm9pbmVkKCBvdGhlclJhbmdlICk7IC8vIG51bGwgLSByYW5nZXMgaGF2ZSBubyBjb21tb24gcGFydAogICAgICoKICAgICAqCQlvdGhlclJhbmdlID0gbW9kZWwuY3JlYXRlUmFuZ2UoCiAgICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMyBdICksCiAgICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgNSBdICkKICAgICAqCQkpOwogICAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0Sm9pbmVkKCBvdGhlclJhbmdlICk7IC8vIHJhbmdlIGZyb20gWyAyLCA3IF0gdG8gWyA1IF0KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gYmUgam9pbmVkLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9ZmFsc2VdIFdoZXRoZXIgdGhlIGludGVyc2VjdGlvbiBjaGVjayBpcyBsb29zZSBvciBzdHJpY3QuIElmIHRoZSBjaGVjayBpcyBzdHJpY3QgKGBmYWxzZWApLAogICAgICogcmFuZ2VzIGFyZSB0ZXN0ZWQgZm9yIGludGVyc2VjdGlvbiBvciB3aGV0aGVyIHN0YXJ0L2VuZCBwb3NpdGlvbnMgYXJlIGVxdWFsLiBJZiB0aGUgY2hlY2sgaXMgbG9vc2UgKGB0cnVlYCksCiAgICAgKiBjb21wYXJlZCByYW5nZSBpcyBhbHNvIGNoZWNrZWQgaWYgaXQncyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNpc1RvdWNoaW5nIHRvdWNoaW5nfSBjdXJyZW50IHJhbmdlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0gQSBzdW0gb2YgZ2l2ZW4gcmFuZ2VzIG9yIGBudWxsYCBpZiByYW5nZXMgaGF2ZSBubyBjb21tb24gcGFydC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRKb2luZWQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEpvaW5lZChvdGhlclJhbmdlKSB7CiAgICAgIHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7CiAgICAgIHZhciBzaG91bGRKb2luID0gdGhpcy5pc0ludGVyc2VjdGluZyhvdGhlclJhbmdlKTsKCiAgICAgIGlmICghc2hvdWxkSm9pbikgewogICAgICAgIGlmICh0aGlzLnN0YXJ0LmlzQmVmb3JlKG90aGVyUmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgICBzaG91bGRKb2luID0gbG9vc2UgPyB0aGlzLmVuZC5pc1RvdWNoaW5nKG90aGVyUmFuZ2Uuc3RhcnQpIDogdGhpcy5lbmQuaXNFcXVhbChvdGhlclJhbmdlLnN0YXJ0KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc2hvdWxkSm9pbiA9IGxvb3NlID8gb3RoZXJSYW5nZS5lbmQuaXNUb3VjaGluZyh0aGlzLnN0YXJ0KSA6IG90aGVyUmFuZ2UuZW5kLmlzRXF1YWwodGhpcy5zdGFydCk7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoIXNob3VsZEpvaW4pIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0OwogICAgICB2YXIgZW5kUG9zaXRpb24gPSB0aGlzLmVuZDsKCiAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0LmlzQmVmb3JlKHN0YXJ0UG9zaXRpb24pKSB7CiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IG90aGVyUmFuZ2Uuc3RhcnQ7CiAgICAgIH0KCiAgICAgIGlmIChvdGhlclJhbmdlLmVuZC5pc0FmdGVyKGVuZFBvc2l0aW9uKSkgewogICAgICAgIGVuZFBvc2l0aW9uID0gb3RoZXJSYW5nZS5lbmQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgc21hbGxlc3Qgc2V0IG9mIHtAbGluayAjaXNGbGF0IGZsYXR9IHJhbmdlcywgdGhhdCBjb3ZlcnMgdGhpcyByYW5nZSBpbiB3aG9sZS4KICAgICAqCiAgICAgKiBTZWUgYW4gZXhhbXBsZSBvZiBhIG1vZGVsIHN0cnVjdHVyZSAoYFtgIGFuZCBgXWAgYXJlIHJhbmdlIGJvdW5kYXJpZXMpOgogICAgICoKICAgICAqCQlyb290ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdAogICAgICoJCSB8LSBlbGVtZW50IERJViAgICAgICAgICAgICAgICAgICAgICAgICBESVYgICAgICAgICAgICAgUDIgICAgICAgICAgICAgIFAzICAgICAgICAgICAgIERJVgogICAgICoJCSB8ICAgfC0gZWxlbWVudCBIICAgICAgICAgICAgICAgICAgIEggICAgICAgIFAxICAgICAgICBmIG8gbyAgICAgICAgICAgYiBhIHIgICAgICAgSCAgICAgICAgIFA0CiAgICAgKgkJIHwgICB8ICAgfC0gImZpcltzdCIgICAgICAgICAgICAgZmlyW3N0ICAgICBsb3JlbSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZV1jb25kICAgICBpcHN1bQogICAgICoJCSB8ICAgfC0gZWxlbWVudCBQMQogICAgICoJCSB8ICAgfCAgIHwtICJsb3JlbSIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwKICAgICAqCQkgfC0gZWxlbWVudCBQMiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8CiAgICAgKgkJIHwgICB8LSAiZm9vIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWVgogICAgICoJCSB8LSBlbGVtZW50IFAzCiAgICAgKgkJIHwgICB8LSAiYmFyIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QKICAgICAqCQkgfC0gZWxlbWVudCBESVYgICAgICAgICAgICAgICAgICAgICAgICAgRElWICAgICAgICAgICAgIFtQMiAgICAgICAgICAgICBQM10gICAgICAgICAgICAgRElWCiAgICAgKgkJIHwgICB8LSBlbGVtZW50IEggICAgICAgICAgICAgICAgICAgSCAgICAgICBbUDFdICAgICAgIGYgbyBvICAgICAgICAgICBiIGEgciAgICAgICAgSCAgICAgICAgIFA0CiAgICAgKgkJIHwgICB8ICAgfC0gInNlXWNvbmQiICAgICAgICAgICAgZmlyW3N0XSAgICBsb3JlbSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VdY29uZCAgICAgaXBzdW0KICAgICAqCQkgfCAgIHwtIGVsZW1lbnQgUDQKICAgICAqCQkgfCAgIHwgICB8LSAiaXBzdW0iCiAgICAgKgogICAgICogQXMgaXQgY2FuIGJlIHNlZW4sIGxldHRlcnMgY29udGFpbmVkIGluIHRoZSByYW5nZSBhcmU6IGBzdGxvcmVtZm9vYmFyc2VgLCBzcHJlYWQgYWNyb3NzIGRpZmZlcmVudCBwYXJlbnRzLgogICAgICogV2UgYXJlIGxvb2tpbmcgZm9yIG1pbmltYWwgc2V0IG9mIGZsYXQgcmFuZ2VzIHRoYXQgY29udGFpbnMgdGhlIHNhbWUgbm9kZXMuCiAgICAgKgogICAgICogTWluaW1hbCBmbGF0IHJhbmdlcyBmb3IgYWJvdmUgcmFuZ2UgYCggWyAwLCAwLCAzIF0sIFsgMywgMCwgMiBdIClgIHdpbGwgYmU6CiAgICAgKgogICAgICoJCSggWyAwLCAwLCAzIF0sIFsgMCwgMCwgNSBdICkgPSAic3QiCiAgICAgKgkJKCBbIDAsIDEgXSwgWyAwLCAyIF0gKSA9IGVsZW1lbnQgUDEgKCJsb3JlbSIpCiAgICAgKgkJKCBbIDEgXSwgWyAzIF0gKSA9IGVsZW1lbnQgUDIsIGVsZW1lbnQgUDMgKCJmb29iYXIiKQogICAgICoJCSggWyAzLCAwLCAwIF0sIFsgMywgMCwgMiBdICkgPSAic2UiCiAgICAgKgogICAgICogKipOb3RlOioqIGlmIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSBpcyBub3Qgd2hvbGx5IGNvbnRhaW5lZCBpbiB0aGlzIHJhbmdlLCBpdCB3b24ndCBiZSByZXR1cm5lZAogICAgICogaW4gYW55IG9mIHRoZSByZXR1cm5lZCBmbGF0IHJhbmdlcy4gU2VlIGluIHRoZSBleGFtcGxlIGhvdyBgSGAgZWxlbWVudHMgYXQgdGhlIGJlZ2lubmluZyBhbmQgYXQgdGhlIGVuZCBvZiB0aGUgcmFuZ2UKICAgICAqIHdlcmUgb21pdHRlZC4gT25seSB0aGVpciBwYXJ0cyB0aGF0IHdlcmUgd2hvbGx5IGluIHRoZSByYW5nZSB3ZXJlIHJldHVybmVkLgogICAgICoKICAgICAqICoqTm90ZToqKiB0aGlzIG1ldGhvZCBpcyBub3QgcmV0dXJuaW5nIGZsYXQgcmFuZ2VzIHRoYXQgY29udGFpbiBubyBub2Rlcy4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBBcnJheSBvZiBmbGF0IHJhbmdlcyBjb3ZlcmluZyB0aGlzIHJhbmdlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldE1pbmltYWxGbGF0UmFuZ2VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNaW5pbWFsRmxhdFJhbmdlcygpIHsKICAgICAgdmFyIHJhbmdlcyA9IFtdOwogICAgICB2YXIgZGlmZkF0ID0gdGhpcy5zdGFydC5nZXRDb21tb25QYXRoKHRoaXMuZW5kKS5sZW5ndGg7CgogICAgICB2YXIgcG9zID0gUG9zaXRpb24uX2NyZWF0ZUF0KHRoaXMuc3RhcnQpOwoKICAgICAgdmFyIHBvc1BhcmVudCA9IHBvcy5wYXJlbnQ7IC8vIEdvIHVwLgoKICAgICAgd2hpbGUgKHBvcy5wYXRoLmxlbmd0aCA+IGRpZmZBdCArIDEpIHsKICAgICAgICB2YXIgaG93TWFueSA9IHBvc1BhcmVudC5tYXhPZmZzZXQgLSBwb3Mub2Zmc2V0OwoKICAgICAgICBpZiAoaG93TWFueSAhPT0gMCkgewogICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHBvcywgcG9zLmdldFNoaWZ0ZWRCeShob3dNYW55KSkpOwogICAgICAgIH0KCiAgICAgICAgcG9zLnBhdGggPSBwb3MucGF0aC5zbGljZSgwLCAtMSk7CiAgICAgICAgcG9zLm9mZnNldCsrOwogICAgICAgIHBvc1BhcmVudCA9IHBvc1BhcmVudC5wYXJlbnQ7CiAgICAgIH0gLy8gR28gZG93bi4KCgogICAgICB3aGlsZSAocG9zLnBhdGgubGVuZ3RoIDw9IHRoaXMuZW5kLnBhdGgubGVuZ3RoKSB7CiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuZW5kLnBhdGhbcG9zLnBhdGgubGVuZ3RoIC0gMV07CgogICAgICAgIHZhciBfaG93TWFueSA9IG9mZnNldCAtIHBvcy5vZmZzZXQ7CgogICAgICAgIGlmIChfaG93TWFueSAhPT0gMCkgewogICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHBvcywgcG9zLmdldFNoaWZ0ZWRCeShfaG93TWFueSkpKTsKICAgICAgICB9CgogICAgICAgIHBvcy5vZmZzZXQgPSBvZmZzZXQ7CiAgICAgICAgcG9zLnBhdGgucHVzaCgwKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJhbmdlczsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciBUcmVlV2Fsa2VyfSBpbnN0YW5jZSB3aXRoIHRoaXMgcmFuZ2UgYXMgYSBib3VuZGFyeS4KICAgICAqCiAgICAgKiBGb3IgZXhhbXBsZSwgdG8gaXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBpbiB0aGUgZW50aXJlIGRvY3VtZW50IHJvb3Q6CiAgICAgKgogICAgICoJCS8vIENyZWF0ZSBhIHJhbmdlIHNwYW5uaW5nIG92ZXIgdGhlIGVudGlyZSByb290IGNvbnRlbnQ6CiAgICAgKgkJY29uc3QgcmFuZ2UgPSBlZGl0b3IubW9kZWwuY3JlYXRlUmFuZ2VJbiggZWRpdG9yLm1vZGVsLmRvY3VtZW50LmdldFJvb3QoKSApOwogICAgICoKICAgICAqCQkvLyBJdGVyYXRlIG92ZXIgYWxsIGl0ZW1zIGluIHRoaXMgcmFuZ2U6CiAgICAgKgkJZm9yICggY29uc3QgdmFsdWUgb2YgcmFuZ2UuZ2V0V2Fsa2VyKCkgKSB7CiAgICAgKgkJCWNvbnNvbGUubG9nKCB2YWx1ZS5pdGVtICk7CiAgICAgKgkJfQogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFtvcHRpb25zLnN0YXJ0UG9zaXRpb25dCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNpbmdsZUNoYXJhY3RlcnM9ZmFsc2VdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNoYWxsb3c9ZmFsc2VdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQ9ZmFsc2VdCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0V2Fsa2VyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXYWxrZXIoKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKICAgICAgb3B0aW9ucy5ib3VuZGFyaWVzID0gdGhpczsKICAgICAgcmV0dXJuIG5ldyBUcmVlV2Fsa2VyKG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIGl0ZW1zfSB0aGF0IGFyZSBpbiB0aGlzIHJhbmdlIGFuZCByZXR1cm5zCiAgICAgKiB0aGVtLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSB3aXRoIGBib3VuZGFyaWVzYCBzZXQgdG8gdGhpcyByYW5nZSBhbmQgYGlnbm9yZUVsZW1lbnRFbmRgIG9wdGlvbgogICAgICogc2V0IHRvIGB0cnVlYC4gSG93ZXZlciBpdCByZXR1cm5zIG9ubHkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW1zfSwKICAgICAqIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICAgKgogICAgICogWW91IG1heSBzcGVjaWZ5IGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRyZWUgd2Fsa2VyLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSBmb3IKICAgICAqIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zLgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRJdGVtcyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldEl0ZW1zKCkgewogICAgICB2YXIgb3B0aW9ucywKICAgICAgICAgIHRyZWVXYWxrZXIsCiAgICAgICAgICBfaXRlcmF0b3IsCiAgICAgICAgICBfc3RlcCwKICAgICAgICAgIF92YWx1ZSwKICAgICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50czsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRJdGVtcyQoX2NvbnRleHQyKSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzMi5sZW5ndGggPiAwICYmIF9hcmdzMlswXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzBdIDoge307CiAgICAgICAgICAgICAgb3B0aW9ucy5ib3VuZGFyaWVzID0gdGhpczsKICAgICAgICAgICAgICBvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQgPSB0cnVlOwogICAgICAgICAgICAgIHRyZWVXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0cmVlV2Fsa2VyKTsKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDU7CgogICAgICAgICAgICAgIF9pdGVyYXRvci5zKCk7CgogICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmUpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF92YWx1ZSA9IF9zdGVwLnZhbHVlOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZS5pdGVtOwoKICAgICAgICAgICAgY2FzZSAxMToKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDEzOgogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTU7CiAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWyJjYXRjaCJdKDUpOwoKICAgICAgICAgICAgICBfaXRlcmF0b3IuZShfY29udGV4dDIudDApOwoKICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE4OwoKICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpOwoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgxOCk7CgogICAgICAgICAgICBjYXNlIDIxOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZ2V0SXRlbXMsIHRoaXMsIFtbNSwgMTUsIDE4LCAyMV1dKTsKICAgIH0pCiAgICAvKioKICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCBpdGVyYXRlcyBvdmVyIGFsbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbnN9IHRoYXQgYXJlIGJvdW5kYXJpZXMgb3IKICAgICAqIGNvbnRhaW5lZCBpbiB0aGlzIHJhbmdlLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSB3aXRoIGBib3VuZGFyaWVzYCBzZXQgdG8gdGhpcyByYW5nZS4gSG93ZXZlciBpdCByZXR1cm5zIG9ubHkKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30sIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICAgKgogICAgICogWW91IG1heSBzcGVjaWZ5IGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRyZWUgd2Fsa2VyLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSBmb3IKICAgICAqIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zLgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFBvc2l0aW9ucyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldFBvc2l0aW9ucygpIHsKICAgICAgdmFyIG9wdGlvbnMsCiAgICAgICAgICB0cmVlV2Fsa2VyLAogICAgICAgICAgX2l0ZXJhdG9yMiwKICAgICAgICAgIF9zdGVwMiwKICAgICAgICAgIF92YWx1ZTIsCiAgICAgICAgICBfYXJnczMgPSBhcmd1bWVudHM7CgogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0UG9zaXRpb25zJChfY29udGV4dDMpIHsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICBvcHRpb25zID0gX2FyZ3MzLmxlbmd0aCA+IDAgJiYgX2FyZ3MzWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczNbMF0gOiB7fTsKICAgICAgICAgICAgICBvcHRpb25zLmJvdW5kYXJpZXMgPSB0aGlzOwogICAgICAgICAgICAgIHRyZWVXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7CiAgICAgICAgICAgICAgcmV0dXJuIHRyZWVXYWxrZXIucG9zaXRpb247CgogICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRyZWVXYWxrZXIpOwogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gNjsKCiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5zKCk7CgogICAgICAgICAgICBjYXNlIDg6CiAgICAgICAgICAgICAgaWYgKChfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgX3ZhbHVlMiA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyOwogICAgICAgICAgICAgIHJldHVybiBfdmFsdWUyLm5leHRQb3NpdGlvbjsKCiAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAxNDoKICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE5OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE2OwogICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1siY2F0Y2giXSg2KTsKCiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKF9jb250ZXh0My50MCk7CgogICAgICAgICAgICBjYXNlIDE5OgogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTk7CgogICAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpOwoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmZpbmlzaCgxOSk7CgogICAgICAgICAgICBjYXNlIDIyOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZ2V0UG9zaXRpb25zLCB0aGlzLCBbWzYsIDE2LCAxOSwgMjJdXSk7CiAgICB9KQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgcmFuZ2UgdGhhdCBpcyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgdGhpcyByYW5nZSBieSBnaXZlbiBgb3BlcmF0aW9uYC4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogdHJhbnNmb3JtYXRpb24gbWF5IGJyZWFrIG9uZSByYW5nZSBpbnRvIG11bHRpcGxlIHJhbmdlcyAoZm9yIGV4YW1wbGUsIHdoZW4gYSBwYXJ0IG9mIHRoZSByYW5nZSBpcwogICAgICogbW92ZWQgdG8gYSBkaWZmZXJlbnQgcGFydCBvZiBkb2N1bWVudCB0cmVlKS4gRm9yIHRoaXMgcmVhc29uLCBhbiBhcnJheSBpcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCBhbmQgaXQKICAgICAqIG1heSBjb250YWluIG9uZSBvciBtb3JlIGBSYW5nZWAgaW5zdGFuY2VzLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BlcmF0aW9uIE9wZXJhdGlvbiB0byB0cmFuc2Zvcm0gcmFuZ2UgYnkuCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBSYW5nZSB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHRyYW5zZm9ybWF0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFRyYW5zZm9ybWVkQnlPcGVyYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyYW5zZm9ybWVkQnlPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHsKICAgICAgICBjYXNlICdpbnNlcnQnOgogICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24ob3BlcmF0aW9uKTsKCiAgICAgICAgY2FzZSAnbW92ZSc6CiAgICAgICAgY2FzZSAncmVtb3ZlJzoKICAgICAgICBjYXNlICdyZWluc2VydCc6CiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24ob3BlcmF0aW9uKTsKCiAgICAgICAgY2FzZSAnc3BsaXQnOgogICAgICAgICAgcmV0dXJuIFt0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24ob3BlcmF0aW9uKV07CgogICAgICAgIGNhc2UgJ21lcmdlJzoKICAgICAgICAgIHJldHVybiBbdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKG9wZXJhdGlvbildOwogICAgICB9CgogICAgICByZXR1cm4gW25ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCldOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgcmFuZ2UgdGhhdCBpcyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgdGhpcyByYW5nZSBieSBtdWx0aXBsZSBgb3BlcmF0aW9uc2AuCiAgICAgKgogICAgICogQHNlZSB+UmFuZ2UjZ2V0VHJhbnNmb3JtZWRCeU9wZXJhdGlvbgogICAgICogQHBhcmFtIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59IG9wZXJhdGlvbnMgT3BlcmF0aW9ucyB0byB0cmFuc2Zvcm0gdGhlIHJhbmdlIGJ5LgogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gUmFuZ2Ugd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiB0cmFuc2Zvcm1hdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9ucyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtZWRCeU9wZXJhdGlvbnMob3BlcmF0aW9ucykgewogICAgICB2YXIgcmFuZ2VzID0gW25ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCldOwoKICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvcGVyYXRpb25zKSwKICAgICAgICAgIF9zdGVwMzsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBvcGVyYXRpb24gPSBfc3RlcDMudmFsdWU7CgogICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHJhbmdlcy5sZW5ndGg7IF9pKyspIHsKICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJhbmdlc1tfaV0uZ2V0VHJhbnNmb3JtZWRCeU9wZXJhdGlvbihvcGVyYXRpb24pOwoKICAgICAgICAgICAgcmFuZ2VzLnNwbGljZS5hcHBseShyYW5nZXMsIFtfaSwgMV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQpKSk7CiAgICAgICAgICAgIF9pICs9IHJlc3VsdC5sZW5ndGggLSAxOwogICAgICAgICAgfQogICAgICAgIH0gLy8gSXQgbWF5IGhhcHBlbiB0aGF0IGEgcmFuZ2UgaXMgc3BsaXQgaW50byB0d28sIGFuZCB0aGVuIHRoZSBwYXJ0IG9mIHNlY29uZCAicGllY2UiIGlzIG1vdmVkIGludG8gZmlyc3QKICAgICAgICAvLyAicGllY2UiLiBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBoYXZlIGluY29ycmVjdCB0aGlyZCByYW5nZSwgd2hpY2ggc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IC0tCiAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyBhbHJlYWR5IGluY2x1ZGVkIGluIHRoZSBmaXJzdCAicGllY2UiLiBJbiB0aGlzIGxvb3Agd2UgYXJlIGxvb2tpbmcgZm9yIGFsbCBzdWNoIHJhbmdlcyB0aGF0CiAgICAgICAgLy8gYXJlIGluc2lkZSBvdGhlciByYW5nZXMgYW5kIHdlIHNpbXBseSByZW1vdmUgdGhlbS4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjMuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjMuZigpOwogICAgICB9CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTsKCiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgcmFuZ2VzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICB2YXIgbmV4dCA9IHJhbmdlc1tqXTsKCiAgICAgICAgICBpZiAocmFuZ2UuY29udGFpbnNSYW5nZShuZXh0KSB8fCBuZXh0LmNvbnRhaW5zUmFuZ2UocmFuZ2UpIHx8IHJhbmdlLmlzRXF1YWwobmV4dCkpIHsKICAgICAgICAgICAgcmFuZ2VzLnNwbGljZShqLCAxKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiByYW5nZXM7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICAgKiB3aGljaCBpcyBhIGNvbW1vbiBhbmNlc3RvciBvZiB0aGUgcmFuZ2UncyBib3RoIGVuZHMgKGluIHdoaWNoIHRoZSBlbnRpcmUgcmFuZ2UgaXMgY29udGFpbmVkKS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDb21tb25BbmNlc3RvciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29tbW9uQW5jZXN0b3IoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmdldENvbW1vbkFuY2VzdG9yKHRoaXMuZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgRWxlbWVudH0gY29udGFpbmVkIGJ5IHRoZSByYW5nZS4KICAgICAqIFRoZSBlbGVtZW50IHdpbGwgYmUgcmV0dXJuZWQgd2hlbiBpdCBpcyB0aGUgKipvbmx5Kiogbm9kZSB3aXRoaW4gdGhlIHJhbmdlIGFuZCAqKmZ1bGx54oCTY29udGFpbmVkKioKICAgICAqIGF0IHRoZSBzYW1lIHRpbWUuCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Q29udGFpbmVkRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGFpbmVkRWxlbWVudCgpIHsKICAgICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgdmFyIG5vZGVBZnRlclN0YXJ0ID0gdGhpcy5zdGFydC5ub2RlQWZ0ZXI7CiAgICAgIHZhciBub2RlQmVmb3JlRW5kID0gdGhpcy5lbmQubm9kZUJlZm9yZTsKCiAgICAgIGlmIChub2RlQWZ0ZXJTdGFydCAmJiBub2RlQWZ0ZXJTdGFydC5pcygnZWxlbWVudCcpICYmIG5vZGVBZnRlclN0YXJ0ID09PSBub2RlQmVmb3JlRW5kKSB7CiAgICAgICAgcmV0dXJuIG5vZGVBZnRlclN0YXJ0OwogICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgYFJhbmdlYCB0byBwbGFpbiBvYmplY3QgYW5kIHJldHVybnMgaXQuCiAgICAgKgogICAgICogQHJldHVybnMge09iamVjdH0gYE5vZGVgIGNvbnZlcnRlZCB0byBwbGFpbiBvYmplY3QuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9KU09OIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQudG9KU09OKCksCiAgICAgICAgZW5kOiB0aGlzLmVuZC50b0pTT04oKQogICAgICB9OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbmV3IHJhbmdlIHRoYXQgaXMgZXF1YWwgdG8gY3VycmVudCByYW5nZS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjbG9uZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSByZXN1bHQgb2YgdHJhbnNmb3JtaW5nIGEgY29weSBvZiB0aGlzIHJhbmdlIGJ5IGluc2VydCBvcGVyYXRpb24uCiAgICAgKgogICAgICogT25lIG9yIG1vcmUgcmFuZ2VzIG1heSBiZSByZXR1cm5lZCBhcyBhIHJlc3VsdCBvZiB0aGlzIHRyYW5zZm9ybWF0aW9uLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vaW5zZXJ0b3BlcmF0aW9ufkluc2VydE9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgICAgdmFyIHNwcmVhZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7CiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKG9wZXJhdGlvbi5wb3NpdGlvbiwgb3BlcmF0aW9uLmhvd01hbnksIHNwcmVhZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSByZXN1bHQgb2YgdHJhbnNmb3JtaW5nIGEgY29weSBvZiB0aGlzIHJhbmdlIGJ5IG1vdmUgb3BlcmF0aW9uLgogICAgICoKICAgICAqIE9uZSBvciBtb3JlIHJhbmdlcyBtYXkgYmUgcmV0dXJuZWQgYXMgYSByZXN1bHQgb2YgdGhpcyB0cmFuc2Zvcm1hdGlvbi4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL21vdmVvcGVyYXRpb25+TW92ZU9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKG9wZXJhdGlvbikgewogICAgICB2YXIgc3ByZWFkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTsKICAgICAgdmFyIHNvdXJjZVBvc2l0aW9uID0gb3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uOwogICAgICB2YXIgaG93TWFueSA9IG9wZXJhdGlvbi5ob3dNYW55OwogICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBvcGVyYXRpb24udGFyZ2V0UG9zaXRpb247CiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhvd01hbnksIHNwcmVhZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSByZXN1bHQgb2YgdHJhbnNmb3JtaW5nIGEgY29weSBvZiB0aGlzIHJhbmdlIGJ5IHNwbGl0IG9wZXJhdGlvbi4KICAgICAqCiAgICAgKiBBbHdheXMgb25lIHJhbmdlIGlzIHJldHVybmVkLiBUaGUgdHJhbnNmb3JtYXRpb24gaXMgZG9uZSBpbiBhIHdheSB0byBub3QgYnJlYWsgdGhlIHJhbmdlLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vc3BsaXRvcGVyYXRpb25+U3BsaXRPcGVyYXRpb259IG9wZXJhdGlvbgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgICB2YXIgZW5kID0gdGhpcy5lbmQuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihvcGVyYXRpb24pOwoKICAgICAgaWYgKHRoaXMuZW5kLmlzRXF1YWwob3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uKSkgewogICAgICAgIGVuZCA9IHRoaXMuZW5kLmdldFNoaWZ0ZWRCeSgxKTsKICAgICAgfSAvLyBCZWxvdyBtYXkgaGFwcGVuIHdoZW4gcmFuZ2UgY29udGFpbnMgZ3JhdmV5YXJkIGVsZW1lbnQgdXNlZCBieSBzcGxpdCBvcGVyYXRpb24uCgoKICAgICAgaWYgKHN0YXJ0LnJvb3QgIT0gZW5kLnJvb3QpIHsKICAgICAgICAvLyBFbmQgcG9zaXRpb24gd2FzIG5leHQgdG8gdGhlIG1vdmVkIGdyYXZleWFyZCBlbGVtZW50IGFuZCB3YXMgbW92ZWQgd2l0aCBpdC4KICAgICAgICAvLyBGaXggaXQgYnkgdXNpbmcgb2xkIGBlbmRgIHdoaWNoIGhhcyBwcm9wZXIgYHJvb3RgLgogICAgICAgIGVuZCA9IHRoaXMuZW5kLmdldFNoaWZ0ZWRCeSgtMSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSByZXN1bHQgb2YgdHJhbnNmb3JtaW5nIGEgY29weSBvZiB0aGlzIHJhbmdlIGJ5IG1lcmdlIG9wZXJhdGlvbi4KICAgICAqCiAgICAgKiBBbHdheXMgb25lIHJhbmdlIGlzIHJldHVybmVkLiBUaGUgdHJhbnNmb3JtYXRpb24gaXMgZG9uZSBpbiBhIHdheSB0byBub3QgYnJlYWsgdGhlIHJhbmdlLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbWVyZ2VvcGVyYXRpb25+TWVyZ2VPcGVyYXRpb259IG9wZXJhdGlvbgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gdGhlIG1hcmtlciBpcyBzZXQgb24gInRoZSBjbG9zaW5nIHRhZyIgb2YgYW4gZWxlbWVudC4gTWFya2VyIGNhbiBiZSBzZXQgbGlrZSB0aGF0IGR1cmluZwogICAgICAvLyB0cmFuc2Zvcm1hdGlvbnMsIGVzcGVjaWFsbHkgd2hlbiBhIGNvbnRlbnQgb2YgYSBmZXcgYmxvY2sgZWxlbWVudHMgd2VyZSByZW1vdmVkLiBGb3IgZXhhbXBsZToKICAgICAgLy8KICAgICAgLy8ge30gaXMgdGhlIHRyYW5zZm9ybWVkIHJhbmdlLCBbXSBpcyB0aGUgcmVtb3ZlZCByYW5nZS4KICAgICAgLy8gPHA+Rltve288L3A+PHA+Qn1hcjwvcD48cD5YeV16PC9wPgogICAgICAvLwogICAgICAvLyA8cD5Gb3tvPC9wPjxwPkJ9YXI8L3A+PHA+ejwvcD4KICAgICAgLy8gPHA+Rns8L3A+PHA+Qn1hcjwvcD48cD56PC9wPgogICAgICAvLyA8cD5GezwvcD59PHA+ejwvcD4KICAgICAgLy8gPHA+Rnt9ejwvcD4KICAgICAgLy8KICAgICAgaWYgKHRoaXMuc3RhcnQuaXNFcXVhbChvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24pICYmIHRoaXMuZW5kLmlzRXF1YWwob3BlcmF0aW9uLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0KTsKICAgICAgfQoKICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgICB2YXIgZW5kID0gdGhpcy5lbmQuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihvcGVyYXRpb24pOwoKICAgICAgaWYgKHN0YXJ0LnJvb3QgIT0gZW5kLnJvb3QpIHsKICAgICAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgZW5kIHBvc2l0aW9uIHdhcyBuZXh0IHRvIHRoZSBtZXJnZWQgKGRlbGV0ZWQpIGVsZW1lbnQuCiAgICAgICAgLy8gVGhlbiwgdGhlIGVuZCBwb3NpdGlvbiB3YXMgbW92ZWQgdG8gdGhlIGdyYXZleWFyZCByb290LiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBmaXgKICAgICAgICAvLyB0aGUgcmFuZ2UgY2F1c2UgaXRzIGJvdW5kYXJpZXMgd291bGQgYmUgaW4gZGlmZmVyZW50IHJvb3RzLgogICAgICAgIGVuZCA9IHRoaXMuZW5kLmdldFNoaWZ0ZWRCeSgtMSk7CiAgICAgIH0KCiAgICAgIGlmIChzdGFydC5pc0FmdGVyKGVuZCkpIHsKICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhyZWUgZm9sbG93aW5nIGNhc2VzOgogICAgICAgIC8vCiAgICAgICAgLy8gQ2FzZSAxOiBNZXJnZSBvcGVyYXRpb24gc291cmNlIHBvc2l0aW9uIGlzIGJlZm9yZSB0aGUgdGFyZ2V0IHBvc2l0aW9uIChkdWUgdG8gc29tZSB0cmFuc2Zvcm1hdGlvbnMsIE9ULCBldGMuKQogICAgICAgIC8vICAgICAgICAgVGhpcyBtZWFucyB0aGF0IHN0YXJ0IGNhbiBiZSBtb3ZlZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgcmFuZ2UuCiAgICAgICAgLy8KICAgICAgICAvLyBCZWZvcmU6IDxwPmF7YTwvcD48cD5ifWI8L3A+PHA+Y2M8L3A+CiAgICAgICAgLy8gTWVyZ2U6ICA8cD5ifWI8L3A+PHA+Y2Nhe2E8L3A+CiAgICAgICAgLy8gRml4OiAgICA8cD57Yn1iPC9wPjxwPmNjYWE8L3A+CiAgICAgICAgLy8KICAgICAgICAvLyBDYXNlIDI6IFJhbmdlIHN0YXJ0IGlzIGJlZm9yZSBtZXJnZWQgbm9kZSBidXQgbm90IGRpcmVjdGx5LgogICAgICAgIC8vICAgICAgICAgUmVzdWx0IHNob3VsZCBpbmNsdWRlIGFsbCBub2RlcyB0aGF0IHdlcmUgaW4gdGhlIG9yaWdpbmFsIHJhbmdlLgogICAgICAgIC8vCiAgICAgICAgLy8gQmVmb3JlOiA8cD5hYTwvcD57PHA+Y2M8L3A+PHA+Yn1iPC9wPgogICAgICAgIC8vIE1lcmdlOiAgPHA+YWFifWI8L3A+ezxwPmNjPC9wPgogICAgICAgIC8vIEZpeDogICAgPHA+YWF7YmI8L3A+PHA+Y2M8L3A+fQogICAgICAgIC8vCiAgICAgICAgLy8gICAgICAgICBUaGUgcmFuZ2UgaXMgZXhwYW5kZWQgYnkgYW4gYWRkaXRpb25hbCBgYmAgbGV0dGVyIGJ1dCBpdCBpcyBiZXR0ZXIgdGhhbiBkcm9wcGluZyB0aGUgd2hvbGUgYGNjYCBwYXJhZ3JhcGguCiAgICAgICAgLy8KICAgICAgICAvLyBDYXNlIDM6IFJhbmdlIHN0YXJ0IGlzIGRpcmVjdGx5IGJlZm9yZSBtZXJnZWQgbm9kZS4KICAgICAgICAvLyAgICAgICAgIFJlc3VsdGluZyByYW5nZSBzaG91bGQgaW5jbHVkZSBvbmx5IG5vZGVzIGZyb20gdGhlIG1lcmdlZCBlbGVtZW50OgogICAgICAgIC8vCiAgICAgICAgLy8gQmVmb3JlOiA8cD5hYTwvcD57PHA+Yn1iPC9wPjxwPmNjPC9wPgogICAgICAgIC8vIE1lcmdlOiAgPHA+YWFifWI8L3A+ezxwPmNjPC9wPgogICAgICAgIC8vIEZpeDogICAgPHA+YWF7Yn1iPC9wPjxwPmNjPC9wPgogICAgICAgIC8vCiAgICAgICAgaWYgKG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbi5pc0JlZm9yZShvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24pKSB7CiAgICAgICAgICAvLyBDYXNlIDEuCiAgICAgICAgICBzdGFydCA9IFBvc2l0aW9uLl9jcmVhdGVBdChlbmQpOwogICAgICAgICAgc3RhcnQub2Zmc2V0ID0gMDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKCFvcGVyYXRpb24uZGVsZXRpb25Qb3NpdGlvbi5pc0VxdWFsKHN0YXJ0KSkgewogICAgICAgICAgICAvLyBDYXNlIDIuCiAgICAgICAgICAgIGVuZCA9IG9wZXJhdGlvbi5kZWxldGlvblBvc2l0aW9uOwogICAgICAgICAgfSAvLyBJbiBib3RoIGNhc2UgMiBhbmQgMyBzdGFydCBpcyBhdCB0aGUgZW5kIG9mIHRoZSBtZXJnZS10byBlbGVtZW50LgoKCiAgICAgICAgICBzdGFydCA9IG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbjsKICAgICAgICB9CgogICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBvbmUgb3IgdHdvIHtAbGluayB+UmFuZ2UgcmFuZ2VzfSB0aGF0IGFyZSBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgdGhpcwogICAgICoge0BsaW5rIH5SYW5nZSByYW5nZX0gYnkgaW5zZXJ0aW5nIGBob3dNYW55YCBub2RlcyBhdCBgaW5zZXJ0UG9zaXRpb25gLiBUd28ge0BsaW5rIH5SYW5nZSByYW5nZXN9IGFyZQogICAgICogcmV0dXJuZWQgaWYgdGhlIGluc2VydGlvbiB3YXMgaW5zaWRlIHRoaXMge0BsaW5rIH5SYW5nZSByYW5nZX0gYW5kIGBzcHJlYWRgIGlzIHNldCB0byBgdHJ1ZWAuCiAgICAgKgogICAgICogRXhhbXBsZXM6CiAgICAgKgogICAgICoJCWxldCByYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDIsIDcgXSApLAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDQsIDAsIDEgXSApCiAgICAgKgkJKTsKICAgICAqCQlsZXQgdHJhbnNmb3JtZWQgPSByYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbiggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAxIF0gKSwgMiApOwogICAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyBvbmUgcmFuZ2UgZnJvbSBbIDQsIDcgXSB0byBbIDYsIDAsIDEgXQogICAgICoKICAgICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDQsIDAsIDAgXSApLCA0ICk7CiAgICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIG9uZSByYW5nZSBmcm9tIFsgMiwgNyBdIHRvIFsgNCwgMCwgNSBdCiAgICAgKgogICAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMywgMiBdICksIDQgKTsKICAgICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgb25lIHJhbmdlLCB3aGljaCBpcyBlcXVhbCB0byBvcmlnaW5hbCByYW5nZQogICAgICoKICAgICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDMsIDIgXSApLCA0LCB0cnVlICk7CiAgICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIHR3byByYW5nZXM6IGZyb20gWyAyLCA3IF0gdG8gWyAzLCAyIF0gYW5kIGZyb20gWyAzLCA2IF0gdG8gWyA0LCAwLCAxIF0KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGluc2VydFBvc2l0aW9uIFBvc2l0aW9uIHdoZXJlIG5vZGVzIGFyZSBpbnNlcnRlZC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IEhvdyBtYW55IG5vZGVzIGFyZSBpbnNlcnRlZC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NwcmVhZF0gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyB7flJhbmdlIHJhbmdlfSBzaG91bGQgYmUgc3ByZWFkIGlmIGluc2VydGlvbgogICAgICogd2FzIGluc2lkZSB0aGUgcmFuZ2UuIERlZmF1bHRzIHRvIGBmYWxzZWAuCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBSZXN1bHQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihpbnNlcnRQb3NpdGlvbiwgaG93TWFueSkgewogICAgICB2YXIgc3ByZWFkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTsKCiAgICAgIGlmIChzcHJlYWQgJiYgdGhpcy5jb250YWluc1Bvc2l0aW9uKGluc2VydFBvc2l0aW9uKSkgewogICAgICAgIC8vIFJhbmdlIGhhcyB0byBiZSBzcHJlYWQuIFRoZSBmaXJzdCBwYXJ0IGlzIGZyb20gb3JpZ2luYWwgc3RhcnQgdG8gdGhlIHNwcmVhZCBwb2ludC4KICAgICAgICAvLyBUaGUgb3RoZXIgcGFydCBpcyBmcm9tIHNwcmVhZCBwb2ludCB0byB0aGUgb3JpZ2luYWwgZW5kLCBidXQgdHJhbnNmb3JtZWQgYnkKICAgICAgICAvLyBpbnNlcnRpb24gdG8gcmVmbGVjdCBpbnNlcnRpb24gY2hhbmdlcy4KICAgICAgICByZXR1cm4gW25ldyBSYW5nZSh0aGlzLnN0YXJ0LCBpbnNlcnRQb3NpdGlvbiksIG5ldyBSYW5nZShpbnNlcnRQb3NpdGlvbi5nZXRTaGlmdGVkQnkoaG93TWFueSksIHRoaXMuZW5kLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGluc2VydFBvc2l0aW9uLCBob3dNYW55KSldOwogICAgICB9IGVsc2UgewogICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7CiAgICAgICAgcmFuZ2Uuc3RhcnQgPSByYW5nZS5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihpbnNlcnRQb3NpdGlvbiwgaG93TWFueSk7CiAgICAgICAgcmFuZ2UuZW5kID0gcmFuZ2UuZW5kLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGluc2VydFBvc2l0aW9uLCBob3dNYW55KTsKICAgICAgICByZXR1cm4gW3JhbmdlXTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcge0BsaW5rIH5SYW5nZSByYW5nZXN9IHRoYXQgYXJlIGEgcmVzdWx0IG9mIHRyYW5zZm9ybWluZyB0aGlzCiAgICAgKiB7QGxpbmsgflJhbmdlIHJhbmdlfSBieSBtb3ZpbmcgYGhvd01hbnlgIG5vZGVzIGZyb20gYHNvdXJjZVBvc2l0aW9uYCB0byBgdGFyZ2V0UG9zaXRpb25gLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gc291cmNlUG9zaXRpb24gUG9zaXRpb24gZnJvbSB3aGljaCBub2RlcyBhcmUgbW92ZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHRhcmdldFBvc2l0aW9uIFBvc2l0aW9uIHRvIHdoZXJlIG5vZGVzIGFyZSBtb3ZlZC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IEhvdyBtYW55IG5vZGVzIGFyZSBtb3ZlZC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NwcmVhZD1mYWxzZV0gV2hldGhlciB0aGUgcmFuZ2Ugc2hvdWxkIGJlIHNwcmVhZCBpZiB0aGUgbW92ZSBwb2ludHMgaW5zaWRlIHRoZSByYW5nZS4KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlNb3ZlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeU1vdmUoc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBob3dNYW55KSB7CiAgICAgIHZhciBzcHJlYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlOwoKICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0cmFuc2Zvcm1pbmcgYSBjb2xsYXBzZWQgcmFuZ2UuIEp1c3QgdHJhbnNmb3JtIGl0IGxpa2UgYSBwb3NpdGlvbi4KICAgICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQpIHsKICAgICAgICB2YXIgbmV3UG9zID0gdGhpcy5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBob3dNYW55KTsKCiAgICAgICAgcmV0dXJuIFtuZXcgUmFuZ2UobmV3UG9zKV07CiAgICAgIH0gLy8gU3BlY2lhbCBjYXNlIGZvciB0cmFuc2Zvcm1hdGlvbiB3aGVuIGEgcGFydCBvZiB0aGUgcmFuZ2UgaXMgbW92ZWQgdG93YXJkcyB0aGUgcmFuZ2UuCiAgICAgIC8vCiAgICAgIC8vIEV4YW1wbGVzOgogICAgICAvLwogICAgICAvLyA8ZGl2PjxwPmFiPC9wPjxwPmNbZDwvcD48L2Rpdj48cD5lXWY8L3A+IC0tPiA8ZGl2PjxwPmFiPC9wPjwvZGl2PjxwPmNbZDwvcD48cD5lXWY8L3A+CiAgICAgIC8vIDxwPmVbZjwvcD48ZGl2PjxwPmFdYjwvcD48cD5jZDwvcD48L2Rpdj4gLS0+IDxwPmVbZjwvcD48cD5hXWI8L3A+PGRpdj48cD5jZDwvcD48L2Rpdj4KICAgICAgLy8KICAgICAgLy8gV2l0aG91dCB0aGlzIHNwZWNpYWwgY29uZGl0aW9uLCB0aGUgZGVmYXVsdCBhbGdvcml0aG0gbGVhdmVzIGFuICJhcnRpZmFjdCIgcmFuZ2UgZnJvbSBvbmUgb2YgYGRpZmZlcmVuY2VTZXRgIHBhcnRzOgogICAgICAvLwogICAgICAvLyA8ZGl2PjxwPmFiPC9wPjxwPmNbZDwvcD48L2Rpdj48cD5lXWY8L3A+IC0tPiA8ZGl2PjxwPmFiPC9wPns8L2Rpdj59PHA+Y1tkPC9wPjxwPmVdZjwvcD4KICAgICAgLy8KICAgICAgLy8gVGhpcyBzcGVjaWFsIGNhc2UgaXMgYXBwbGllZCBvbmx5IGlmIHRoZSByYW5nZSBpcyB0byBiZSBrZXB0IHRvZ2V0aGVyIChub3Qgc3ByZWFkKS4KCgogICAgICB2YXIgbW92ZVJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KHNvdXJjZVBvc2l0aW9uLCBob3dNYW55KTsKCiAgICAgIHZhciBpbnNlcnRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oc291cmNlUG9zaXRpb24sIGhvd01hbnkpOwoKICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbih0YXJnZXRQb3NpdGlvbikgJiYgIXNwcmVhZCkgewogICAgICAgIGlmIChtb3ZlUmFuZ2UuY29udGFpbnNQb3NpdGlvbih0aGlzLnN0YXJ0KSB8fCBtb3ZlUmFuZ2UuY29udGFpbnNQb3NpdGlvbih0aGlzLmVuZCkpIHsKICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgaG93TWFueSk7CgogICAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhvd01hbnkpOwoKICAgICAgICAgIHJldHVybiBbbmV3IFJhbmdlKHN0YXJ0LCBlbmQpXTsKICAgICAgICB9CiAgICAgIH0gLy8gRGVmYXVsdCBhbGdvcml0aG0uCgoKICAgICAgdmFyIHJlc3VsdDsKICAgICAgdmFyIGRpZmZlcmVuY2VTZXQgPSB0aGlzLmdldERpZmZlcmVuY2UobW92ZVJhbmdlKTsKICAgICAgdmFyIGRpZmZlcmVuY2UgPSBudWxsOwogICAgICB2YXIgY29tbW9uID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24obW92ZVJhbmdlKTsKCiAgICAgIGlmIChkaWZmZXJlbmNlU2V0Lmxlbmd0aCA9PSAxKSB7CiAgICAgICAgLy8gYG1vdmVSYW5nZWAgYW5kIHRoaXMgcmFuZ2UgbWF5IGludGVyc2VjdCBidXQgbWF5IGJlIHNlcGFyYXRlLgogICAgICAgIGRpZmZlcmVuY2UgPSBuZXcgUmFuZ2UoZGlmZmVyZW5jZVNldFswXS5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKHNvdXJjZVBvc2l0aW9uLCBob3dNYW55KSwgZGlmZmVyZW5jZVNldFswXS5lbmQuX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihzb3VyY2VQb3NpdGlvbiwgaG93TWFueSkpOwogICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2VTZXQubGVuZ3RoID09IDIpIHsKICAgICAgICAvLyBgbW92ZVJhbmdlYCBpcyBpbnNpZGUgdGhpcyByYW5nZS4KICAgICAgICBkaWZmZXJlbmNlID0gbmV3IFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oc291cmNlUG9zaXRpb24sIGhvd01hbnkpKTsKICAgICAgfSAvLyBlbHNlLCBgbW92ZVJhbmdlYCBjb250YWlucyB0aGlzIHJhbmdlLgoKCiAgICAgIGlmIChkaWZmZXJlbmNlKSB7CiAgICAgICAgcmVzdWx0ID0gZGlmZmVyZW5jZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihpbnNlcnRQb3NpdGlvbiwgaG93TWFueSwgY29tbW9uICE9PSBudWxsIHx8IHNwcmVhZCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0ID0gW107CiAgICAgIH0KCiAgICAgIGlmIChjb21tb24pIHsKICAgICAgICB2YXIgdHJhbnNmb3JtZWRDb21tb24gPSBuZXcgUmFuZ2UoY29tbW9uLnN0YXJ0Ll9nZXRDb21iaW5lZChtb3ZlUmFuZ2Uuc3RhcnQsIGluc2VydFBvc2l0aW9uKSwgY29tbW9uLmVuZC5fZ2V0Q29tYmluZWQobW92ZVJhbmdlLnN0YXJ0LCBpbnNlcnRQb3NpdGlvbikpOwoKICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAyKSB7CiAgICAgICAgICByZXN1bHQuc3BsaWNlKDEsIDAsIHRyYW5zZm9ybWVkQ29tbW9uKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmVzdWx0LnB1c2godHJhbnNmb3JtZWRDb21tb24pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyByYW5nZSB0aGF0IGlzIHRyYW5zZm9ybWVkIGJ5IGRlbGV0aW9uIG9mIGBob3dNYW55YCBub2RlcyBmcm9tIGBkZWxldGVQb3NpdGlvbmAuCiAgICAgKgogICAgICogSWYgdGhlIGRlbGV0ZWQgcmFuZ2UgaXMgaW50ZXJzZWN0aW5nIHdpdGggdGhlIHRyYW5zZm9ybWVkIHJhbmdlLCB0aGUgdHJhbnNmb3JtZWQgcmFuZ2Ugd2lsbCBiZSBzaHJhbmsuCiAgICAgKgogICAgICogSWYgdGhlIGRlbGV0ZWQgcmFuZ2UgY29udGFpbnMgdHJhbnNmb3JtZWQgcmFuZ2UsIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gZGVsZXRpb25Qb3NpdGlvbiBQb3NpdGlvbiBmcm9tIHdoaWNoIG5vZGVzIGFyZSByZW1vdmVkLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgSG93IG1hbnkgbm9kZXMgYXJlIHJlbW92ZWQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxudWxsfSBSZXN1bHQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oZGVsZXRlUG9zaXRpb24sIGhvd01hbnkpIHsKICAgICAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGRlbGV0ZVBvc2l0aW9uLCBob3dNYW55KTsKCiAgICAgIHZhciBuZXdFbmQgPSB0aGlzLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGRlbGV0ZVBvc2l0aW9uLCBob3dNYW55KTsKCiAgICAgIGlmIChuZXdTdGFydCA9PSBudWxsICYmIG5ld0VuZCA9PSBudWxsKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIGlmIChuZXdTdGFydCA9PSBudWxsKSB7CiAgICAgICAgbmV3U3RhcnQgPSBkZWxldGVQb3NpdGlvbjsKICAgICAgfQoKICAgICAgaWYgKG5ld0VuZCA9PSBudWxsKSB7CiAgICAgICAgbmV3RW5kID0gZGVsZXRlUG9zaXRpb247CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgUmFuZ2UobmV3U3RhcnQsIG5ld0VuZCk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcgcmFuZ2UsIHNwcmVhZGluZyBmcm9tIHNwZWNpZmllZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0gdG8gYSBwb3NpdGlvbiBtb3ZlZCBieQogICAgICogZ2l2ZW4gYHNoaWZ0YC4gSWYgYHNoaWZ0YCBpcyBhIG5lZ2F0aXZlIHZhbHVlLCBzaGlmdGVkIHBvc2l0aW9uIGlzIHRyZWF0ZWQgYXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmFuZ2UuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBCZWdpbm5pbmcgb2YgdGhlIHJhbmdlLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IHNoaWZ0IEhvdyBsb25nIHRoZSByYW5nZSBzaG91bGQgYmUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9XSwgW3sKICAgIGtleTogIl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KHBvc2l0aW9uLCBzaGlmdCkgewogICAgICB2YXIgc3RhcnQgPSBwb3NpdGlvbjsKICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uLmdldFNoaWZ0ZWRCeShzaGlmdCk7CiAgICAgIHJldHVybiBzaGlmdCA+IDAgPyBuZXcgdGhpcyhzdGFydCwgZW5kKSA6IG5ldyB0aGlzKGVuZCwgc3RhcnQpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZgogICAgICogdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgd2hpY2ggaXMgYSBwYXJlbnQgZm9yIHRoZSByYW5nZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jcmVhdGVJbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUluKGVsZW1lbnQpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzKFBvc2l0aW9uLl9jcmVhdGVBdChlbGVtZW50LCAwKSwgUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQsIGVsZW1lbnQubWF4T2Zmc2V0KSk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSByYW5nZSB0aGF0IHN0YXJ0cyBiZWZvcmUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19IGFuZCBlbmRzIGFmdGVyIGl0LgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IGl0ZW0KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jcmVhdGVPbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZU9uKGl0ZW0pIHsKICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSksIGl0ZW0ub2Zmc2V0U2l6ZSk7CiAgICB9CiAgICAvKioKICAgICAqIENvbWJpbmVzIGFsbCByYW5nZXMgZnJvbSB0aGUgcGFzc2VkIGFycmF5IGludG8gYSBvbmUgcmFuZ2UuIEF0IGxlYXN0IG9uZSByYW5nZSBoYXMgdG8gYmUgcGFzc2VkLgogICAgICogUGFzc2VkIHJhbmdlcyBtdXN0IG5vdCBoYXZlIGNvbW1vbiBwYXJ0cy4KICAgICAqCiAgICAgKiBUaGUgZmlyc3QgcmFuZ2UgZnJvbSB0aGUgYXJyYXkgaXMgYSByZWZlcmVuY2UgcmFuZ2UuIElmIG90aGVyIHJhbmdlcyBzdGFydCBvciBlbmQgb24gdGhlIGV4YWN0bHkgc2FtZSBwb3NpdGlvbiB3aGVyZQogICAgICogdGhlIHJlZmVyZW5jZSByYW5nZSwgdGhleSBnZXQgY29tYmluZWQgaW50byBvbmUgcmFuZ2UuCiAgICAgKgogICAgICoJCVsgIF1bXSAgWyAgICBdWyBdWyAgICAgICAgICAgICBdWyBdW10gIFsgIF0gIC8vIFBhc3NlZCByYW5nZXMsIHNob3duIHNvcnRlZAogICAgICoJCVsgICAgXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlmIHRoZSBmaXJzdCByYW5nZSB3YXMgYSByZWZlcmVuY2UgcmFuZ2UuCiAgICAgKgkgICAgICAgICAgICBbICAgICAgICAgICAgICAgICAgICAgICAgICAgXSAgICAgICAgLy8gVGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaWYgdGhlIHRoaXJkLXRvLXNldmVudGggcmFuZ2Ugd2FzIGEgcmVmZXJlbmNlIHJhbmdlLgogICAgICoJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgIF0gIC8vIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlmIHRoZSBsYXN0IHJhbmdlIHdhcyBhIHJlZmVyZW5jZSByYW5nZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gcmFuZ2VzIFJhbmdlcyB0byBjb21iaW5lLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IENvbWJpbmVkIHJhbmdlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jcmVhdGVGcm9tUmFuZ2VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRnJvbVJhbmdlcyhyYW5nZXMpIHsKICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDApIHsKICAgICAgICAvKioKICAgICAgICAgKiBBdCBsZWFzdCBvbmUgcmFuZ2UgaGFzIHRvIGJlIHBhc3NlZCB0bwogICAgICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlLl9jcmVhdGVGcm9tUmFuZ2VzIGBSYW5nZS5fY3JlYXRlRnJvbVJhbmdlcygpYH0uCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgcmFuZ2UtY3JlYXRlLWZyb20tcmFuZ2VzLWVtcHR5LWFycmF5CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3JhbmdlLWNyZWF0ZS1mcm9tLXJhbmdlcy1lbXB0eS1hcnJheScsIG51bGwpOwogICAgICB9IGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPT0gMSkgewogICAgICAgIHJldHVybiByYW5nZXNbMF0uY2xvbmUoKTsKICAgICAgfSAvLyAxLiBTZXQgdGhlIGZpcnN0IHJhbmdlIGluIGByYW5nZXNgIGFycmF5IGFzIGEgcmVmZXJlbmNlIHJhbmdlLgogICAgICAvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gcmV0dXJuIGp1c3QgYSBvbmUgcmFuZ2UsIG9uZSBvZiB0aGUgcmFuZ2VzIG5lZWQgdG8gYmUgdGhlIHJlZmVyZW5jZSBvbmUuCiAgICAgIC8vIE90aGVyIHJhbmdlcyB3aWxsIGJlIHN0dWNrIHRvIHRoYXQgcmFuZ2UsIGlmIHBvc3NpYmxlLgoKCiAgICAgIHZhciByZWYgPSByYW5nZXNbMF07IC8vIDIuIFNvcnQgYWxsIHRoZSByYW5nZXMgc28gaXQncyBlYXNpZXIgdG8gcHJvY2VzcyB0aGVtLgoKICAgICAgcmFuZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICByZXR1cm4gYS5zdGFydC5pc0FmdGVyKGIuc3RhcnQpID8gMSA6IC0xOwogICAgICB9KTsgLy8gMy4gQ2hlY2sgYXQgd2hpY2ggaW5kZXggdGhlIHJlZmVyZW5jZSByYW5nZSBpcyBub3cuCgogICAgICB2YXIgcmVmSW5kZXggPSByYW5nZXMuaW5kZXhPZihyZWYpOyAvLyA0LiBBdCB0aGlzIG1vbWVudCB3ZSBkb24ndCBuZWVkIHRoZSBvcmlnaW5hbCByYW5nZS4KICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIG1vZGlmeSB0aGUgcmVzdWx0IGFuZCB3ZSBuZWVkIHRvIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBSYW5nZS4KICAgICAgLy8gV2UgaGF2ZSB0byBjcmVhdGUgYSBjb3B5IG9mIHRoZSByZWZlcmVuY2UgcmFuZ2UuCgogICAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMocmVmLnN0YXJ0LCByZWYuZW5kKTsgLy8gNS4gUmFuZ2VzIHNob3VsZCBiZSBjaGVja2VkIGFuZCBnbHVlZCBzdGFydGluZyBmcm9tIHRoZSByYW5nZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHJlZmVyZW5jZSByYW5nZS4KICAgICAgLy8gU2luY2UgcmFuZ2VzIGFyZSBzb3J0ZWQsIHN0YXJ0IHdpdGggdGhlIHJhbmdlIHdpdGggaW5kZXggdGhhdCBpcyBjbG9zZXN0IHRvIHJlZmVyZW5jZSByYW5nZSBpbmRleC4KCiAgICAgIGlmIChyZWZJbmRleCA+IDApIHsKICAgICAgICBmb3IgKHZhciBpID0gcmVmSW5kZXggLSAxOyB0cnVlOyBpKyspIHsKICAgICAgICAgIGlmIChyYW5nZXNbaV0uZW5kLmlzRXF1YWwocmVzdWx0LnN0YXJ0KSkgewogICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQocmFuZ2VzW2ldLnN0YXJ0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIElmIHJhbmdlcyBhcmUgbm90IHN0YXJ0aW5nL2VuZGluZyBhdCB0aGUgc2FtZSBwb3NpdGlvbiB0aGVyZSBpcyBubyBwb2ludCBpbiBsb29raW5nIGZ1cnRoZXIuCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyA2LiBSYW5nZXMgc2hvdWxkIGJlIGNoZWNrZWQgYW5kIGdsdWVkIHN0YXJ0aW5nIGZyb20gdGhlIHJhbmdlIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcmVmZXJlbmNlIHJhbmdlLgogICAgICAvLyBTaW5jZSByYW5nZXMgYXJlIHNvcnRlZCwgc3RhcnQgd2l0aCB0aGUgcmFuZ2Ugd2l0aCBpbmRleCB0aGF0IGlzIGNsb3Nlc3QgdG8gcmVmZXJlbmNlIHJhbmdlIGluZGV4LgoKCiAgICAgIGZvciAodmFyIF9pMiA9IHJlZkluZGV4ICsgMTsgX2kyIDwgcmFuZ2VzLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICBpZiAocmFuZ2VzW19pMl0uc3RhcnQuaXNFcXVhbChyZXN1bHQuZW5kKSkgewogICAgICAgICAgcmVzdWx0LmVuZCA9IFBvc2l0aW9uLl9jcmVhdGVBdChyYW5nZXNbX2kyXS5lbmQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBJZiByYW5nZXMgYXJlIG5vdCBzdGFydGluZy9lbmRpbmcgYXQgdGhlIHNhbWUgcG9zaXRpb24gdGhlcmUgaXMgbm8gcG9pbnQgaW4gbG9va2luZyBmdXJ0aGVyLgogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgYFJhbmdlYCBpbnN0YW5jZSBmcm9tIGdpdmVuIHBsYWluIG9iamVjdCAoaS5lLiBwYXJzZWQgSlNPTiBzdHJpbmcpLgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIFBsYWluIG9iamVjdCB0byBiZSBjb252ZXJ0ZWQgdG8gYFJhbmdlYC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0gZG9jIERvY3VtZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgcmFuZ2Ugb3duZXIuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGBSYW5nZWAgaW5zdGFuY2UgY3JlYXRlZCB1c2luZyBnaXZlbiBwbGFpbiBvYmplY3QuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZnJvbUpTT04iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24sIGRvYykgewogICAgICByZXR1cm4gbmV3IHRoaXMoUG9zaXRpb24uZnJvbUpTT04oanNvbi5zdGFydCwgZG9jKSwgUG9zaXRpb24uZnJvbUpTT04oanNvbi5lbmQsIGRvYykpOwogICAgfSAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRvU3RyaW5nKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJcmV0dXJuIGAkeyB0aGlzLnJvb3QgfSBbICR7IHRoaXMuc3RhcnQucGF0aC5qb2luKCAnLCAnICkgfSBdIC0gWyAkeyB0aGlzLmVuZC5wYXRoLmpvaW4oICcsICcgKSB9IF1gOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGxvZygpIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCWNvbnNvbGUubG9nKCAnTW9kZWxQb3NpdGlvbjogJyArIHRoaXMgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKICB9XSk7CgogIHJldHVybiBSYW5nZTsKfSgpOwoKZXhwb3J0IHsgUmFuZ2UgYXMgZGVmYXVsdCB9Ow=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js"],"names":["Position","TreeWalker","CKEditorError","compareArrays","Range","start","end","_createAt","stickiness","isCollapsed","Symbol","iterator","boundaries","ignoreElementEnd","isEqual","startParentPath","getParentPath","endParentPath","root","position","isAfter","isBefore","otherRange","loose","containsStart","containsPosition","containsEnd","item","pos","_createBefore","type","ranges","isIntersecting","push","commonRangeStart","commonRangeEnd","shouldJoin","isTouching","startPosition","endPosition","diffAt","getCommonPath","length","posParent","parent","path","howMany","maxOffset","offset","getShiftedBy","slice","options","treeWalker","value","nextPosition","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","operations","i","result","getTransformedByOperation","splice","range","j","next","containsRange","getCommonAncestor","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","is","toJSON","constructor","spread","_getTransformedByInsertion","sourcePosition","targetPosition","_getTransformedByMove","insertionPosition","deletionPosition","insertPosition","newPos","moveRange","_createFromPositionAndShift","_getTransformedByDeletion","differenceSet","getDifference","difference","common","getIntersection","transformedCommon","_getCombined","deletePosition","newStart","newEnd","shift","element","offsetSize","clone","ref","sort","a","b","refIndex","indexOf","json","doc","fromJSON"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n/**\n * Represents a range in the model tree.\n *\n * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}\n * positions.\n *\n * You can create range instances via its constructor or the `createRange*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.start = Position._createAt( start );\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.end = end ? Position._createAt( end ) : Position._createAt( start );\n\n\t\t// If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.\n\t\t// In other case, make the boundaries stick to the \"inside\" of the range.\n\t\tthis.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';\n\t\tthis.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/model/position~Position positions},\n\t * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n\t * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n\t *\n\t * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n\t * and `ignoreElementEnd` option set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is if {@link #start} and\n\t * {@link #end} positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link #start} position and\n\t * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\tconst startParentPath = this.start.getParentPath();\n\t\tconst endParentPath = this.end.getParentPath();\n\n\t\treturn compareArrays( startParentPath, endParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n\t *\n\t * @param {module:engine/model/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n\t * in this range,`false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link ~Range range}.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n\t *\n\t * @param {module:engine/model/item~Item} item Model item to check.\n\t */\n\tcontainsItem( item ) {\n\t\tconst pos = Position._createBefore( item );\n\n\t\treturn this.containsPosition( pos ) || this.start.isEqual( pos );\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\trange.is( 'range' ); // -> true\n\t *\t\trange.is( 'model:range' ); // -> true\n\t *\n\t *\t\trange.is( 'view:range' ); // -> false\n\t *\t\trange.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'range' || type === 'model:range';\n\t}\n\n\t/**\n\t * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end );\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with given range.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n\t * Returned array contains zero, one or two {@link ~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( new Range( this.start, this.end ) );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n\t *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.\n\t * If ranges have no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 1 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2 ] )\n \t *\t\t);\n\t *\t\tlet transformed = range.getJoined( otherRange ); // null - ranges have no common part\n\t *\n\t *\t\totherRange = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 3 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 5 ] )\n\t *\t\t);\n\t *\t\ttransformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to be joined.\n\t * @param {Boolean} [loose=false] Whether the intersection check is loose or strict. If the check is strict (`false`),\n\t * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),\n\t * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.\n\t * @returns {module:engine/model/range~Range|null} A sum of given ranges or `null` if ranges have no common part.\n\t */\n\tgetJoined( otherRange, loose = false ) {\n\t\tlet shouldJoin = this.isIntersecting( otherRange );\n\n\t\tif ( !shouldJoin ) {\n\t\t\tif ( this.start.isBefore( otherRange.start ) ) {\n\t\t\t\tshouldJoin = loose ? this.end.isTouching( otherRange.start ) : this.end.isEqual( otherRange.start );\n\t\t\t} else {\n\t\t\t\tshouldJoin = loose ? otherRange.end.isTouching( this.start ) : otherRange.end.isEqual( this.start );\n\t\t\t}\n\t\t}\n\n\t\tif ( !shouldJoin ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet startPosition = this.start;\n\t\tlet endPosition = this.end;\n\n\t\tif ( otherRange.start.isBefore( startPosition ) ) {\n\t\t\tstartPosition = otherRange.start;\n\t\t}\n\n\t\tif ( otherRange.end.isAfter( endPosition ) ) {\n\t\t\tendPosition = otherRange.end;\n\t\t}\n\n\t\treturn new Range( startPosition, endPosition );\n\t}\n\n\t/**\n\t * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n\t *\n\t * See an example of a model structure (`[` and `]` are range boundaries):\n\t *\n\t *\t\troot                                                            root\n\t *\t\t |- element DIV                         DIV             P2              P3             DIV\n\t *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n\t *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n\t *\t\t |   |- element P1\n\t *\t\t |   |   |- \"lorem\"                                              ||\n\t *\t\t |- element P2                                                   ||\n\t *\t\t |   |- \"foo\"                                                    VV\n\t *\t\t |- element P3\n\t *\t\t |   |- \"bar\"                                                   root\n\t *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n\t *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n\t *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n\t *\t\t |   |- element P4\n\t *\t\t |   |   |- \"ipsum\"\n\t *\n\t * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n\t * We are looking for minimal set of flat ranges that contains the same nodes.\n\t *\n\t * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n\t *\n\t *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n\t *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n\t *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n\t *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n\t *\n\t * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n\t * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n\t * were omitted. Only their parts that were wholly in the range were returned.\n\t *\n\t * **Note:** this method is not returning flat ranges that contain no nodes.\n\t *\n\t * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n\t */\n\tgetMinimalFlatRanges() {\n\t\tconst ranges = [];\n\t\tconst diffAt = this.start.getCommonPath( this.end ).length;\n\n\t\tconst pos = Position._createAt( this.start );\n\t\tlet posParent = pos.parent;\n\n\t\t// Go up.\n\t\twhile ( pos.path.length > diffAt + 1 ) {\n\t\t\tconst howMany = posParent.maxOffset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.path = pos.path.slice( 0, -1 );\n\t\t\tpos.offset++;\n\t\t\tposParent = posParent.parent;\n\t\t}\n\n\t\t// Go down.\n\t\twhile ( pos.path.length <= this.end.path.length ) {\n\t\t\tconst offset = this.end.path[ pos.path.length - 1 ];\n\t\t\tconst howMany = offset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.offset = offset;\n\t\t\tpos.path.push( 0 );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * For example, to iterate over all items in the entire document root:\n\t *\n\t *\t\t// Create a range spanning over the entire root content:\n\t *\t\tconst range = editor.model.createRangeIn( editor.model.document.getRoot() );\n\t *\n\t *\t\t// Iterate over all items in this range:\n\t *\t\tfor ( const value of range.getWalker() ) {\n\t *\t\t\tconsole.log( value.item );\n\t *\t\t}\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @param {module:engine/model/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n\t * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by given `operation`.\n\t *\n\t * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is\n\t * moved to a different part of document tree). For this reason, an array is returned by this method and it\n\t * may contain one or more `Range` instances.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\treturn this._getTransformedByInsertOperation( operation );\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\treturn this._getTransformedByMoveOperation( operation );\n\t\t\tcase 'split':\n\t\t\t\treturn [ this._getTransformedBySplitOperation( operation ) ];\n\t\t\tcase 'merge':\n\t\t\t\treturn [ this._getTransformedByMergeOperation( operation ) ];\n\t\t}\n\n\t\treturn [ new Range( this.start, this.end ) ];\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by multiple `operations`.\n\t *\n\t * @see ~Range#getTransformedByOperation\n\t * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByOperations( operations ) {\n\t\tconst ranges = [ new Range( this.start, this.end ) ];\n\n\t\tfor ( const operation of operations ) {\n\t\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\t\tconst result = ranges[ i ].getTransformedByOperation( operation );\n\n\t\t\t\tranges.splice( i, 1, ...result );\n\t\t\t\ti += result.length - 1;\n\t\t\t}\n\t\t}\n\n\t\t// It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n\t\t// \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n\t\t// because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n\t\t// are inside other ranges and we simply remove them.\n\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\tconst range = ranges[ i ];\n\n\t\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t\tconst next = ranges[ j ];\n\n\t\t\t\tif ( range.containsRange( next ) || next.containsRange( range ) || range.isEqual( next ) ) {\n\t\t\t\t\tranges.splice( j, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of the range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element Element} contained by the range.\n\t * The element will be returned when it is the **only** node within the range and **fullycontained**\n\t * at the same time.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetContainedElement() {\n\t\tif ( this.isCollapsed ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst nodeAfterStart = this.start.nodeAfter;\n\t\tconst nodeBeforeEnd = this.end.nodeBefore;\n\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'element' ) && nodeAfterStart === nodeBeforeEnd ) {\n\t\t\treturn nodeAfterStart;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts `Range` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\tstart: this.start.toJSON(),\n\t\t\tend: this.end.toJSON()\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new range that is equal to current range.\n\t *\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.start, this.end );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by insert operation.\n\t *\n\t * One or more ranges may be returned as a result of this transformation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByInsertOperation( operation, spread = false ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany, spread );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by move operation.\n\t *\n\t * One or more ranges may be returned as a result of this transformation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByMoveOperation( operation, spread = false ) {\n\t\tconst sourcePosition = operation.sourcePosition;\n\t\tconst howMany = operation.howMany;\n\t\tconst targetPosition = operation.targetPosition;\n\n\t\treturn this._getTransformedByMove( sourcePosition, targetPosition, howMany, spread );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by split operation.\n\t *\n\t * Always one range is returned. The transformation is done in a way to not break the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst start = this.start._getTransformedBySplitOperation( operation );\n\t\tlet end = this.end._getTransformedBySplitOperation( operation );\n\n\t\tif ( this.end.isEqual( operation.insertionPosition ) ) {\n\t\t\tend = this.end.getShiftedBy( 1 );\n\t\t}\n\n\t\t// Below may happen when range contains graveyard element used by split operation.\n\t\tif ( start.root != end.root ) {\n\t\t\t// End position was next to the moved graveyard element and was moved with it.\n\t\t\t// Fix it by using old `end` which has proper `root`.\n\t\t\tend = this.end.getShiftedBy( -1 );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by merge operation.\n\t *\n\t * Always one range is returned. The transformation is done in a way to not break the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\t// Special case when the marker is set on \"the closing tag\" of an element. Marker can be set like that during\n\t\t// transformations, especially when a content of a few block elements were removed. For example:\n\t\t//\n\t\t// {} is the transformed range, [] is the removed range.\n\t\t// <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>\n\t\t//\n\t\t// <p>Fo{o</p><p>B}ar</p><p>z</p>\n\t\t// <p>F{</p><p>B}ar</p><p>z</p>\n\t\t// <p>F{</p>}<p>z</p>\n\t\t// <p>F{}z</p>\n\t\t//\n\t\tif ( this.start.isEqual( operation.targetPosition ) && this.end.isEqual( operation.deletionPosition ) ) {\n\t\t\treturn new Range( this.start );\n\t\t}\n\n\t\tlet start = this.start._getTransformedByMergeOperation( operation );\n\t\tlet end = this.end._getTransformedByMergeOperation( operation );\n\n\t\tif ( start.root != end.root ) {\n\t\t\t// This happens when the end position was next to the merged (deleted) element.\n\t\t\t// Then, the end position was moved to the graveyard root. In this case we need to fix\n\t\t\t// the range cause its boundaries would be in different roots.\n\t\t\tend = this.end.getShiftedBy( -1 );\n\t\t}\n\n\t\tif ( start.isAfter( end ) ) {\n\t\t\t// This happens in three following cases:\n\t\t\t//\n\t\t\t// Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)\n\t\t\t//         This means that start can be moved before the end of the range.\n\t\t\t//\n\t\t\t// Before: <p>a{a</p><p>b}b</p><p>cc</p>\n\t\t\t// Merge:  <p>b}b</p><p>cca{a</p>\n\t\t\t// Fix:    <p>{b}b</p><p>ccaa</p>\n\t\t\t//\n\t\t\t// Case 2: Range start is before merged node but not directly.\n\t\t\t//         Result should include all nodes that were in the original range.\n\t\t\t//\n\t\t\t// Before: <p>aa</p>{<p>cc</p><p>b}b</p>\n\t\t\t// Merge:  <p>aab}b</p>{<p>cc</p>\n\t\t\t// Fix:    <p>aa{bb</p><p>cc</p>}\n\t\t\t//\n\t\t\t//         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.\n\t\t\t//\n\t\t\t// Case 3: Range start is directly before merged node.\n\t\t\t//         Resulting range should include only nodes from the merged element:\n\t\t\t//\n\t\t\t// Before: <p>aa</p>{<p>b}b</p><p>cc</p>\n\t\t\t// Merge:  <p>aab}b</p>{<p>cc</p>\n\t\t\t// Fix:    <p>aa{b}b</p><p>cc</p>\n\t\t\t//\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Case 1.\n\t\t\t\tstart = Position._createAt( end );\n\t\t\t\tstart.offset = 0;\n\t\t\t} else {\n\t\t\t\tif ( !operation.deletionPosition.isEqual( start ) ) {\n\t\t\t\t\t// Case 2.\n\t\t\t\t\tend = operation.deletionPosition;\n\t\t\t\t}\n\n\t\t\t\t// In both case 2 and 3 start is at the end of the merge-to element.\n\t\t\t\tstart = operation.targetPosition;\n\t\t\t}\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n\t * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );\n\t *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );\n\t *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );\n\t *\t\t// transformed array has one range, which is equal to original range\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n\t * was inside the range. Defaults to `false`.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany, spread = false ) {\n\t\tif ( spread && this.containsPosition( insertPosition ) ) {\n\t\t\t// Range has to be spread. The first part is from original start to the spread point.\n\t\t\t// The other part is from spread point to the original end, but transformed by\n\t\t\t// insertion to reflect insertion changes.\n\n\t\t\treturn [\n\t\t\t\tnew Range( this.start, insertPosition ),\n\t\t\t\tnew Range(\n\t\t\t\t\tinsertPosition.getShiftedBy( howMany ),\n\t\t\t\t\tthis.end._getTransformedByInsertion( insertPosition, howMany )\n\t\t\t\t)\n\t\t\t];\n\t\t} else {\n\t\t\tconst range = new Range( this.start, this.end );\n\n\t\t\trange.start = range.start._getTransformedByInsertion( insertPosition, howMany );\n\t\t\trange.end = range.end._getTransformedByInsertion( insertPosition, howMany );\n\n\t\t\treturn [ range ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n\t * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n\t * @param {Number} howMany How many nodes are moved.\n\t * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany, spread = false ) {\n\t\t// Special case for transforming a collapsed range. Just transform it like a position.\n\t\tif ( this.isCollapsed ) {\n\t\t\tconst newPos = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\n\t\t\treturn [ new Range( newPos ) ];\n\t\t}\n\n\t\t// Special case for transformation when a part of the range is moved towards the range.\n\t\t//\n\t\t// Examples:\n\t\t//\n\t\t// <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>\n\t\t// <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>\n\t\t//\n\t\t// Without this special condition, the default algorithm leaves an \"artifact\" range from one of `differenceSet` parts:\n\t\t//\n\t\t// <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>\n\t\t//\n\t\t// This special case is applied only if the range is to be kept together (not spread).\n\t\tconst moveRange = Range._createFromPositionAndShift( sourcePosition, howMany );\n\t\tconst insertPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( this.containsPosition( targetPosition ) && !spread ) {\n\t\t\tif ( moveRange.containsPosition( this.start ) || moveRange.containsPosition( this.end ) ) {\n\t\t\t\tconst start = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\t\t\t\tconst end = this.end._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\n\t\t\t\treturn [ new Range( start, end ) ];\n\t\t\t}\n\t\t}\n\n\t\t// Default algorithm.\n\t\tlet result;\n\n\t\tconst differenceSet = this.getDifference( moveRange );\n\t\tlet difference = null;\n\n\t\tconst common = this.getIntersection( moveRange );\n\n\t\tif ( differenceSet.length == 1 ) {\n\t\t\t// `moveRange` and this range may intersect but may be separate.\n\t\t\tdifference = new Range(\n\t\t\t\tdifferenceSet[ 0 ].start._getTransformedByDeletion( sourcePosition, howMany ),\n\t\t\t\tdifferenceSet[ 0 ].end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} else if ( differenceSet.length == 2 ) {\n\t\t\t// `moveRange` is inside this range.\n\t\t\tdifference = new Range(\n\t\t\t\tthis.start,\n\t\t\t\tthis.end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} // else, `moveRange` contains this range.\n\n\t\tif ( difference ) {\n\t\t\tresult = difference._getTransformedByInsertion( insertPosition, howMany, common !== null || spread );\n\t\t} else {\n\t\t\tresult = [];\n\t\t}\n\n\t\tif ( common ) {\n\t\t\tconst transformedCommon = new Range(\n\t\t\t\tcommon.start._getCombined( moveRange.start, insertPosition ),\n\t\t\t\tcommon.end._getCombined( moveRange.start, insertPosition )\n\t\t\t);\n\n\t\t\tif ( result.length == 2 ) {\n\t\t\t\tresult.splice( 1, 0, transformedCommon );\n\t\t\t} else {\n\t\t\t\tresult.push( transformedCommon );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.\n\t *\n\t * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.\n\t *\n\t * If the deleted range contains transformed range, `null` will be returned.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/range~Range|null} Result of the transformation.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tlet newStart = this.start._getTransformedByDeletion( deletePosition, howMany );\n\t\tlet newEnd = this.end._getTransformedByDeletion( deletePosition, howMany );\n\n\t\tif ( newStart == null && newEnd == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( newStart == null ) {\n\t\t\tnewStart = deletePosition;\n\t\t}\n\n\t\tif ( newEnd == null ) {\n\t\t\tnewEnd = deletePosition;\n\t\t}\n\n\t\treturn new Range( newStart, newEnd );\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createIn( element ) {\n\t\treturn new this( Position._createAt( element, 0 ), Position._createAt( element, element.maxOffset ) );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createOn( item ) {\n\t\treturn this._createFromPositionAndShift( Position._createBefore( item ), item.offsetSize );\n\t}\n\n\t/**\n\t * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n\t * Passed ranges must not have common parts.\n\t *\n\t * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n\t * the reference range, they get combined into one range.\n\t *\n\t *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n\t *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n\t *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n\t *\t                                           [  ]  // The result of the function if the last range was a reference range.\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n\t * @returns {module:engine/model/range~Range} Combined range.\n\t */\n\tstatic _createFromRanges( ranges ) {\n\t\tif ( ranges.length === 0 ) {\n\t\t\t/**\n\t\t\t * At least one range has to be passed to\n\t\t\t * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.\n\t\t\t *\n\t\t\t * @error range-create-from-ranges-empty-array\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'range-create-from-ranges-empty-array',\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if ( ranges.length == 1 ) {\n\t\t\treturn ranges[ 0 ].clone();\n\t\t}\n\n\t\t// 1. Set the first range in `ranges` array as a reference range.\n\t\t// If we are going to return just a one range, one of the ranges need to be the reference one.\n\t\t// Other ranges will be stuck to that range, if possible.\n\t\tconst ref = ranges[ 0 ];\n\n\t\t// 2. Sort all the ranges so it's easier to process them.\n\t\tranges.sort( ( a, b ) => {\n\t\t\treturn a.start.isAfter( b.start ) ? 1 : -1;\n\t\t} );\n\n\t\t// 3. Check at which index the reference range is now.\n\t\tconst refIndex = ranges.indexOf( ref );\n\n\t\t// 4. At this moment we don't need the original range.\n\t\t// We are going to modify the result and we need to return a new instance of Range.\n\t\t// We have to create a copy of the reference range.\n\t\tconst result = new this( ref.start, ref.end );\n\n\t\t// 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tif ( refIndex > 0 ) {\n\t\t\tfor ( let i = refIndex - 1; true; i++ ) {\n\t\t\t\tif ( ranges[ i ].end.isEqual( result.start ) ) {\n\t\t\t\t\tresult.start = Position._createAt( ranges[ i ].start );\n\t\t\t\t} else {\n\t\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tfor ( let i = refIndex + 1; i < ranges.length; i++ ) {\n\t\t\tif ( ranges[ i ].start.isEqual( result.end ) ) {\n\t\t\t\tresult.end = Position._createAt( ranges[ i ].end );\n\t\t\t} else {\n\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Range`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n\t * @returns {module:engine/model/element~Element} `Range` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\treturn new this( Position.fromJSON( json.start, doc ), Position.fromJSON( json.end, doc ) );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.start.path.join( ', ' ) } ] - [ ${ this.end.path.join( ', ' ) } ]`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n}\n"]}]}