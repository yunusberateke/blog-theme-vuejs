{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zZXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyCiAqLwppbXBvcnQgTW9kZWxQb3NpdGlvbiBmcm9tICcuLi9tb2RlbC9wb3NpdGlvbic7CmltcG9ydCBNb2RlbFJhbmdlIGZyb20gJy4uL21vZGVsL3JhbmdlJzsKaW1wb3J0IFZpZXdQb3NpdGlvbiBmcm9tICcuLi92aWV3L3Bvc2l0aW9uJzsKaW1wb3J0IFZpZXdSYW5nZSBmcm9tICcuLi92aWV3L3JhbmdlJzsKaW1wb3J0IFZpZXdUZXh0IGZyb20gJy4uL3ZpZXcvdGV4dCc7CmltcG9ydCBFbWl0dGVyTWl4aW4gZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvZW1pdHRlcm1peGluJzsKaW1wb3J0IG1peCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9taXgnOwovKioKICogTWFwcyBlbGVtZW50cywgcG9zaXRpb25zIGFuZCBtYXJrZXJzIGJldHdlZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudCB0aGUgdmlld30gYW5kCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsIHRoZSBtb2RlbH0uCiAqCiAqIFRoZSBpbnN0YW5jZSBvZiB0aGUgTWFwcGVyIHVzZWQgZm9yIHRoZSBlZGl0aW5nIHBpcGVsaW5lIGlzIGF2YWlsYWJsZSBpbgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb250cm9sbGVyL2VkaXRpbmdjb250cm9sbGVyfkVkaXRpbmdDb250cm9sbGVyI21hcHBlciBgZWRpdG9yLmVkaXRpbmcubWFwcGVyYH0uCiAqCiAqIE1hcHBlciB1c2VzIGJvdW5kIGVsZW1lbnRzIHRvIGZpbmQgY29ycmVzcG9uZGluZyBlbGVtZW50cyBhbmQgcG9zaXRpb25zLCBzbywgdG8gZ2V0IHByb3BlciByZXN1bHRzLAogKiBhbGwgbW9kZWwgZWxlbWVudHMgc2hvdWxkIGJlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciNiaW5kRWxlbWVudHMgYm91bmR9LgogKgogKiBUbyBtYXAgY29tcGxleCBtb2RlbCB0by9mcm9tIHZpZXcgcmVsYXRpb25zLCB5b3UgbWF5IHByb3ZpZGUgY3VzdG9tIGNhbGxiYWNrcyBmb3IKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyI2V2ZW50Om1vZGVsVG9WaWV3UG9zaXRpb24gbW9kZWxUb1ZpZXdQb3NpdGlvbiBldmVudH0gYW5kCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciNldmVudDp2aWV3VG9Nb2RlbFBvc2l0aW9uIHZpZXdUb01vZGVsUG9zaXRpb24gZXZlbnR9IHRoYXQgYXJlIGZpcmVkIHdoZW5ldmVyCiAqIGEgcG9zaXRpb24gbWFwcGluZyByZXF1ZXN0IG9jY3Vycy4KICogVGhvc2UgZXZlbnRzIGFyZSBmaXJlZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjdG9WaWV3UG9zaXRpb24gdG9WaWV3UG9zaXRpb259CiAqIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjdG9Nb2RlbFBvc2l0aW9uIHRvTW9kZWxQb3NpdGlvbn0gbWV0aG9kcy4gYE1hcHBlcmAgYWRkcyBpdCdzIG93biBkZWZhdWx0IGNhbGxiYWNrcwogKiB3aXRoIGAnbG93ZXN0J2AgcHJpb3JpdHkuIFRvIG92ZXJyaWRlIGRlZmF1bHQgYE1hcHBlcmAgbWFwcGluZywgYWRkIGN1c3RvbSBjYWxsYmFjayB3aXRoIGhpZ2hlciBwcmlvcml0eSBhbmQKICogc3RvcCB0aGUgZXZlbnQuCiAqLwoKdmFyIE1hcHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgbWFwcGVyLgogICAqLwogIGZ1bmN0aW9uIE1hcHBlcigpIHsKICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcHBlcik7CgogICAgLyoqCiAgICAgKiBNb2RlbCBlbGVtZW50IHRvIHZpZXcgZWxlbWVudCBtYXBwaW5nLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfQogICAgICovCiAgICB0aGlzLl9tb2RlbFRvVmlld01hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgLyoqCiAgICAgKiBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgZWxlbWVudCBtYXBwaW5nLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfQogICAgICovCgogICAgdGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nID0gbmV3IFdlYWtNYXAoKTsKICAgIC8qKgogICAgICogQSBtYXAgY29udGFpbmluZyBjYWxsYmFja3MgYmV0d2VlbiB2aWV3IGVsZW1lbnQgbmFtZXMgYW5kIGZ1bmN0aW9ucyBldmFsdWF0aW5nIGxlbmd0aCBvZiB2aWV3IGVsZW1lbnRzCiAgICAgKiBpbiBtb2RlbC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7TWFwfQogICAgICovCgogICAgdGhpcy5fdmlld1RvTW9kZWxMZW5ndGhDYWxsYmFja3MgPSBuZXcgTWFwKCk7CiAgICAvKioKICAgICAqIE1vZGVsIG1hcmtlciBuYW1lIHRvIHZpZXcgZWxlbWVudHMgbWFwcGluZy4KICAgICAqCiAgICAgKiBLZXlzIGFyZSBgU3RyaW5nYHMgd2hpbGUgdmFsdWVzIGFyZSBgU2V0YHMgd2l0aCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnRzfS4KICAgICAqIE9uZSBtYXJrZXIgKG5hbWUpIGNhbiBiZSBtYXBwZWQgdG8gbXVsdGlwbGUgZWxlbWVudHMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge01hcH0KICAgICAqLwoKICAgIHRoaXMuX21hcmtlck5hbWVUb0VsZW1lbnRzID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgbWFya2VyIG5hbWVzIG1hcHBpbmcuCiAgICAgKgogICAgICogVGhpcyBpcyByZXZlcnNlIHRvIHtAbGluayB+TWFwcGVyI19tYXJrZXJOYW1lVG9FbGVtZW50c30gbWFwLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtNYXB9CiAgICAgKi8KCiAgICB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcyA9IG5ldyBNYXAoKTsKICAgIC8qKgogICAgICogU3RvcmVzIG1hcmtlciBuYW1lcyBvZiBtYXJrZXJzIHdoaWNoIGhhcyBjaGFuZ2VkIGR1ZSB0byB1bmJpbmRpbmcgYSB2aWV3IGVsZW1lbnQgKHNvIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdmlldyBlbGVtZW50CiAgICAgKiBoYXMgYmVlbiByZW1vdmVkLCBtb3ZlZCBvciByZW5hbWVkKS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7U2V0Ljxtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyPn0KICAgICAqLwoKICAgIHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcyA9IG5ldyBTZXQoKTsgLy8gRGVmYXVsdCBtYXBwZXIgYWxnb3JpdGhtIGZvciBtYXBwaW5nIG1vZGVsIHBvc2l0aW9uIHRvIHZpZXcgcG9zaXRpb24uCgogICAgdGhpcy5vbignbW9kZWxUb1ZpZXdQb3NpdGlvbicsIGZ1bmN0aW9uIChldnQsIGRhdGEpIHsKICAgICAgaWYgKGRhdGEudmlld1Bvc2l0aW9uKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgdmlld0NvbnRhaW5lciA9IF90aGlzLl9tb2RlbFRvVmlld01hcHBpbmcuZ2V0KGRhdGEubW9kZWxQb3NpdGlvbi5wYXJlbnQpOwoKICAgICAgZGF0YS52aWV3UG9zaXRpb24gPSBfdGhpcy5maW5kUG9zaXRpb25Jbih2aWV3Q29udGFpbmVyLCBkYXRhLm1vZGVsUG9zaXRpb24ub2Zmc2V0KTsKICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdsb3cnCiAgICB9KTsgLy8gRGVmYXVsdCBtYXBwZXIgYWxnb3JpdGhtIGZvciBtYXBwaW5nIHZpZXcgcG9zaXRpb24gdG8gbW9kZWwgcG9zaXRpb24uCgogICAgdGhpcy5vbigndmlld1RvTW9kZWxQb3NpdGlvbicsIGZ1bmN0aW9uIChldnQsIGRhdGEpIHsKICAgICAgaWYgKGRhdGEubW9kZWxQb3NpdGlvbikgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIHZpZXdCbG9jayA9IF90aGlzLmZpbmRNYXBwZWRWaWV3QW5jZXN0b3IoZGF0YS52aWV3UG9zaXRpb24pOwoKICAgICAgdmFyIG1vZGVsUGFyZW50ID0gX3RoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5nZXQodmlld0Jsb2NrKTsKCiAgICAgIHZhciBtb2RlbE9mZnNldCA9IF90aGlzLl90b01vZGVsT2Zmc2V0KGRhdGEudmlld1Bvc2l0aW9uLnBhcmVudCwgZGF0YS52aWV3UG9zaXRpb24ub2Zmc2V0LCB2aWV3QmxvY2spOwoKICAgICAgZGF0YS5tb2RlbFBvc2l0aW9uID0gTW9kZWxQb3NpdGlvbi5fY3JlYXRlQXQobW9kZWxQYXJlbnQsIG1vZGVsT2Zmc2V0KTsKICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdsb3cnCiAgICB9KTsKICB9CiAgLyoqCiAgICogTWFya3MgbW9kZWwgYW5kIHZpZXcgZWxlbWVudHMgYXMgY29ycmVzcG9uZGluZy4gQ29ycmVzcG9uZGluZyBlbGVtZW50cyBjYW4gYmUgcmV0cmlldmVkIGJ5IHVzaW5nCiAgICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciN0b01vZGVsRWxlbWVudCB0b01vZGVsRWxlbWVudH0gYW5kCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyI3RvVmlld0VsZW1lbnQgdG9WaWV3RWxlbWVudH0gbWV0aG9kcy4KICAgKiBUaGUgaW5mb3JtYXRpb24gdGhhdCBlbGVtZW50cyBhcmUgYm91bmQgaXMgYWxzbyB1c2VkIHRvIHRyYW5zbGF0ZSBwb3NpdGlvbnMuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBtb2RlbEVsZW1lbnQgTW9kZWwgZWxlbWVudC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IHZpZXdFbGVtZW50IFZpZXcgZWxlbWVudC4KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhNYXBwZXIsIFt7CiAgICBrZXk6ICJiaW5kRWxlbWVudHMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFbGVtZW50cyhtb2RlbEVsZW1lbnQsIHZpZXdFbGVtZW50KSB7CiAgICAgIHRoaXMuX21vZGVsVG9WaWV3TWFwcGluZy5zZXQobW9kZWxFbGVtZW50LCB2aWV3RWxlbWVudCk7CgogICAgICB0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcuc2V0KHZpZXdFbGVtZW50LCBtb2RlbEVsZW1lbnQpOwogICAgfQogICAgLyoqCiAgICAgKiBVbmJpbmRzIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gZnJvbSB0aGUgbWFwLgogICAgICoKICAgICAqICoqTm90ZToqKiB2aWV3LXRvLW1vZGVsIGJpbmRpbmcgd2lsbCBiZSByZW1vdmVkLCBpZiBpdCBleGlzdGVkLiBIb3dldmVyLCBjb3JyZXNwb25kaW5nIG1vZGVsLXRvLXZpZXcgYmluZGluZwogICAgICogd2lsbCBiZSByZW1vdmVkIG9ubHkgaWYgbW9kZWwgZWxlbWVudCBpcyBzdGlsbCBib3VuZCB0byBwYXNzZWQgYHZpZXdFbGVtZW50YC4KICAgICAqCiAgICAgKiBUaGlzIGJlaGF2aW9yIGxldHMgZm9yIHJlLWJpbmRpbmcgbW9kZWwgZWxlbWVudCB0byBhbm90aGVyIHZpZXcgZWxlbWVudCB3aXRob3V0IGZlYXIgb2YgbG9zaW5nIHRoZSBuZXcgYmluZGluZwogICAgICogd2hlbiB0aGUgcHJldmlvdXNseSBib3VuZCB2aWV3IGVsZW1lbnQgaXMgdW5ib3VuZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IHZpZXdFbGVtZW50IFZpZXcgZWxlbWVudCB0byB1bmJpbmQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidW5iaW5kVmlld0VsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZFZpZXdFbGVtZW50KHZpZXdFbGVtZW50KSB7CiAgICAgIHZhciBtb2RlbEVsZW1lbnQgPSB0aGlzLnRvTW9kZWxFbGVtZW50KHZpZXdFbGVtZW50KTsKCiAgICAgIHRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5kZWxldGUodmlld0VsZW1lbnQpOwoKICAgICAgaWYgKHRoaXMuX2VsZW1lbnRUb01hcmtlck5hbWVzLmhhcyh2aWV3RWxlbWVudCkpIHsKICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fZWxlbWVudFRvTWFya2VyTmFtZXMuZ2V0KHZpZXdFbGVtZW50KSksCiAgICAgICAgICAgIF9zdGVwOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIG1hcmtlck5hbWUgPSBfc3RlcC52YWx1ZTsKCiAgICAgICAgICAgIHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcy5hZGQobWFya2VyTmFtZSk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuX21vZGVsVG9WaWV3TWFwcGluZy5nZXQobW9kZWxFbGVtZW50KSA9PSB2aWV3RWxlbWVudCkgewogICAgICAgIHRoaXMuX21vZGVsVG9WaWV3TWFwcGluZy5kZWxldGUobW9kZWxFbGVtZW50KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBVbmJpbmRzIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBtb2RlbCBlbGVtZW50fSBmcm9tIHRoZSBtYXAuCiAgICAgKgogICAgICogKipOb3RlOioqIG1vZGVsLXRvLXZpZXcgYmluZGluZyB3aWxsIGJlIHJlbW92ZWQsIGlmIGl0IGV4aXN0ZWQuIEhvd2V2ZXIsIGNvcnJlc3BvbmRpbmcgdmlldy10by1tb2RlbCBiaW5kaW5nCiAgICAgKiB3aWxsIGJlIHJlbW92ZWQgb25seSBpZiB2aWV3IGVsZW1lbnQgaXMgc3RpbGwgYm91bmQgdG8gcGFzc2VkIGBtb2RlbEVsZW1lbnRgLgogICAgICoKICAgICAqIFRoaXMgYmVoYXZpb3IgbGV0cyBmb3IgcmUtYmluZGluZyB2aWV3IGVsZW1lbnQgdG8gYW5vdGhlciBtb2RlbCBlbGVtZW50IHdpdGhvdXQgZmVhciBvZiBsb3NpbmcgdGhlIG5ldyBiaW5kaW5nCiAgICAgKiB3aGVuIHRoZSBwcmV2aW91c2x5IGJvdW5kIG1vZGVsIGVsZW1lbnQgaXMgdW5ib3VuZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBtb2RlbEVsZW1lbnQgTW9kZWwgZWxlbWVudCB0byB1bmJpbmQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidW5iaW5kTW9kZWxFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRNb2RlbEVsZW1lbnQobW9kZWxFbGVtZW50KSB7CiAgICAgIHZhciB2aWV3RWxlbWVudCA9IHRoaXMudG9WaWV3RWxlbWVudChtb2RlbEVsZW1lbnQpOwoKICAgICAgdGhpcy5fbW9kZWxUb1ZpZXdNYXBwaW5nLmRlbGV0ZShtb2RlbEVsZW1lbnQpOwoKICAgICAgaWYgKHRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5nZXQodmlld0VsZW1lbnQpID09IG1vZGVsRWxlbWVudCkgewogICAgICAgIHRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5kZWxldGUodmlld0VsZW1lbnQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEJpbmRzIGdpdmVuIG1hcmtlciBuYW1lIHdpdGggZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fS4gVGhlIGVsZW1lbnQKICAgICAqIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgc2V0IG9mIGVsZW1lbnRzIGJvdW5kIHdpdGggZ2l2ZW4gbWFya2VyIG5hbWUuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gYmluZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE1hcmtlciBuYW1lLgogICAgICovCgogIH0sIHsKICAgIGtleTogImJpbmRFbGVtZW50VG9NYXJrZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFbGVtZW50VG9NYXJrZXIoZWxlbWVudCwgbmFtZSkgewogICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLl9tYXJrZXJOYW1lVG9FbGVtZW50cy5nZXQobmFtZSkgfHwgbmV3IFNldCgpOwogICAgICBlbGVtZW50cy5hZGQoZWxlbWVudCk7CiAgICAgIHZhciBuYW1lcyA9IHRoaXMuX2VsZW1lbnRUb01hcmtlck5hbWVzLmdldChlbGVtZW50KSB8fCBuZXcgU2V0KCk7CiAgICAgIG5hbWVzLmFkZChuYW1lKTsKCiAgICAgIHRoaXMuX21hcmtlck5hbWVUb0VsZW1lbnRzLnNldChuYW1lLCBlbGVtZW50cyk7CgogICAgICB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcy5zZXQoZWxlbWVudCwgbmFtZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBVbmJpbmRzIGFuIGVsZW1lbnQgZnJvbSBnaXZlbiBtYXJrZXIgbmFtZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB1bmJpbmQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBNYXJrZXIgbmFtZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ1bmJpbmRFbGVtZW50RnJvbU1hcmtlck5hbWUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZEVsZW1lbnRGcm9tTWFya2VyTmFtZShlbGVtZW50LCBuYW1lKSB7CiAgICAgIHZhciBuYW1lVG9FbGVtZW50cyA9IHRoaXMuX21hcmtlck5hbWVUb0VsZW1lbnRzLmdldChuYW1lKTsKCiAgICAgIGlmIChuYW1lVG9FbGVtZW50cykgewogICAgICAgIG5hbWVUb0VsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTsKCiAgICAgICAgaWYgKG5hbWVUb0VsZW1lbnRzLnNpemUgPT0gMCkgewogICAgICAgICAgdGhpcy5fbWFya2VyTmFtZVRvRWxlbWVudHMuZGVsZXRlKG5hbWUpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIGVsZW1lbnRUb05hbWVzID0gdGhpcy5fZWxlbWVudFRvTWFya2VyTmFtZXMuZ2V0KGVsZW1lbnQpOwoKICAgICAgaWYgKGVsZW1lbnRUb05hbWVzKSB7CiAgICAgICAgZWxlbWVudFRvTmFtZXMuZGVsZXRlKG5hbWUpOwoKICAgICAgICBpZiAoZWxlbWVudFRvTmFtZXMuc2l6ZSA9PSAwKSB7CiAgICAgICAgICB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcy5kZWxldGUoZWxlbWVudCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYWxsIG1hcmtlciBuYW1lcyBvZiBtYXJrZXJzIHdoaWNoIGhhcyBjaGFuZ2VkIGR1ZSB0byB1bmJpbmRpbmcgYSB2aWV3IGVsZW1lbnQgKHNvIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdmlldyBlbGVtZW50CiAgICAgKiBoYXMgYmVlbiByZW1vdmVkLCBtb3ZlZCBvciByZW5hbWVkKSBzaW5jZSB0aGUgbGFzdCBmbHVzaC4gQWZ0ZXIgcmV0dXJuaW5nLCB0aGUgbWFya2VyIG5hbWVzIGxpc3QgaXMgY2xlYXJlZC4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZmx1c2hVbmJvdW5kTWFya2VyTmFtZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoVW5ib3VuZE1hcmtlck5hbWVzKCkgewogICAgICB2YXIgbWFya2VyTmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcyk7CgogICAgICB0aGlzLl91bmJvdW5kTWFya2VyTmFtZXMuY2xlYXIoKTsKCiAgICAgIHJldHVybiBtYXJrZXJOYW1lczsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhbGwgbW9kZWwgdG8gdmlldyBhbmQgdmlldyB0byBtb2RlbCBiaW5kaW5ncy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjbGVhckJpbmRpbmdzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckJpbmRpbmdzKCkgewogICAgICB0aGlzLl9tb2RlbFRvVmlld01hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgICB0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgICB0aGlzLl9tYXJrZXJOYW1lVG9FbGVtZW50cyA9IG5ldyBNYXAoKTsKICAgICAgdGhpcy5fZWxlbWVudFRvTWFya2VyTmFtZXMgPSBuZXcgTWFwKCk7CiAgICAgIHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcyA9IG5ldyBTZXQoKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyBtb2RlbCBlbGVtZW50LgogICAgICoKICAgICAqICoqTm90ZToqKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR9IGRvZXMgbm90IGhhdmUgY29ycmVzcG9uZGluZyBlbGVtZW50IGluIG1vZGVsLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld0VsZW1lbnQgVmlldyBlbGVtZW50LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fHVuZGVmaW5lZH0gQ29ycmVzcG9uZGluZyBtb2RlbCBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b01vZGVsRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Nb2RlbEVsZW1lbnQodmlld0VsZW1lbnQpIHsKICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5nZXQodmlld0VsZW1lbnQpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBjb3JyZXNwb25kaW5nIHZpZXcgZWxlbWVudC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBtb2RlbEVsZW1lbnQgTW9kZWwgZWxlbWVudC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fHVuZGVmaW5lZH0gQ29ycmVzcG9uZGluZyB2aWV3IGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvVmlld0VsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvVmlld0VsZW1lbnQobW9kZWxFbGVtZW50KSB7CiAgICAgIHJldHVybiB0aGlzLl9tb2RlbFRvVmlld01hcHBpbmcuZ2V0KG1vZGVsRWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIGNvcnJlc3BvbmRpbmcgbW9kZWwgcmFuZ2UuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHZpZXdSYW5nZSBWaWV3IHJhbmdlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IENvcnJlc3BvbmRpbmcgbW9kZWwgcmFuZ2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9Nb2RlbFJhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB0b01vZGVsUmFuZ2Uodmlld1JhbmdlKSB7CiAgICAgIHJldHVybiBuZXcgTW9kZWxSYW5nZSh0aGlzLnRvTW9kZWxQb3NpdGlvbih2aWV3UmFuZ2Uuc3RhcnQpLCB0aGlzLnRvTW9kZWxQb3NpdGlvbih2aWV3UmFuZ2UuZW5kKSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIGNvcnJlc3BvbmRpbmcgdmlldyByYW5nZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG1vZGVsUmFuZ2UgTW9kZWwgcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBDb3JyZXNwb25kaW5nIHZpZXcgcmFuZ2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9WaWV3UmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvVmlld1JhbmdlKG1vZGVsUmFuZ2UpIHsKICAgICAgcmV0dXJuIG5ldyBWaWV3UmFuZ2UodGhpcy50b1ZpZXdQb3NpdGlvbihtb2RlbFJhbmdlLnN0YXJ0KSwgdGhpcy50b1ZpZXdQb3NpdGlvbihtb2RlbFJhbmdlLmVuZCkpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBjb3JyZXNwb25kaW5nIG1vZGVsIHBvc2l0aW9uLgogICAgICoKICAgICAqIEBmaXJlcyB2aWV3VG9Nb2RlbFBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdmlld1Bvc2l0aW9uIFZpZXcgcG9zaXRpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gQ29ycmVzcG9uZGluZyBtb2RlbCBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b01vZGVsUG9zaXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvTW9kZWxQb3NpdGlvbih2aWV3UG9zaXRpb24pIHsKICAgICAgdmFyIGRhdGEgPSB7CiAgICAgICAgdmlld1Bvc2l0aW9uOiB2aWV3UG9zaXRpb24sCiAgICAgICAgbWFwcGVyOiB0aGlzCiAgICAgIH07CiAgICAgIHRoaXMuZmlyZSgndmlld1RvTW9kZWxQb3NpdGlvbicsIGRhdGEpOwogICAgICByZXR1cm4gZGF0YS5tb2RlbFBvc2l0aW9uOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBjb3JyZXNwb25kaW5nIHZpZXcgcG9zaXRpb24uCiAgICAgKgogICAgICogQGZpcmVzIG1vZGVsVG9WaWV3UG9zaXRpb24KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gbW9kZWxQb3NpdGlvbiBNb2RlbCBwb3NpdGlvbi4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIGZvciBwb3NpdGlvbiBtYXBwaW5nIHByb2Nlc3MuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzUGhhbnRvbT1mYWxzZV0gU2hvdWxkIGJlIHNldCB0byBgdHJ1ZWAgaWYgdGhlIG1vZGVsIHBvc2l0aW9uIHRvIG1hcCBpcyBwb2ludGluZyB0byBhIHBsYWNlCiAgICAgKiBpbiBtb2RlbCB0cmVlIHdoaWNoIG5vIGxvbmdlciBleGlzdHMuIEZvciBleGFtcGxlLCBpdCBjb3VsZCBiZSBhbiBlbmQgb2YgYSByZW1vdmVkIG1vZGVsIHJhbmdlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gQ29ycmVzcG9uZGluZyB2aWV3IHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvVmlld1Bvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB0b1ZpZXdQb3NpdGlvbihtb2RlbFBvc2l0aW9uKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7CiAgICAgICAgaXNQaGFudG9tOiBmYWxzZQogICAgICB9OwogICAgICB2YXIgZGF0YSA9IHsKICAgICAgICBtb2RlbFBvc2l0aW9uOiBtb2RlbFBvc2l0aW9uLAogICAgICAgIG1hcHBlcjogdGhpcywKICAgICAgICBpc1BoYW50b206IG9wdGlvbnMuaXNQaGFudG9tCiAgICAgIH07CiAgICAgIHRoaXMuZmlyZSgnbW9kZWxUb1ZpZXdQb3NpdGlvbicsIGRhdGEpOwogICAgICByZXR1cm4gZGF0YS52aWV3UG9zaXRpb247CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgYWxsIHZpZXcgZWxlbWVudHMgYm91bmQgdG8gdGhlIGdpdmVuIG1hcmtlciBuYW1lLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE1hcmtlciBuYW1lLgogICAgICogQHJldHVybnMge1NldC48bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudD58bnVsbH0gVmlldyBlbGVtZW50cyBib3VuZCB3aXRoIGdpdmVuIG1hcmtlciBuYW1lIG9yIGBudWxsYAogICAgICogaWYgbm8gZWxlbWVudHMgYXJlIGJvdW5kIHRvIGdpdmVuIG1hcmtlciBuYW1lLgogICAgICovCgogIH0sIHsKICAgIGtleTogIm1hcmtlck5hbWVUb0VsZW1lbnRzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrZXJOYW1lVG9FbGVtZW50cyhuYW1lKSB7CiAgICAgIHZhciBib3VuZEVsZW1lbnRzID0gdGhpcy5fbWFya2VyTmFtZVRvRWxlbWVudHMuZ2V0KG5hbWUpOwoKICAgICAgaWYgKCFib3VuZEVsZW1lbnRzKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIHZhciBlbGVtZW50cyA9IG5ldyBTZXQoKTsKCiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYm91bmRFbGVtZW50cyksCiAgICAgICAgICBfc3RlcDI7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgZWxlbWVudCA9IF9zdGVwMi52YWx1ZTsKCiAgICAgICAgICBpZiAoZWxlbWVudC5pcygnYXR0cmlidXRlRWxlbWVudCcpKSB7CiAgICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZWxlbWVudC5nZXRFbGVtZW50c1dpdGhTYW1lSWQoKSksCiAgICAgICAgICAgICAgICBfc3RlcDM7CgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSBfc3RlcDMudmFsdWU7CiAgICAgICAgICAgICAgICBlbGVtZW50cy5hZGQoY2xvbmUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGVsZW1lbnRzLmFkZChlbGVtZW50KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjIuZigpOwogICAgICB9CgogICAgICByZXR1cm4gZWxlbWVudHM7CiAgICB9CiAgICAvKioKICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgZXZhbHVhdGVzIHRoZSBsZW5ndGggaW4gdGhlIG1vZGVsIG9mIGEgdmlldyBlbGVtZW50IHdpdGggZ2l2ZW4gbmFtZS4KICAgICAqCiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgZmlyZWQgd2l0aCBvbmUgYXJndW1lbnQsIHdoaWNoIGlzIGEgdmlldyBlbGVtZW50IGluc3RhbmNlLiBUaGUgY2FsbGJhY2sgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuCiAgICAgKiBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGxlbmd0aCBvZiB2aWV3IGVsZW1lbnQgaW4gbW9kZWwuCiAgICAgKgogICAgICoJCS8vIExpc3QgaXRlbSBpbiB2aWV3IG1heSBjb250YWluIG5lc3RlZCBsaXN0LCB3aGljaCBoYXZlIG90aGVyIGxpc3QgaXRlbXMuIEluIG1vZGVsIHRob3VnaCwKICAgICAqCQkvLyB0aGUgbGlzdHMgYXJlIHJlcHJlc2VudGVkIGJ5IGZsYXQgc3RydWN0dXJlLiBCZWNhdXNlIG9mIHRob3NlIGRpZmZlcmVuY2VzLCBsZW5ndGggb2YgbGlzdCB2aWV3IGVsZW1lbnQKICAgICAqCQkvLyBtYXkgYmUgZ3JlYXRlciB0aGFuIG9uZS4gSW4gdGhlIGNhbGxiYWNrIGl0J3MgY2hlY2tlZCBob3cgbWFueSBuZXN0ZWQgbGlzdCBpdGVtcyBhcmUgaW4gZXZhbHVhdGVkIGxpc3QgaXRlbS4KICAgICAqCiAgICAgKgkJZnVuY3Rpb24gZ2V0Vmlld0xpc3RJdGVtTGVuZ3RoKCBlbGVtZW50ICkgewogICAgICoJCQlsZXQgbGVuZ3RoID0gMTsKICAgICAqCiAgICAgKgkJCWZvciAoIGxldCBjaGlsZCBvZiBlbGVtZW50LmdldENoaWxkcmVuKCkgKSB7CiAgICAgKgkJCQlpZiAoIGNoaWxkLm5hbWUgPT0gJ3VsJyB8fCBjaGlsZC5uYW1lID09ICdvbCcgKSB7CiAgICAgKgkJCQkJZm9yICggbGV0IGl0ZW0gb2YgY2hpbGQuZ2V0Q2hpbGRyZW4oKSApIHsKICAgICAqCQkJCQkJbGVuZ3RoICs9IGdldFZpZXdMaXN0SXRlbUxlbmd0aCggaXRlbSApOwogICAgICoJCQkJCX0KICAgICAqCQkJCX0KICAgICAqCQkJfQogICAgICoKICAgICAqCQkJcmV0dXJuIGxlbmd0aDsKICAgICAqCQl9CiAgICAgKgogICAgICoJCW1hcHBlci5yZWdpc3RlclZpZXdUb01vZGVsTGVuZ3RoKCAnbGknLCBnZXRWaWV3TGlzdEl0ZW1MZW5ndGggKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmlld0VsZW1lbnROYW1lIE5hbWUgb2YgdmlldyBlbGVtZW50IGZvciB3aGljaCBjYWxsYmFjayBpcyByZWdpc3RlcmVkLgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGVuZ3RoQ2FsbGJhY2sgRnVuY3Rpb24gcmV0dXJuIGEgbGVuZ3RoIG9mIHZpZXcgZWxlbWVudCBpbnN0YW5jZSBpbiBtb2RlbC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZWdpc3RlclZpZXdUb01vZGVsTGVuZ3RoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlclZpZXdUb01vZGVsTGVuZ3RoKHZpZXdFbGVtZW50TmFtZSwgbGVuZ3RoQ2FsbGJhY2spIHsKICAgICAgdGhpcy5fdmlld1RvTW9kZWxMZW5ndGhDYWxsYmFja3Muc2V0KHZpZXdFbGVtZW50TmFtZSwgbGVuZ3RoQ2FsbGJhY2spOwogICAgfQogICAgLyoqCiAgICAgKiBGb3IgZ2l2ZW4gYHZpZXdQb3NpdGlvbmAsIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIHRoaXMgcG9zaXRpb24gdGhhdCBoYXMgYSBtYXBwaW5nIHRvCiAgICAgKiB0aGUgbW9kZWwuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHZpZXdQb3NpdGlvbiBQb3NpdGlvbiBmb3Igd2hpY2ggbWFwcGVkIGFuY2VzdG9yIHNob3VsZCBiZSBmb3VuZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fQogICAgICovCgogIH0sIHsKICAgIGtleTogImZpbmRNYXBwZWRWaWV3QW5jZXN0b3IiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRNYXBwZWRWaWV3QW5jZXN0b3Iodmlld1Bvc2l0aW9uKSB7CiAgICAgIHZhciBwYXJlbnQgPSB2aWV3UG9zaXRpb24ucGFyZW50OwoKICAgICAgd2hpbGUgKCF0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcuaGFzKHBhcmVudCkpIHsKICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50OwogICAgICB9CgogICAgICByZXR1cm4gcGFyZW50OwogICAgfQogICAgLyoqCiAgICAgKiBDYWxjdWxhdGVzIG1vZGVsIG9mZnNldCBiYXNlZCBvbiB0aGUgdmlldyBwb3NpdGlvbiBhbmQgdGhlIGJsb2NrIGVsZW1lbnQuCiAgICAgKgogICAgICogRXhhbXBsZToKICAgICAqCiAgICAgKgkJPHA+Zm9vPGI+YmF8cjwvYj48L3A+IC8vIF90b01vZGVsT2Zmc2V0KCBiLCAyLCBwICkgLT4gNQogICAgICoKICAgICAqIElzIGEgc3VtIG9mOgogICAgICoKICAgICAqCQk8cD5mb298PGI+YmFyPC9iPjwvcD4gLy8gX3RvTW9kZWxPZmZzZXQoIHAsIDMsIHAgKSAtPiAzCiAgICAgKgkJPHA+Zm9vPGI+YmF8cjwvYj48L3A+IC8vIF90b01vZGVsT2Zmc2V0KCBiLCAyLCBiICkgLT4gMgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IHZpZXdQYXJlbnQgUG9zaXRpb24gcGFyZW50LgogICAgICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdPZmZzZXQgUG9zaXRpb24gb2Zmc2V0LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3QmxvY2sgQmxvY2sgdXNlZCBhcyBhIGJhc2UgdG8gY2FsY3VsYXRlIG9mZnNldC4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IE9mZnNldCBpbiB0aGUgbW9kZWwuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3RvTW9kZWxPZmZzZXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF90b01vZGVsT2Zmc2V0KHZpZXdQYXJlbnQsIHZpZXdPZmZzZXQsIHZpZXdCbG9jaykgewogICAgICBpZiAodmlld0Jsb2NrICE9IHZpZXdQYXJlbnQpIHsKICAgICAgICAvLyBTZWUgZXhhbXBsZS4KICAgICAgICB2YXIgb2Zmc2V0VG9QYXJlbnRTdGFydCA9IHRoaXMuX3RvTW9kZWxPZmZzZXQodmlld1BhcmVudC5wYXJlbnQsIHZpZXdQYXJlbnQuaW5kZXgsIHZpZXdCbG9jayk7CgogICAgICAgIHZhciBvZmZzZXRJblBhcmVudCA9IHRoaXMuX3RvTW9kZWxPZmZzZXQodmlld1BhcmVudCwgdmlld09mZnNldCwgdmlld1BhcmVudCk7CgogICAgICAgIHJldHVybiBvZmZzZXRUb1BhcmVudFN0YXJ0ICsgb2Zmc2V0SW5QYXJlbnQ7CiAgICAgIH0gLy8gdmlld0Jsb2NrID09IHZpZXdQYXJlbnQsIHNvIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgaW4gdGhlIHBhcmVudCBlbGVtZW50LgogICAgICAvLyBJZiB0aGUgcG9zaXRpb24gaXMgYSB0ZXh0IGl0IGlzIHNpbXBsZSAoImJhfHIiIC0+IDIpLgoKCiAgICAgIGlmICh2aWV3UGFyZW50LmlzKCckdGV4dCcpKSB7CiAgICAgICAgcmV0dXJuIHZpZXdPZmZzZXQ7CiAgICAgIH0gLy8gSWYgdGhlIHBvc2l0aW9uIGlzIGluIGFuIGVsZW1lbnQgd2UgbmVlZCB0byBzdW0gbGVuZ3RocyBvZiBzaWJsaW5ncyAoIDxiPiBiYXIgPC9iPiBmb28gfCAtPiAzICsgMyA9IDYgKS4KCgogICAgICB2YXIgbW9kZWxPZmZzZXQgPSAwOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3T2Zmc2V0OyBpKyspIHsKICAgICAgICBtb2RlbE9mZnNldCArPSB0aGlzLmdldE1vZGVsTGVuZ3RoKHZpZXdQYXJlbnQuZ2V0Q2hpbGQoaSkpOwogICAgICB9CgogICAgICByZXR1cm4gbW9kZWxPZmZzZXQ7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIGxlbmd0aCBvZiB0aGUgdmlldyBlbGVtZW50IGluIHRoZSBtb2RlbC4KICAgICAqCiAgICAgKiBUaGUgbGVuZ3RoIGlzIGNhbGN1bGF0ZWQgYXMgZm9sbG93czoKICAgICAqICogaWYge0BsaW5rICNyZWdpc3RlclZpZXdUb01vZGVsTGVuZ3RoIGxlbmd0aCBtYXBwaW5nIGNhbGxiYWNrfSBpcyBwcm92aWRlZCBmb3IgZ2l2ZW4gYHZpZXdOb2RlYCBpdCBpcyB1c2VkIHRvCiAgICAgKiBldmFsdWF0ZSBtb2RlbCBsZW5ndGggKGB2aWV3Tm9kZWAgaXMgdXNlZCBhcyBmaXJzdCBhbmQgb25seSBwYXJhbWV0ZXIgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayksCiAgICAgKiAqIGxlbmd0aCBvZiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHRleHQgbm9kZX0gaXMgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiBpdCdzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCNkYXRhIGRhdGF9LAogICAgICogKiBsZW5ndGggb2YgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgdWkgZWxlbWVudH0gaXMgZXF1YWwgdG8gMCwKICAgICAqICogbGVuZ3RoIG9mIGEgbWFwcGVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IGlzIGVxdWFsIHRvIDEsCiAgICAgKiAqIGxlbmd0aCBvZiBhIG5vdC1tYXBwZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gaXMgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiBpdCdzIGNoaWxkcmVuLgogICAgICoKICAgICAqIEV4YW1wbGVzOgogICAgICoKICAgICAqCQlmb28gICAgICAgICAgICAgICAgICAgICAgICAgIC0+IDMgLy8gVGV4dCBsZW5ndGggaXMgZXF1YWwgdG8gaXQncyBkYXRhIGxlbmd0aC4KICAgICAqCQk8cD5mb288L3A+ICAgICAgICAgICAgICAgICAgIC0+IDEgLy8gTGVuZ3RoIG9mIGFuIGVsZW1lbnQgd2hpY2ggaXMgbWFwcGVkIGlzIGJ5IGRlZmF1bHQgZXF1YWwgdG8gMS4KICAgICAqCQk8Yj5mb288L2I+ICAgICAgICAgICAgICAgICAgIC0+IDMgLy8gTGVuZ3RoIG9mIGFuIGVsZW1lbnQgd2hpY2ggaXMgbm90IG1hcHBlZCBpcyBhIGxlbmd0aCBvZiBpdHMgY2hpbGRyZW4uCiAgICAgKgkJPGRpdj48cD54PC9wPjxwPnk8L3A+PC9kaXY+ICAtPiAyIC8vIEFzc3VtaW5nIHRoYXQgPGRpdj4gaXMgbm90IG1hcHBlZCBhbmQgPHA+IGFyZSBtYXBwZWQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3Tm9kZSBWaWV3IG5vZGUuCiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBMZW5ndGggb2YgdGhlIG5vZGUgaW4gdGhlIHRyZWUgbW9kZWwuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0TW9kZWxMZW5ndGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vZGVsTGVuZ3RoKHZpZXdOb2RlKSB7CiAgICAgIGlmICh0aGlzLl92aWV3VG9Nb2RlbExlbmd0aENhbGxiYWNrcy5nZXQodmlld05vZGUubmFtZSkpIHsKICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl92aWV3VG9Nb2RlbExlbmd0aENhbGxiYWNrcy5nZXQodmlld05vZGUubmFtZSk7CgogICAgICAgIHJldHVybiBjYWxsYmFjayh2aWV3Tm9kZSk7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nLmhhcyh2aWV3Tm9kZSkpIHsKICAgICAgICByZXR1cm4gMTsKICAgICAgfSBlbHNlIGlmICh2aWV3Tm9kZS5pcygnJHRleHQnKSkgewogICAgICAgIHJldHVybiB2aWV3Tm9kZS5kYXRhLmxlbmd0aDsKICAgICAgfSBlbHNlIGlmICh2aWV3Tm9kZS5pcygndWlFbGVtZW50JykpIHsKICAgICAgICByZXR1cm4gMDsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgbGVuID0gMDsKCiAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih2aWV3Tm9kZS5nZXRDaGlsZHJlbigpKSwKICAgICAgICAgICAgX3N0ZXA0OwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXA0LnZhbHVlOwogICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRNb2RlbExlbmd0aChjaGlsZCk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbGVuOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEZpbmRzIHRoZSBwb3NpdGlvbiBpbiB0aGUgdmlldyBub2RlIChvciBpdHMgY2hpbGRyZW4pIHdpdGggdGhlIGV4cGVjdGVkIG1vZGVsIG9mZnNldC4KICAgICAqCiAgICAgKiBFeGFtcGxlOgogICAgICoKICAgICAqCQk8cD5mbzxiPmJhcjwvYj5ib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogNAogICAgICoKICAgICAqCQlmaW5kUG9zaXRpb25JbiggcCwgNCApOgogICAgICoJCTxwPnxmbzxiPmJhcjwvYj5ib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogNCwgYWN0dWFsIG9mZnNldDogMAogICAgICoJCTxwPmZvfDxiPmJhcjwvYj5ib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogNCwgYWN0dWFsIG9mZnNldDogMgogICAgICoJCTxwPmZvPGI+YmFyPC9iPnxib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogNCwgYWN0dWFsIG9mZnNldDogNSAtPiB3ZSBhcmUgdG9vIGZhcgogICAgICoKICAgICAqCQlmaW5kUG9zaXRpb25JbiggYiwgNCAtICggNSAtIDMgKSApOgogICAgICoJCTxwPmZvPGI+fGJhcjwvYj5ib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogMiwgYWN0dWFsIG9mZnNldDogMAogICAgICoJCTxwPmZvPGI+YmFyfDwvYj5ib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogMiwgYWN0dWFsIG9mZnNldDogMyAtPiB3ZSBhcmUgdG9vIGZhcgogICAgICoKICAgICAqCQlmaW5kUG9zaXRpb25JbiggYmFyLCAyIC0gKCAzIC0gMyApICk6CiAgICAgKgkJV2UgYXJlIGluIHRoZSB0ZXh0IG5vZGUgc28gd2UgY2FuIHNpbXBsZSBmaW5kIHRoZSBvZmZzZXQuCiAgICAgKgkJPHA+Zm88Yj5iYXxyPC9iPmJvbTwvcD4gLT4gZXhwZWN0ZWQgb2Zmc2V0OiAyLCBhY3R1YWwgb2Zmc2V0OiAyIC0+IHBvc2l0aW9uIGZvdW5kCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3UGFyZW50IFRyZWUgdmlldyBlbGVtZW50IGluIHdoaWNoIHdlIGFyZSBsb29raW5nIGZvciB0aGUgcG9zaXRpb24uCiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRPZmZzZXQgRXhwZWN0ZWQgb2Zmc2V0LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gRm91bmQgcG9zaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZmluZFBvc2l0aW9uSW4iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRQb3NpdGlvbkluKHZpZXdQYXJlbnQsIGV4cGVjdGVkT2Zmc2V0KSB7CiAgICAgIC8vIExhc3Qgc2Nhbm5lZCB2aWV3IG5vZGUuCiAgICAgIHZhciB2aWV3Tm9kZTsgLy8gTGVuZ3RoIG9mIHRoZSBsYXN0IHNjYW5uZWQgdmlldyBub2RlLgoKICAgICAgdmFyIGxhc3RMZW5ndGggPSAwOwogICAgICB2YXIgbW9kZWxPZmZzZXQgPSAwOwogICAgICB2YXIgdmlld09mZnNldCA9IDA7IC8vIEluIHRoZSB0ZXh0IG5vZGUgaXQgaXMgc2ltcGxlOiBvZmZzZXQgaW4gdGhlIG1vZGVsIGVxdWFscyBvZmZzZXQgaW4gdGhlIHRleHQuCgogICAgICBpZiAodmlld1BhcmVudC5pcygnJHRleHQnKSkgewogICAgICAgIHJldHVybiBuZXcgVmlld1Bvc2l0aW9uKHZpZXdQYXJlbnQsIGV4cGVjdGVkT2Zmc2V0KTsKICAgICAgfSAvLyBJbiBvdGhlciBjYXNlcyB3ZSBhZGQgbGVuZ3RocyBvZiBjaGlsZCBub2RlcyB0byBmaW5kIHRoZSBwcm9wZXIgb2Zmc2V0LgogICAgICAvLyBJZiBpdCBpcyBzbWFsbGVyIHdlIGFkZCB0aGUgbGVuZ3RoLgoKCiAgICAgIHdoaWxlIChtb2RlbE9mZnNldCA8IGV4cGVjdGVkT2Zmc2V0KSB7CiAgICAgICAgdmlld05vZGUgPSB2aWV3UGFyZW50LmdldENoaWxkKHZpZXdPZmZzZXQpOwogICAgICAgIGxhc3RMZW5ndGggPSB0aGlzLmdldE1vZGVsTGVuZ3RoKHZpZXdOb2RlKTsKICAgICAgICBtb2RlbE9mZnNldCArPSBsYXN0TGVuZ3RoOwogICAgICAgIHZpZXdPZmZzZXQrKzsKICAgICAgfSAvLyBJZiBpdCBlcXVhbHMgd2UgZm91bmQgdGhlIHBvc2l0aW9uLgoKCiAgICAgIGlmIChtb2RlbE9mZnNldCA9PSBleHBlY3RlZE9mZnNldCkgewogICAgICAgIHJldHVybiB0aGlzLl9tb3ZlVmlld1Bvc2l0aW9uVG9UZXh0Tm9kZShuZXcgVmlld1Bvc2l0aW9uKHZpZXdQYXJlbnQsIHZpZXdPZmZzZXQpKTsKICAgICAgfSAvLyBJZiBpdCBpcyBoaWdoZXIgd2UgbmVlZCB0byBlbnRlciBsYXN0IGNoaWxkLgogICAgICBlbHNlIHsKICAgICAgICAgIC8vICggbW9kZWxPZmZzZXQgLSBsYXN0TGVuZ3RoICkgaXMgdGhlIG9mZnNldCB0byB0aGUgY2hpbGQgd2UgZW50ZXIsCiAgICAgICAgICAvLyBzbyB3ZSBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBleHBlY3RlZCBvZmZzZXQgdG8gZmluZSB0aGUgb2Zmc2V0IGluIHRoZSBjaGlsZC4KICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRQb3NpdGlvbkluKHZpZXdOb2RlLCBleHBlY3RlZE9mZnNldCAtIChtb2RlbE9mZnNldCAtIGxhc3RMZW5ndGgpKTsKICAgICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEJlY2F1c2Ugd2UgcHJlZmVyIHBvc2l0aW9ucyBpbiB0ZXh0IG5vZGVzIG92ZXIgcG9zaXRpb25zIG5leHQgdG8gdGV4dCBub2RlIG1vdmVzIHZpZXcgcG9zaXRpb24gdG8gdGhlIHRleHQgbm9kZQogICAgICogaWYgaXQgd2FzIG5leHQgdG8gaXQuCiAgICAgKgogICAgICoJCTxwPltdPGI+Zm9vPC9iPjwvcD4gLT4gPHA+W108Yj5mb288L2I+PC9wPiAvLyBkbyBub3QgdG91Y2ggaWYgcG9zaXRpb24gaXMgbm90IGRpcmVjdGx5IG5leHQgdG8gdGV4dAogICAgICoJCTxwPmZvb1tdPGI+Zm9vPC9iPjwvcD4gLT4gPHA+Zm9ve308Yj5mb288L2I+PC9wPiAvLyBtb3ZlIHRvIHRleHQgbm9kZQogICAgICoJCTxwPjxiPltdZm9vPC9iPjwvcD4gLT4gPHA+PGI+e31mb288L2I+PC9wPiAvLyBtb3ZlIHRvIHRleHQgbm9kZQogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdmlld1Bvc2l0aW9uIFBvc2l0aW9uIHBvdGVudGlhbGx5IG5leHQgdG8gdGV4dCBub2RlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gaW4gdGV4dCBub2RlIGlmIHBvc3NpYmxlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9tb3ZlVmlld1Bvc2l0aW9uVG9UZXh0Tm9kZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVWaWV3UG9zaXRpb25Ub1RleHROb2RlKHZpZXdQb3NpdGlvbikgewogICAgICAvLyBJZiB0aGUgcG9zaXRpb24gaXMganVzdCBhZnRlciB0ZXh0IG5vZGUsIHB1dCBpdCBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlLgogICAgICAvLyBJZiB0aGUgcG9zaXRpb24gaXMganVzdCBiZWZvcmUgdGV4dCBub2RlLCBwdXQgaXQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGF0IHRleHQgbm9kZS4KICAgICAgdmFyIG5vZGVCZWZvcmUgPSB2aWV3UG9zaXRpb24ubm9kZUJlZm9yZTsKICAgICAgdmFyIG5vZGVBZnRlciA9IHZpZXdQb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgICBpZiAobm9kZUJlZm9yZSBpbnN0YW5jZW9mIFZpZXdUZXh0KSB7CiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UG9zaXRpb24obm9kZUJlZm9yZSwgbm9kZUJlZm9yZS5kYXRhLmxlbmd0aCk7CiAgICAgIH0gZWxzZSBpZiAobm9kZUFmdGVyIGluc3RhbmNlb2YgVmlld1RleHQpIHsKICAgICAgICByZXR1cm4gbmV3IFZpZXdQb3NpdGlvbihub2RlQWZ0ZXIsIDApOwogICAgICB9IC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gdGhlIGdpdmVuIHBvc2l0aW9uLgoKCiAgICAgIHJldHVybiB2aWV3UG9zaXRpb247CiAgICB9CiAgICAvKioKICAgICAqIEZpcmVkIGZvciBlYWNoIG1vZGVsLXRvLXZpZXcgcG9zaXRpb24gbWFwcGluZyByZXF1ZXN0LiBUaGUgcHVycG9zZSBvZiB0aGlzIGV2ZW50IGlzIHRvIGVuYWJsZSBjdXN0b20gbW9kZWwtdG8tdmlldyBwb3NpdGlvbgogICAgICogbWFwcGluZy4gQ2FsbGJhY2tzIGFkZGVkIHRvIHRoaXMgZXZlbnQgdGFrZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBtb2RlbCBwb3NpdGlvbn0gYW5kIGFyZSBleHBlY3RlZCB0bwogICAgICogY2FsY3VsYXRlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gdmlldyBwb3NpdGlvbn0uIENhbGN1bGF0ZWQgdmlldyBwb3NpdGlvbiBzaG91bGQgYmUgYWRkZWQgYXMgYHZpZXdQb3NpdGlvbmAKICAgICAqIHZhbHVlIGluIGBkYXRhYCBvYmplY3QgdGhhdCBpcyBwYXNzZWQgYXMgb25lIG9mIHBhcmFtZXRlcnMgdG8gdGhlIGV2ZW50IGNhbGxiYWNrLgogICAgICoKICAgICAqIAkJLy8gQXNzdW1lIHRoYXQgImNhcHRpb25lZEltYWdlIiBtb2RlbCBlbGVtZW50IGlzIGNvbnZlcnRlZCB0byA8aW1nPiBhbmQgZm9sbG93aW5nIDxzcGFuPiBlbGVtZW50cyBpbiB2aWV3LAogICAgICogCQkvLyBhbmQgdGhlIG1vZGVsIGVsZW1lbnQgaXMgYm91bmQgdG8gPGltZz4gZWxlbWVudC4gRm9yY2UgbWFwcGluZyBtb2RlbCBwb3NpdGlvbnMgaW5zaWRlICJjYXB0aW9uZWRJbWFnZSIgdG8gdGhhdAogICAgICogCQkvLyA8c3Bhbj4gZWxlbWVudC4KICAgICAqCQltYXBwZXIub24oICdtb2RlbFRvVmlld1Bvc2l0aW9uJywgKCBldnQsIGRhdGEgKSA9PiB7CiAgICAgKgkJCWNvbnN0IHBvc2l0aW9uUGFyZW50ID0gbW9kZWxQb3NpdGlvbi5wYXJlbnQ7CiAgICAgKgogICAgICoJCQlpZiAoIHBvc2l0aW9uUGFyZW50Lm5hbWUgPT0gJ2NhcHRpb25lZEltYWdlJyApIHsKICAgICAqCQkJCWNvbnN0IHZpZXdJbWcgPSBkYXRhLm1hcHBlci50b1ZpZXdFbGVtZW50KCBwb3NpdGlvblBhcmVudCApOwogICAgICoJCQkJY29uc3Qgdmlld0NhcHRpb24gPSB2aWV3SW1nLm5leHRTaWJsaW5nOyAvLyBUaGUgPHNwYW4+IGVsZW1lbnQuCiAgICAgKgogICAgICoJCQkJZGF0YS52aWV3UG9zaXRpb24gPSBuZXcgVmlld1Bvc2l0aW9uKCB2aWV3Q2FwdGlvbiwgbW9kZWxQb3NpdGlvbi5vZmZzZXQgKTsKICAgICAqCiAgICAgKgkJCQkvLyBTdG9wIHRoZSBldmVudCBpZiBvdGhlciBjYWxsYmFja3Mgc2hvdWxkIG5vdCBtb2RpZnkgY2FsY3VsYXRlZCB2YWx1ZS4KICAgICAqCQkJCWV2dC5zdG9wKCk7CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogKipOb3RlOioqIGtlZXAgaW4gbWluZCB0aGF0IHNvbWV0aW1lcyBhICJwaGFudG9tIiBtb2RlbCBwb3NpdGlvbiBpcyBiZWluZyBjb252ZXJ0ZWQuICJQaGFudG9tIiBtb2RlbCBwb3NpdGlvbiBpcwogICAgICogYSBwb3NpdGlvbiB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBwbGFjZSBpbiBtb2RlbC4gU3VjaCBwb3NpdGlvbiBtaWdodCBzdGlsbCBiZSB2YWxpZCBmb3IgY29udmVyc2lvbiwgdGhvdWdoCiAgICAgKiAoaXQgd291bGQgcG9pbnQgdG8gYSBjb3JyZWN0IHBsYWNlIGluIHZpZXcgd2hlbiBjb252ZXJ0ZWQpLiBPbmUgZXhhbXBsZSBvZiBzdWNoIHNpdHVhdGlvbiBpcyB3aGVuIGEgcmFuZ2UgaXMKICAgICAqIHJlbW92ZWQgZnJvbSBtb2RlbCwgdGhlcmUgbWF5IGJlIGEgbmVlZCB0byBtYXAgdGhlIHJhbmdlJ3MgZW5kICh3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgbW9kZWwgcG9zaXRpb24pLiBUbwogICAgICogaGFuZGxlIHN1Y2ggc2l0dWF0aW9uLCBjaGVjayBgZGF0YS5pc1BoYW50b21gIGZsYWc6CiAgICAgKgogICAgICogCQkvLyBBc3N1bWUgdGhhdCB0aGVyZSBpcyAiY3VzdG9tRWxlbWVudCIgbW9kZWwgZWxlbWVudCBhbmQgd2hlbmV2ZXIgcG9zaXRpb24gaXMgYmVmb3JlIGl0LCB3ZSB3YW50IHRvIG1vdmUgaXQKICAgICAqIAkJLy8gdG8gdGhlIGluc2lkZSBvZiB0aGUgdmlldyBlbGVtZW50IGJvdW5kIHRvICJjdXN0b21FbGVtZW50Ii4KICAgICAqCQltYXBwZXIub24oICdtb2RlbFRvVmlld1Bvc2l0aW9uJywgKCBldnQsIGRhdGEgKSA9PiB7CiAgICAgKgkJCWlmICggZGF0YS5pc1BoYW50b20gKSB7CiAgICAgKgkJCQlyZXR1cm47CiAgICAgKgkJCX0KICAgICAqCiAgICAgKgkJCS8vIEJlbG93IGxpbmUgbWlnaHQgY3Jhc2ggZm9yIHBoYW50b20gcG9zaXRpb24gdGhhdCBkb2VzIG5vdCBleGlzdCBpbiBtb2RlbC4KICAgICAqCQkJY29uc3Qgc2libGluZyA9IGRhdGEubW9kZWxQb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgICoKICAgICAqCQkJLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgZWxlbWVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi4KICAgICAqCQkJaWYgKCAhc2libGluZy5pcyggJ2VsZW1lbnQnLCAnY3VzdG9tRWxlbWVudCcgKSApIHsKICAgICAqCQkJCXJldHVybjsKICAgICAqCQkJfQogICAgICoKICAgICAqCQkJY29uc3Qgdmlld0VsZW1lbnQgPSBkYXRhLm1hcHBlci50b1ZpZXdFbGVtZW50KCBzaWJsaW5nICk7CiAgICAgKgogICAgICoJCQlkYXRhLnZpZXdQb3NpdGlvbiA9IG5ldyBWaWV3UG9zaXRpb24oIHNpYmxpbmcsIDAgKTsKICAgICAqCiAgICAgKgkJCWV2dC5zdG9wKCk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqICoqTm90ZToqKiBkZWZhdWx0IG1hcHBpbmcgY2FsbGJhY2sgaXMgcHJvdmlkZWQgd2l0aCBgbG93YCBwcmlvcml0eSBzZXR0aW5nIGFuZCBkb2VzIG5vdCBjYW5jZWwgdGhlIGV2ZW50LCBzbyBpdCBpcyBwb3NzaWJsZSB0bwogICAgICogYXR0YWNoIGEgY3VzdG9tIGNhbGxiYWNrIGFmdGVyIGRlZmF1bHQgY2FsbGJhY2sgYW5kIGFsc28gdXNlIGBkYXRhLnZpZXdQb3NpdGlvbmAgY2FsY3VsYXRlZCBieSBkZWZhdWx0IGNhbGxiYWNrCiAgICAgKiAoZm9yIGV4YW1wbGUgdG8gZml4IGl0KS4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogZGVmYXVsdCBtYXBwaW5nIGNhbGxiYWNrIHdpbGwgbm90IGZpcmUgaWYgYGRhdGEudmlld1Bvc2l0aW9uYCBpcyBhbHJlYWR5IHNldC4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogdGhlc2UgY2FsbGJhY2tzIGFyZSBjYWxsZWQgKip2ZXJ5IG9mdGVuKiouIEZvciBlZmZpY2llbmN5IHJlYXNvbnMsIGl0IGlzIGFkdmlzZWQgdG8gdXNlIHRoZW0gb25seSB3aGVuIHBvc2l0aW9uCiAgICAgKiBtYXBwaW5nIGJldHdlZW4gZ2l2ZW4gbW9kZWwgYW5kIHZpZXcgZWxlbWVudHMgaXMgdW5zb2x2YWJsZSB1c2luZyBqdXN0IGVsZW1lbnRzIG1hcHBpbmcgYW5kIGRlZmF1bHQgYWxnb3JpdGhtLiBBbHNvLAogICAgICogdGhlIGNvbmRpdGlvbiB0aGF0IGNoZWNrcyBpZiBzcGVjaWFsIGNhc2Ugc2NlbmFyaW8gaGFwcGVuZWQgc2hvdWxkIGJlIGFzIHNpbXBsZSBhcyBwb3NzaWJsZS4KICAgICAqCiAgICAgKiBAZXZlbnQgbW9kZWxUb1ZpZXdQb3NpdGlvbgogICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSBwaXBlbGluZSBvYmplY3QgdGhhdCBjYW4gc3RvcmUgYW5kIHBhc3MgZGF0YSBiZXR3ZWVuIGNhbGxiYWNrcy4gVGhlIGNhbGxiYWNrIHNob3VsZCBhZGQKICAgICAqIGB2aWV3UG9zaXRpb25gIHZhbHVlIHRvIHRoYXQgb2JqZWN0IHdpdGggY2FsY3VsYXRlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHZpZXcgcG9zaXRpb259LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlcn0gZGF0YS5tYXBwZXIgTWFwcGVyIGluc3RhbmNlIHRoYXQgZmlyZWQgdGhlIGV2ZW50LgogICAgICovCgogICAgLyoqCiAgICAgKiBGaXJlZCBmb3IgZWFjaCB2aWV3LXRvLW1vZGVsIHBvc2l0aW9uIG1hcHBpbmcgcmVxdWVzdC4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciNldmVudDptb2RlbFRvVmlld1Bvc2l0aW9ufS4KICAgICAqCiAgICAgKiAJCS8vIFNlZSBleGFtcGxlIGluIGBtb2RlbFRvVmlld1Bvc2l0aW9uYCBldmVudCBkZXNjcmlwdGlvbi4KICAgICAqIAkJLy8gVGhpcyBjdXN0b20gbWFwcGluZyB3aWxsIG1hcCBwb3NpdGlvbnMgZnJvbSA8c3Bhbj4gZWxlbWVudCBuZXh0IHRvIDxpbWc+IHRvIHRoZSAiY2FwdGlvbmVkSW1hZ2UiIGVsZW1lbnQuCiAgICAgKgkJbWFwcGVyLm9uKCAndmlld1RvTW9kZWxQb3NpdGlvbicsICggZXZ0LCBkYXRhICkgPT4gewogICAgICoJCQljb25zdCBwb3NpdGlvblBhcmVudCA9IHZpZXdQb3NpdGlvbi5wYXJlbnQ7CiAgICAgKgogICAgICoJCQlpZiAoIHBvc2l0aW9uUGFyZW50Lmhhc0NsYXNzKCAnaW1hZ2UtY2FwdGlvbicgKSApIHsKICAgICAqCQkJCWNvbnN0IHZpZXdJbWcgPSBwb3NpdGlvblBhcmVudC5wcmV2aW91c1NpYmxpbmc7CiAgICAgKgkJCQljb25zdCBtb2RlbEltZyA9IGRhdGEubWFwcGVyLnRvTW9kZWxFbGVtZW50KCB2aWV3SW1nICk7CiAgICAgKgogICAgICoJCQkJZGF0YS5tb2RlbFBvc2l0aW9uID0gbmV3IE1vZGVsUG9zaXRpb24oIG1vZGVsSW1nLCB2aWV3UG9zaXRpb24ub2Zmc2V0ICk7CiAgICAgKgkJCQlldnQuc3RvcCgpOwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqICoqTm90ZToqKiBkZWZhdWx0IG1hcHBpbmcgY2FsbGJhY2sgaXMgcHJvdmlkZWQgd2l0aCBgbG93YCBwcmlvcml0eSBzZXR0aW5nIGFuZCBkb2VzIG5vdCBjYW5jZWwgdGhlIGV2ZW50LCBzbyBpdCBpcyBwb3NzaWJsZSB0bwogICAgICogYXR0YWNoIGEgY3VzdG9tIGNhbGxiYWNrIGFmdGVyIGRlZmF1bHQgY2FsbGJhY2sgYW5kIGFsc28gdXNlIGBkYXRhLm1vZGVsUG9zaXRpb25gIGNhbGN1bGF0ZWQgYnkgZGVmYXVsdCBjYWxsYmFjawogICAgICogKGZvciBleGFtcGxlIHRvIGZpeCBpdCkuCiAgICAgKgogICAgICogKipOb3RlOioqIGRlZmF1bHQgbWFwcGluZyBjYWxsYmFjayB3aWxsIG5vdCBmaXJlIGlmIGBkYXRhLm1vZGVsUG9zaXRpb25gIGlzIGFscmVhZHkgc2V0LgogICAgICoKICAgICAqICoqTm90ZToqKiB0aGVzZSBjYWxsYmFja3MgYXJlIGNhbGxlZCAqKnZlcnkgb2Z0ZW4qKi4gRm9yIGVmZmljaWVuY3kgcmVhc29ucywgaXQgaXMgYWR2aXNlZCB0byB1c2UgdGhlbSBvbmx5IHdoZW4gcG9zaXRpb24KICAgICAqIG1hcHBpbmcgYmV0d2VlbiBnaXZlbiBtb2RlbCBhbmQgdmlldyBlbGVtZW50cyBpcyB1bnNvbHZhYmxlIHVzaW5nIGp1c3QgZWxlbWVudHMgbWFwcGluZyBhbmQgZGVmYXVsdCBhbGdvcml0aG0uIEFsc28sCiAgICAgKiB0aGUgY29uZGl0aW9uIHRoYXQgY2hlY2tzIGlmIHNwZWNpYWwgY2FzZSBzY2VuYXJpbyBoYXBwZW5lZCBzaG91bGQgYmUgYXMgc2ltcGxlIGFzIHBvc3NpYmxlLgogICAgICoKICAgICAqIEBldmVudCB2aWV3VG9Nb2RlbFBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBEYXRhIHBpcGVsaW5lIG9iamVjdCB0aGF0IGNhbiBzdG9yZSBhbmQgcGFzcyBkYXRhIGJldHdlZW4gY2FsbGJhY2tzLiBUaGUgY2FsbGJhY2sgc2hvdWxkIGFkZAogICAgICogYG1vZGVsUG9zaXRpb25gIHZhbHVlIHRvIHRoYXQgb2JqZWN0IHdpdGggY2FsY3VsYXRlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBtb2RlbCBwb3NpdGlvbn0uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyfSBkYXRhLm1hcHBlciBNYXBwZXIgaW5zdGFuY2UgdGhhdCBmaXJlZCB0aGUgZXZlbnQuCiAgICAgKi8KCiAgfV0pOwoKICByZXR1cm4gTWFwcGVyOwp9KCk7CgpleHBvcnQgeyBNYXBwZXIgYXMgZGVmYXVsdCB9OwptaXgoTWFwcGVyLCBFbWl0dGVyTWl4aW4pOw=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js"],"names":["ModelPosition","ModelRange","ViewPosition","ViewRange","ViewText","EmitterMixin","mix","Mapper","_modelToViewMapping","WeakMap","_viewToModelMapping","_viewToModelLengthCallbacks","Map","_markerNameToElements","_elementToMarkerNames","_unboundMarkerNames","Set","on","evt","data","viewPosition","viewContainer","get","modelPosition","parent","findPositionIn","offset","priority","viewBlock","findMappedViewAncestor","modelParent","modelOffset","_toModelOffset","_createAt","modelElement","viewElement","set","toModelElement","delete","has","markerName","add","toViewElement","element","name","elements","names","nameToElements","size","elementToNames","markerNames","Array","from","clear","viewRange","toModelPosition","start","end","modelRange","toViewPosition","mapper","fire","options","isPhantom","boundElements","is","getElementsWithSameId","clone","viewElementName","lengthCallback","viewParent","viewOffset","offsetToParentStart","index","offsetInParent","i","getModelLength","getChild","viewNode","callback","length","len","getChildren","child","expectedOffset","lastLength","_moveViewPositionToTextNode","nodeBefore","nodeAfter"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\n\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\n\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Maps elements, positions and markers between {@link module:engine/view/document~Document the view} and\n * {@link module:engine/model/model the model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map complex model to/from view relations, you may provide custom callbacks for\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n */\nexport default class Mapper {\n\t/**\n\t * Creates an instance of the mapper.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Model element to view element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._modelToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View element to model element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._viewToModelMapping = new WeakMap();\n\n\t\t/**\n\t\t * A map containing callbacks between view element names and functions evaluating length of view elements\n\t\t * in model.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._viewToModelLengthCallbacks = new Map();\n\n\t\t/**\n\t\t * Model marker name to view elements mapping.\n\t\t *\n\t\t * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n\t\t * One marker (name) can be mapped to multiple elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._markerNameToElements = new Map();\n\n\t\t/**\n\t\t * View element to model marker names mapping.\n\t\t *\n\t\t * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._elementToMarkerNames = new Map();\n\n\t\t/**\n\t\t * Stores marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n\t\t * has been removed, moved or renamed).\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<module:engine/model/markercollection~Marker>}\n\t\t */\n\t\tthis._unboundMarkerNames = new Set();\n\n\t\t// Default mapper algorithm for mapping model position to view position.\n\t\tthis.on( 'modelToViewPosition', ( evt, data ) => {\n\t\t\tif ( data.viewPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewContainer = this._modelToViewMapping.get( data.modelPosition.parent );\n\n\t\t\tdata.viewPosition = this.findPositionIn( viewContainer, data.modelPosition.offset );\n\t\t}, { priority: 'low' } );\n\n\t\t// Default mapper algorithm for mapping view position to model position.\n\t\tthis.on( 'viewToModelPosition', ( evt, data ) => {\n\t\t\tif ( data.modelPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewBlock = this.findMappedViewAncestor( data.viewPosition );\n\t\t\tconst modelParent = this._viewToModelMapping.get( viewBlock );\n\t\t\tconst modelOffset = this._toModelOffset( data.viewPosition.parent, data.viewPosition.offset, viewBlock );\n\n\t\t\tdata.modelPosition = ModelPosition._createAt( modelParent, modelOffset );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n\t * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n\t * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n\t * The information that elements are bound is also used to translate positions.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t */\n\tbindElements( modelElement, viewElement ) {\n\t\tthis._modelToViewMapping.set( modelElement, viewElement );\n\t\tthis._viewToModelMapping.set( viewElement, modelElement );\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/view/element~Element view element} from the map.\n\t *\n\t * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n\t * will be removed only if model element is still bound to passed `viewElement`.\n\t *\n\t * This behavior lets for re-binding model element to another view element without fear of losing the new binding\n\t * when the previously bound view element is unbound.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element to unbind.\n\t */\n\tunbindViewElement( viewElement ) {\n\t\tconst modelElement = this.toModelElement( viewElement );\n\n\t\tthis._viewToModelMapping.delete( viewElement );\n\n\t\tif ( this._elementToMarkerNames.has( viewElement ) ) {\n\t\t\tfor ( const markerName of this._elementToMarkerNames.get( viewElement ) ) {\n\t\t\t\tthis._unboundMarkerNames.add( markerName );\n\t\t\t}\n\t\t}\n\n\t\tif ( this._modelToViewMapping.get( modelElement ) == viewElement ) {\n\t\t\tthis._modelToViewMapping.delete( modelElement );\n\t\t}\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/model/element~Element model element} from the map.\n\t *\n\t * **Note:** model-to-view binding will be removed, if it existed. However, corresponding view-to-model binding\n\t * will be removed only if view element is still bound to passed `modelElement`.\n\t *\n\t * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n\t * when the previously bound model element is unbound.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n\t */\n\tunbindModelElement( modelElement ) {\n\t\tconst viewElement = this.toViewElement( modelElement );\n\n\t\tthis._modelToViewMapping.delete( modelElement );\n\n\t\tif ( this._viewToModelMapping.get( viewElement ) == modelElement ) {\n\t\t\tthis._viewToModelMapping.delete( viewElement );\n\t\t}\n\t}\n\n\t/**\n\t * Binds given marker name with given {@link module:engine/view/element~Element view element}. The element\n\t * will be added to the current set of elements bound with given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to bind.\n\t * @param {String} name Marker name.\n\t */\n\tbindElementToMarker( element, name ) {\n\t\tconst elements = this._markerNameToElements.get( name ) || new Set();\n\t\telements.add( element );\n\n\t\tconst names = this._elementToMarkerNames.get( element ) || new Set();\n\t\tnames.add( name );\n\n\t\tthis._markerNameToElements.set( name, elements );\n\t\tthis._elementToMarkerNames.set( element, names );\n\t}\n\n\t/**\n\t * Unbinds an element from given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to unbind.\n\t * @param {String} name Marker name.\n\t */\n\tunbindElementFromMarkerName( element, name ) {\n\t\tconst nameToElements = this._markerNameToElements.get( name );\n\n\t\tif ( nameToElements ) {\n\t\t\tnameToElements.delete( element );\n\n\t\t\tif ( nameToElements.size == 0 ) {\n\t\t\t\tthis._markerNameToElements.delete( name );\n\t\t\t}\n\t\t}\n\n\t\tconst elementToNames = this._elementToMarkerNames.get( element );\n\n\t\tif ( elementToNames ) {\n\t\t\telementToNames.delete( name );\n\n\t\t\tif ( elementToNames.size == 0 ) {\n\t\t\t\tthis._elementToMarkerNames.delete( element );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n\t * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tflushUnboundMarkerNames() {\n\t\tconst markerNames = Array.from( this._unboundMarkerNames );\n\n\t\tthis._unboundMarkerNames.clear();\n\n\t\treturn markerNames;\n\t}\n\n\t/**\n\t * Removes all model to view and view to model bindings.\n\t */\n\tclearBindings() {\n\t\tthis._modelToViewMapping = new WeakMap();\n\t\tthis._viewToModelMapping = new WeakMap();\n\t\tthis._markerNameToElements = new Map();\n\t\tthis._elementToMarkerNames = new Map();\n\t\tthis._unboundMarkerNames = new Set();\n\t}\n\n\t/**\n\t * Gets the corresponding model element.\n\t *\n\t * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n\t */\n\ttoModelElement( viewElement ) {\n\t\treturn this._viewToModelMapping.get( viewElement );\n\t}\n\n\t/**\n\t * Gets the corresponding view element.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n\t */\n\ttoViewElement( modelElement ) {\n\t\treturn this._modelToViewMapping.get( modelElement );\n\t}\n\n\t/**\n\t * Gets the corresponding model range.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {module:engine/model/range~Range} Corresponding model range.\n\t */\n\ttoModelRange( viewRange ) {\n\t\treturn new ModelRange( this.toModelPosition( viewRange.start ), this.toModelPosition( viewRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding view range.\n\t *\n\t * @param {module:engine/model/range~Range} modelRange Model range.\n\t * @returns {module:engine/view/range~Range} Corresponding view range.\n\t */\n\ttoViewRange( modelRange ) {\n\t\treturn new ViewRange( this.toViewPosition( modelRange.start ), this.toViewPosition( modelRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding model position.\n\t *\n\t * @fires viewToModelPosition\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {module:engine/model/position~Position} Corresponding model position.\n\t */\n\ttoModelPosition( viewPosition ) {\n\t\tconst data = {\n\t\t\tviewPosition,\n\t\t\tmapper: this\n\t\t};\n\n\t\tthis.fire( 'viewToModelPosition', data );\n\n\t\treturn data.modelPosition;\n\t}\n\n\t/**\n\t * Gets the corresponding view position.\n\t *\n\t * @fires modelToViewPosition\n\t * @param {module:engine/model/position~Position} modelPosition Model position.\n\t * @param {Object} [options] Additional options for position mapping process.\n\t * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n\t * in model tree which no longer exists. For example, it could be an end of a removed model range.\n\t * @returns {module:engine/view/position~Position} Corresponding view position.\n\t */\n\ttoViewPosition( modelPosition, options = { isPhantom: false } ) {\n\t\tconst data = {\n\t\t\tmodelPosition,\n\t\t\tmapper: this,\n\t\t\tisPhantom: options.isPhantom\n\t\t};\n\n\t\tthis.fire( 'modelToViewPosition', data );\n\n\t\treturn data.viewPosition;\n\t}\n\n\t/**\n\t * Gets all view elements bound to the given marker name.\n\t *\n\t * @param {String} name Marker name.\n\t * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with given marker name or `null`\n\t * if no elements are bound to given marker name.\n\t */\n\tmarkerNameToElements( name ) {\n\t\tconst boundElements = this._markerNameToElements.get( name );\n\n\t\tif ( !boundElements ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst elements = new Set();\n\n\t\tfor ( const element of boundElements ) {\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tfor ( const clone of element.getElementsWithSameId() ) {\n\t\t\t\t\telements.add( clone );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements.add( element );\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Registers a callback that evaluates the length in the model of a view element with given name.\n\t *\n\t * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n\t * a number representing the length of view element in model.\n\t *\n\t *\t\t// List item in view may contain nested list, which have other list items. In model though,\n\t *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n\t *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n\t *\n\t *\t\tfunction getViewListItemLength( element ) {\n\t *\t\t\tlet length = 1;\n\t *\n\t *\t\t\tfor ( let child of element.getChildren() ) {\n\t *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n\t *\t\t\t\t\t\tlength += getViewListItemLength( item );\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn length;\n\t *\t\t}\n\t *\n\t *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n\t *\n\t * @param {String} viewElementName Name of view element for which callback is registered.\n\t * @param {Function} lengthCallback Function return a length of view element instance in model.\n\t */\n\tregisterViewToModelLength( viewElementName, lengthCallback ) {\n\t\tthis._viewToModelLengthCallbacks.set( viewElementName, lengthCallback );\n\t}\n\n\t/**\n\t * For given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n\t * the model.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition Position for which mapped ancestor should be found.\n\t * @returns {module:engine/view/element~Element}\n\t */\n\tfindMappedViewAncestor( viewPosition ) {\n\t\tlet parent = viewPosition.parent;\n\n\t\twhile ( !this._viewToModelMapping.has( parent ) ) {\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Calculates model offset based on the view position and the block element.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n\t *\n\t * Is a sum of:\n\t *\n\t *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Position parent.\n\t * @param {Number} viewOffset Position offset.\n\t * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n\t * @returns {Number} Offset in the model.\n\t */\n\t_toModelOffset( viewParent, viewOffset, viewBlock ) {\n\t\tif ( viewBlock != viewParent ) {\n\t\t\t// See example.\n\t\t\tconst offsetToParentStart = this._toModelOffset( viewParent.parent, viewParent.index, viewBlock );\n\t\t\tconst offsetInParent = this._toModelOffset( viewParent, viewOffset, viewParent );\n\n\t\t\treturn offsetToParentStart + offsetInParent;\n\t\t}\n\n\t\t// viewBlock == viewParent, so we need to calculate the offset in the parent element.\n\n\t\t// If the position is a text it is simple (\"ba|r\" -> 2).\n\t\tif ( viewParent.is( '$text' ) ) {\n\t\t\treturn viewOffset;\n\t\t}\n\n\t\t// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\t\tlet modelOffset = 0;\n\n\t\tfor ( let i = 0; i < viewOffset; i++ ) {\n\t\t\tmodelOffset += this.getModelLength( viewParent.getChild( i ) );\n\t\t}\n\n\t\treturn modelOffset;\n\t}\n\n\t/**\n\t * Gets the length of the view element in the model.\n\t *\n\t * The length is calculated as follows:\n\t * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to\n\t * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),\n\t * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's\n\t * {@link module:engine/view/text~Text#data data},\n\t * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n\t * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n\t * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.\n\t *\n\t * Examples:\n\t *\n\t *\t\tfoo                          -> 3 // Text length is equal to it's data length.\n\t *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n\t *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n\t *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n\t *\n\t * @param {module:engine/view/element~Element} viewNode View node.\n\t * @returns {Number} Length of the node in the tree model.\n\t */\n\tgetModelLength( viewNode ) {\n\t\tif ( this._viewToModelLengthCallbacks.get( viewNode.name ) ) {\n\t\t\tconst callback = this._viewToModelLengthCallbacks.get( viewNode.name );\n\n\t\t\treturn callback( viewNode );\n\t\t} else if ( this._viewToModelMapping.has( viewNode ) ) {\n\t\t\treturn 1;\n\t\t} else if ( viewNode.is( '$text' ) ) {\n\t\t\treturn viewNode.data.length;\n\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tlet len = 0;\n\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tlen += this.getModelLength( child );\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t}\n\n\t/**\n\t * Finds the position in the view node (or its children) with the expected model offset.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n\t *\n\t *\t\tfindPositionIn( p, 4 ):\n\t *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n\t *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n\t *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n\t *\n\t *\t\tfindPositionIn( b, 4 - ( 5 - 3 ) ):\n\t *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n\t *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n\t *\n\t *\t\tfindPositionIn( bar, 2 - ( 3 - 3 ) ):\n\t *\t\tWe are in the text node so we can simple find the offset.\n\t *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n\t *\n\t * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n\t * @param {Number} expectedOffset Expected offset.\n\t * @returns {module:engine/view/position~Position} Found position.\n\t */\n\tfindPositionIn( viewParent, expectedOffset ) {\n\t\t// Last scanned view node.\n\t\tlet viewNode;\n\t\t// Length of the last scanned view node.\n\t\tlet lastLength = 0;\n\n\t\tlet modelOffset = 0;\n\t\tlet viewOffset = 0;\n\n\t\t// In the text node it is simple: offset in the model equals offset in the text.\n\t\tif ( viewParent.is( '$text' ) ) {\n\t\t\treturn new ViewPosition( viewParent, expectedOffset );\n\t\t}\n\n\t\t// In other cases we add lengths of child nodes to find the proper offset.\n\n\t\t// If it is smaller we add the length.\n\t\twhile ( modelOffset < expectedOffset ) {\n\t\t\tviewNode = viewParent.getChild( viewOffset );\n\t\t\tlastLength = this.getModelLength( viewNode );\n\t\t\tmodelOffset += lastLength;\n\t\t\tviewOffset++;\n\t\t}\n\n\t\t// If it equals we found the position.\n\t\tif ( modelOffset == expectedOffset ) {\n\t\t\treturn this._moveViewPositionToTextNode( new ViewPosition( viewParent, viewOffset ) );\n\t\t}\n\t\t// If it is higher we need to enter last child.\n\t\telse {\n\t\t\t// ( modelOffset - lastLength ) is the offset to the child we enter,\n\t\t\t// so we subtract it from the expected offset to fine the offset in the child.\n\t\t\treturn this.findPositionIn( viewNode, expectedOffset - ( modelOffset - lastLength ) );\n\t\t}\n\t}\n\n\t/**\n\t * Because we prefer positions in text nodes over positions next to text node moves view position to the text node\n\t * if it was next to it.\n\t *\n\t *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n\t *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n\t *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.\n\t * @returns {module:engine/view/position~Position} Position in text node if possible.\n\t */\n\t_moveViewPositionToTextNode( viewPosition ) {\n\t\t// If the position is just after text node, put it at the end of that text node.\n\t\t// If the position is just before text node, put it at the beginning of that text node.\n\t\tconst nodeBefore = viewPosition.nodeBefore;\n\t\tconst nodeAfter = viewPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeBefore, nodeBefore.data.length );\n\t\t} else if ( nodeAfter instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeAfter, 0 );\n\t\t}\n\n\t\t// Otherwise, just return the given position.\n\t\treturn viewPosition;\n\t}\n\n\t/**\n\t * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n\t * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n\t * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`\n\t * value in `data` object that is passed as one of parameters to the event callback.\n\t *\n\t * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n\t * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n\t * \t\t// <span> element.\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = modelPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n\t *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n\t *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n\t *\n\t *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n\t *\n\t *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. \"Phantom\" model position is\n\t * a position that points to a non-existing place in model. Such position might still be valid for conversion, though\n\t * (it would point to a correct place in view when converted). One example of such situation is when a range is\n\t * removed from model, there may be a need to map the range's end (which is no longer valid model position). To\n\t * handle such situation, check `data.isPhantom` flag:\n\t *\n\t * \t\t// Assume that there is \"customElement\" model element and whenever position is before it, we want to move it\n\t * \t\t// to the inside of the view element bound to \"customElement\".\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tif ( data.isPhantom ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\t// Below line might crash for phantom position that does not exist in model.\n\t *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n\t *\n\t *\t\t\t// Check if this is the element we are interested in.\n\t *\t\t\tif ( !sibling.is( 'element', 'customElement' ) ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n\t *\n\t *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n\t *\n\t *\t\t\tevt.stop();\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event modelToViewPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n\n\t/**\n\t * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n\t *\n\t * \t\t// See example in `modelToViewPosition` event description.\n\t * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n\t *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = viewPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n\t *\t\t\t\tconst viewImg = positionParent.previousSibling;\n\t *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n\t *\n\t *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event viewToModelPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n}\n\nmix( Mapper, EmitterMixin );\n"]}]}