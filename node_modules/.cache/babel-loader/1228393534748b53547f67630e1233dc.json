{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwppbXBvcnQgInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLXNldC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL3ZpZXcvZG9tY29udmVydGVyCiAqLwoKLyogZ2xvYmFscyBkb2N1bWVudCwgTm9kZSwgTm9kZUZpbHRlciwgVGV4dCAqLwppbXBvcnQgVmlld1RleHQgZnJvbSAnLi90ZXh0JzsKaW1wb3J0IFZpZXdFbGVtZW50IGZyb20gJy4vZWxlbWVudCc7CmltcG9ydCBWaWV3UG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBWaWV3UmFuZ2UgZnJvbSAnLi9yYW5nZSc7CmltcG9ydCBWaWV3U2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJzsKaW1wb3J0IFZpZXdEb2N1bWVudEZyYWdtZW50IGZyb20gJy4vZG9jdW1lbnRmcmFnbWVudCc7CmltcG9ydCBWaWV3VHJlZVdhbGtlciBmcm9tICcuL3RyZWV3YWxrZXInOwppbXBvcnQgTWF0Y2hlciBmcm9tICcuL21hdGNoZXInOwppbXBvcnQgeyBCUl9GSUxMRVIsIElOTElORV9GSUxMRVJfTEVOR1RILCBOQlNQX0ZJTExFUiwgTUFSS0VEX05CU1BfRklMTEVSLCBnZXREYXRhV2l0aG91dEZpbGxlciwgaXNJbmxpbmVGaWxsZXIsIHN0YXJ0c1dpdGhGaWxsZXIgfSBmcm9tICcuL2ZpbGxlcic7CmltcG9ydCBnbG9iYWwgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvZG9tL2dsb2JhbCc7CmltcG9ydCBpbmRleE9mIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2RvbS9pbmRleG9mJzsKaW1wb3J0IGdldEFuY2VzdG9ycyBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9kb20vZ2V0YW5jZXN0b3JzJzsKaW1wb3J0IGdldENvbW1vbkFuY2VzdG9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2RvbS9nZXRjb21tb25hbmNlc3Rvcic7CmltcG9ydCBpc1RleHQgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvZG9tL2lzdGV4dCc7CmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJ2xvZGFzaC1lcyc7CnZhciBCUl9GSUxMRVJfUkVGID0gQlJfRklMTEVSKGRvY3VtZW50KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwCgp2YXIgTkJTUF9GSUxMRVJfUkVGID0gTkJTUF9GSUxMRVIoZG9jdW1lbnQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXAKCnZhciBNQVJLRURfTkJTUF9GSUxMRVJfUkVGID0gTUFSS0VEX05CU1BfRklMTEVSKGRvY3VtZW50KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwCgovKioKICogYERvbUNvbnZlcnRlcmAgaXMgYSBzZXQgb2YgdG9vbHMgdG8gZG8gdHJhbnNmb3JtYXRpb25zIGJldHdlZW4gRE9NIG5vZGVzIGFuZCB2aWV3IG5vZGVzLiBJdCBhbHNvIGhhbmRsZXMKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBiaW5kaW5nc30gYmV0d2VlbiB0aGVzZSBub2Rlcy4KICoKICogQW4gaW5zdGFuY2Ugb2YgdGhlIERPTSBjb252ZXJ0ZXIgaXMgYXZhaWxhYmxlIHVuZGVyCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlld35WaWV3I2RvbUNvbnZlcnRlciBgZWRpdG9yLmVkaXRpbmcudmlldy5kb21Db252ZXJ0ZXJgfS4KICoKICogVGhlIERPTSBjb252ZXJ0ZXIgZG9lcyBub3QgY2hlY2sgd2hpY2ggbm9kZXMgc2hvdWxkIGJlIHJlbmRlcmVkICh1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yZW5kZXJlcn5SZW5kZXJlcn0pLCBkb2VzIG5vdCBrZWVwIHRoZQogKiBzdGF0ZSBvZiBhIHRyZWUgbm9yIGtlZXBzIHRoZSBzeW5jaHJvbml6YXRpb24gYmV0d2VlbiB0aGUgdHJlZSB2aWV3IGFuZCB0aGUgRE9NIHRyZWUgKHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50fkRvY3VtZW50fSkuCiAqCiAqIFRoZSBET00gY29udmVydGVyIGtlZXBzIERPTSBlbGVtZW50cyB0byB2aWV3IGVsZW1lbnQgYmluZGluZ3MsIHNvIHdoZW4gdGhlIGNvbnZlcnRlciBnZXRzIGRlc3Ryb3llZCwgdGhlIGJpbmRpbmdzIGFyZSBsb3N0LgogKiBUd28gY29udmVydGVycyB3aWxsIGtlZXAgc2VwYXJhdGUgYmluZGluZyBtYXBzLCBzbyBvbmUgdHJlZSB2aWV3IGNhbiBiZSBib3VuZCB3aXRoIHR3byBET00gdHJlZXMuCiAqLwoKdmFyIERvbUNvbnZlcnRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIERPTSBjb252ZXJ0ZXIuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudH0gZG9jdW1lbnQgVGhlIHZpZXcgZG9jdW1lbnQgaW5zdGFuY2UuCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2ZpbGxlcn5CbG9ja0ZpbGxlck1vZGV9IFtvcHRpb25zLmJsb2NrRmlsbGVyTW9kZT0nYnInXSBUaGUgdHlwZSBvZiB0aGUgYmxvY2sgZmlsbGVyIHRvIHVzZS4KICAgKi8KICBmdW5jdGlvbiBEb21Db252ZXJ0ZXIoZG9jdW1lbnQpIHsKICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9tQ29udmVydGVyKTsKCiAgICAvKioKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudH0KICAgICAqLwogICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50OwogICAgLyoqCiAgICAgKiBUaGUgbW9kZSBvZiBhIGJsb2NrIGZpbGxlciB1c2VkIGJ5IHRoZSBET00gY29udmVydGVyLgogICAgICoKICAgICAqIEBtZW1iZXIgeydicid8J25ic3AnfCdtYXJrZWROYnNwJ30gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmxvY2tGaWxsZXJNb2RlCiAgICAgKi8KCiAgICB0aGlzLmJsb2NrRmlsbGVyTW9kZSA9IG9wdGlvbnMuYmxvY2tGaWxsZXJNb2RlIHx8ICdicic7CiAgICAvKioKICAgICAqIEVsZW1lbnRzIHdoaWNoIGFyZSBjb25zaWRlcmVkIHByZS1mb3JtYXR0ZWQgZWxlbWVudHMuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtBcnJheS48U3RyaW5nPn0gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjcHJlRWxlbWVudHMKICAgICAqLwoKICAgIHRoaXMucHJlRWxlbWVudHMgPSBbJ3ByZSddOwogICAgLyoqCiAgICAgKiBFbGVtZW50cyB3aGljaCBhcmUgY29uc2lkZXJlZCBibG9jayBlbGVtZW50cyAoYW5kIGhlbmNlIHNob3VsZCBiZSBmaWxsZWQgd2l0aCBhCiAgICAgKiB7QGxpbmsgI2lzQmxvY2tGaWxsZXIgYmxvY2sgZmlsbGVyfSkuCiAgICAgKgogICAgICogV2hldGhlciBhbiBlbGVtZW50IGlzIGNvbnNpZGVyZWQgYSBibG9jayBlbGVtZW50IGFsc28gYWZmZWN0cyBoYW5kbGluZyBvZiB0cmFpbGluZyB3aGl0ZXNwYWNlcy4KICAgICAqCiAgICAgKiBZb3UgY2FuIGV4dGVuZCB0aGlzIGFycmF5IGlmIHlvdSBpbnRyb2R1Y2Ugc3VwcG9ydCBmb3IgYmxvY2sgZWxlbWVudHMgd2hpY2ggYXJlIG5vdCB5ZXQgcmVjb2duaXplZCBoZXJlLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7QXJyYXkuPFN0cmluZz59IG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2Jsb2NrRWxlbWVudHMKICAgICAqLwoKICAgIHRoaXMuYmxvY2tFbGVtZW50cyA9IFsncCcsICdkaXYnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnbGknLCAnZGQnLCAnZHQnLCAnZmlnY2FwdGlvbicsICd0ZCcsICd0aCddOwogICAgLyoqCiAgICAgKiBUaGUgRE9NLXRvLXZpZXcgbWFwcGluZy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7V2Vha01hcH0gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjX2RvbVRvVmlld01hcHBpbmcKICAgICAqLwoKICAgIHRoaXMuX2RvbVRvVmlld01hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgLyoqCiAgICAgKiBUaGUgdmlldy10by1ET00gbWFwcGluZy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7V2Vha01hcH0gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjX3ZpZXdUb0RvbU1hcHBpbmcKICAgICAqLwoKICAgIHRoaXMuX3ZpZXdUb0RvbU1hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgLyoqCiAgICAgKiBIb2xkcyB0aGUgbWFwcGluZyBiZXR3ZWVuIGZha2Ugc2VsZWN0aW9uIGNvbnRhaW5lcnMgYW5kIGNvcnJlc3BvbmRpbmcgdmlldyBzZWxlY3Rpb25zLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfSBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNfZmFrZVNlbGVjdGlvbk1hcHBpbmcKICAgICAqLwoKICAgIHRoaXMuX2Zha2VTZWxlY3Rpb25NYXBwaW5nID0gbmV3IFdlYWtNYXAoKTsKICAgIC8qKgogICAgICogTWF0Y2hlciBmb3IgdmlldyBlbGVtZW50cyB3aG9zZSBjb250ZW50IHNob3VsZCBiZSB0cmVhdGVkIGFzIHJhdyBkYXRhCiAgICAgKiBhbmQgbm90IHByb2Nlc3NlZCBkdXJpbmcgdGhlIGNvbnZlcnNpb24gZnJvbSBET00gbm9kZXMgdG8gdmlldyBlbGVtZW50cy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJ9CiAgICAgKi8KCiAgICB0aGlzLl9yYXdDb250ZW50RWxlbWVudE1hdGNoZXIgPSBuZXcgTWF0Y2hlcigpOwogICAgLyoqCiAgICAgKiBBIHNldCBvZiBlbmNvdW50ZXJlZCByYXcgY29udGVudCBET00gbm9kZXMuIEl0IGlzIHVzZWQgZm9yIHByZXZlbnRpbmcgbGVmdCB0cmltbWluZyBvZiB0aGUgZm9sbG93aW5nIHRleHQgbm9kZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge1dlYWtTZXQuPE5vZGU+fQogICAgICovCgogICAgdGhpcy5fZW5jb3VudGVyZWRSYXdDb250ZW50RG9tTm9kZXMgPSBuZXcgV2Vha1NldCgpOwogIH0KICAvKioKICAgKiBCaW5kcyBhIGdpdmVuIERPTSBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBmYWtlIHNlbGVjdGlvbiB0byBhICoqcG9zaXRpb24qKiBvZiBhCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbiBkb2N1bWVudCBzZWxlY3Rpb259LgogICAqIERvY3VtZW50IHNlbGVjdGlvbiBjb3B5IGlzIHN0b3JlZCBhbmQgY2FuIGJlIHJldHJpZXZlZCBieSB0aGUKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjZmFrZVNlbGVjdGlvblRvVmlld30gbWV0aG9kLgogICAqCiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tRWxlbWVudAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9ufSB2aWV3RG9jdW1lbnRTZWxlY3Rpb24KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhEb21Db252ZXJ0ZXIsIFt7CiAgICBrZXk6ICJiaW5kRmFrZVNlbGVjdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEZha2VTZWxlY3Rpb24oZG9tRWxlbWVudCwgdmlld0RvY3VtZW50U2VsZWN0aW9uKSB7CiAgICAgIHRoaXMuX2Zha2VTZWxlY3Rpb25NYXBwaW5nLnNldChkb21FbGVtZW50LCBuZXcgVmlld1NlbGVjdGlvbih2aWV3RG9jdW1lbnRTZWxlY3Rpb24pKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGlvbiB2aWV3IHNlbGVjdGlvbn0gaW5zdGFuY2UgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuCiAgICAgKiBET00gZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgZmFrZSBzZWxlY3Rpb24uIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgYmluZGluZyB0byB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuCiAgICAgKgogICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tRWxlbWVudAogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufHVuZGVmaW5lZH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmYWtlU2VsZWN0aW9uVG9WaWV3IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBmYWtlU2VsZWN0aW9uVG9WaWV3KGRvbUVsZW1lbnQpIHsKICAgICAgcmV0dXJuIHRoaXMuX2Zha2VTZWxlY3Rpb25NYXBwaW5nLmdldChkb21FbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogQmluZHMgRE9NIGFuZCB2aWV3IGVsZW1lbnRzLCBzbyBpdCB3aWxsIGJlIHBvc3NpYmxlIHRvIGdldCBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIHVzaW5nCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjbWFwRG9tVG9WaWV3fSBhbmQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNtYXBWaWV3VG9Eb219LgogICAgICoKICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbUVsZW1lbnQgVGhlIERPTSBlbGVtZW50IHRvIGJpbmQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IHZpZXdFbGVtZW50IFRoZSB2aWV3IGVsZW1lbnQgdG8gYmluZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJiaW5kRWxlbWVudHMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFbGVtZW50cyhkb21FbGVtZW50LCB2aWV3RWxlbWVudCkgewogICAgICB0aGlzLl9kb21Ub1ZpZXdNYXBwaW5nLnNldChkb21FbGVtZW50LCB2aWV3RWxlbWVudCk7CgogICAgICB0aGlzLl92aWV3VG9Eb21NYXBwaW5nLnNldCh2aWV3RWxlbWVudCwgZG9tRWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIFVuYmluZHMgYSBnaXZlbiBET00gZWxlbWVudCBmcm9tIHRoZSB2aWV3IGVsZW1lbnQgaXQgd2FzIGJvdW5kIHRvLiBVbmJpbmRpbmcgaXMgZGVlcCwgbWVhbmluZyB0aGF0IGFsbCBjaGlsZHJlbiBvZgogICAgICogdGhlIERPTSBlbGVtZW50IHdpbGwgYmUgdW5ib3VuZCB0b28uCiAgICAgKgogICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tRWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdG8gdW5iaW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogInVuYmluZERvbUVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZERvbUVsZW1lbnQoZG9tRWxlbWVudCkgewogICAgICB2YXIgdmlld0VsZW1lbnQgPSB0aGlzLl9kb21Ub1ZpZXdNYXBwaW5nLmdldChkb21FbGVtZW50KTsKCiAgICAgIGlmICh2aWV3RWxlbWVudCkgewogICAgICAgIHRoaXMuX2RvbVRvVmlld01hcHBpbmcuZGVsZXRlKGRvbUVsZW1lbnQpOwoKICAgICAgICB0aGlzLl92aWV3VG9Eb21NYXBwaW5nLmRlbGV0ZSh2aWV3RWxlbWVudCk7CgogICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkb21FbGVtZW50LmNoaWxkTm9kZXMpLAogICAgICAgICAgICBfc3RlcDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlOwogICAgICAgICAgICB0aGlzLnVuYmluZERvbUVsZW1lbnQoY2hpbGQpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgX2l0ZXJhdG9yLmYoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQmluZHMgRE9NIGFuZCB2aWV3IGRvY3VtZW50IGZyYWdtZW50cywgc28gaXQgd2lsbCBiZSBwb3NzaWJsZSB0byBnZXQgY29ycmVzcG9uZGluZyBkb2N1bWVudCBmcmFnbWVudHMgdXNpbmcKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNtYXBEb21Ub1ZpZXd9IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI21hcFZpZXdUb0RvbX0uCiAgICAgKgogICAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBkb21GcmFnbWVudCBUaGUgRE9NIGRvY3VtZW50IGZyYWdtZW50IHRvIGJpbmQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHZpZXdGcmFnbWVudCBUaGUgdmlldyBkb2N1bWVudCBmcmFnbWVudCB0byBiaW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogImJpbmREb2N1bWVudEZyYWdtZW50cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZERvY3VtZW50RnJhZ21lbnRzKGRvbUZyYWdtZW50LCB2aWV3RnJhZ21lbnQpIHsKICAgICAgdGhpcy5fZG9tVG9WaWV3TWFwcGluZy5zZXQoZG9tRnJhZ21lbnQsIHZpZXdGcmFnbWVudCk7CgogICAgICB0aGlzLl92aWV3VG9Eb21NYXBwaW5nLnNldCh2aWV3RnJhZ21lbnQsIGRvbUZyYWdtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgdGhlIHZpZXcgdG8gdGhlIERPTS4gRm9yIGFsbCB0ZXh0IG5vZGVzLCBub3QgYm91bmQgZWxlbWVudHMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyBuZXcgaXRlbXMgd2lsbAogICAgICogYmUgY3JlYXRlZC4gRm9yIGJvdW5kIGVsZW1lbnRzIGFuZCBkb2N1bWVudCBmcmFnbWVudHMgdGhlIG1ldGhvZCB3aWxsIHJldHVybiBjb3JyZXNwb25kaW5nIGl0ZW1zLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSB2aWV3Tm9kZQogICAgICogVmlldyBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50IHRvIHRyYW5zZm9ybS4KICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvbURvY3VtZW50IERvY3VtZW50IHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgRE9NIG5vZGVzLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnMuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmQ9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciBuZXcgZWxlbWVudHMgd2lsbCBiZSBib3VuZC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aENoaWxkcmVuPXRydWVdIElmIGB0cnVlYCwgbm9kZSdzIGFuZCBkb2N1bWVudCBmcmFnbWVudCdzIGNoaWxkcmVuIHdpbGwgYmUgY29udmVydGVkIHRvby4KICAgICAqIEByZXR1cm5zIHtOb2RlfERvY3VtZW50RnJhZ21lbnR9IENvbnZlcnRlZCBub2RlIG9yIERvY3VtZW50RnJhZ21lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidmlld1RvRG9tIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3VG9Eb20odmlld05vZGUsIGRvbURvY3VtZW50KSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTsKCiAgICAgIGlmICh2aWV3Tm9kZS5pcygnJHRleHQnKSkgewogICAgICAgIHZhciB0ZXh0RGF0YSA9IHRoaXMuX3Byb2Nlc3NEYXRhRnJvbVZpZXdUZXh0KHZpZXdOb2RlKTsKCiAgICAgICAgcmV0dXJuIGRvbURvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHREYXRhKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5tYXBWaWV3VG9Eb20odmlld05vZGUpKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5tYXBWaWV3VG9Eb20odmlld05vZGUpOwogICAgICAgIH0KCiAgICAgICAgdmFyIGRvbUVsZW1lbnQ7CgogICAgICAgIGlmICh2aWV3Tm9kZS5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgICAvLyBDcmVhdGUgRE9NIGRvY3VtZW50IGZyYWdtZW50LgogICAgICAgICAgZG9tRWxlbWVudCA9IGRvbURvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsKCiAgICAgICAgICBpZiAob3B0aW9ucy5iaW5kKSB7CiAgICAgICAgICAgIHRoaXMuYmluZERvY3VtZW50RnJhZ21lbnRzKGRvbUVsZW1lbnQsIHZpZXdOb2RlKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHZpZXdOb2RlLmlzKCd1aUVsZW1lbnQnKSkgewogICAgICAgICAgLy8gVUlFbGVtZW50IGhhcyBpdHMgb3duIHJlbmRlcigpIG1ldGhvZCAoc2VlICM3OTkpLgogICAgICAgICAgZG9tRWxlbWVudCA9IHZpZXdOb2RlLnJlbmRlcihkb21Eb2N1bWVudCk7CgogICAgICAgICAgaWYgKG9wdGlvbnMuYmluZCkgewogICAgICAgICAgICB0aGlzLmJpbmRFbGVtZW50cyhkb21FbGVtZW50LCB2aWV3Tm9kZSk7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQ7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIENyZWF0ZSBET00gZWxlbWVudC4KICAgICAgICAgIGlmICh2aWV3Tm9kZS5oYXNBdHRyaWJ1dGUoJ3htbG5zJykpIHsKICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvbURvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh2aWV3Tm9kZS5nZXRBdHRyaWJ1dGUoJ3htbG5zJyksIHZpZXdOb2RlLm5hbWUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvbURvY3VtZW50LmNyZWF0ZUVsZW1lbnQodmlld05vZGUubmFtZSk7CiAgICAgICAgICB9IC8vIFJhd0VsZW1lbnQgdGFrZSBjYXJlIG9mIHRoZWlyIGNoaWxkcmVuIGluIFJhd0VsZW1lbnQjcmVuZGVyKCkgbWV0aG9kIHdoaWNoIGNhbiBiZSBjdXN0b21pemVkCiAgICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUvaXNzdWVzLzQ0NjkpLgoKCiAgICAgICAgICBpZiAodmlld05vZGUuaXMoJ3Jhd0VsZW1lbnQnKSkgewogICAgICAgICAgICB2aWV3Tm9kZS5yZW5kZXIoZG9tRWxlbWVudCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKG9wdGlvbnMuYmluZCkgewogICAgICAgICAgICB0aGlzLmJpbmRFbGVtZW50cyhkb21FbGVtZW50LCB2aWV3Tm9kZSk7CiAgICAgICAgICB9IC8vIENvcHkgZWxlbWVudCdzIGF0dHJpYnV0ZXMuCgoKICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodmlld05vZGUuZ2V0QXR0cmlidXRlS2V5cygpKSwKICAgICAgICAgICAgICBfc3RlcDI7CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAyLnZhbHVlOwogICAgICAgICAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmlld05vZGUuZ2V0QXR0cmlidXRlKGtleSkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChvcHRpb25zLndpdGhDaGlsZHJlbiAhPT0gZmFsc2UpIHsKICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy52aWV3Q2hpbGRyZW5Ub0RvbSh2aWV3Tm9kZSwgZG9tRG9jdW1lbnQsIG9wdGlvbnMpKSwKICAgICAgICAgICAgICBfc3RlcDM7CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcDMudmFsdWU7CiAgICAgICAgICAgICAgZG9tRWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTsKICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjMuZigpOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQ7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgY2hpbGRyZW4gb2YgdGhlIHZpZXcgZWxlbWVudCB0byBET00gdXNpbmcgdGhlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjdmlld1RvRG9tfSBtZXRob2QuCiAgICAgKiBBZGRpdGlvbmFsbHksIHRoaXMgbWV0aG9kIGFkZHMgYmxvY2sge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyfSB0byB0aGUgbGlzdCBvZiBjaGlsZHJlbiwgaWYgbmVlZGVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSB2aWV3RWxlbWVudCBQYXJlbnQgdmlldyBlbGVtZW50LgogICAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9tRG9jdW1lbnQgRG9jdW1lbnQgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBET00gbm9kZXMuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI3ZpZXdUb0RvbX0gb3B0aW9ucyBwYXJhbWV0ZXIuCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPE5vZGU+fSBET00gbm9kZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidmlld0NoaWxkcmVuVG9Eb20iLAogICAgdmFsdWU6CiAgICAvKiNfX1BVUkVfXyovCiAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiB2aWV3Q2hpbGRyZW5Ub0RvbSh2aWV3RWxlbWVudCwgZG9tRG9jdW1lbnQpIHsKICAgICAgdmFyIG9wdGlvbnMsCiAgICAgICAgICBmaWxsZXJQb3NpdGlvbk9mZnNldCwKICAgICAgICAgIG9mZnNldCwKICAgICAgICAgIF9pdGVyYXRvcjQsCiAgICAgICAgICBfc3RlcDQsCiAgICAgICAgICBjaGlsZFZpZXcsCiAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50czsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiB2aWV3Q2hpbGRyZW5Ub0RvbSQoX2NvbnRleHQpIHsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzLmxlbmd0aCA+IDIgJiYgX2FyZ3NbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzJdIDoge307CiAgICAgICAgICAgICAgZmlsbGVyUG9zaXRpb25PZmZzZXQgPSB2aWV3RWxlbWVudC5nZXRGaWxsZXJPZmZzZXQgJiYgdmlld0VsZW1lbnQuZ2V0RmlsbGVyT2Zmc2V0KCk7CiAgICAgICAgICAgICAgb2Zmc2V0ID0gMDsKICAgICAgICAgICAgICBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodmlld0VsZW1lbnQuZ2V0Q2hpbGRyZW4oKSk7CiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDQ7CgogICAgICAgICAgICAgIF9pdGVyYXRvcjQucygpOwoKICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgIGlmICgoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmUpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgY2hpbGRWaWV3ID0gX3N0ZXA0LnZhbHVlOwoKICAgICAgICAgICAgICBpZiAoIShmaWxsZXJQb3NpdGlvbk9mZnNldCA9PT0gb2Zmc2V0KSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJsb2NrRmlsbGVyKGRvbURvY3VtZW50KTsKCiAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzOwogICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdUb0RvbShjaGlsZFZpZXcsIGRvbURvY3VtZW50LCBvcHRpb25zKTsKCiAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgb2Zmc2V0Kys7CgogICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE4OgogICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODsKICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0WyJjYXRjaCJdKDQpOwoKICAgICAgICAgICAgICBfaXRlcmF0b3I0LmUoX2NvbnRleHQudDApOwoKICAgICAgICAgICAgY2FzZSAyMToKICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjE7CgogICAgICAgICAgICAgIF9pdGVyYXRvcjQuZigpOwoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIxKTsKCiAgICAgICAgICAgIGNhc2UgMjQ6CiAgICAgICAgICAgICAgaWYgKCEoZmlsbGVyUG9zaXRpb25PZmZzZXQgPT09IG9mZnNldCkpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNzsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI3OwogICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCbG9ja0ZpbGxlcihkb21Eb2N1bWVudCk7CgogICAgICAgICAgICBjYXNlIDI3OgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCB2aWV3Q2hpbGRyZW5Ub0RvbSwgdGhpcywgW1s0LCAxOCwgMjEsIDI0XV0pOwogICAgfSkKICAgIC8qKgogICAgICogQ29udmVydHMgdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSB0byBET00gcmFuZ2UuCiAgICAgKiBJbmxpbmUgYW5kIGJsb2NrIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcnN9IGFyZSBoYW5kbGVkIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gdmlld1JhbmdlIFZpZXcgcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7UmFuZ2V9IERPTSByYW5nZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ2aWV3UmFuZ2VUb0RvbSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdmlld1JhbmdlVG9Eb20odmlld1JhbmdlKSB7CiAgICAgIHZhciBkb21TdGFydCA9IHRoaXMudmlld1Bvc2l0aW9uVG9Eb20odmlld1JhbmdlLnN0YXJ0KTsKICAgICAgdmFyIGRvbUVuZCA9IHRoaXMudmlld1Bvc2l0aW9uVG9Eb20odmlld1JhbmdlLmVuZCk7CiAgICAgIHZhciBkb21SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7CiAgICAgIGRvbVJhbmdlLnNldFN0YXJ0KGRvbVN0YXJ0LnBhcmVudCwgZG9tU3RhcnQub2Zmc2V0KTsKICAgICAgZG9tUmFuZ2Uuc2V0RW5kKGRvbUVuZC5wYXJlbnQsIGRvbUVuZC5vZmZzZXQpOwogICAgICByZXR1cm4gZG9tUmFuZ2U7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIHZpZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdG8gRE9NIHBhcmVudCBhbmQgb2Zmc2V0LgogICAgICoKICAgICAqIElubGluZSBhbmQgYmxvY2sge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyc30gYXJlIGhhbmRsZWQgZHVyaW5nIHRoZSBjb252ZXJzaW9uLgogICAgICogSWYgdGhlIGNvbnZlcnRlZCBwb3NpdGlvbiBpcyBkaXJlY3RseSBiZWZvcmUgaW5saW5lIGZpbGxlciBpdCBpcyBtb3ZlZCBpbnNpZGUgdGhlIGZpbGxlci4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdmlld1Bvc2l0aW9uIFZpZXcgcG9zaXRpb24uCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IHBvc2l0aW9uIERPTSBwb3NpdGlvbiBvciBgbnVsbGAgaWYgdmlldyBwb3NpdGlvbiBjb3VsZCBub3QgYmUgY29udmVydGVkIHRvIERPTS4KICAgICAqIEByZXR1cm5zIHtOb2RlfSBwb3NpdGlvbi5wYXJlbnQgRE9NIHBvc2l0aW9uIHBhcmVudC4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBvc2l0aW9uLm9mZnNldCBET00gcG9zaXRpb24gb2Zmc2V0LgogICAgICovCgogIH0sIHsKICAgIGtleTogInZpZXdQb3NpdGlvblRvRG9tIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3UG9zaXRpb25Ub0RvbSh2aWV3UG9zaXRpb24pIHsKICAgICAgdmFyIHZpZXdQYXJlbnQgPSB2aWV3UG9zaXRpb24ucGFyZW50OwoKICAgICAgaWYgKHZpZXdQYXJlbnQuaXMoJyR0ZXh0JykpIHsKICAgICAgICB2YXIgZG9tUGFyZW50ID0gdGhpcy5maW5kQ29ycmVzcG9uZGluZ0RvbVRleHQodmlld1BhcmVudCk7CgogICAgICAgIGlmICghZG9tUGFyZW50KSB7CiAgICAgICAgICAvLyBQb3NpdGlvbiBpcyBpbiBhIHZpZXcgdGV4dCBub2RlIHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIHRvIERPTSB5ZXQuCiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CgogICAgICAgIHZhciBvZmZzZXQgPSB2aWV3UG9zaXRpb24ub2Zmc2V0OwoKICAgICAgICBpZiAoc3RhcnRzV2l0aEZpbGxlcihkb21QYXJlbnQpKSB7CiAgICAgICAgICBvZmZzZXQgKz0gSU5MSU5FX0ZJTExFUl9MRU5HVEg7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gewogICAgICAgICAgcGFyZW50OiBkb21QYXJlbnQsCiAgICAgICAgICBvZmZzZXQ6IG9mZnNldAogICAgICAgIH07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gdmlld1BhcmVudCBpcyBpbnN0YW5jZSBvZiBWaWV3RWxlbWVudC4KICAgICAgICB2YXIgX2RvbVBhcmVudCwgZG9tQmVmb3JlLCBkb21BZnRlcjsKCiAgICAgICAgaWYgKHZpZXdQb3NpdGlvbi5vZmZzZXQgPT09IDApIHsKICAgICAgICAgIF9kb21QYXJlbnQgPSB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3UGFyZW50KTsKCiAgICAgICAgICBpZiAoIV9kb21QYXJlbnQpIHsKICAgICAgICAgICAgLy8gUG9zaXRpb24gaXMgaW4gYSB2aWV3IGVsZW1lbnQgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQgdG8gRE9NIHlldC4KICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CgogICAgICAgICAgZG9tQWZ0ZXIgPSBfZG9tUGFyZW50LmNoaWxkTm9kZXNbMF07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBub2RlQmVmb3JlID0gdmlld1Bvc2l0aW9uLm5vZGVCZWZvcmU7CiAgICAgICAgICBkb21CZWZvcmUgPSBub2RlQmVmb3JlLmlzKCckdGV4dCcpID8gdGhpcy5maW5kQ29ycmVzcG9uZGluZ0RvbVRleHQobm9kZUJlZm9yZSkgOiB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3UG9zaXRpb24ubm9kZUJlZm9yZSk7CgogICAgICAgICAgaWYgKCFkb21CZWZvcmUpIHsKICAgICAgICAgICAgLy8gUG9zaXRpb24gaXMgYWZ0ZXIgYSB2aWV3IGVsZW1lbnQgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQgdG8gRE9NIHlldC4KICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CgogICAgICAgICAgX2RvbVBhcmVudCA9IGRvbUJlZm9yZS5wYXJlbnROb2RlOwogICAgICAgICAgZG9tQWZ0ZXIgPSBkb21CZWZvcmUubmV4dFNpYmxpbmc7CiAgICAgICAgfSAvLyBJZiB0aGVyZSBpcyBhbiBpbmxpbmUgZmlsbGVyIGF0IHBvc2l0aW9uIHJldHVybiBwb3NpdGlvbiBpbnNpZGUgdGhlIGZpbGxlci4gV2Ugc2hvdWxkIG5ldmVyIHJldHVybgogICAgICAgIC8vIHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIGlubGluZSBmaWxsZXIuCgoKICAgICAgICBpZiAoaXNUZXh0KGRvbUFmdGVyKSAmJiBzdGFydHNXaXRoRmlsbGVyKGRvbUFmdGVyKSkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgcGFyZW50OiBkb21BZnRlciwKICAgICAgICAgICAgb2Zmc2V0OiBJTkxJTkVfRklMTEVSX0xFTkdUSAogICAgICAgICAgfTsKICAgICAgICB9CgogICAgICAgIHZhciBfb2Zmc2V0ID0gZG9tQmVmb3JlID8gaW5kZXhPZihkb21CZWZvcmUpICsgMSA6IDA7CgogICAgICAgIHJldHVybiB7CiAgICAgICAgICBwYXJlbnQ6IF9kb21QYXJlbnQsCiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQKICAgICAgICB9OwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIERPTSB0byB2aWV3LiBGb3IgYWxsIHRleHQgbm9kZXMsIG5vdCBib3VuZCBlbGVtZW50cyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIG5ldyBpdGVtcyB3aWxsCiAgICAgKiBiZSBjcmVhdGVkLiBGb3IgYm91bmQgZWxlbWVudHMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyBmdW5jdGlvbiB3aWxsIHJldHVybiBjb3JyZXNwb25kaW5nIGl0ZW1zLiBGb3IKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcnN9IGBudWxsYCB3aWxsIGJlIHJldHVybmVkLgogICAgICogRm9yIGFsbCBET00gZWxlbWVudHMgcmVuZGVyZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fSB0aGF0IFVJRWxlbWVudCB3aWxsIGJlIHJldHVybmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7Tm9kZXxEb2N1bWVudEZyYWdtZW50fSBkb21Ob2RlIERPTSBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50IHRvIHRyYW5zZm9ybS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5kPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgbmV3IGVsZW1lbnRzIHdpbGwgYmUgYm91bmQuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhDaGlsZHJlbj10cnVlXSBJZiBgdHJ1ZWAsIG5vZGUncyBhbmQgZG9jdW1lbnQgZnJhZ21lbnQncyBjaGlsZHJlbiB3aWxsIGJlIGNvbnZlcnRlZCB0b28uCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmtlZXBPcmlnaW5hbENhc2U9ZmFsc2VdIElmIGBmYWxzZWAsIG5vZGUncyB0YWcgbmFtZSB3aWxsIGJlIGNvbnZlcnRlciB0byBsb3dlciBjYXNlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxudWxsfSBDb252ZXJ0ZWQgbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudAogICAgICogb3IgYG51bGxgIGlmIERPTSBub2RlIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyfSBvciB0aGUgZ2l2ZW4gbm9kZSBpcyBhbiBlbXB0eSB0ZXh0IG5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZG9tVG9WaWV3IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBkb21Ub1ZpZXcoZG9tTm9kZSkgewogICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307CgogICAgICBpZiAodGhpcy5pc0Jsb2NrRmlsbGVyKGRvbU5vZGUpKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0gLy8gV2hlbiBub2RlIGlzIGluc2lkZSBhIFVJRWxlbWVudCBvciBhIFJhd0VsZW1lbnQgcmV0dXJuIHRoYXQgcGFyZW50IGFzIGl0J3MgdmlldyByZXByZXNlbnRhdGlvbi4KCgogICAgICB2YXIgaG9zdEVsZW1lbnQgPSB0aGlzLmdldEhvc3RWaWV3RWxlbWVudChkb21Ob2RlKTsKCiAgICAgIGlmIChob3N0RWxlbWVudCkgewogICAgICAgIHJldHVybiBob3N0RWxlbWVudDsKICAgICAgfQoKICAgICAgaWYgKGlzVGV4dChkb21Ob2RlKSkgewogICAgICAgIGlmIChpc0lubGluZUZpbGxlcihkb21Ob2RlKSkgewogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciB0ZXh0RGF0YSA9IHRoaXMuX3Byb2Nlc3NEYXRhRnJvbURvbVRleHQoZG9tTm9kZSk7CgogICAgICAgICAgcmV0dXJuIHRleHREYXRhID09PSAnJyA/IG51bGwgOiBuZXcgVmlld1RleHQodGhpcy5kb2N1bWVudCwgdGV4dERhdGEpOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQ29tbWVudChkb21Ob2RlKSkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9IGVsc2UgewogICAgICAgIGlmICh0aGlzLm1hcERvbVRvVmlldyhkb21Ob2RlKSkgewogICAgICAgICAgcmV0dXJuIHRoaXMubWFwRG9tVG9WaWV3KGRvbU5vZGUpOwogICAgICAgIH0KCiAgICAgICAgdmFyIHZpZXdFbGVtZW50OwoKICAgICAgICBpZiAodGhpcy5pc0RvY3VtZW50RnJhZ21lbnQoZG9tTm9kZSkpIHsKICAgICAgICAgIC8vIENyZWF0ZSB2aWV3IGRvY3VtZW50IGZyYWdtZW50LgogICAgICAgICAgdmlld0VsZW1lbnQgPSBuZXcgVmlld0RvY3VtZW50RnJhZ21lbnQodGhpcy5kb2N1bWVudCk7CgogICAgICAgICAgaWYgKG9wdGlvbnMuYmluZCkgewogICAgICAgICAgICB0aGlzLmJpbmREb2N1bWVudEZyYWdtZW50cyhkb21Ob2RlLCB2aWV3RWxlbWVudCk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIENyZWF0ZSB2aWV3IGVsZW1lbnQuCiAgICAgICAgICB2YXIgdmlld05hbWUgPSBvcHRpb25zLmtlZXBPcmlnaW5hbENhc2UgPyBkb21Ob2RlLnRhZ05hbWUgOiBkb21Ob2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTsKICAgICAgICAgIHZpZXdFbGVtZW50ID0gbmV3IFZpZXdFbGVtZW50KHRoaXMuZG9jdW1lbnQsIHZpZXdOYW1lKTsKCiAgICAgICAgICBpZiAob3B0aW9ucy5iaW5kKSB7CiAgICAgICAgICAgIHRoaXMuYmluZEVsZW1lbnRzKGRvbU5vZGUsIHZpZXdFbGVtZW50KTsKICAgICAgICAgIH0gLy8gQ29weSBlbGVtZW50J3MgYXR0cmlidXRlcy4KCgogICAgICAgICAgdmFyIGF0dHJzID0gZG9tTm9kZS5hdHRyaWJ1dGVzOwoKICAgICAgICAgIGZvciAodmFyIGkgPSBhdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgICB2aWV3RWxlbWVudC5fc2V0QXR0cmlidXRlKGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldLnZhbHVlKTsKICAgICAgICAgIH0gLy8gVHJlYXQgdGhpcyBlbGVtZW50J3MgY29udGVudCBhcyBhIHJhdyBkYXRhIGlmIGl0IHdhcyByZWdpc3RlcmVkIGFzIHN1Y2guCgoKICAgICAgICAgIGlmIChvcHRpb25zLndpdGhDaGlsZHJlbiAhPT0gZmFsc2UgJiYgdGhpcy5fcmF3Q29udGVudEVsZW1lbnRNYXRjaGVyLm1hdGNoKHZpZXdFbGVtZW50KSkgewogICAgICAgICAgICB2aWV3RWxlbWVudC5fc2V0Q3VzdG9tUHJvcGVydHkoJyRyYXdDb250ZW50JywgZG9tTm9kZS5pbm5lckhUTUwpOyAvLyBTdG9yZSBhIERPTSBub2RlIHRvIHByZXZlbnQgbGVmdCB0cmltbWluZyBvZiB0aGUgZm9sbG93aW5nIHRleHQgbm9kZS4KCgogICAgICAgICAgICB0aGlzLl9lbmNvdW50ZXJlZFJhd0NvbnRlbnREb21Ob2Rlcy5hZGQoZG9tTm9kZSk7CgogICAgICAgICAgICByZXR1cm4gdmlld0VsZW1lbnQ7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAob3B0aW9ucy53aXRoQ2hpbGRyZW4gIT09IGZhbHNlKSB7CiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZG9tQ2hpbGRyZW5Ub1ZpZXcoZG9tTm9kZSwgb3B0aW9ucykpLAogICAgICAgICAgICAgIF9zdGVwNTsKCiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykgewogICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwNS52YWx1ZTsKCiAgICAgICAgICAgICAgdmlld0VsZW1lbnQuX2FwcGVuZENoaWxkKGNoaWxkKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgX2l0ZXJhdG9yNS5mKCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdmlld0VsZW1lbnQ7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgY2hpbGRyZW4gb2YgdGhlIERPTSBlbGVtZW50IHRvIHZpZXcgbm9kZXMgdXNpbmcKICAgICAqIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjZG9tVG9WaWV3fSBtZXRob2QuCiAgICAgKiBBZGRpdGlvbmFsbHkgdGhpcyBtZXRob2Qgb21pdHMgYmxvY2sge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyfSwgaWYgaXQgZXhpc3RzIGluIHRoZSBET00gcGFyZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbUVsZW1lbnQgUGFyZW50IERPTSBlbGVtZW50LgogICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNkb21Ub1ZpZXd9IG9wdGlvbnMgcGFyYW1ldGVyLgogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlPn0gVmlldyBub2Rlcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJkb21DaGlsZHJlblRvVmlldyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGRvbUNoaWxkcmVuVG9WaWV3KGRvbUVsZW1lbnQpIHsKICAgICAgdmFyIG9wdGlvbnMsCiAgICAgICAgICBpLAogICAgICAgICAgZG9tQ2hpbGQsCiAgICAgICAgICB2aWV3Q2hpbGQsCiAgICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7CiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBkb21DaGlsZHJlblRvVmlldyQoX2NvbnRleHQyKSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzMi5sZW5ndGggPiAxICYmIF9hcmdzMlsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzFdIDoge307CiAgICAgICAgICAgICAgaSA9IDA7CgogICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgaWYgKCEoaSA8IGRvbUVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGgpKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBkb21DaGlsZCA9IGRvbUVsZW1lbnQuY2hpbGROb2Rlc1tpXTsKICAgICAgICAgICAgICB2aWV3Q2hpbGQgPSB0aGlzLmRvbVRvVmlldyhkb21DaGlsZCwgb3B0aW9ucyk7CgogICAgICAgICAgICAgIGlmICghKHZpZXdDaGlsZCAhPT0gbnVsbCkpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4OwogICAgICAgICAgICAgIHJldHVybiB2aWV3Q2hpbGQ7CgogICAgICAgICAgICBjYXNlIDg6CiAgICAgICAgICAgICAgaSsrOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCBkb21DaGlsZHJlblRvVmlldywgdGhpcyk7CiAgICB9KQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBET00gc2VsZWN0aW9uIHRvIHZpZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufS4KICAgICAqIFJhbmdlcyB3aGljaCBjYW5ub3QgYmUgY29udmVydGVkIHdpbGwgYmUgb21pdHRlZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gZG9tU2VsZWN0aW9uIERPTSBzZWxlY3Rpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3NlbGVjdGlvbn5TZWxlY3Rpb259IFZpZXcgc2VsZWN0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogImRvbVNlbGVjdGlvblRvVmlldyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZG9tU2VsZWN0aW9uVG9WaWV3KGRvbVNlbGVjdGlvbikgewogICAgICAvLyBET00gc2VsZWN0aW9uIG1pZ2h0IGJlIHBsYWNlZCBpbiBmYWtlIHNlbGVjdGlvbiBjb250YWluZXIuCiAgICAgIC8vIElmIGNvbnRhaW5lciBjb250YWlucyBmYWtlIHNlbGVjdGlvbiAtIHJldHVybiBjb3JyZXNwb25kaW5nIHZpZXcgc2VsZWN0aW9uLgogICAgICBpZiAoZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEpIHsKICAgICAgICB2YXIgY29udGFpbmVyID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuc3RhcnRDb250YWluZXI7IC8vIFRoZSBET00gc2VsZWN0aW9uIG1pZ2h0IGJlIG1vdmVkIHRvIHRoZSB0ZXh0IG5vZGUgaW5zaWRlIHRoZSBmYWtlIHNlbGVjdGlvbiBjb250YWluZXIuCgogICAgICAgIGlmIChpc1RleHQoY29udGFpbmVyKSkgewogICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7CiAgICAgICAgfQoKICAgICAgICB2YXIgdmlld1NlbGVjdGlvbiA9IHRoaXMuZmFrZVNlbGVjdGlvblRvVmlldyhjb250YWluZXIpOwoKICAgICAgICBpZiAodmlld1NlbGVjdGlvbikgewogICAgICAgICAgcmV0dXJuIHZpZXdTZWxlY3Rpb247CiAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgaXNCYWNrd2FyZCA9IHRoaXMuaXNEb21TZWxlY3Rpb25CYWNrd2FyZChkb21TZWxlY3Rpb24pOwogICAgICB2YXIgdmlld1JhbmdlcyA9IFtdOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSsrKSB7CiAgICAgICAgLy8gRE9NIFJhbmdlIGhhdmUgY29ycmVjdCBzdGFydCBhbmQgZW5kLCBubyBtYXR0ZXIgd2hhdCBpcyB0aGUgRE9NIFNlbGVjdGlvbiBkaXJlY3Rpb24uIFNvIHdlIGRvbid0IGhhdmUgdG8gZml4IGFueXRoaW5nLgogICAgICAgIHZhciBkb21SYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpOwogICAgICAgIHZhciB2aWV3UmFuZ2UgPSB0aGlzLmRvbVJhbmdlVG9WaWV3KGRvbVJhbmdlKTsKCiAgICAgICAgaWYgKHZpZXdSYW5nZSkgewogICAgICAgICAgdmlld1Jhbmdlcy5wdXNoKHZpZXdSYW5nZSk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gbmV3IFZpZXdTZWxlY3Rpb24odmlld1JhbmdlcywgewogICAgICAgIGJhY2t3YXJkOiBpc0JhY2t3YXJkCiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBET00gUmFuZ2UgdG8gdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfS4KICAgICAqIElmIHRoZSBzdGFydCBvciBlbmQgcG9zaXRpb24gY2FuIG5vdCBiZSBjb252ZXJ0ZWQgYG51bGxgIGlzIHJldHVybmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7UmFuZ2V9IGRvbVJhbmdlIERPTSByYW5nZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V8bnVsbH0gVmlldyByYW5nZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJkb21SYW5nZVRvVmlldyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZG9tUmFuZ2VUb1ZpZXcoZG9tUmFuZ2UpIHsKICAgICAgdmFyIHZpZXdTdGFydCA9IHRoaXMuZG9tUG9zaXRpb25Ub1ZpZXcoZG9tUmFuZ2Uuc3RhcnRDb250YWluZXIsIGRvbVJhbmdlLnN0YXJ0T2Zmc2V0KTsKICAgICAgdmFyIHZpZXdFbmQgPSB0aGlzLmRvbVBvc2l0aW9uVG9WaWV3KGRvbVJhbmdlLmVuZENvbnRhaW5lciwgZG9tUmFuZ2UuZW5kT2Zmc2V0KTsKCiAgICAgIGlmICh2aWV3U3RhcnQgJiYgdmlld0VuZCkgewogICAgICAgIHJldHVybiBuZXcgVmlld1JhbmdlKHZpZXdTdGFydCwgdmlld0VuZCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBET00gcGFyZW50IGFuZCBvZmZzZXQgdG8gdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufS4KICAgICAqCiAgICAgKiBJZiB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyfSB3aGljaCBoYXMgbm8gY29ycmVzcG9uZGluZyB2aWV3IG5vZGUsCiAgICAgKiBwb3NpdGlvbiBvZiB0aGUgZmlsbGVyIHdpbGwgYmUgY29udmVydGVkIGFuZCByZXR1cm5lZC4KICAgICAqCiAgICAgKiBJZiB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIERPTSBlbGVtZW50IHJlbmRlcmVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0KICAgICAqIHRoYXQgcG9zaXRpb24gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdmlldyBwb3NpdGlvbiBiZWZvcmUgdGhhdCBVSUVsZW1lbnQuCiAgICAgKgogICAgICogSWYgc3RydWN0dXJlcyBhcmUgdG9vIGRpZmZlcmVudCBhbmQgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGZpbmQgY29ycmVzcG9uZGluZyBwb3NpdGlvbiB0aGVuIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7Tm9kZX0gZG9tUGFyZW50IERPTSBwb3NpdGlvbiBwYXJlbnQuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gZG9tT2Zmc2V0IERPTSBwb3NpdGlvbiBvZmZzZXQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSB2aWV3UG9zaXRpb24gVmlldyBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJkb21Qb3NpdGlvblRvVmlldyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZG9tUG9zaXRpb25Ub1ZpZXcoZG9tUGFyZW50LCBkb21PZmZzZXQpIHsKICAgICAgaWYgKHRoaXMuaXNCbG9ja0ZpbGxlcihkb21QYXJlbnQpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZG9tUG9zaXRpb25Ub1ZpZXcoZG9tUGFyZW50LnBhcmVudE5vZGUsIGluZGV4T2YoZG9tUGFyZW50KSk7CiAgICAgIH0gLy8gSWYgcG9zaXRpb24gaXMgc29tZXdoZXJlIGluc2lkZSBVSUVsZW1lbnQgb3IgYSBSYXdFbGVtZW50IC0gcmV0dXJuIHBvc2l0aW9uIGJlZm9yZSB0aGF0IGVsZW1lbnQuCgoKICAgICAgdmFyIHZpZXdFbGVtZW50ID0gdGhpcy5tYXBEb21Ub1ZpZXcoZG9tUGFyZW50KTsKCiAgICAgIGlmICh2aWV3RWxlbWVudCAmJiAodmlld0VsZW1lbnQuaXMoJ3VpRWxlbWVudCcpIHx8IHZpZXdFbGVtZW50LmlzKCdyYXdFbGVtZW50JykpKSB7CiAgICAgICAgcmV0dXJuIFZpZXdQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKHZpZXdFbGVtZW50KTsKICAgICAgfQoKICAgICAgaWYgKGlzVGV4dChkb21QYXJlbnQpKSB7CiAgICAgICAgaWYgKGlzSW5saW5lRmlsbGVyKGRvbVBhcmVudCkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmRvbVBvc2l0aW9uVG9WaWV3KGRvbVBhcmVudC5wYXJlbnROb2RlLCBpbmRleE9mKGRvbVBhcmVudCkpOwogICAgICAgIH0KCiAgICAgICAgdmFyIHZpZXdQYXJlbnQgPSB0aGlzLmZpbmRDb3JyZXNwb25kaW5nVmlld1RleHQoZG9tUGFyZW50KTsKICAgICAgICB2YXIgb2Zmc2V0ID0gZG9tT2Zmc2V0OwoKICAgICAgICBpZiAoIXZpZXdQYXJlbnQpIHsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgaWYgKHN0YXJ0c1dpdGhGaWxsZXIoZG9tUGFyZW50KSkgewogICAgICAgICAgb2Zmc2V0IC09IElOTElORV9GSUxMRVJfTEVOR1RIOwogICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQ7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbmV3IFZpZXdQb3NpdGlvbih2aWV3UGFyZW50LCBvZmZzZXQpOwogICAgICB9IC8vIGRvbVBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50LgogICAgICBlbHNlIHsKICAgICAgICAgIGlmIChkb21PZmZzZXQgPT09IDApIHsKICAgICAgICAgICAgdmFyIF92aWV3UGFyZW50ID0gdGhpcy5tYXBEb21Ub1ZpZXcoZG9tUGFyZW50KTsKCiAgICAgICAgICAgIGlmIChfdmlld1BhcmVudCkgewogICAgICAgICAgICAgIHJldHVybiBuZXcgVmlld1Bvc2l0aW9uKF92aWV3UGFyZW50LCAwKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGRvbUJlZm9yZSA9IGRvbVBhcmVudC5jaGlsZE5vZGVzW2RvbU9mZnNldCAtIDFdOwogICAgICAgICAgICB2YXIgdmlld0JlZm9yZSA9IGlzVGV4dChkb21CZWZvcmUpID8gdGhpcy5maW5kQ29ycmVzcG9uZGluZ1ZpZXdUZXh0KGRvbUJlZm9yZSkgOiB0aGlzLm1hcERvbVRvVmlldyhkb21CZWZvcmUpOyAvLyBUT0RPICM2NjMKCiAgICAgICAgICAgIGlmICh2aWV3QmVmb3JlICYmIHZpZXdCZWZvcmUucGFyZW50KSB7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3UG9zaXRpb24odmlld0JlZm9yZS5wYXJlbnQsIHZpZXdCZWZvcmUuaW5kZXggKyAxKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBjb3JyZXNwb25kaW5nIHZpZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgRWxlbWVudH0gb3IKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBmb3IgcHJvdmlkZWQgRE9NIGVsZW1lbnQgb3IKICAgICAqIGRvY3VtZW50IGZyYWdtZW50LiBJZiB0aGVyZSBpcyBubyB2aWV3IGl0ZW0ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBib3VuZH0KICAgICAqIHRvIHRoZSBnaXZlbiBET00gLSBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC4KICAgICAqCiAgICAgKiBGb3IgYWxsIERPTSBlbGVtZW50cyByZW5kZXJlZCBieSBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0gb3IKICAgICAqIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYXdlbGVtZW50flJhd0VsZW1lbnR9LCB0aGUgcGFyZW50IGBVSUVsZW1lbnRgIG9yIGBSYXdFbGVtZW50YCB3aWxsIGJlIHJldHVybmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudHxFbGVtZW50fSBkb21FbGVtZW50T3JEb2N1bWVudEZyYWdtZW50IERPTSBlbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9CiAgICAgKiBDb3JyZXNwb25kaW5nIHZpZXcgZWxlbWVudCwgZG9jdW1lbnQgZnJhZ21lbnQgb3IgYHVuZGVmaW5lZGAgaWYgbm8gZWxlbWVudCB3YXMgYm91bmQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibWFwRG9tVG9WaWV3IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBEb21Ub1ZpZXcoZG9tRWxlbWVudE9yRG9jdW1lbnRGcmFnbWVudCkgewogICAgICB2YXIgaG9zdEVsZW1lbnQgPSB0aGlzLmdldEhvc3RWaWV3RWxlbWVudChkb21FbGVtZW50T3JEb2N1bWVudEZyYWdtZW50KTsKICAgICAgcmV0dXJuIGhvc3RFbGVtZW50IHx8IHRoaXMuX2RvbVRvVmlld01hcHBpbmcuZ2V0KGRvbUVsZW1lbnRPckRvY3VtZW50RnJhZ21lbnQpOwogICAgfQogICAgLyoqCiAgICAgKiBGaW5kcyBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4gVGV4dCBub2RlcyBhcmUgbm90IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNiaW5kRWxlbWVudHMgYm91bmR9LAogICAgICogY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUgaXMgcmV0dXJuZWQgYmFzZWQgb24gdGhlIHNpYmxpbmcgb3IgcGFyZW50LgogICAgICoKICAgICAqIElmIHRoZSBkaXJlY3RseSBwcmV2aW91cyBzaWJsaW5nIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBib3VuZH0gZWxlbWVudCwgaXQgaXMgdXNlZAogICAgICogdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCiAgICAgKgogICAgICogSWYgdGhpcyBpcyBhIGZpcnN0IGNoaWxkIGluIHRoZSBwYXJlbnQgYW5kIHRoZSBwYXJlbnQgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmluZEVsZW1lbnRzIGJvdW5kfQogICAgICogZWxlbWVudCwgaXQgaXMgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4KICAgICAqCiAgICAgKiBGb3IgYWxsIHRleHQgbm9kZXMgcmVuZGVyZWQgYnkgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR9IG9yCiAgICAgKiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmF3ZWxlbWVudH5SYXdFbGVtZW50fSwgdGhlIHBhcmVudCBgVUlFbGVtZW50YCBvciBgUmF3RWxlbWVudGAgd2lsbCBiZSByZXR1cm5lZC4KICAgICAqCiAgICAgKiBPdGhlcndpc2UgYG51bGxgIGlzIHJldHVybmVkLgogICAgICoKICAgICAqIE5vdGUgdGhhdCBmb3IgdGhlIGJsb2NrIG9yIGlubGluZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2ZpbGxlciBmaWxsZXJ9IHRoaXMgbWV0aG9kIHJldHVybnMgYG51bGxgLgogICAgICoKICAgICAqIEBwYXJhbSB7VGV4dH0gZG9tVGV4dCBET00gdGV4dCBub2RlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR8bnVsbH0gQ29ycmVzcG9uZGluZyB2aWV3IHRleHQgbm9kZSBvciBgbnVsbGAsIGlmIGl0IHdhcyBub3QgcG9zc2libGUgdG8gZmluZCBhCiAgICAgKiBjb3JyZXNwb25kaW5nIG5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZmluZENvcnJlc3BvbmRpbmdWaWV3VGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZENvcnJlc3BvbmRpbmdWaWV3VGV4dChkb21UZXh0KSB7CiAgICAgIGlmIChpc0lubGluZUZpbGxlcihkb21UZXh0KSkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9IC8vIElmIERPTSB0ZXh0IHdhcyByZW5kZXJlZCBieSBhIFVJRWxlbWVudCBvciBhIFJhd0VsZW1lbnQgLSByZXR1cm4gdGhpcyBwYXJlbnQgZWxlbWVudC4KCgogICAgICB2YXIgaG9zdEVsZW1lbnQgPSB0aGlzLmdldEhvc3RWaWV3RWxlbWVudChkb21UZXh0KTsKCiAgICAgIGlmIChob3N0RWxlbWVudCkgewogICAgICAgIHJldHVybiBob3N0RWxlbWVudDsKICAgICAgfQoKICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IGRvbVRleHQucHJldmlvdXNTaWJsaW5nOyAvLyBUcnkgdG8gdXNlIHByZXZpb3VzIHNpYmxpbmcgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCgogICAgICBpZiAocHJldmlvdXNTaWJsaW5nKSB7CiAgICAgICAgaWYgKCF0aGlzLmlzRWxlbWVudChwcmV2aW91c1NpYmxpbmcpKSB7CiAgICAgICAgICAvLyBUaGUgcHJldmlvdXMgaXMgdGV4dCBvciBjb21tZW50LgogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQoKICAgICAgICB2YXIgdmlld0VsZW1lbnQgPSB0aGlzLm1hcERvbVRvVmlldyhwcmV2aW91c1NpYmxpbmcpOwoKICAgICAgICBpZiAodmlld0VsZW1lbnQpIHsKICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IHZpZXdFbGVtZW50Lm5leHRTaWJsaW5nOyAvLyBJdCBtaWdodCBiZSBmaWxsZXIgd2hpY2ggaGFzIG5vIGNvcnJlc3BvbmRpbmcgdmlldyBub2RlLgoKICAgICAgICAgIGlmIChuZXh0U2libGluZyBpbnN0YW5jZW9mIFZpZXdUZXh0KSB7CiAgICAgICAgICAgIHJldHVybiB2aWV3RWxlbWVudC5uZXh0U2libGluZzsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyBUcnkgdG8gdXNlIHBhcmVudCB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4KICAgICAgZWxzZSB7CiAgICAgICAgICB2YXIgX3ZpZXdFbGVtZW50ID0gdGhpcy5tYXBEb21Ub1ZpZXcoZG9tVGV4dC5wYXJlbnROb2RlKTsKCiAgICAgICAgICBpZiAoX3ZpZXdFbGVtZW50KSB7CiAgICAgICAgICAgIHZhciBmaXJzdENoaWxkID0gX3ZpZXdFbGVtZW50LmdldENoaWxkKDApOyAvLyBJdCBtaWdodCBiZSBmaWxsZXIgd2hpY2ggaGFzIG5vIGNvcnJlc3BvbmRpbmcgdmlldyBub2RlLgoKCiAgICAgICAgICAgIGlmIChmaXJzdENoaWxkIGluc3RhbmNlb2YgVmlld1RleHQpIHsKICAgICAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZDsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgRE9NIGl0ZW0gZm9yIHByb3ZpZGVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IEVsZW1lbnR9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBEb2N1bWVudEZyYWdtZW50fS4KICAgICAqIFRvIGZpbmQgYSBjb3JyZXNwb25kaW5nIHRleHQgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHZpZXcgVGV4dCBpbnN0YW5jZX0KICAgICAqIHVzZSB7QGxpbmsgI2ZpbmRDb3JyZXNwb25kaW5nRG9tVGV4dH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHZpZXdOb2RlCiAgICAgKiBWaWV3IGVsZW1lbnQgb3IgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgKiBAcmV0dXJucyB7Tm9kZXxEb2N1bWVudEZyYWdtZW50fHVuZGVmaW5lZH0gQ29ycmVzcG9uZGluZyBET00gbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJtYXBWaWV3VG9Eb20iLAogICAgdmFsdWU6IGZ1bmN0aW9uIG1hcFZpZXdUb0RvbShkb2N1bWVudEZyYWdtZW50T3JFbGVtZW50KSB7CiAgICAgIHJldHVybiB0aGlzLl92aWV3VG9Eb21NYXBwaW5nLmdldChkb2N1bWVudEZyYWdtZW50T3JFbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogRmluZHMgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuIFRleHQgbm9kZXMgYXJlIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmluZEVsZW1lbnRzIGJvdW5kfSwKICAgICAqIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlIGlzIHJldHVybmVkIGJhc2VkIG9uIHRoZSBzaWJsaW5nIG9yIHBhcmVudC4KICAgICAqCiAgICAgKiBJZiB0aGUgZGlyZWN0bHkgcHJldmlvdXMgc2libGluZyBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNiaW5kRWxlbWVudHMgYm91bmR9IGVsZW1lbnQsIGl0IGlzIHVzZWQKICAgICAqIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLgogICAgICoKICAgICAqIElmIHRoaXMgaXMgYSBmaXJzdCBjaGlsZCBpbiB0aGUgcGFyZW50IGFuZCB0aGUgcGFyZW50IGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBib3VuZH0KICAgICAqIGVsZW1lbnQsIGl0IGlzIHVzZWQgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCiAgICAgKgogICAgICogT3RoZXJ3aXNlIGBudWxsYCBpcyByZXR1cm5lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IHZpZXdUZXh0IFZpZXcgdGV4dCBub2RlLgogICAgICogQHJldHVybnMge1RleHR8bnVsbH0gQ29ycmVzcG9uZGluZyBET00gdGV4dCBub2RlIG9yIGBudWxsYCwgaWYgaXQgd2FzIG5vdCBwb3NzaWJsZSB0byBmaW5kIGEgY29ycmVzcG9uZGluZyBub2RlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImZpbmRDb3JyZXNwb25kaW5nRG9tVGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZENvcnJlc3BvbmRpbmdEb21UZXh0KHZpZXdUZXh0KSB7CiAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSB2aWV3VGV4dC5wcmV2aW91c1NpYmxpbmc7IC8vIFRyeSB0byB1c2UgcHJldmlvdXMgc2libGluZyB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4KCiAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgdGhpcy5tYXBWaWV3VG9Eb20ocHJldmlvdXNTaWJsaW5nKSkgewogICAgICAgIHJldHVybiB0aGlzLm1hcFZpZXdUb0RvbShwcmV2aW91c1NpYmxpbmcpLm5leHRTaWJsaW5nOwogICAgICB9IC8vIElmIHRoaXMgaXMgYSBmaXJzdCBub2RlLCB0cnkgdG8gdXNlIHBhcmVudCB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4KCgogICAgICBpZiAoIXByZXZpb3VzU2libGluZyAmJiB2aWV3VGV4dC5wYXJlbnQgJiYgdGhpcy5tYXBWaWV3VG9Eb20odmlld1RleHQucGFyZW50KSkgewogICAgICAgIHJldHVybiB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3VGV4dC5wYXJlbnQpLmNoaWxkTm9kZXNbMF07CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBGb2N1c2VzIERPTSBlZGl0YWJsZSB0aGF0IGlzIGNvcnJlc3BvbmRpbmcgdG8gcHJvdmlkZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lZGl0YWJsZWVsZW1lbnR+RWRpdGFibGVFbGVtZW50fS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lZGl0YWJsZWVsZW1lbnR+RWRpdGFibGVFbGVtZW50fSB2aWV3RWRpdGFibGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmb2N1cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXModmlld0VkaXRhYmxlKSB7CiAgICAgIHZhciBkb21FZGl0YWJsZSA9IHRoaXMubWFwVmlld1RvRG9tKHZpZXdFZGl0YWJsZSk7CgogICAgICBpZiAoZG9tRWRpdGFibGUgJiYgZG9tRWRpdGFibGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBkb21FZGl0YWJsZSkgewogICAgICAgIC8vIFNhdmUgdGhlIHNjcm9sbFggYW5kIHNjcm9sbFkgcG9zaXRpb25zIGJlZm9yZSB0aGUgZm9jdXMuCiAgICAgICAgdmFyIF9nbG9iYWwkd2luZG93ID0gZ2xvYmFsLndpbmRvdywKICAgICAgICAgICAgc2Nyb2xsWCA9IF9nbG9iYWwkd2luZG93LnNjcm9sbFgsCiAgICAgICAgICAgIHNjcm9sbFkgPSBfZ2xvYmFsJHdpbmRvdy5zY3JvbGxZOwogICAgICAgIHZhciBzY3JvbGxQb3NpdGlvbnMgPSBbXTsgLy8gU2F2ZSBhbGwgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIHZhbHVlcyBzdGFydGluZyBmcm9tIGRvbUVkaXRhYmxlIHVwIHRvCiAgICAgICAgLy8gZG9jdW1lbnQjZG9jdW1lbnRFbGVtZW50LgoKICAgICAgICBmb3JFYWNoRG9tTm9kZUFuY2VzdG9yKGRvbUVkaXRhYmxlLCBmdW5jdGlvbiAobm9kZSkgewogICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBub2RlLnNjcm9sbExlZnQsCiAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gbm9kZS5zY3JvbGxUb3A7CiAgICAgICAgICBzY3JvbGxQb3NpdGlvbnMucHVzaChbc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wXSk7CiAgICAgICAgfSk7CiAgICAgICAgZG9tRWRpdGFibGUuZm9jdXMoKTsgLy8gUmVzdG9yZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgdmFsdWVzIHN0YXJ0aW5nIGZyb20gZG9tRWRpdGFibGUgdXAgdG8KICAgICAgICAvLyBkb2N1bWVudCNkb2N1bWVudEVsZW1lbnQuCiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzk1MQogICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy85NTcKCiAgICAgICAgZm9yRWFjaERvbU5vZGVBbmNlc3Rvcihkb21FZGl0YWJsZSwgZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIHZhciBfc2Nyb2xsUG9zaXRpb25zJHNoaWYgPSBzY3JvbGxQb3NpdGlvbnMuc2hpZnQoKSwKICAgICAgICAgICAgICBfc2Nyb2xsUG9zaXRpb25zJHNoaWYyID0gX3NsaWNlZFRvQXJyYXkoX3Njcm9sbFBvc2l0aW9ucyRzaGlmLCAyKSwKICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gX3Njcm9sbFBvc2l0aW9ucyRzaGlmMlswXSwKICAgICAgICAgICAgICBzY3JvbGxUb3AgPSBfc2Nyb2xsUG9zaXRpb25zJHNoaWYyWzFdOwoKICAgICAgICAgIG5vZGUuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7CiAgICAgICAgICBub2RlLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDsKICAgICAgICB9KTsgLy8gUmVzdG9yZSB0aGUgc2Nyb2xsWCBhbmQgc2Nyb2xsWSBwb3NpdGlvbnMgYWZ0ZXIgdGhlIGZvY3VzLgogICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy85NTEKCiAgICAgICAgZ2xvYmFsLndpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGB0cnVlYCB3aGVuIGBub2RlLm5vZGVUeXBlYCBlcXVhbHMgYE5vZGUuRUxFTUVOVF9OT0RFYC4KICAgICAqCiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHsKICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgd2hlbiBgbm9kZS5ub2RlVHlwZWAgZXF1YWxzIGBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVgLgogICAgICoKICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNEb2N1bWVudEZyYWdtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RvY3VtZW50RnJhZ21lbnQobm9kZSkgewogICAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgd2hlbiBgbm9kZS5ub2RlVHlwZWAgZXF1YWxzIGBOb2RlLkNPTU1FTlRfTk9ERWAuCiAgICAgKgogICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0NvbW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ29tbWVudChub2RlKSB7CiAgICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5DT01NRU5UX05PREU7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgYmxvY2sgZmlsbGVyIGZvciB0aGlzIERPTSBjb252ZXJ0ZXIuCiAgICAgKgogICAgICoJCWNvbnN0IGNvbnZlcnRlciA9IG5ldyBEb21Db252ZXJ0ZXIoIHZpZXdEb2N1bWVudCwgeyBibG9ja0ZpbGxlck1vZGU6ICdicicgfSApOwogICAgICoKICAgICAqCQljb252ZXJ0ZXIuaXNCbG9ja0ZpbGxlciggQlJfRklMTEVSKCBkb2N1bWVudCApICk7IC8vIHRydWUKICAgICAqCQljb252ZXJ0ZXIuaXNCbG9ja0ZpbGxlciggTkJTUF9GSUxMRVIoIGRvY3VtZW50ICkgKTsgLy8gZmFsc2UKICAgICAqCiAgICAgKiAqKk5vdGU6Kio6IEZvciB0aGUgYCduYnNwJ2AgbW9kZSB0aGUgbWV0aG9kIGFsc28gY2hlY2tzIGNvbnRleHQgb2YgYSBub2RlIHNvIGl0IGNhbm5vdCBiZSBhIGRldGFjaGVkIG5vZGUuCiAgICAgKgogICAgICogKipOb3RlOioqIEEgc3BlY2lhbCBjYXNlIGluIHRoZSBgJ25ic3AnYCBtb2RlIGV4aXN0cyB3aGVyZSB0aGUgYDxicj5gIGluIGA8cD48YnI+PC9wPmAgaXMgdHJlYXRlZCBhcyBhIGJsb2NrIGZpbGxlci4KICAgICAqCiAgICAgKiBAcGFyYW0ge05vZGV9IGRvbU5vZGUgRE9NIG5vZGUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBhIG5vZGUgaXMgY29uc2lkZXJlZCBhIGJsb2NrIGZpbGxlciBmb3IgZ2l2ZW4gbW9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0Jsb2NrRmlsbGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Jsb2NrRmlsbGVyKGRvbU5vZGUpIHsKICAgICAgaWYgKHRoaXMuYmxvY2tGaWxsZXJNb2RlID09ICdicicpIHsKICAgICAgICByZXR1cm4gZG9tTm9kZS5pc0VxdWFsTm9kZShCUl9GSUxMRVJfUkVGKTsKICAgICAgfSAvLyBTcGVjaWFsIGNhc2UgZm9yIDxwPjxicj48L3A+IGluIHdoaWNoIDxicj4gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZmlsbGVyIGV2ZW4gd2hlbiB3ZSBhcmUgbm90IGluIHRoZSAnYnInIG1vZGUuIFNlZSBja2VkaXRvcjUjNTU2NC4KCgogICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnQlInICYmIGhhc0Jsb2NrUGFyZW50KGRvbU5vZGUsIHRoaXMuYmxvY2tFbGVtZW50cykgJiYgZG9tTm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0gLy8gSWYgbm90IGluICdicicgbW9kZSwgdHJ5IHJlY29nbml6aW5nIGJvdGggbWFya2VkIGFuZCByZWd1bGFyIG5ic3AgYmxvY2sgZmlsbGVycy4KCgogICAgICByZXR1cm4gZG9tTm9kZS5pc0VxdWFsTm9kZShNQVJLRURfTkJTUF9GSUxMRVJfUkVGKSB8fCBpc05ic3BCbG9ja0ZpbGxlcihkb21Ob2RlLCB0aGlzLmJsb2NrRWxlbWVudHMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBnaXZlbiBzZWxlY3Rpb24gaXMgYSBiYWNrd2FyZCBzZWxlY3Rpb24sIHRoYXQgaXMsIGlmIGl0J3MgYGZvY3VzYCBpcyBiZWZvcmUgYGFuY2hvcmAuCiAgICAgKgogICAgICogQHBhcmFtIHtTZWxlY3Rpb259IERPTSBTZWxlY3Rpb24gaW5zdGFuY2UgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0RvbVNlbGVjdGlvbkJhY2t3YXJkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RvbVNlbGVjdGlvbkJhY2t3YXJkKHNlbGVjdGlvbikgewogICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9IC8vIFNpbmNlIGl0IHRha2VzIG11bHRpcGxlIGxpbmVzIG9mIGNvZGUgdG8gY2hlY2sgd2hldGhlciBhICJET00gUG9zaXRpb24iIGlzIGJlZm9yZS9hZnRlciBhbm90aGVyICJET00gUG9zaXRpb24iLAogICAgICAvLyB3ZSB3aWxsIHVzZSB0aGUgZmFjdCB0aGF0IHJhbmdlIHdpbGwgY29sbGFwc2UgaWYgaXQncyBlbmQgaXMgYmVmb3JlIGl0J3Mgc3RhcnQuCgoKICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTsKICAgICAgcmFuZ2Uuc2V0U3RhcnQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQpOwogICAgICByYW5nZS5zZXRFbmQoc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTsKICAgICAgdmFyIGJhY2t3YXJkID0gcmFuZ2UuY29sbGFwc2VkOwogICAgICByYW5nZS5kZXRhY2goKTsKICAgICAgcmV0dXJuIGJhY2t3YXJkOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgcGFyZW50IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYXdlbGVtZW50flJhd0VsZW1lbnR9CiAgICAgKiB0aGF0IGhvc3RzIHRoZSBwcm92aWRlZCBET00gbm9kZS4gUmV0dXJucyBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gc3VjaCBwYXJlbnQuCiAgICAgKgogICAgICogQHBhcmFtIHtOb2RlfSBkb21Ob2RlCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L3Jhd2VsZW1lbnR+UmF3RWxlbWVudHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEhvc3RWaWV3RWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SG9zdFZpZXdFbGVtZW50KGRvbU5vZGUpIHsKICAgICAgdmFyIGFuY2VzdG9ycyA9IGdldEFuY2VzdG9ycyhkb21Ob2RlKTsgLy8gUmVtb3ZlIGRvbU5vZGUgZnJvbSB0aGUgbGlzdC4KCiAgICAgIGFuY2VzdG9ycy5wb3AoKTsKCiAgICAgIHdoaWxlIChhbmNlc3RvcnMubGVuZ3RoKSB7CiAgICAgICAgdmFyIF9kb21Ob2RlID0gYW5jZXN0b3JzLnBvcCgpOwoKICAgICAgICB2YXIgdmlld05vZGUgPSB0aGlzLl9kb21Ub1ZpZXdNYXBwaW5nLmdldChfZG9tTm9kZSk7CgogICAgICAgIGlmICh2aWV3Tm9kZSAmJiAodmlld05vZGUuaXMoJ3VpRWxlbWVudCcpIHx8IHZpZXdOb2RlLmlzKCdyYXdFbGVtZW50JykpKSB7CiAgICAgICAgICByZXR1cm4gdmlld05vZGU7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzZWxlY3Rpb24ncyBib3VuZGFyaWVzIGFyZSBhdCBjb3JyZWN0IHBsYWNlcy4KICAgICAqCiAgICAgKiBUaGUgZm9sbG93aW5nIHBsYWNlcyBhcmUgY29uc2lkZXJlZCBhcyBpbmNvcnJlY3QgZm9yIHNlbGVjdGlvbiBib3VuZGFyaWVzOgogICAgICoKICAgICAqICogYmVmb3JlIG9yIGluIHRoZSBtaWRkbGUgb2YgYW4gaW5saW5lIGZpbGxlciBzZXF1ZW5jZSwKICAgICAqICogaW5zaWRlIGEgRE9NIGVsZW1lbnQgd2hpY2ggcmVwcmVzZW50cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgYSB2aWV3IFVJIGVsZW1lbnR9LAogICAgICogKiBpbnNpZGUgYSBET00gZWxlbWVudCB3aGljaCByZXByZXNlbnRzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmF3ZWxlbWVudH5SYXdFbGVtZW50IGEgdmlldyByYXcgZWxlbWVudH0uCiAgICAgKgogICAgICogQHBhcmFtIHtTZWxlY3Rpb259IGRvbVNlbGVjdGlvbiBUaGUgRE9NIHNlbGVjdGlvbiBvYmplY3QgdG8gYmUgY2hlY2tlZC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHNlbGVjdGlvbiBpcyBhdCBhIGNvcnJlY3QgcGxhY2UsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImlzRG9tU2VsZWN0aW9uQ29ycmVjdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEb21TZWxlY3Rpb25Db3JyZWN0KGRvbVNlbGVjdGlvbikgewogICAgICByZXR1cm4gdGhpcy5faXNEb21TZWxlY3Rpb25Qb3NpdGlvbkNvcnJlY3QoZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUsIGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQpICYmIHRoaXMuX2lzRG9tU2VsZWN0aW9uUG9zaXRpb25Db3JyZWN0KGRvbVNlbGVjdGlvbi5mb2N1c05vZGUsIGRvbVNlbGVjdGlvbi5mb2N1c09mZnNldCk7CiAgICB9CiAgICAvKioKICAgICAqIFJlZ2lzdGVycyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybn0gZm9yIHZpZXcgZWxlbWVudHMgd2hvc2UgY29udGVudCBzaG91bGQgYmUgdHJlYXRlZCBhcyByYXcgZGF0YQogICAgICogYW5kIG5vdCBwcm9jZXNzZWQgZHVyaW5nIHRoZSBjb252ZXJzaW9uIGZyb20gRE9NIG5vZGVzIHRvIHZpZXcgZWxlbWVudHMuCiAgICAgKgogICAgICogVGhpcyBpcyBhZmZlY3RpbmcgaG93IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNkb21Ub1ZpZXd9IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2RvbUNoaWxkcmVuVG9WaWV3fSBwcm9jZXNzIERPTSBub2Rlcy4KICAgICAqCiAgICAgKiBUaGUgcmF3IGRhdGEgY2FuIGJlIGxhdGVyIGFjY2Vzc2VkIGJ5IGEKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50I2dldEN1c3RvbVByb3BlcnR5IGN1c3RvbSBwcm9wZXJ0eSBvZiBhIHZpZXcgZWxlbWVudH0gY2FsbGVkIGAiJHJhd0NvbnRlbnQiYC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBwYXR0ZXJuIFBhdHRlcm4gbWF0Y2hpbmcgYSB2aWV3IGVsZW1lbnQgd2hvc2UgY29udGVudCBzaG91bGQKICAgICAqIGJlIHRyZWF0ZWQgYXMgcmF3IGRhdGEuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVnaXN0ZXJSYXdDb250ZW50TWF0Y2hlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJSYXdDb250ZW50TWF0Y2hlcihwYXR0ZXJuKSB7CiAgICAgIHRoaXMuX3Jhd0NvbnRlbnRFbGVtZW50TWF0Y2hlci5hZGQocGF0dGVybik7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYmxvY2sge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyfSBub2RlIGJhc2VkIG9uIGN1cnJlbnQge0BsaW5rICNibG9ja0ZpbGxlck1vZGV9IHNldHRpbmcuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbXMge0RvY3VtZW50fSBkb21Eb2N1bWVudAogICAgICogQHJldHVybnMge05vZGV9IGZpbGxlcgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRCbG9ja0ZpbGxlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJsb2NrRmlsbGVyKGRvbURvY3VtZW50KSB7CiAgICAgIHN3aXRjaCAodGhpcy5ibG9ja0ZpbGxlck1vZGUpIHsKICAgICAgICBjYXNlICduYnNwJzoKICAgICAgICAgIHJldHVybiBOQlNQX0ZJTExFUihkb21Eb2N1bWVudCk7CiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwCgogICAgICAgIGNhc2UgJ21hcmtlZE5ic3AnOgogICAgICAgICAgcmV0dXJuIE1BUktFRF9OQlNQX0ZJTExFUihkb21Eb2N1bWVudCk7CiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwCgogICAgICAgIGNhc2UgJ2JyJzoKICAgICAgICAgIHJldHVybiBCUl9GSUxMRVIoZG9tRG9jdW1lbnQpOwogICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcAogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gRE9NIHBvc2l0aW9uIGlzIGEgY29ycmVjdCBwbGFjZSBmb3Igc2VsZWN0aW9uIGJvdW5kYXJ5LiBTZWUge0BsaW5rICNpc0RvbVNlbGVjdGlvbkNvcnJlY3R9LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVBhcmVudCBQb3NpdGlvbiBwYXJlbnQuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFBvc2l0aW9uIG9mZnNldC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gcG9zaXRpb24gaXMgYXQgYSBjb3JyZWN0IHBsYWNlIGZvciBzZWxlY3Rpb24gYm91bmRhcnksIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9pc0RvbVNlbGVjdGlvblBvc2l0aW9uQ29ycmVjdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzRG9tU2VsZWN0aW9uUG9zaXRpb25Db3JyZWN0KGRvbVBhcmVudCwgb2Zmc2V0KSB7CiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBiZWZvcmUgb3IgaW4gdGhlIG1pZGRsZSBvZiBpbmxpbmUgZmlsbGVyIHN0cmluZywgaXQgaXMgaW5jb3JyZWN0LgogICAgICBpZiAoaXNUZXh0KGRvbVBhcmVudCkgJiYgc3RhcnRzV2l0aEZpbGxlcihkb21QYXJlbnQpICYmIG9mZnNldCA8IElOTElORV9GSUxMRVJfTEVOR1RIKSB7CiAgICAgICAgLy8gU2VsZWN0aW9uIGluIGEgdGV4dCBub2RlLCBhdCB3cm9uZyBwb3NpdGlvbiAoYmVmb3JlIG9yIGluIHRoZSBtaWRkbGUgb2YgZmlsbGVyKS4KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmlzRWxlbWVudChkb21QYXJlbnQpICYmIHN0YXJ0c1dpdGhGaWxsZXIoZG9tUGFyZW50LmNoaWxkTm9kZXNbb2Zmc2V0XSkpIHsKICAgICAgICAvLyBTZWxlY3Rpb24gaW4gYW4gZWxlbWVudCBub2RlLCBiZWZvcmUgZmlsbGVyIHRleHQgbm9kZS4KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciB2aWV3UGFyZW50ID0gdGhpcy5tYXBEb21Ub1ZpZXcoZG9tUGFyZW50KTsgLy8gVGhlIHBvc2l0aW9uIGlzIGluY29ycmVjdCB3aGVuIGFuY2hvcmVkIGluc2lkZSBhIFVJRWxlbWVudCBvciBhIFJhd0VsZW1lbnQuCiAgICAgIC8vIE5vdGU6IEluIGNhc2Ugb2YgVUlFbGVtZW50IGFuZCBSYXdFbGVtZW50LCBtYXBEb21Ub1ZpZXcoKSByZXR1cm5zIGEgcGFyZW50IGVsZW1lbnQgZm9yIGFueSBET00gY2hpbGQKICAgICAgLy8gc28gdGhlcmUncyBubyBuZWVkIHRvIHBlcmZvcm0gYW55IGFkZGl0aW9uYWwgY2hlY2tzLgoKICAgICAgaWYgKHZpZXdQYXJlbnQgJiYgKHZpZXdQYXJlbnQuaXMoJ3VpRWxlbWVudCcpIHx8IHZpZXdQYXJlbnQuaXMoJ3Jhd0VsZW1lbnQnKSkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBUYWtlcyB0ZXh0IGRhdGEgZnJvbSBhIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0I2RhdGF9IGFuZCBwcm9jZXNzZXMgaXQgc28KICAgICAqIGl0IGlzIGNvcnJlY3RseSBkaXNwbGF5ZWQgaW4gdGhlIERPTS4KICAgICAqCiAgICAgKiBGb2xsb3dpbmcgY2hhbmdlcyBhcmUgZG9uZToKICAgICAqCiAgICAgKiAqIGEgc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBpcyBjaGFuZ2VkIHRvIGAmbmJzcDtgIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRleHQgbm9kZSBpbiBpdHMgY29udGFpbmVyCiAgICAgKiBlbGVtZW50IG9yIGlmIGEgcHJldmlvdXMgdGV4dCBub2RlIGVuZHMgd2l0aCBhIHNwYWNlIGNoYXJhY3RlciwKICAgICAqICogc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgdGV4dCBub2RlIGlzIGNoYW5nZWQgdG8gYCZuYnNwO2AgaWYgdGhlcmUgYXJlIHR3byBzcGFjZXMgYXQgdGhlIGVuZCBvZiBhIG5vZGUgb3IgaWYgbmV4dCBub2RlCiAgICAgKiBzdGFydHMgd2l0aCBhIHNwYWNlIG9yIGlmIGl0IGlzIHRoZSBsYXN0IHRleHQgbm9kZSBpbiBpdHMgY29udGFpbmVyLAogICAgICogKiByZW1haW5pbmcgc3BhY2VzIGFyZSByZXBsYWNlZCB0byBhIGNoYWluIG9mIHNwYWNlcyBhbmQgYCZuYnNwO2AgKGUuZy4gYCd4ICAgeCdgIGJlY29tZXMgYCd4ICZuYnNwOyB4J2ApLgogICAgICoKICAgICAqIENvbnRlbnQgb2Yge0BsaW5rICNwcmVFbGVtZW50c30gaXMgbm90IHByb2Nlc3NlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSBub2RlIFZpZXcgdGV4dCBub2RlIHRvIHByb2Nlc3MuCiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBQcm9jZXNzZWQgdGV4dCBkYXRhLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9wcm9jZXNzRGF0YUZyb21WaWV3VGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NEYXRhRnJvbVZpZXdUZXh0KG5vZGUpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgIHZhciBkYXRhID0gbm9kZS5kYXRhOyAvLyBJZiBhbnkgb2Ygbm9kZSBhbmNlc3RvcnMgaGFzIGEgbmFtZSB3aGljaCBpcyBpbiBgcHJlRWxlbWVudHNgIGFycmF5LCB0aGVuIGN1cnJlbnRseSBwcm9jZXNzZWQKICAgICAgLy8gdmlldyB0ZXh0IG5vZGUgaXMgKHdpbGwgYmUpIGluIHByZWZvcm1hdHRlZCBlbGVtZW50LiBXZSBzaG91bGQgbm90IGNoYW5nZSB3aGl0ZXNwYWNlcyB0aGVuLgoKICAgICAgaWYgKG5vZGUuZ2V0QW5jZXN0b3JzKCkuc29tZShmdW5jdGlvbiAocGFyZW50KSB7CiAgICAgICAgcmV0dXJuIF90aGlzLnByZUVsZW1lbnRzLmluY2x1ZGVzKHBhcmVudC5uYW1lKTsKICAgICAgfSkpIHsKICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgfSAvLyAxLiBSZXBsYWNlIHRoZSBmaXJzdCBzcGFjZSB3aXRoIGEgbmJzcCBpZiB0aGUgcHJldmlvdXMgbm9kZSBlbmRzIHdpdGggYSBzcGFjZSBvciB0aGVyZSBpcyBubyBwcmV2aW91cyBub2RlCiAgICAgIC8vIChjb250YWluZXIgZWxlbWVudCBib3VuZGFyeSkuCgoKICAgICAgaWYgKGRhdGEuY2hhckF0KDApID09ICcgJykgewogICAgICAgIHZhciBwcmV2Tm9kZSA9IHRoaXMuX2dldFRvdWNoaW5nVmlld1RleHROb2RlKG5vZGUsIGZhbHNlKTsKCiAgICAgICAgdmFyIHByZXZFbmRzV2l0aFNwYWNlID0gcHJldk5vZGUgJiYgdGhpcy5fbm9kZUVuZHNXaXRoU3BhY2UocHJldk5vZGUpOwoKICAgICAgICBpZiAocHJldkVuZHNXaXRoU3BhY2UgfHwgIXByZXZOb2RlKSB7CiAgICAgICAgICBkYXRhID0gIlx4QTAiICsgZGF0YS5zdWJzdHIoMSk7CiAgICAgICAgfQogICAgICB9IC8vIDIuIFJlcGxhY2UgdGhlIGxhc3Qgc3BhY2Ugd2l0aCBuYnNwIGlmIHRoZXJlIGFyZSB0d28gc3BhY2VzIGF0IHRoZSBlbmQgb3IgaWYgdGhlIG5leHQgbm9kZSBzdGFydHMgd2l0aCBzcGFjZSBvciB0aGVyZSBpcyBubwogICAgICAvLyBuZXh0IG5vZGUgKGNvbnRhaW5lciBlbGVtZW50IGJvdW5kYXJ5KS4KICAgICAgLy8KICAgICAgLy8gS2VlcCBpbiBtaW5kIHRoYXQgRmlyZWZveCBwcmVmZXJzICRuYnNwOyBiZWZvcmUgdGFnLCBub3QgaW5zaWRlIGl0OgogICAgICAvLwogICAgICAvLyBGb28gPHNwYW4+Jm5ic3A7YmFyPC9zcGFuPiAgPC0tIGJhZC4KICAgICAgLy8gRm9vJm5ic3A7PHNwYW4+IGJhcjwvc3Bhbj4gIDwtLSBnb29kLgogICAgICAvLwogICAgICAvLyBNb3JlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy8xNzQ3LgoKCiAgICAgIGlmIChkYXRhLmNoYXJBdChkYXRhLmxlbmd0aCAtIDEpID09ICcgJykgewogICAgICAgIHZhciBuZXh0Tm9kZSA9IHRoaXMuX2dldFRvdWNoaW5nVmlld1RleHROb2RlKG5vZGUsIHRydWUpOwoKICAgICAgICBpZiAoZGF0YS5jaGFyQXQoZGF0YS5sZW5ndGggLSAyKSA9PSAnICcgfHwgIW5leHROb2RlIHx8IG5leHROb2RlLmRhdGEuY2hhckF0KDApID09ICcgJykgewogICAgICAgICAgZGF0YSA9IGRhdGEuc3Vic3RyKDAsIGRhdGEubGVuZ3RoIC0gMSkgKyAiXHhBMCI7CiAgICAgICAgfQogICAgICB9IC8vIDMuIENyZWF0ZSBzcGFjZStuYnNwIHBhaXJzLgoKCiAgICAgIHJldHVybiBkYXRhLnJlcGxhY2UoLyB7Mn0vZywgIiBceEEwIik7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIG5vZGUgZW5kcyB3aXRoIGEgc3BhY2UgY2hhcmFjdGVyIGFmdGVyIGNoYW5naW5nIGFwcHJvcHJpYXRlIHNwYWNlIGNoYXJhY3RlcnMgdG8gYCZuYnNwO2BzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IG5vZGUgTm9kZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gYG5vZGVgIGVuZHMgd2l0aCBzcGFjZSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX25vZGVFbmRzV2l0aFNwYWNlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfbm9kZUVuZHNXaXRoU3BhY2Uobm9kZSkgewogICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgIGlmIChub2RlLmdldEFuY2VzdG9ycygpLnNvbWUoZnVuY3Rpb24gKHBhcmVudCkgewogICAgICAgIHJldHVybiBfdGhpczIucHJlRWxlbWVudHMuaW5jbHVkZXMocGFyZW50Lm5hbWUpOwogICAgICB9KSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgdmFyIGRhdGEgPSB0aGlzLl9wcm9jZXNzRGF0YUZyb21WaWV3VGV4dChub2RlKTsKCiAgICAgIHJldHVybiBkYXRhLmNoYXJBdChkYXRhLmxlbmd0aCAtIDEpID09ICcgJzsKICAgIH0KICAgIC8qKgogICAgICogVGFrZXMgdGV4dCBkYXRhIGZyb20gbmF0aXZlIGBUZXh0YCBub2RlIGFuZCBwcm9jZXNzZXMgaXQgdG8gYSBjb3JyZWN0IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHZpZXcgdGV4dCBub2RlfSBkYXRhLgogICAgICoKICAgICAqIEZvbGxvd2luZyBjaGFuZ2VzIGFyZSBkb25lOgogICAgICoKICAgICAqICogbXVsdGlwbGUgd2hpdGVzcGFjZXMgYXJlIHJlcGxhY2VkIHRvIGEgc2luZ2xlIHNwYWNlLAogICAgICogKiBzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdGV4dCBub2RlIGlzIHJlbW92ZWQgaWYgaXQgaXMgdGhlIGZpcnN0IHRleHQgbm9kZSBpbiBpdHMgY29udGFpbmVyCiAgICAgKiBlbGVtZW50IG9yIGlmIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGUgZW5kcyB3aXRoIGEgc3BhY2UgY2hhcmFjdGVyLAogICAgICogKiBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSB0ZXh0IG5vZGUgaXMgcmVtb3ZlZCBpZiB0aGVyZSBhcmUgdHdvIHNwYWNlcyBhdCB0aGUgZW5kIG9mIGEgbm9kZSBvciBpZiBuZXh0IG5vZGUKICAgICAqIHN0YXJ0cyB3aXRoIGEgc3BhY2Ugb3IgaWYgaXQgaXMgdGhlIGxhc3QgdGV4dCBub2RlIGluIGl0cyBjb250YWluZXIKICAgICAqICogbmJzcHMgYXJlIGNvbnZlcnRlZCB0byBzcGFjZXMuCiAgICAgKgogICAgICogQHBhcmFtIHtOb2RlfSBub2RlIERPTSB0ZXh0IG5vZGUgdG8gcHJvY2Vzcy4KICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFByb2Nlc3NlZCBkYXRhLgogICAgICogQHByaXZhdGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcHJvY2Vzc0RhdGFGcm9tRG9tVGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NEYXRhRnJvbURvbVRleHQobm9kZSkgewogICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTsKCiAgICAgIGlmIChfaGFzRG9tUGFyZW50T2ZUeXBlKG5vZGUsIHRoaXMucHJlRWxlbWVudHMpKSB7CiAgICAgICAgcmV0dXJuIGdldERhdGFXaXRob3V0RmlsbGVyKG5vZGUpOwogICAgICB9IC8vIENoYW5nZSBhbGwgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIChmcm9tIHRoZSBbIFxuXHRccl0gc2V0IOKAkwogICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzgyMiNpc3N1ZWNvbW1lbnQtMzExNjcwMjQ5KSB0byBhIHNpbmdsZSBzcGFjZSBjaGFyYWN0ZXIuCiAgICAgIC8vIFRoYXQncyBob3cgbXVsdGlwbGUgd2hpdGVzcGFjZXMgYXJlIHRyZWF0ZWQgd2hlbiByZW5kZXJlZCwgc28gd2Ugbm9ybWFsaXplIHRob3NlIHdoaXRlc3BhY2VzLgogICAgICAvLyBXZSdyZSByZXBsYWNpbmcgMSsgKGFuZCBub3QgMispIHRvIGFsc28gbm9ybWFsaXplIHNpbmd1bGFyIFxuXHRcciBjaGFyYWN0ZXJzICgjODIyKS4KCgogICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9bIFxuXHRccl17MSx9L2csICcgJyk7CgogICAgICB2YXIgcHJldk5vZGUgPSB0aGlzLl9nZXRUb3VjaGluZ0lubGluZURvbU5vZGUobm9kZSwgZmFsc2UpOwoKICAgICAgdmFyIG5leHROb2RlID0gdGhpcy5fZ2V0VG91Y2hpbmdJbmxpbmVEb21Ob2RlKG5vZGUsIHRydWUpOwoKICAgICAgdmFyIHNob3VsZExlZnRUcmltID0gdGhpcy5fY2hlY2tTaG91bGRMZWZ0VHJpbURvbVRleHQobm9kZSwgcHJldk5vZGUpOwoKICAgICAgdmFyIHNob3VsZFJpZ2h0VHJpbSA9IHRoaXMuX2NoZWNrU2hvdWxkUmlnaHRUcmltRG9tVGV4dChub2RlLCBuZXh0Tm9kZSk7IC8vIElmIHRoZSBwcmV2aW91cyBkb20gdGV4dCBub2RlIGRvZXMgbm90IGV4aXN0IG9yIGl0IGVuZHMgYnkgd2hpdGVzcGFjZSBjaGFyYWN0ZXIsIHJlbW92ZSBzcGFjZSBjaGFyYWN0ZXIgZnJvbSB0aGUgYmVnaW5uaW5nCiAgICAgIC8vIG9mIHRoaXMgdGV4dCBub2RlLiBTdWNoIHNwYWNlIGNoYXJhY3RlciBpcyB0cmVhdGVkIGFzIGEgd2hpdGVzcGFjZS4KCgogICAgICBpZiAoc2hvdWxkTGVmdFRyaW0pIHsKICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9eIC8sICcnKTsKICAgICAgfSAvLyBJZiB0aGUgbmV4dCB0ZXh0IG5vZGUgZG9lcyBub3QgZXhpc3QgcmVtb3ZlIHNwYWNlIGNoYXJhY3RlciBmcm9tIHRoZSBlbmQgb2YgdGhpcyB0ZXh0IG5vZGUuCgoKICAgICAgaWYgKHNob3VsZFJpZ2h0VHJpbSkgewogICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLyAkLywgJycpOwogICAgICB9IC8vIEF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIGJsb2NrIGVsZW1lbnQsIEZpcmVmb3ggaW5zZXJ0cyBub3JtYWwgc3BhY2UgKyA8YnI+IGluc3RlYWQgb2Ygbm9uLWJyZWFraW5nIHNwYWNlLgogICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIHRleHQgbm9kZSBzdGFydHMvZW5kIHdpdGggbm9ybWFsIHNwYWNlIGluc3RlYWQgb2Ygbm9uLWJyZWFraW5nIHNwYWNlLgogICAgICAvLyBUaGlzIGNhdXNlcyBhIHByb2JsZW0gYmVjYXVzZSB0aGUgbm9ybWFsIHNwYWNlIHdvdWxkIGJlIHJlbW92ZWQgaW4gYC5yZXBsYWNlYCBjYWxscyBhYm92ZS4gVG8gcHJldmVudCB0aGF0LAogICAgICAvLyB0aGUgaW5saW5lIGZpbGxlciBpcyByZW1vdmVkIG9ubHkgYWZ0ZXIgdGhlIGRhdGEgaXMgaW5pdGlhbGx5IHByb2Nlc3NlZCAoYnkgdGhlIGAucmVwbGFjZWAgYWJvdmUpLiBTZWUgY2tlZGl0b3I1IzY5Mi4KCgogICAgICBkYXRhID0gZ2V0RGF0YVdpdGhvdXRGaWxsZXIobmV3IFRleHQoZGF0YSkpOyAvLyBBdCB0aGlzIHBvaW50IHdlIHNob3VsZCBoYXZlIHJlbW92ZWQgYWxsIHdoaXRlc3BhY2VzIGZyb20gRE9NIHRleHQgZGF0YS4KICAgICAgLy8KICAgICAgLy8gTm93LCBXZSB3aWxsIHJldmVyc2UgdGhlIHByb2Nlc3MgdGhhdCBoYXBwZW5zIGluIGBfcHJvY2Vzc0RhdGFGcm9tVmlld1RleHRgLgogICAgICAvLwogICAgICAvLyBXZSBoYXZlIHRvIGNoYW5nZSAmbmJzcDsgY2hhcnMsIHRoYXQgd2VyZSBpbiBET00gdGV4dCBkYXRhIGJlY2F1c2Ugb2YgcmVuZGVyaW5nIHJlYXNvbnMsIHRvIHNwYWNlcy4KICAgICAgLy8gRmlyc3QsIGNoYW5nZSBhbGwgYCBcdTAwQTBgIHBhaXJzIChzcGFjZSArICZuYnNwOykgdG8gdHdvIHNwYWNlcy4gRE9NIGNvbnZlcnRlciBjaGFuZ2VzIHR3byBzcGFjZXMgZnJvbSBtb2RlbC92aWV3IHRvCiAgICAgIC8vIGAgXHUwMEEwYCB0byBlbnN1cmUgcHJvcGVyIHJlbmRlcmluZy4gU2luY2UgaGVyZSB3ZSBjb252ZXJ0IGJhY2ssIHdlIHJlY29nbml6ZSB0aG9zZSBwYWlycyBhbmQgY2hhbmdlIHRoZW0gYmFjayB0byBgICBgLgoKICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvIFx1MDBBMC9nLCAnICAnKTsgLy8gVGhlbiwgbGV0J3MgY2hhbmdlIHRoZSBsYXN0IG5ic3AgdG8gYSBzcGFjZS4KCiAgICAgIGlmICgvKCB8XHUwMEEwKVx1MDBBMCQvLnRlc3QoZGF0YSkgfHwgIW5leHROb2RlIHx8IG5leHROb2RlLmRhdGEgJiYgbmV4dE5vZGUuZGF0YS5jaGFyQXQoMCkgPT0gJyAnKSB7CiAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvXHUwMEEwJC8sICcgJyk7CiAgICAgIH0gLy8gVGhlbiwgY2hhbmdlICZuYnNwOyBjaGFyYWN0ZXIgdGhhdCBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0IG5vZGUgdG8gc3BhY2UgY2hhcmFjdGVyLgogICAgICAvLyBXZSBkbyB0aGF0IHJlcGxhY2VtZW50IG9ubHkgaWYgdGhpcyBpcyB0aGUgZmlyc3Qgbm9kZSBvciB0aGUgcHJldmlvdXMgbm9kZSBlbmRzIG9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyLgoKCiAgICAgIGlmIChzaG91bGRMZWZ0VHJpbSkgewogICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoL15cdTAwQTAvLCAnICcpOwogICAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIGFsbCB3aGl0ZXNwYWNlcyBzaG91bGQgYmUgcmVtb3ZlZCBhbmQgYWxsICZuYnNwOyBjcmVhdGVkIGZvciByZW5kZXJpbmcgcmVhc29ucyBzaG91bGQgYmUKICAgICAgLy8gY2hhbmdlZCB0byBub3JtYWwgc3BhY2UuIEFsbCBsZWZ0ICZuYnNwOyBhcmUgJm5ic3A7IGluc2VydGVkIGludGVudGlvbmFsbHkuCgoKICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCBjaGVja3MgaWYgYSBET00gdGV4dCBub2RlLCBwcmVjZWRlZCBieSB0aGUgZ2l2ZW4gYHByZXZOb2RlYCBzaG91bGQKICAgICAqIGJlIHRyaW1tZWQgZnJvbSB0aGUgbGVmdCBzaWRlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUKICAgICAqIEBwYXJhbSB7Tm9kZX0gcHJldk5vZGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY2hlY2tTaG91bGRMZWZ0VHJpbURvbVRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3VsZExlZnRUcmltRG9tVGV4dChub2RlLCBwcmV2Tm9kZSkgewogICAgICBpZiAoIXByZXZOb2RlKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIGlmIChpc0VsZW1lbnQocHJldk5vZGUpKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0gLy8gU2hvdWxkbid0IGxlZnQgdHJpbSBpZiBwcmV2aW91cyBub2RlIGlzIGEgbm9kZSB0aGF0IHdhcyBlbmNvdW50ZXJlZCBhcyBhIHJhdyBjb250ZW50IG5vZGUuCgoKICAgICAgaWYgKHRoaXMuX2VuY291bnRlcmVkUmF3Q29udGVudERvbU5vZGVzLmhhcyhub2RlLnByZXZpb3VzU2libGluZykpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiAvW15cU1x1MDBBMF0vLnRlc3QocHJldk5vZGUuZGF0YS5jaGFyQXQocHJldk5vZGUuZGF0YS5sZW5ndGggLSAxKSk7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCBjaGVja3MgaWYgYSBET00gdGV4dCBub2RlLCBzdWNjZWVkZWQgYnkgdGhlIGdpdmVuIGBuZXh0Tm9kZWAgc2hvdWxkCiAgICAgKiBiZSB0cmltbWVkIGZyb20gdGhlIHJpZ2h0IHNpZGUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZQogICAgICogQHBhcmFtIHtOb2RlfSBuZXh0Tm9kZQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jaGVja1Nob3VsZFJpZ2h0VHJpbURvbVRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3VsZFJpZ2h0VHJpbURvbVRleHQobm9kZSwgbmV4dE5vZGUpIHsKICAgICAgaWYgKG5leHROb2RlKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gIXN0YXJ0c1dpdGhGaWxsZXIobm9kZSk7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBmdW5jdGlvbi4gRm9yIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHZpZXcgdGV4dCBub2RlfSwgaXQgZmluZHMgcHJldmlvdXMgb3IgbmV4dCBzaWJsaW5nCiAgICAgKiB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGUgc2FtZSBjb250YWluZXIgZWxlbWVudC4gSWYgdGhlcmUgaXMgbm8gc3VjaCBzaWJsaW5nLCBgbnVsbGAgaXMgcmV0dXJuZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gbm9kZSBSZWZlcmVuY2Ugbm9kZS4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZ2V0TmV4dAogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR8bnVsbH0gVG91Y2hpbmcgdGV4dCBub2RlIG9yIGBudWxsYCBpZiB0aGVyZSBpcyBubyBuZXh0IG9yIHByZXZpb3VzIHRvdWNoaW5nIHRleHQgbm9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VG91Y2hpbmdWaWV3VGV4dE5vZGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUb3VjaGluZ1ZpZXdUZXh0Tm9kZShub2RlLCBnZXROZXh0KSB7CiAgICAgIHZhciB0cmVlV2Fsa2VyID0gbmV3IFZpZXdUcmVlV2Fsa2VyKHsKICAgICAgICBzdGFydFBvc2l0aW9uOiBnZXROZXh0ID8gVmlld1Bvc2l0aW9uLl9jcmVhdGVBZnRlcihub2RlKSA6IFZpZXdQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKG5vZGUpLAogICAgICAgIGRpcmVjdGlvbjogZ2V0TmV4dCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCcKICAgICAgfSk7CgogICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRyZWVXYWxrZXIpLAogICAgICAgICAgX3N0ZXA2OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykgewogICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXA2LnZhbHVlOwoKICAgICAgICAgIC8vIFZpZXdDb250YWluZXJFbGVtZW50IGlzIGZvdW5kIG9uIGEgd2F5IHRvIG5leHQgVmlld1RleHQgbm9kZSwgc28gZ2l2ZW4gYG5vZGVgIHdhcyBmaXJzdC9sYXN0CiAgICAgICAgICAvLyB0ZXh0IG5vZGUgaW4gaXRzIGNvbnRhaW5lciBlbGVtZW50LgogICAgICAgICAgaWYgKHZhbHVlLml0ZW0uaXMoJ2NvbnRhaW5lckVsZW1lbnQnKSkgewogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0gLy8gPGJyPiBmb3VuZCDigJMgaXQgd29ya3MgbGlrZSBhIGJsb2NrIGJvdW5kYXJ5LCBzbyBkbyBub3Qgc2NhbiBmdXJ0aGVyLgogICAgICAgICAgZWxzZSBpZiAodmFsdWUuaXRlbS5pcygnZWxlbWVudCcsICdicicpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0gLy8gRm91bmQgYSB0ZXh0IG5vZGUgaW4gdGhlIHNhbWUgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLml0ZW0uaXMoJyR0ZXh0UHJveHknKSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLml0ZW07CiAgICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBIZWxwZXIgZnVuY3Rpb24uIEZvciB0aGUgZ2l2ZW4gdGV4dCBub2RlLCBpdCBmaW5kcyB0aGUgY2xvc2VzdCB0b3VjaGluZyBub2RlIHdoaWNoIGlzIGVpdGhlcgogICAgICogYSB0ZXh0IG5vZGUgb3IgYSBgPGJyPmAuIFRoZSBzZWFyY2ggaXMgdGVybWluYXRlZCBhdCBibG9jayBlbGVtZW50IGJvdW5kYXJpZXMgYW5kIGlmIGEgbWF0Y2hpbmcgbm9kZQogICAgICogd2Fzbid0IGZvdW5kIHNvIGZhciwgYG51bGxgIGlzIHJldHVybmVkLgogICAgICoKICAgICAqIEluIHRoZSBmb2xsb3dpbmcgRE9NIHN0cnVjdHVyZToKICAgICAqCiAgICAgKgkJPHA+Zm9vPGI+YmFyPC9iPjxicj5ib208L3A+CiAgICAgKgogICAgICogKiBgZm9vYCBkb2Vzbid0IGhhdmUgaXRzIHByZXZpb3VzIHRvdWNoaW5nIGlubGluZSBub2RlIChgbnVsbGAgaXMgcmV0dXJuZWQpLAogICAgICogKiBgZm9vYCdzIG5leHQgdG91Y2hpbmcgaW5saW5lIG5vZGUgaXMgYGJhcmAKICAgICAqICogYGJhcmAncyBuZXh0IHRvdWNoaW5nIGlubGluZSBub2RlIGlzIGA8YnI+YAogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGV4dCBub2RlcyBhbmQgYDxicj5gIGVsZW1lbnRzIGJlY2F1c2UgdGhlc2UgdHlwZXMgb2Ygbm9kZXMgYWZmZWN0IGhvdwogICAgICogc3BhY2VzIGluIHRoZSBnaXZlbiB0ZXh0IG5vZGUgbmVlZCB0byBiZSBjb252ZXJ0ZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7VGV4dH0gbm9kZQogICAgICogQHBhcmFtIHtCb29sZWFufSBnZXROZXh0CiAgICAgKiBAcmV0dXJucyB7VGV4dHxFbGVtZW50fG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRvdWNoaW5nSW5saW5lRG9tTm9kZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRvdWNoaW5nSW5saW5lRG9tTm9kZShub2RlLCBnZXROZXh0KSB7CiAgICAgIGlmICghbm9kZS5wYXJlbnROb2RlKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIHZhciBkaXJlY3Rpb24gPSBnZXROZXh0ID8gJ25leHROb2RlJyA6ICdwcmV2aW91c05vZGUnOwogICAgICB2YXIgZG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7CiAgICAgIHZhciB0b3Btb3N0UGFyZW50ID0gZ2V0QW5jZXN0b3JzKG5vZGUpWzBdOwogICAgICB2YXIgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIodG9wbW9zdFBhcmVudCwgTm9kZUZpbHRlci5TSE9XX1RFWFQgfCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgewogICAgICAgIGFjY2VwdE5vZGU6IGZ1bmN0aW9uIGFjY2VwdE5vZGUobm9kZSkgewogICAgICAgICAgaWYgKGlzVGV4dChub2RlKSkgewogICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT0gJ0JSJykgewogICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHRyZWVXYWxrZXIuY3VycmVudE5vZGUgPSBub2RlOwogICAgICB2YXIgdG91Y2hpbmdOb2RlID0gdHJlZVdhbGtlcltkaXJlY3Rpb25dKCk7CgogICAgICBpZiAodG91Y2hpbmdOb2RlICE9PSBudWxsKSB7CiAgICAgICAgdmFyIGxjYSA9IGdldENvbW1vbkFuY2VzdG9yKG5vZGUsIHRvdWNoaW5nTm9kZSk7IC8vIElmIHRoZXJlIGlzIGNvbW1vbiBhbmNlc3RvciBiZXR3ZWVuIHRoZSB0ZXh0IG5vZGUgYW5kIG5leHQvcHJldiB0ZXh0IG5vZGUsCiAgICAgICAgLy8gYW5kIHRoZXJlIGFyZSBubyBibG9jayBlbGVtZW50cyBvbiBhIHdheSBmcm9tIHRoZSB0ZXh0IG5vZGUgdG8gdGhhdCBhbmNlc3RvciwKICAgICAgICAvLyBhbmQgdGhlcmUgYXJlIG5vIGJsb2NrIGVsZW1lbnRzIG9uIGEgd2F5IGZyb20gbmV4dC9wcmV2IHRleHQgbm9kZSB0byB0aGF0IGFuY2VzdG9yLi4uCgogICAgICAgIGlmIChsY2EgJiYgIV9oYXNEb21QYXJlbnRPZlR5cGUobm9kZSwgdGhpcy5ibG9ja0VsZW1lbnRzLCBsY2EpICYmICFfaGFzRG9tUGFyZW50T2ZUeXBlKHRvdWNoaW5nTm9kZSwgdGhpcy5ibG9ja0VsZW1lbnRzLCBsY2EpKSB7CiAgICAgICAgICAvLyBUaGVuIHRoZXkgYXJlIGluIHRoZSBzYW1lIGNvbnRhaW5lciBlbGVtZW50LgogICAgICAgICAgcmV0dXJuIHRvdWNoaW5nTm9kZTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogIH1dKTsKCiAgcmV0dXJuIERvbUNvbnZlcnRlcjsKfSgpOyAvLyBIZWxwZXIgZnVuY3Rpb24uCi8vIFVzZWQgdG8gY2hlY2sgaWYgZ2l2ZW4gbmF0aXZlIGBFbGVtZW50YCBvciBgVGV4dGAgbm9kZSBoYXMgcGFyZW50IHdpdGggdGFnIG5hbWUgZnJvbSBgdHlwZXNgIGFycmF5LgovLwovLyBAcGFyYW0ge05vZGV9IG5vZGUKLy8gQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gdHlwZXMKLy8gQHBhcmFtIHtCb29sZWFufSBbYm91bmRhcnlQYXJlbnRdIENhbiBiZSBnaXZlbiBpZiBwYXJlbnRzIHNob3VsZCBiZSBjaGVja2VkIHVwIHRvIGEgZ2l2ZW4gZWxlbWVudCAoZXhjbHVkaW5nIHRoYXQgZWxlbWVudCkuCi8vIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgc3VjaCBwYXJlbnQgZXhpc3RzIG9yIGBmYWxzZWAgaWYgaXQgZG9lcyBub3QuCgoKZXhwb3J0IHsgRG9tQ29udmVydGVyIGFzIGRlZmF1bHQgfTsKCmZ1bmN0aW9uIF9oYXNEb21QYXJlbnRPZlR5cGUobm9kZSwgdHlwZXMsIGJvdW5kYXJ5UGFyZW50KSB7CiAgdmFyIHBhcmVudHMgPSBnZXRBbmNlc3RvcnMobm9kZSk7CgogIGlmIChib3VuZGFyeVBhcmVudCkgewogICAgcGFyZW50cyA9IHBhcmVudHMuc2xpY2UocGFyZW50cy5pbmRleE9mKGJvdW5kYXJ5UGFyZW50KSArIDEpOwogIH0KCiAgcmV0dXJuIHBhcmVudHMuc29tZShmdW5jdGlvbiAocGFyZW50KSB7CiAgICByZXR1cm4gcGFyZW50LnRhZ05hbWUgJiYgdHlwZXMuaW5jbHVkZXMocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7CiAgfSk7Cn0gLy8gQSBoZWxwZXIgdGhhdCBleGVjdXRlcyBnaXZlbiBjYWxsYmFjayBmb3IgZWFjaCBET00gbm9kZSdzIGFuY2VzdG9yLCBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBub2RlCi8vIGFuZCBlbmRpbmcgaW4gZG9jdW1lbnQjZG9jdW1lbnRFbGVtZW50LgovLwovLyBAcGFyYW0ge05vZGV9IG5vZGUKLy8gQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBmb3IgZWFjaCBhbmNlc3Rvci4KCgpmdW5jdGlvbiBmb3JFYWNoRG9tTm9kZUFuY2VzdG9yKG5vZGUsIGNhbGxiYWNrKSB7CiAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPSBnbG9iYWwuZG9jdW1lbnQpIHsKICAgIGNhbGxiYWNrKG5vZGUpOwogICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTsKICB9Cn0gLy8gQ2hlY2tzIGlmIGdpdmVuIG5vZGUgaXMgYSBuYnNwIGJsb2NrIGZpbGxlci4KLy8KLy8gQSAmbmJzcDsgaXMgYSBibG9jayBmaWxsZXIgb25seSBpZiBpdCBpcyBhIHNpbmdsZSBjaGlsZCBvZiBhIGJsb2NrIGVsZW1lbnQuCi8vCi8vIEBwYXJhbSB7Tm9kZX0gZG9tTm9kZSBET00gbm9kZS4KLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gaXNOYnNwQmxvY2tGaWxsZXIoZG9tTm9kZSwgYmxvY2tFbGVtZW50cykgewogIHZhciBpc05CU1AgPSBkb21Ob2RlLmlzRXF1YWxOb2RlKE5CU1BfRklMTEVSX1JFRik7CiAgcmV0dXJuIGlzTkJTUCAmJiBoYXNCbG9ja1BhcmVudChkb21Ob2RlLCBibG9ja0VsZW1lbnRzKSAmJiBkb21Ob2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IDE7Cn0gLy8gQ2hlY2tzIGlmIGRvbU5vZGUgaGFzIGJsb2NrIHBhcmVudC4KLy8KLy8gQHBhcmFtIHtOb2RlfSBkb21Ob2RlIERPTSBub2RlLgovLyBAcmV0dXJucyB7Qm9vbGVhbn0KCgpmdW5jdGlvbiBoYXNCbG9ja1BhcmVudChkb21Ob2RlLCBibG9ja0VsZW1lbnRzKSB7CiAgdmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTsKICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC50YWdOYW1lICYmIGJsb2NrRWxlbWVudHMuaW5jbHVkZXMocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7Cn0KLyoqCiAqIEVudW0gcmVwcmVzZW50aW5nIHR5cGUgb2YgdGhlIGJsb2NrIGZpbGxlci4KICoKICogUG9zc2libGUgdmFsdWVzOgogKgogKiAqIGBicmAgLSBmb3IgYDxiciBkYXRhLWNrZS1maWxsZXI9InRydWUiPmAgYmxvY2sgZmlsbGVyIHVzZWQgaW4gdGhlIGVkaXRpbmcgdmlldywKICogKiBgbmJzcGAgLSBmb3IgYCZuYnNwO2AgYmxvY2sgZmlsbGVycyB1c2VkIGluIHRoZSBkYXRhLAogKiAqIGBtYXJrZWROYnNwYCAtIGZvciBuYnNwIGJsb2NrIGZpbGxlcnMgd3JhcHBlZCBpbiBhIHNwYW46IGA8c3BhbiBkYXRhLWNrZS1maWxsZXI9InRydWUiPiZuYnNwOzwvc3Bhbj5gIHVzZWQgaW4gdGhlIGRhdGEuCiAqCiAqIEB0eXBlZGVmIHtTdHJpbmd9IG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXJ+QmxvY2tGaWxsZXJNb2RlCiAqLw=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js"],"names":["ViewText","ViewElement","ViewPosition","ViewRange","ViewSelection","ViewDocumentFragment","ViewTreeWalker","Matcher","BR_FILLER","INLINE_FILLER_LENGTH","NBSP_FILLER","MARKED_NBSP_FILLER","getDataWithoutFiller","isInlineFiller","startsWithFiller","global","indexOf","getAncestors","getCommonAncestor","isText","isElement","BR_FILLER_REF","document","NBSP_FILLER_REF","MARKED_NBSP_FILLER_REF","DomConverter","options","blockFillerMode","preElements","blockElements","_domToViewMapping","WeakMap","_viewToDomMapping","_fakeSelectionMapping","_rawContentElementMatcher","_encounteredRawContentDomNodes","WeakSet","domElement","viewDocumentSelection","set","get","viewElement","delete","childNodes","child","unbindDomElement","domFragment","viewFragment","viewNode","domDocument","is","textData","_processDataFromViewText","createTextNode","mapViewToDom","createDocumentFragment","bind","bindDocumentFragments","render","bindElements","hasAttribute","createElementNS","getAttribute","name","createElement","getAttributeKeys","key","setAttribute","withChildren","viewChildrenToDom","appendChild","fillerPositionOffset","getFillerOffset","offset","getChildren","childView","_getBlockFiller","viewToDom","viewRange","domStart","viewPositionToDom","start","domEnd","end","domRange","createRange","setStart","parent","setEnd","viewPosition","viewParent","domParent","findCorrespondingDomText","domBefore","domAfter","nodeBefore","parentNode","nextSibling","domNode","isBlockFiller","hostElement","getHostViewElement","_processDataFromDomText","isComment","mapDomToView","isDocumentFragment","viewName","keepOriginalCase","tagName","toLowerCase","attrs","attributes","i","length","_setAttribute","value","match","_setCustomProperty","innerHTML","add","domChildrenToView","_appendChild","domChild","viewChild","domToView","domSelection","rangeCount","container","getRangeAt","startContainer","viewSelection","fakeSelectionToView","isBackward","isDomSelectionBackward","viewRanges","domRangeToView","push","backward","viewStart","domPositionToView","startOffset","viewEnd","endContainer","endOffset","domOffset","_createBefore","findCorrespondingViewText","viewBefore","index","domElementOrDocumentFragment","domText","previousSibling","firstChild","getChild","documentFragmentOrElement","viewText","viewEditable","domEditable","ownerDocument","activeElement","window","scrollX","scrollY","scrollPositions","forEachDomNodeAncestor","node","scrollLeft","scrollTop","focus","shift","scrollTo","nodeType","Node","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","COMMENT_NODE","isEqualNode","hasBlockParent","isNbspBlockFiller","selection","isCollapsed","range","anchorNode","anchorOffset","focusNode","focusOffset","collapsed","detach","ancestors","pop","_isDomSelectionPositionCorrect","pattern","data","some","includes","charAt","prevNode","_getTouchingViewTextNode","prevEndsWithSpace","_nodeEndsWithSpace","substr","nextNode","replace","_hasDomParentOfType","_getTouchingInlineDomNode","shouldLeftTrim","_checkShouldLeftTrimDomText","shouldRightTrim","_checkShouldRightTrimDomText","Text","test","has","getNext","treeWalker","startPosition","_createAfter","direction","item","topmostParent","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","acceptNode","FILTER_ACCEPT","FILTER_SKIP","currentNode","touchingNode","lca","types","boundaryParent","parents","slice","callback","isNBSP"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\n\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport Matcher from './matcher';\nimport {\n\tBR_FILLER, INLINE_FILLER_LENGTH, NBSP_FILLER, MARKED_NBSP_FILLER,\n\tgetDataWithoutFiller, isInlineFiller, startsWithFiller\n} from './filler';\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport { isElement } from 'lodash-es';\n\nconst BR_FILLER_REF = BR_FILLER( document ); // eslint-disable-line new-cap\nconst NBSP_FILLER_REF = NBSP_FILLER( document ); // eslint-disable-line new-cap\nconst MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER( document ); // eslint-disable-line new-cap\n\n/**\n * `DomConverter` is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements bindings} between these nodes.\n *\n * An instance of the DOM converter is available under\n * {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * The DOM converter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep the\n * state of a tree nor keeps the synchronization between the tree view and the DOM tree (use {@link module:engine/view/document~Document}).\n *\n * The DOM converter keeps DOM elements to view element bindings, so when the converter gets destroyed, the bindings are lost.\n * Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n\t/**\n\t * Creates a DOM converter.\n\t *\n\t * @param {module:engine/view/document~Document} document The view document instance.\n\t * @param {Object} options An object with configuration options.\n\t * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode='br'] The type of the block filler to use.\n\t */\n\tconstructor( document, options = {} ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * The mode of a block filler used by the DOM converter.\n\t\t *\n\t\t * @member {'br'|'nbsp'|'markedNbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n\t\t */\n\t\tthis.blockFillerMode = options.blockFillerMode || 'br';\n\n\t\t/**\n\t\t * Elements which are considered pre-formatted elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n\t\t */\n\t\tthis.preElements = [ 'pre' ];\n\n\t\t/**\n\t\t * Elements which are considered block elements (and hence should be filled with a\n\t\t * {@link #isBlockFiller block filler}).\n\t\t *\n\t\t * Whether an element is considered a block element also affects handling of trailing whitespaces.\n\t\t *\n\t\t * You can extend this array if you introduce support for block elements which are not yet recognized here.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n\t\t */\n\t\tthis.blockElements = [ 'p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'dd', 'dt', 'figcaption', 'td', 'th' ];\n\n\t\t/**\n\t\t * The DOM-to-view mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n\t\t */\n\t\tthis._domToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * The view-to-DOM mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n\t\t */\n\t\tthis._viewToDomMapping = new WeakMap();\n\n\t\t/**\n\t\t * Holds the mapping between fake selection containers and corresponding view selections.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n\t\t */\n\t\tthis._fakeSelectionMapping = new WeakMap();\n\n\t\t/**\n\t\t * Matcher for view elements whose content should be treated as raw data\n\t\t * and not processed during the conversion from DOM nodes to view elements.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/view/matcher~Matcher}\n\t\t */\n\t\tthis._rawContentElementMatcher = new Matcher();\n\n\t\t/**\n\t\t * A set of encountered raw content DOM nodes. It is used for preventing left trimming of the following text node.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakSet.<Node>}\n\t\t */\n\t\tthis._encounteredRawContentDomNodes = new WeakSet();\n\t}\n\n\t/**\n\t * Binds a given DOM element that represents fake selection to a **position** of a\n\t * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n\t * Document selection copy is stored and can be retrieved by the\n\t * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n\t */\n\tbindFakeSelection( domElement, viewDocumentSelection ) {\n\t\tthis._fakeSelectionMapping.set( domElement, new ViewSelection( viewDocumentSelection ) );\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given\n\t * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @returns {module:engine/view/selection~Selection|undefined}\n\t */\n\tfakeSelectionToView( domElement ) {\n\t\treturn this._fakeSelectionMapping.get( domElement );\n\t}\n\n\t/**\n\t * Binds DOM and view elements, so it will be possible to get corresponding elements using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {HTMLElement} domElement The DOM element to bind.\n\t * @param {module:engine/view/element~Element} viewElement The view element to bind.\n\t */\n\tbindElements( domElement, viewElement ) {\n\t\tthis._domToViewMapping.set( domElement, viewElement );\n\t\tthis._viewToDomMapping.set( viewElement, domElement );\n\t}\n\n\t/**\n\t * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of\n\t * the DOM element will be unbound too.\n\t *\n\t * @param {HTMLElement} domElement The DOM element to unbind.\n\t */\n\tunbindDomElement( domElement ) {\n\t\tconst viewElement = this._domToViewMapping.get( domElement );\n\n\t\tif ( viewElement ) {\n\t\t\tthis._domToViewMapping.delete( domElement );\n\t\t\tthis._viewToDomMapping.delete( viewElement );\n\n\t\t\tfor ( const child of domElement.childNodes ) {\n\t\t\t\tthis.unbindDomElement( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {DocumentFragment} domFragment The DOM document fragment to bind.\n\t * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment The view document fragment to bind.\n\t */\n\tbindDocumentFragments( domFragment, viewFragment ) {\n\t\tthis._domToViewMapping.set( domFragment, viewFragment );\n\t\tthis._viewToDomMapping.set( viewFragment, domFragment );\n\t}\n\n\t/**\n\t * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments the method will return corresponding items.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View node or document fragment to transform.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n\t */\n\tviewToDom( viewNode, domDocument, options = {} ) {\n\t\tif ( viewNode.is( '$text' ) ) {\n\t\t\tconst textData = this._processDataFromViewText( viewNode );\n\n\t\t\treturn domDocument.createTextNode( textData );\n\t\t} else {\n\t\t\tif ( this.mapViewToDom( viewNode ) ) {\n\t\t\t\treturn this.mapViewToDom( viewNode );\n\t\t\t}\n\n\t\t\tlet domElement;\n\n\t\t\tif ( viewNode.is( 'documentFragment' ) ) {\n\t\t\t\t// Create DOM document fragment.\n\t\t\t\tdomElement = domDocument.createDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domElement, viewNode );\n\t\t\t\t}\n\t\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\t\t// UIElement has its own render() method (see #799).\n\t\t\t\tdomElement = viewNode.render( domDocument );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\treturn domElement;\n\t\t\t} else {\n\t\t\t\t// Create DOM element.\n\t\t\t\tif ( viewNode.hasAttribute( 'xmlns' ) ) {\n\t\t\t\t\tdomElement = domDocument.createElementNS( viewNode.getAttribute( 'xmlns' ), viewNode.name );\n\t\t\t\t} else {\n\t\t\t\t\tdomElement = domDocument.createElement( viewNode.name );\n\t\t\t\t}\n\n\t\t\t\t// RawElement take care of their children in RawElement#render() method which can be customized\n\t\t\t\t// (see https://github.com/ckeditor/ckeditor5/issues/4469).\n\t\t\t\tif ( viewNode.is( 'rawElement' ) ) {\n\t\t\t\t\tviewNode.render( domElement );\n\t\t\t\t}\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tfor ( const key of viewNode.getAttributeKeys() ) {\n\t\t\t\t\tdomElement.setAttribute( key, viewNode.getAttribute( key ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren !== false ) {\n\t\t\t\tfor ( const child of this.viewChildrenToDom( viewNode, domDocument, options ) ) {\n\t\t\t\t\tdomElement.appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the view element to DOM using the\n\t * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n\t * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n\t * @returns {Iterable.<Node>} DOM nodes.\n\t */\n\t* viewChildrenToDom( viewElement, domDocument, options = {} ) {\n\t\tconst fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n\t\tlet offset = 0;\n\n\t\tfor ( const childView of viewElement.getChildren() ) {\n\t\t\tif ( fillerPositionOffset === offset ) {\n\t\t\t\tyield this._getBlockFiller( domDocument );\n\t\t\t}\n\n\t\t\tyield this.viewToDom( childView, domDocument, options );\n\n\t\t\toffset++;\n\t\t}\n\n\t\tif ( fillerPositionOffset === offset ) {\n\t\t\tyield this._getBlockFiller( domDocument );\n\t\t}\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/range~Range} to DOM range.\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {Range} DOM range.\n\t */\n\tviewRangeToDom( viewRange ) {\n\t\tconst domStart = this.viewPositionToDom( viewRange.start );\n\t\tconst domEnd = this.viewPositionToDom( viewRange.end );\n\n\t\tconst domRange = document.createRange();\n\t\tdomRange.setStart( domStart.parent, domStart.offset );\n\t\tdomRange.setEnd( domEnd.parent, domEnd.offset );\n\n\t\treturn domRange;\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n\t *\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t * If the converted position is directly before inline filler it is moved inside the filler.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n\t * @returns {Node} position.parent DOM position parent.\n\t * @returns {Number} position.offset DOM position offset.\n\t */\n\tviewPositionToDom( viewPosition ) {\n\t\tconst viewParent = viewPosition.parent;\n\n\t\tif ( viewParent.is( '$text' ) ) {\n\t\t\tconst domParent = this.findCorrespondingDomText( viewParent );\n\n\t\t\tif ( !domParent ) {\n\t\t\t\t// Position is in a view text node that has not been rendered to DOM yet.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet offset = viewPosition.offset;\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset += INLINE_FILLER_LENGTH;\n\t\t\t}\n\n\t\t\treturn { parent: domParent, offset };\n\t\t} else {\n\t\t\t// viewParent is instance of ViewElement.\n\t\t\tlet domParent, domBefore, domAfter;\n\n\t\t\tif ( viewPosition.offset === 0 ) {\n\t\t\t\tdomParent = this.mapViewToDom( viewParent );\n\n\t\t\t\tif ( !domParent ) {\n\t\t\t\t\t// Position is in a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomAfter = domParent.childNodes[ 0 ];\n\t\t\t} else {\n\t\t\t\tconst nodeBefore = viewPosition.nodeBefore;\n\n\t\t\t\tdomBefore = nodeBefore.is( '$text' ) ?\n\t\t\t\t\tthis.findCorrespondingDomText( nodeBefore ) :\n\t\t\t\t\tthis.mapViewToDom( viewPosition.nodeBefore );\n\n\t\t\t\tif ( !domBefore ) {\n\t\t\t\t\t// Position is after a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomParent = domBefore.parentNode;\n\t\t\t\tdomAfter = domBefore.nextSibling;\n\t\t\t}\n\n\t\t\t// If there is an inline filler at position return position inside the filler. We should never return\n\t\t\t// the position before the inline filler.\n\t\t\tif ( isText( domAfter ) && startsWithFiller( domAfter ) ) {\n\t\t\t\treturn { parent: domAfter, offset: INLINE_FILLER_LENGTH };\n\t\t\t}\n\n\t\t\tconst offset = domBefore ? indexOf( domBefore ) + 1 : 0;\n\n\t\t\treturn { parent: domParent, offset };\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items. For\n\t * {@link module:engine/view/filler fillers} `null` will be returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n\t * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n\t */\n\tdomToView( domNode, options = {} ) {\n\t\tif ( this.isBlockFiller( domNode ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When node is inside a UIElement or a RawElement return that parent as it's view representation.\n\t\tconst hostElement = this.getHostViewElement( domNode );\n\n\t\tif ( hostElement ) {\n\t\t\treturn hostElement;\n\t\t}\n\n\t\tif ( isText( domNode ) ) {\n\t\t\tif ( isInlineFiller( domNode ) ) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst textData = this._processDataFromDomText( domNode );\n\n\t\t\t\treturn textData === '' ? null : new ViewText( this.document, textData );\n\t\t\t}\n\t\t} else if ( this.isComment( domNode ) ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif ( this.mapDomToView( domNode ) ) {\n\t\t\t\treturn this.mapDomToView( domNode );\n\t\t\t}\n\n\t\t\tlet viewElement;\n\n\t\t\tif ( this.isDocumentFragment( domNode ) ) {\n\t\t\t\t// Create view document fragment.\n\t\t\t\tviewElement = new ViewDocumentFragment( this.document );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domNode, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create view element.\n\t\t\t\tconst viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n\t\t\t\tviewElement = new ViewElement( this.document, viewName );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domNode, viewElement );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tconst attrs = domNode.attributes;\n\n\t\t\t\tfor ( let i = attrs.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tviewElement._setAttribute( attrs[ i ].name, attrs[ i ].value );\n\t\t\t\t}\n\n\t\t\t\t// Treat this element's content as a raw data if it was registered as such.\n\t\t\t\tif ( options.withChildren !== false && this._rawContentElementMatcher.match( viewElement ) ) {\n\t\t\t\t\tviewElement._setCustomProperty( '$rawContent', domNode.innerHTML );\n\n\t\t\t\t\t// Store a DOM node to prevent left trimming of the following text node.\n\t\t\t\t\tthis._encounteredRawContentDomNodes.add( domNode );\n\n\t\t\t\t\treturn viewElement;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren !== false ) {\n\t\t\t\tfor ( const child of this.domChildrenToView( domNode, options ) ) {\n\t\t\t\t\tviewElement._appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn viewElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the DOM element to view nodes using\n\t * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n\t * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n\t *\n\t * @param {HTMLElement} domElement Parent DOM element.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n\t */\n\t* domChildrenToView( domElement, options = {} ) {\n\t\tfor ( let i = 0; i < domElement.childNodes.length; i++ ) {\n\t\t\tconst domChild = domElement.childNodes[ i ];\n\t\t\tconst viewChild = this.domToView( domChild, options );\n\n\t\t\tif ( viewChild !== null ) {\n\t\t\t\tyield viewChild;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n\t * Ranges which cannot be converted will be omitted.\n\t *\n\t * @param {Selection} domSelection DOM selection.\n\t * @returns {module:engine/view/selection~Selection} View selection.\n\t */\n\tdomSelectionToView( domSelection ) {\n\t\t// DOM selection might be placed in fake selection container.\n\t\t// If container contains fake selection - return corresponding view selection.\n\t\tif ( domSelection.rangeCount === 1 ) {\n\t\t\tlet container = domSelection.getRangeAt( 0 ).startContainer;\n\n\t\t\t// The DOM selection might be moved to the text node inside the fake selection container.\n\t\t\tif ( isText( container ) ) {\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t}\n\n\t\t\tconst viewSelection = this.fakeSelectionToView( container );\n\n\t\t\tif ( viewSelection ) {\n\t\t\t\treturn viewSelection;\n\t\t\t}\n\t\t}\n\n\t\tconst isBackward = this.isDomSelectionBackward( domSelection );\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( let i = 0; i < domSelection.rangeCount; i++ ) {\n\t\t\t// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n\t\t\tconst domRange = domSelection.getRangeAt( i );\n\t\t\tconst viewRange = this.domRangeToView( domRange );\n\n\t\t\tif ( viewRange ) {\n\t\t\t\tviewRanges.push( viewRange );\n\t\t\t}\n\t\t}\n\n\t\treturn new ViewSelection( viewRanges, { backward: isBackward } );\n\t}\n\n\t/**\n\t * Converts DOM Range to view {@link module:engine/view/range~Range}.\n\t * If the start or end position can not be converted `null` is returned.\n\t *\n\t * @param {Range} domRange DOM range.\n\t * @returns {module:engine/view/range~Range|null} View range.\n\t */\n\tdomRangeToView( domRange ) {\n\t\tconst viewStart = this.domPositionToView( domRange.startContainer, domRange.startOffset );\n\t\tconst viewEnd = this.domPositionToView( domRange.endContainer, domRange.endOffset );\n\n\t\tif ( viewStart && viewEnd ) {\n\t\t\treturn new ViewRange( viewStart, viewEnd );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n\t *\n\t * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n\t * position of the filler will be converted and returned.\n\t *\n\t * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n\t * that position will be converted to view position before that UIElement.\n\t *\n\t * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n\t *\n\t * @param {Node} domParent DOM position parent.\n\t * @param {Number} domOffset DOM position offset.\n\t * @returns {module:engine/view/position~Position} viewPosition View position.\n\t */\n\tdomPositionToView( domParent, domOffset ) {\n\t\tif ( this.isBlockFiller( domParent ) ) {\n\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t}\n\n\t\t// If position is somewhere inside UIElement or a RawElement - return position before that element.\n\t\tconst viewElement = this.mapDomToView( domParent );\n\n\t\tif ( viewElement && ( viewElement.is( 'uiElement' ) || viewElement.is( 'rawElement' ) ) ) {\n\t\t\treturn ViewPosition._createBefore( viewElement );\n\t\t}\n\n\t\tif ( isText( domParent ) ) {\n\t\t\tif ( isInlineFiller( domParent ) ) {\n\t\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t\t}\n\n\t\t\tconst viewParent = this.findCorrespondingViewText( domParent );\n\t\t\tlet offset = domOffset;\n\n\t\t\tif ( !viewParent ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset -= INLINE_FILLER_LENGTH;\n\t\t\t\toffset = offset < 0 ? 0 : offset;\n\t\t\t}\n\n\t\t\treturn new ViewPosition( viewParent, offset );\n\t\t}\n\t\t// domParent instanceof HTMLElement.\n\t\telse {\n\t\t\tif ( domOffset === 0 ) {\n\t\t\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t\t\tif ( viewParent ) {\n\t\t\t\t\treturn new ViewPosition( viewParent, 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst domBefore = domParent.childNodes[ domOffset - 1 ];\n\t\t\t\tconst viewBefore = isText( domBefore ) ?\n\t\t\t\t\tthis.findCorrespondingViewText( domBefore ) :\n\t\t\t\t\tthis.mapDomToView( domBefore );\n\n\t\t\t\t// TODO #663\n\t\t\t\tif ( viewBefore && viewBefore.parent ) {\n\t\t\t\t\treturn new ViewPosition( viewBefore.parent, viewBefore.index + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns corresponding view {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n\t * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * to the given DOM - `undefined` is returned.\n\t *\n\t * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or\n\t * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n\t *\n\t * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n\t * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n\t * Corresponding view element, document fragment or `undefined` if no element was bound.\n\t */\n\tmapDomToView( domElementOrDocumentFragment ) {\n\t\tconst hostElement = this.getHostViewElement( domElementOrDocumentFragment );\n\n\t\treturn hostElement || this._domToViewMapping.get( domElementOrDocumentFragment );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or\n\t * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n\t *\n\t * @param {Text} domText DOM text node.\n\t * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n\t * corresponding node.\n\t */\n\tfindCorrespondingViewText( domText ) {\n\t\tif ( isInlineFiller( domText ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If DOM text was rendered by a UIElement or a RawElement - return this parent element.\n\t\tconst hostElement = this.getHostViewElement( domText );\n\n\t\tif ( hostElement ) {\n\t\t\treturn hostElement;\n\t\t}\n\n\t\tconst previousSibling = domText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling ) {\n\t\t\tif ( !( this.isElement( previousSibling ) ) ) {\n\t\t\t\t// The previous is text or comment.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst viewElement = this.mapDomToView( previousSibling );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst nextSibling = viewElement.nextSibling;\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( nextSibling instanceof ViewText ) {\n\t\t\t\t\treturn viewElement.nextSibling;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to use parent to find the corresponding text node.\n\t\telse {\n\t\t\tconst viewElement = this.mapDomToView( domText.parentNode );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst firstChild = viewElement.getChild( 0 );\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( firstChild instanceof ViewText ) {\n\t\t\t\t\treturn firstChild;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n\t * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n\t * use {@link #findCorrespondingDomText}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View element or document fragment.\n\t * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n\t */\n\tmapViewToDom( documentFragmentOrElement ) {\n\t\treturn this._viewToDomMapping.get( documentFragmentOrElement );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} viewText View text node.\n\t * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n\t */\n\tfindCorrespondingDomText( viewText ) {\n\t\tconst previousSibling = viewText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling && this.mapViewToDom( previousSibling ) ) {\n\t\t\treturn this.mapViewToDom( previousSibling ).nextSibling;\n\t\t}\n\n\t\t// If this is a first node, try to use parent to find the corresponding text node.\n\t\tif ( !previousSibling && viewText.parent && this.mapViewToDom( viewText.parent ) ) {\n\t\t\treturn this.mapViewToDom( viewText.parent ).childNodes[ 0 ];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t * @param {module:engine/view/editableelement~EditableElement} viewEditable\n\t */\n\tfocus( viewEditable ) {\n\t\tconst domEditable = this.mapViewToDom( viewEditable );\n\n\t\tif ( domEditable && domEditable.ownerDocument.activeElement !== domEditable ) {\n\t\t\t// Save the scrollX and scrollY positions before the focus.\n\t\t\tconst { scrollX, scrollY } = global.window;\n\t\t\tconst scrollPositions = [];\n\n\t\t\t// Save all scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst { scrollLeft, scrollTop } = node;\n\n\t\t\t\tscrollPositions.push( [ scrollLeft, scrollTop ] );\n\t\t\t} );\n\n\t\t\tdomEditable.focus();\n\n\t\t\t// Restore scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/957\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst [ scrollLeft, scrollTop ] = scrollPositions.shift();\n\n\t\t\t\tnode.scrollLeft = scrollLeft;\n\t\t\t\tnode.scrollTop = scrollTop;\n\t\t\t} );\n\n\t\t\t// Restore the scrollX and scrollY positions after the focus.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\tglobal.window.scrollTo( scrollX, scrollY );\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisElement( node ) {\n\t\treturn node && node.nodeType == Node.ELEMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisDocumentFragment( node ) {\n\t\treturn node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisComment( node ) {\n\t\treturn node && node.nodeType == Node.COMMENT_NODE;\n\t}\n\n\t/**\n\t * Checks if the node is an instance of the block filler for this DOM converter.\n\t *\n\t *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n\t *\n\t *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n\t *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n\t *\n\t * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n\t *\n\t * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n\t *\n\t * @param {Node} domNode DOM node to check.\n\t * @returns {Boolean} True if a node is considered a block filler for given mode.\n\t */\n\tisBlockFiller( domNode ) {\n\t\tif ( this.blockFillerMode == 'br' ) {\n\t\t\treturn domNode.isEqualNode( BR_FILLER_REF );\n\t\t}\n\n\t\t// Special case for <p><br></p> in which <br> should be treated as filler even when we are not in the 'br' mode. See ckeditor5#5564.\n\t\tif ( domNode.tagName === 'BR' && hasBlockParent( domNode, this.blockElements ) && domNode.parentNode.childNodes.length === 1 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If not in 'br' mode, try recognizing both marked and regular nbsp block fillers.\n\t\treturn domNode.isEqualNode( MARKED_NBSP_FILLER_REF ) || isNbspBlockFiller( domNode, this.blockElements );\n\t}\n\n\t/**\n\t * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n\t *\n\t * @param {Selection} DOM Selection instance to check.\n\t * @returns {Boolean}\n\t */\n\tisDomSelectionBackward( selection ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n\t\t// we will use the fact that range will collapse if it's end is before it's start.\n\t\tconst range = document.createRange();\n\n\t\trange.setStart( selection.anchorNode, selection.anchorOffset );\n\t\trange.setEnd( selection.focusNode, selection.focusOffset );\n\n\t\tconst backward = range.collapsed;\n\n\t\trange.detach();\n\n\t\treturn backward;\n\t}\n\n\t/**\n\t * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}\n\t * that hosts the provided DOM node. Returns `null` if there is no such parent.\n\t *\n\t * @param {Node} domNode\n\t * @returns {module:engine/view/uielement~UIElement|module:engine/view/rawelement~RawElement|null}\n\t */\n\tgetHostViewElement( domNode ) {\n\t\tconst ancestors = getAncestors( domNode );\n\n\t\t// Remove domNode from the list.\n\t\tancestors.pop();\n\n\t\twhile ( ancestors.length ) {\n\t\t\tconst domNode = ancestors.pop();\n\t\t\tconst viewNode = this._domToViewMapping.get( domNode );\n\n\t\t\tif ( viewNode && ( viewNode.is( 'uiElement' ) || viewNode.is( 'rawElement' ) ) ) {\n\t\t\t\treturn viewNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if the given selection's boundaries are at correct places.\n\t *\n\t * The following places are considered as incorrect for selection boundaries:\n\t *\n\t * * before or in the middle of an inline filler sequence,\n\t * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},\n\t * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.\n\t *\n\t * @param {Selection} domSelection The DOM selection object to be checked.\n\t * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n\t */\n\tisDomSelectionCorrect( domSelection ) {\n\t\treturn this._isDomSelectionPositionCorrect( domSelection.anchorNode, domSelection.anchorOffset ) &&\n\t\t\tthis._isDomSelectionPositionCorrect( domSelection.focusNode, domSelection.focusOffset );\n\t}\n\n\t/**\n\t * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data\n\t * and not processed during the conversion from DOM nodes to view elements.\n\t *\n\t * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.\n\t *\n\t * The raw data can be later accessed by a\n\t * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `\"$rawContent\"`.\n\t *\n\t * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching a view element whose content should\n\t * be treated as raw data.\n\t */\n\tregisterRawContentMatcher( pattern ) {\n\t\tthis._rawContentElementMatcher.add( pattern );\n\t}\n\n\t/**\n\t * Returns block {@link module:engine/view/filler filler} node based on current {@link #blockFillerMode} setting.\n\t *\n\t * @private\n\t * @params {Document} domDocument\n\t * @returns {Node} filler\n\t */\n\t_getBlockFiller( domDocument ) {\n\t\tswitch ( this.blockFillerMode ) {\n\t\t\tcase 'nbsp':\n\t\t\t\treturn NBSP_FILLER( domDocument ); // eslint-disable-line new-cap\n\t\t\tcase 'markedNbsp':\n\t\t\t\treturn MARKED_NBSP_FILLER( domDocument ); // eslint-disable-line new-cap\n\t\t\tcase 'br':\n\t\t\t\treturn BR_FILLER( domDocument ); // eslint-disable-line new-cap\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n\t *\n\t * @private\n\t * @param {Element} domParent Position parent.\n\t * @param {Number} offset Position offset.\n\t * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n\t */\n\t_isDomSelectionPositionCorrect( domParent, offset ) {\n\t\t// If selection is before or in the middle of inline filler string, it is incorrect.\n\t\tif ( isText( domParent ) && startsWithFiller( domParent ) && offset < INLINE_FILLER_LENGTH ) {\n\t\t\t// Selection in a text node, at wrong position (before or in the middle of filler).\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isElement( domParent ) && startsWithFiller( domParent.childNodes[ offset ] ) ) {\n\t\t\t// Selection in an element node, before filler text node.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t// The position is incorrect when anchored inside a UIElement or a RawElement.\n\t\t// Note: In case of UIElement and RawElement, mapDomToView() returns a parent element for any DOM child\n\t\t// so there's no need to perform any additional checks.\n\t\tif ( viewParent && ( viewParent.is( 'uiElement' ) || viewParent.is( 'rawElement' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n\t * it is correctly displayed in the DOM.\n\t *\n\t * Following changes are done:\n\t *\n\t * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n\t * element or if a previous text node ends with a space character,\n\t * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container,\n\t * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n\t *\n\t * Content of {@link #preElements} is not processed.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node View text node to process.\n\t * @returns {String} Processed text data.\n\t */\n\t_processDataFromViewText( node ) {\n\t\tlet data = node.data;\n\n\t\t// If any of node ancestors has a name which is in `preElements` array, then currently processed\n\t\t// view text node is (will be) in preformatted element. We should not change whitespaces then.\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn data;\n\t\t}\n\n\t\t// 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n\t\t// (container element boundary).\n\t\tif ( data.charAt( 0 ) == ' ' ) {\n\t\t\tconst prevNode = this._getTouchingViewTextNode( node, false );\n\t\t\tconst prevEndsWithSpace = prevNode && this._nodeEndsWithSpace( prevNode );\n\n\t\t\tif ( prevEndsWithSpace || !prevNode ) {\n\t\t\t\tdata = '\\u00A0' + data.substr( 1 );\n\t\t\t}\n\t\t}\n\n\t\t// 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n\t\t// next node (container element boundary).\n\t\t//\n\t\t// Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n\t\t//\n\t\t// Foo <span>&nbsp;bar</span>  <-- bad.\n\t\t// Foo&nbsp;<span> bar</span>  <-- good.\n\t\t//\n\t\t// More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\t\tif ( data.charAt( data.length - 1 ) == ' ' ) {\n\t\t\tconst nextNode = this._getTouchingViewTextNode( node, true );\n\n\t\t\tif ( data.charAt( data.length - 2 ) == ' ' || !nextNode || nextNode.data.charAt( 0 ) == ' ' ) {\n\t\t\t\tdata = data.substr( 0, data.length - 1 ) + '\\u00A0';\n\t\t\t}\n\t\t}\n\n\t\t// 3. Create space+nbsp pairs.\n\t\treturn data.replace( / {2}/g, ' \\u00A0' );\n\t}\n\n\t/**\n\t * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Node to check.\n\t * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n\t */\n\t_nodeEndsWithSpace( node ) {\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst data = this._processDataFromViewText( node );\n\n\t\treturn data.charAt( data.length - 1 ) == ' ';\n\t}\n\n\t/**\n\t * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n\t *\n\t * Following changes are done:\n\t *\n\t * * multiple whitespaces are replaced to a single space,\n\t * * space at the beginning of a text node is removed if it is the first text node in its container\n\t * element or if the previous text node ends with a space character,\n\t * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container\n\t * * nbsps are converted to spaces.\n\t *\n\t * @param {Node} node DOM text node to process.\n\t * @returns {String} Processed data.\n\t * @private\n\t */\n\t_processDataFromDomText( node ) {\n\t\tlet data = node.data;\n\n\t\tif ( _hasDomParentOfType( node, this.preElements ) ) {\n\t\t\treturn getDataWithoutFiller( node );\n\t\t}\n\n\t\t// Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n\t\t// That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n\t\t// We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\t\tdata = data.replace( /[ \\n\\t\\r]{1,}/g, ' ' );\n\n\t\tconst prevNode = this._getTouchingInlineDomNode( node, false );\n\t\tconst nextNode = this._getTouchingInlineDomNode( node, true );\n\n\t\tconst shouldLeftTrim = this._checkShouldLeftTrimDomText( node, prevNode );\n\t\tconst shouldRightTrim = this._checkShouldRightTrimDomText( node, nextNode );\n\n\t\t// If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n\t\t// of this text node. Such space character is treated as a whitespace.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^ /, '' );\n\t\t}\n\n\t\t// If the next text node does not exist remove space character from the end of this text node.\n\t\tif ( shouldRightTrim ) {\n\t\t\tdata = data.replace( / $/, '' );\n\t\t}\n\n\t\t// At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n\t\t// This means that the text node starts/end with normal space instead of non-breaking space.\n\t\t// This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n\t\t// the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\t\tdata = getDataWithoutFiller( new Text( data ) );\n\n\t\t// At this point we should have removed all whitespaces from DOM text data.\n\t\t//\n\t\t// Now, We will reverse the process that happens in `_processDataFromViewText`.\n\t\t//\n\t\t// We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n\t\t// First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n\t\t// ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\t\tdata = data.replace( / \\u00A0/g, '  ' );\n\n\t\t// Then, let's change the last nbsp to a space.\n\t\tif ( /( |\\u00A0)\\u00A0$/.test( data ) || !nextNode || ( nextNode.data && nextNode.data.charAt( 0 ) == ' ' ) ) {\n\t\t\tdata = data.replace( /\\u00A0$/, ' ' );\n\t\t}\n\n\t\t// Then, change &nbsp; character that is at the beginning of the text node to space character.\n\t\t// We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^\\u00A0/, ' ' );\n\t\t}\n\n\t\t// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n\t\t// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\t\treturn data;\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n\t * be trimmed from the left side.\n\t *\n\t * @private\n\t * @param {Node} node\n\t * @param {Node} prevNode\n\t */\n\t_checkShouldLeftTrimDomText( node, prevNode ) {\n\t\tif ( !prevNode ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( isElement( prevNode ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Shouldn't left trim if previous node is a node that was encountered as a raw content node.\n\t\tif ( this._encounteredRawContentDomNodes.has( node.previousSibling ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn /[^\\S\\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) );\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n\t * be trimmed from the right side.\n\t *\n\t * @private\n\t * @param {Node} node\n\t * @param {Node} nextNode\n\t */\n\t_checkShouldRightTrimDomText( node, nextNode ) {\n\t\tif ( nextNode ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !startsWithFiller( node );\n\t}\n\n\t/**\n\t * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n\t * that is contained in the same container element. If there is no such sibling, `null` is returned.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Reference node.\n\t * @param {Boolean} getNext\n\t * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n\t */\n\t_getTouchingViewTextNode( node, getNext ) {\n\t\tconst treeWalker = new ViewTreeWalker( {\n\t\t\tstartPosition: getNext ? ViewPosition._createAfter( node ) : ViewPosition._createBefore( node ),\n\t\t\tdirection: getNext ? 'forward' : 'backward'\n\t\t} );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\t// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n\t\t\t// text node in its container element.\n\t\t\tif ( value.item.is( 'containerElement' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// <br> found – it works like a block boundary, so do not scan further.\n\t\t\telse if ( value.item.is( 'element', 'br' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Found a text node in the same container element.\n\t\t\telse if ( value.item.is( '$textProxy' ) ) {\n\t\t\t\treturn value.item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Helper function. For the given text node, it finds the closest touching node which is either\n\t * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n\t * wasn't found so far, `null` is returned.\n\t *\n\t * In the following DOM structure:\n\t *\n\t *\t\t<p>foo<b>bar</b><br>bom</p>\n\t *\n\t * * `foo` doesn't have its previous touching inline node (`null` is returned),\n\t * * `foo`'s next touching inline node is `bar`\n\t * * `bar`'s next touching inline node is `<br>`\n\t *\n\t * This method returns text nodes and `<br>` elements because these types of nodes affect how\n\t * spaces in the given text node need to be converted.\n\t *\n\t * @private\n\t * @param {Text} node\n\t * @param {Boolean} getNext\n\t * @returns {Text|Element|null}\n\t */\n\t_getTouchingInlineDomNode( node, getNext ) {\n\t\tif ( !node.parentNode ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst direction = getNext ? 'nextNode' : 'previousNode';\n\t\tconst document = node.ownerDocument;\n\t\tconst topmostParent = getAncestors( node )[ 0 ];\n\n\t\tconst treeWalker = document.createTreeWalker( topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode( node ) {\n\t\t\t\tif ( isText( node ) ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\tif ( node.tagName == 'BR' ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\t\t}\n\t\t} );\n\n\t\ttreeWalker.currentNode = node;\n\n\t\tconst touchingNode = treeWalker[ direction ]();\n\n\t\tif ( touchingNode !== null ) {\n\t\t\tconst lca = getCommonAncestor( node, touchingNode );\n\n\t\t\t// If there is common ancestor between the text node and next/prev text node,\n\t\t\t// and there are no block elements on a way from the text node to that ancestor,\n\t\t\t// and there are no block elements on a way from next/prev text node to that ancestor...\n\t\t\tif (\n\t\t\t\tlca &&\n\t\t\t\t!_hasDomParentOfType( node, this.blockElements, lca ) &&\n\t\t\t\t!_hasDomParentOfType( touchingNode, this.blockElements, lca )\n\t\t\t) {\n\t\t\t\t// Then they are in the same container element.\n\t\t\t\treturn touchingNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType( node, types, boundaryParent ) {\n\tlet parents = getAncestors( node );\n\n\tif ( boundaryParent ) {\n\t\tparents = parents.slice( parents.indexOf( boundaryParent ) + 1 );\n\t}\n\n\treturn parents.some( parent => parent.tagName && types.includes( parent.tagName.toLowerCase() ) );\n}\n\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomNodeAncestor( node, callback ) {\n\twhile ( node && node != global.document ) {\n\t\tcallback( node );\n\t\tnode = node.parentNode;\n\t}\n}\n\n// Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\nfunction isNbspBlockFiller( domNode, blockElements ) {\n\tconst isNBSP = domNode.isEqualNode( NBSP_FILLER_REF );\n\n\treturn isNBSP && hasBlockParent( domNode, blockElements ) && domNode.parentNode.childNodes.length === 1;\n}\n\n// Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\nfunction hasBlockParent( domNode, blockElements ) {\n\tconst parent = domNode.parentNode;\n\n\treturn parent && parent.tagName && blockElements.includes( parent.tagName.toLowerCase() );\n}\n\n/**\n * Enum representing type of the block filler.\n *\n * Possible values:\n *\n * * `br` - for `<br data-cke-filler=\"true\">` block filler used in the editing view,\n * * `nbsp` - for `&nbsp;` block fillers used in the data,\n * * `markedNbsp` - for nbsp block fillers wrapped in a span: `<span data-cke-filler=\"true\">&nbsp;</span>` used in the data.\n *\n * @typedef {String} module:engine/view/filler~BlockFillerMode\n */\n"]}]}