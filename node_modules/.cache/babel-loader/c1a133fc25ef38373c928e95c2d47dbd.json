{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuYW5jaG9yLmpzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvbW9kZWwvd3JpdGVyCiAqLwppbXBvcnQgQXR0cmlidXRlT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uL2F0dHJpYnV0ZW9wZXJhdGlvbic7CmltcG9ydCBEZXRhY2hPcGVyYXRpb24gZnJvbSAnLi9vcGVyYXRpb24vZGV0YWNob3BlcmF0aW9uJzsKaW1wb3J0IEluc2VydE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbi9pbnNlcnRvcGVyYXRpb24nOwppbXBvcnQgTWFya2VyT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uL21hcmtlcm9wZXJhdGlvbic7CmltcG9ydCBNb3ZlT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uL21vdmVvcGVyYXRpb24nOwppbXBvcnQgUmVuYW1lT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uL3JlbmFtZW9wZXJhdGlvbic7CmltcG9ydCBSb290QXR0cmlidXRlT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uL3Jvb3RhdHRyaWJ1dGVvcGVyYXRpb24nOwppbXBvcnQgU3BsaXRPcGVyYXRpb24gZnJvbSAnLi9vcGVyYXRpb24vc3BsaXRvcGVyYXRpb24nOwppbXBvcnQgTWVyZ2VPcGVyYXRpb24gZnJvbSAnLi9vcGVyYXRpb24vbWVyZ2VvcGVyYXRpb24nOwppbXBvcnQgRG9jdW1lbnRGcmFnbWVudCBmcm9tICcuL2RvY3VtZW50ZnJhZ21lbnQnOwppbXBvcnQgVGV4dCBmcm9tICcuL3RleHQnOwppbXBvcnQgRWxlbWVudCBmcm9tICcuL2VsZW1lbnQnOwppbXBvcnQgUm9vdEVsZW1lbnQgZnJvbSAnLi9yb290ZWxlbWVudCc7CmltcG9ydCBQb3NpdGlvbiBmcm9tICcuL3Bvc2l0aW9uJzsKaW1wb3J0IFJhbmdlIGZyb20gJy4vcmFuZ2UuanMnOwppbXBvcnQgRG9jdW1lbnRTZWxlY3Rpb24gZnJvbSAnLi9kb2N1bWVudHNlbGVjdGlvbic7CmltcG9ydCB0b01hcCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy90b21hcCc7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwovKioKICogVGhlIG1vZGVsIGNhbiBvbmx5IGJlIG1vZGlmaWVkIGJ5IHVzaW5nIHRoZSB3cml0ZXIuIEl0IHNob3VsZCBiZSB1c2VkIHdoZW5ldmVyIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG5vZGUsIG1vZGlmeQogKiBjaGlsZCBub2RlcywgYXR0cmlidXRlcyBvciB0ZXh0LCBzZXQgdGhlIHNlbGVjdGlvbidzIHBvc2l0aW9uIGFuZCBpdHMgYXR0cmlidXRlcy4KICoKICogVGhlIGluc3RhbmNlIG9mIHRoZSB3cml0ZXIgaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NoYW5nZSBgY2hhbmdlKClgfSBvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNlbnF1ZXVlQ2hhbmdlIGBlbnF1ZXVlQ2hhbmdlKClgfS4KICoKICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICoJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHBhcmFncmFwaCwgJ2VuZCcgKTsKICoJCX0gKTsKICoKICogTm90ZSB0aGF0IHRoZSB3cml0ZXIgc2hvdWxkIG5ldmVyIGJlIHN0b3JlZCBhbmQgdXNlZCBvdXRzaWRlIG9mIHRoZSBgY2hhbmdlKClgIGFuZAogKiBgZW5xdWV1ZUNoYW5nZSgpYCBibG9ja3MuCiAqCiAqIE5vdGUgdGhhdCB3cml0ZXIncyBtZXRob2RzIGRvIG5vdCBjaGVjayB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYX0uIEl0IGlzIHBvc3NpYmxlCiAqIHRvIGNyZWF0ZSBpbmNvcnJlY3QgbW9kZWwgc3RydWN0dXJlcyBieSB1c2luZyB0aGUgd3JpdGVyLiBSZWFkIG1vcmUgYWJvdXQgaW4KICoge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2RlZXAtZGl2ZS9zY2hlbWEjd2hvLWNoZWNrcy10aGUtc2NoZW1hICJXaG8gY2hlY2tzIHRoZSBzY2hlbWE/In0uCiAqCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjaGFuZ2UKICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2VucXVldWVDaGFuZ2UKICovCgp2YXIgV3JpdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGEgd3JpdGVyIGluc3RhbmNlLgogICAqCiAgICogKipOb3RlOioqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byB1c2UgaXQgZGlyZWN0bHkuIFVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjaGFuZ2UgYE1vZGVsI2NoYW5nZSgpYH0gb3IKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNlbnF1ZXVlQ2hhbmdlIGBNb2RlbCNlbnF1ZXVlQ2hhbmdlKClgfSBpbnN0ZWFkLgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0gbW9kZWwKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvYmF0Y2h+QmF0Y2h9IGJhdGNoCiAgICovCiAgZnVuY3Rpb24gV3JpdGVyKG1vZGVsLCBiYXRjaCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdyaXRlcik7CgogICAgLyoqCiAgICAgKiBJbnN0YW5jZSBvZiB0aGUgbW9kZWwgb24gd2hpY2ggdGhpcyB3cml0ZXIgb3BlcmF0ZXMuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0KICAgICAqLwogICAgdGhpcy5tb2RlbCA9IG1vZGVsOwogICAgLyoqCiAgICAgKiBUaGUgYmF0Y2ggdG8gd2hpY2ggdGhpcyB3cml0ZXIgd2lsbCBhZGQgY2hhbmdlcy4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNofQogICAgICovCgogICAgdGhpcy5iYXRjaCA9IGJhdGNoOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCB0ZXh0IG5vZGV9LgogICAqCiAgICoJCXdyaXRlci5jcmVhdGVUZXh0KCAnZm9vJyApOwogICAqCQl3cml0ZXIuY3JlYXRlVGV4dCggJ2ZvbycsIHsgYm9sZDogdHJ1ZSB9ICk7CiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUZXh0IGRhdGEuCiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBUZXh0IGF0dHJpYnV0ZXMuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0fSBDcmVhdGVkIHRleHQgbm9kZS4KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhXcml0ZXIsIFt7CiAgICBrZXk6ICJjcmVhdGVUZXh0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZXh0KGRhdGEsIGF0dHJpYnV0ZXMpIHsKICAgICAgcmV0dXJuIG5ldyBUZXh0KGRhdGEsIGF0dHJpYnV0ZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fS4KICAgICAqCiAgICAgKgkJd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAgICAgKgkJd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnLCB7IGFsaWdubWVudDogJ2NlbnRlcicgfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnRzIGF0dHJpYnV0ZXMuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IENyZWF0ZWQgZWxlbWVudC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpIHsKICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBkb2N1bWVudCBmcmFnbWVudH0uCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBDcmVhdGVkIGRvY3VtZW50IGZyYWdtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSB7CiAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudCgpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgZWxlbWVudCBhbmQgcmV0dXJucyBpdC4gQ3JlYXRlZCBlbGVtZW50IGhhcyB0aGUgc2FtZSBuYW1lIGFuZCBhdHRyaWJ1dGVzIGFzIHRoZSBvcmlnaW5hbCBlbGVtZW50LgogICAgICogSWYgY2xvbmUgaXMgZGVlcCwgdGhlIG9yaWdpbmFsIGVsZW1lbnQncyBjaGlsZHJlbiBhcmUgYWxzbyBjbG9uZWQuIElmIG5vdCwgdGhlbiBlbXB0eSBlbGVtZW50IGlzIHJldHVybmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY2xvbmUuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWVwPXRydWVdIElmIHNldCB0byBgdHJ1ZWAgY2xvbmVzIGVsZW1lbnQgYW5kIGFsbCBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuIFdoZW4gc2V0IHRvIGBmYWxzZWAsCiAgICAgKiBlbGVtZW50IHdpbGwgYmUgY2xvbmVkIHdpdGhvdXQgYW55IGNoaWxkLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNsb25lRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQpIHsKICAgICAgdmFyIGRlZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7CiAgICAgIHJldHVybiBlbGVtZW50Ll9jbG9uZShkZWVwKTsKICAgIH0KICAgIC8qKgogICAgICogSW5zZXJ0cyBpdGVtIG9uIGdpdmVuIHBvc2l0aW9uLgogICAgICoKICAgICAqCQljb25zdCBwYXJhZ3JhcGggPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgICAqCQl3cml0ZXIuaW5zZXJ0KCBwYXJhZ3JhcGgsIHBvc2l0aW9uICk7CiAgICAgKgogICAgICogSW5zdGVhZCBvZiB1c2luZyBwb3NpdGlvbiB5b3UgY2FuIHVzZSBwYXJlbnQgYW5kIG9mZnNldDoKICAgICAqCiAgICAgKgkJY29uc3QgdGV4dCA9IHdyaXRlci5jcmVhdGVUZXh0KCAnZm9vJyApOwogICAgICoJCXdyaXRlci5pbnNlcnQoIHRleHQsIHBhcmFncmFwaCwgNSApOwogICAgICoKICAgICAqIFlvdSBjYW4gYWxzbyB1c2UgYGVuZGAgaW5zdGVhZCBvZiB0aGUgb2Zmc2V0IHRvIGluc2VydCBhdCB0aGUgZW5kOgogICAgICoKICAgICAqCQljb25zdCB0ZXh0ID0gd3JpdGVyLmNyZWF0ZVRleHQoICdmb28nICk7CiAgICAgKgkJd3JpdGVyLmluc2VydCggdGV4dCwgcGFyYWdyYXBoLCAnZW5kJyApOwogICAgICoKICAgICAqIE9yIGluc2VydCBiZWZvcmUgb3IgYWZ0ZXIgYW5vdGhlciBlbGVtZW50OgogICAgICoKICAgICAqCQljb25zdCBwYXJhZ3JhcGggPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgICAqCQl3cml0ZXIuaW5zZXJ0KCBwYXJhZ3JhcGgsIGFub3RoZXJQYXJhZ3JhcGgsICdhZnRlcicgKTsKICAgICAqCiAgICAgKiBUaGVzZSBwYXJhbWV0ZXJzIHdvcmtzIHRoZSBzYW1lIHdheSBhcyB7QGxpbmsgI2NyZWF0ZVBvc2l0aW9uQXQgYHdyaXRlci5jcmVhdGVQb3NpdGlvbkF0KClgfS4KICAgICAqCiAgICAgKiBOb3RlIHRoYXQgaWYgdGhlIGl0ZW0gYWxyZWFkeSBoYXMgcGFyZW50IGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBwcmV2aW91cyBwYXJlbnQuCiAgICAgKgogICAgICogTm90ZSB0aGF0IHlvdSBjYW5ub3QgcmUtaW5zZXJ0IGEgbm9kZSBmcm9tIGEgZG9jdW1lbnQgdG8gYSBkaWZmZXJlbnQgZG9jdW1lbnQgb3IgYSBkb2N1bWVudCBmcmFnbWVudC4gSW4gdGhpcyBjYXNlLAogICAgICogYG1vZGVsLXdyaXRlci1pbnNlcnQtZm9yYmlkZGVuLW1vdmVgIGlzIHRocm93bi4KICAgICAqCiAgICAgKiBJZiB5b3Ugd2FudCB0byBtb3ZlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfSBpbnN0ZWFkIG9mIGFuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gaXRlbX0gdXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjbW92ZSBgV3JpdGVyI21vdmUoKWB9LgogICAgICoKICAgICAqICoqTm90ZToqKiBGb3IgYSBwYXN0ZS1saWtlIGNvbnRlbnQgaW5zZXJ0aW9uIG1lY2hhbmlzbSBzZWUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2luc2VydENvbnRlbnQgYG1vZGVsLmluc2VydENvbnRlbnQoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGl0ZW0gSXRlbSBvciBkb2N1bWVudAogICAgICogZnJhZ21lbnQgdG8gaW5zZXJ0LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBpdGVtT3JQb3NpdGlvbgogICAgICogQHBhcmFtIHtOdW1iZXJ8J2VuZCd8J2JlZm9yZSd8J2FmdGVyJ30gW29mZnNldF0gT2Zmc2V0IG9yIG9uZSBvZiB0aGUgZmxhZ3MuIFVzZWQgb25seSB3aGVuCiAgICAgKiBzZWNvbmQgcGFyYW1ldGVyIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICovCgogIH0sIHsKICAgIGtleTogImluc2VydCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KGl0ZW0sIGl0ZW1PclBvc2l0aW9uKSB7CiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7CgogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHQgJiYgaXRlbS5kYXRhID09ICcnKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgcG9zaXRpb24gPSBQb3NpdGlvbi5fY3JlYXRlQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCk7IC8vIElmIGl0ZW0gaGFzIGEgcGFyZW50IGFscmVhZHkuCgoKICAgICAgaWYgKGl0ZW0ucGFyZW50KSB7CiAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBpdGVtIGlzIGdvaW5nIHRvIGJlIGluc2VydGVkIHdpdGhpbiB0aGUgc2FtZSBkb2N1bWVudC4KICAgICAgICBpZiAoaXNTYW1lVHJlZShpdGVtLnJvb3QsIHBvc2l0aW9uLnJvb3QpKSB7CiAgICAgICAgICAvLyBJZiBpdCdzIHdlIGp1c3QgbmVlZCB0byBtb3ZlIGl0LgogICAgICAgICAgdGhpcy5tb3ZlKFJhbmdlLl9jcmVhdGVPbihpdGVtKSwgcG9zaXRpb24pOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0gLy8gSWYgaXQgaXNuJ3QgdGhlIHNhbWUgcm9vdC4KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgaWYgKGl0ZW0ucm9vdC5kb2N1bWVudCkgewogICAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgICAqIENhbm5vdCBtb3ZlIGEgbm9kZSBmcm9tIGEgZG9jdW1lbnQgdG8gYSBkaWZmZXJlbnQgdHJlZS4KICAgICAgICAgICAgICAgKiBJdCBpcyBmb3JiaWRkZW4gdG8gbW92ZSBhIG5vZGUgdGhhdCB3YXMgYWxyZWFkeSBpbiBhIGRvY3VtZW50IG91dHNpZGUgb2YgaXQuCiAgICAgICAgICAgICAgICoKICAgICAgICAgICAgICAgKiBAZXJyb3IgbW9kZWwtd3JpdGVyLWluc2VydC1mb3JiaWRkZW4tbW92ZQogICAgICAgICAgICAgICAqLwogICAgICAgICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC13cml0ZXItaW5zZXJ0LWZvcmJpZGRlbi1tb3ZlJywgdGhpcyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgLy8gTW92ZSBiZXR3ZWVuIHR3byBkaWZmZXJlbnQgZG9jdW1lbnQgZnJhZ21lbnRzIG9yIGZyb20gZG9jdW1lbnQgZnJhZ21lbnQgdG8gYSBkb2N1bWVudCBpcyBwb3NzaWJsZS4KICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHJlbW92ZSB0aGUgaXRlbSBmcm9tIGl0J3Mgb3JpZ2luYWwgcGFyZW50LgogICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGl0ZW0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciB2ZXJzaW9uID0gcG9zaXRpb24ucm9vdC5kb2N1bWVudCA/IHBvc2l0aW9uLnJvb3QuZG9jdW1lbnQudmVyc2lvbiA6IG51bGw7CiAgICAgIHZhciBpbnNlcnQgPSBuZXcgSW5zZXJ0T3BlcmF0aW9uKHBvc2l0aW9uLCBpdGVtLCB2ZXJzaW9uKTsKCiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dCkgewogICAgICAgIGluc2VydC5zaG91bGRSZWNlaXZlQXR0cmlidXRlcyA9IHRydWU7CiAgICAgIH0KCiAgICAgIHRoaXMuYmF0Y2guYWRkT3BlcmF0aW9uKGluc2VydCk7CiAgICAgIHRoaXMubW9kZWwuYXBwbHlPcGVyYXRpb24oaW5zZXJ0KTsgLy8gV2hlbiBlbGVtZW50IGlzIGEgRG9jdW1lbnRGcmFnbWVudCB3ZSBuZWVkIHRvIG1vdmUgaXRzIG1hcmtlcnMgdG8gRG9jdW1lbnQjbWFya2Vycy4KCiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkgewogICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVtLm1hcmtlcnMpLAogICAgICAgICAgICBfc3RlcDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSwKICAgICAgICAgICAgICAgIG1hcmtlck5hbWUgPSBfc3RlcCR2YWx1ZVswXSwKICAgICAgICAgICAgICAgIG1hcmtlclJhbmdlID0gX3N0ZXAkdmFsdWVbMV07CgogICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1pZ3JhdGUgbWFya2VyIHJhbmdlIGZyb20gRG9jdW1lbnRGcmFnbWVudCB0byBEb2N1bWVudC4KICAgICAgICAgICAgdmFyIHJhbmdlUm9vdFBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUF0KG1hcmtlclJhbmdlLnJvb3QsIDApOwoKICAgICAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKG1hcmtlclJhbmdlLnN0YXJ0Ll9nZXRDb21iaW5lZChyYW5nZVJvb3RQb3NpdGlvbiwgcG9zaXRpb24pLCBtYXJrZXJSYW5nZS5lbmQuX2dldENvbWJpbmVkKHJhbmdlUm9vdFBvc2l0aW9uLCBwb3NpdGlvbikpOwogICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHsKICAgICAgICAgICAgICByYW5nZTogcmFuZ2UsCiAgICAgICAgICAgICAgdXNpbmdPcGVyYXRpb246IHRydWUsCiAgICAgICAgICAgICAgYWZmZWN0c0RhdGE6IHRydWUKICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLm1hcmtlcnMuaGFzKG1hcmtlck5hbWUpKSB7CiAgICAgICAgICAgICAgdGhpcy51cGRhdGVNYXJrZXIobWFya2VyTmFtZSwgb3B0aW9ucyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhpcy5hZGRNYXJrZXIobWFya2VyTmFtZSwgb3B0aW9ucyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIF9pdGVyYXRvci5mKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYW5kIGluc2VydHMgdGV4dCBvbiBnaXZlbiBwb3NpdGlvbi4gWW91IGNhbiBvcHRpb25hbGx5IHNldCB0ZXh0IGF0dHJpYnV0ZXM6CiAgICAgKgogICAgICoJCXdyaXRlci5pbnNlcnRUZXh0KCAnZm9vJywgcG9zaXRpb24gKTsKICAgICAqCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHsgYm9sZDogdHJ1ZSB9LCBwb3NpdGlvbiApOwogICAgICoKICAgICAqIEluc3RlYWQgb2YgdXNpbmcgcG9zaXRpb24geW91IGNhbiB1c2UgcGFyZW50IGFuZCBvZmZzZXQgb3IgZGVmaW5lIHRoYXQgdGV4dCBzaG91bGQgYmUgaW5zZXJ0ZWQgYXQgdGhlIGVuZAogICAgICogb3IgYmVmb3JlIG9yIGFmdGVyIG90aGVyIG5vZGU6CiAgICAgKgogICAgICoJCS8vIEluc2VydHMgJ2ZvbycgaW4gcGFyYWdyYXBoLCBhdCBvZmZzZXQgNToKICAgICAqCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHBhcmFncmFwaCwgNSApOwogICAgICoJCS8vIEluc2VydHMgJ2ZvbycgYXQgdGhlIGVuZCBvZiBhIHBhcmFncmFwaDoKICAgICAqCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHBhcmFncmFwaCwgJ2VuZCcgKTsKICAgICAqCQkvLyBJbnNlcnRzICdmb28nIGFmdGVyIGFuIGltYWdlOgogICAgICoJCXdyaXRlci5pbnNlcnRUZXh0KCAnZm9vJywgaW1hZ2UsICdhZnRlcicgKTsKICAgICAqCiAgICAgKiBUaGVzZSBwYXJhbWV0ZXJzIHdvcmsgaW4gdGhlIHNhbWUgd2F5IGFzIHtAbGluayAjY3JlYXRlUG9zaXRpb25BdCBgd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRleHQgZGF0YS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gVGV4dCBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBpdGVtT3JQb3NpdGlvbgogICAgICogQHBhcmFtIHtOdW1iZXJ8J2VuZCd8J2JlZm9yZSd8J2FmdGVyJ30gW29mZnNldF0gT2Zmc2V0IG9yIG9uZSBvZiB0aGUgZmxhZ3MuIFVzZWQgb25seSB3aGVuCiAgICAgKiB0aGlyZCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaW5zZXJ0VGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0VGV4dCh0ZXh0LCBhdHRyaWJ1dGVzLCBpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIGlmIChhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCBhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRWxlbWVudCB8fCBhdHRyaWJ1dGVzIGluc3RhbmNlb2YgUG9zaXRpb24pIHsKICAgICAgICB0aGlzLmluc2VydCh0aGlzLmNyZWF0ZVRleHQodGV4dCksIGF0dHJpYnV0ZXMsIGl0ZW1PclBvc2l0aW9uKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmluc2VydCh0aGlzLmNyZWF0ZVRleHQodGV4dCwgYXR0cmlidXRlcyksIGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYW5kIGluc2VydHMgZWxlbWVudCBvbiBnaXZlbiBwb3NpdGlvbi4gWW91IGNhbiBvcHRpb25hbGx5IHNldCBhdHRyaWJ1dGVzOgogICAgICoKICAgICAqCQl3cml0ZXIuaW5zZXJ0RWxlbWVudCggJ3BhcmFncmFwaCcsIHBvc2l0aW9uICk7CiAgICAgKgkJd3JpdGVyLmluc2VydEVsZW1lbnQoICdwYXJhZ3JhcGgnLCB7IGFsaWdubWVudDogJ2NlbnRlcicgfSwgcG9zaXRpb24gKTsKICAgICAqCiAgICAgKiBJbnN0ZWFkIG9mIHVzaW5nIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHBhcmVudCBhbmQgb2Zmc2V0IG9yIGRlZmluZSB0aGF0IHRleHQgc2hvdWxkIGJlIGluc2VydGVkIGF0IHRoZSBlbmQKICAgICAqIG9yIGJlZm9yZSBvciBhZnRlciBvdGhlciBub2RlOgogICAgICoKICAgICAqCQkvLyBJbnNlcnRzIHBhcmFncmFwaCBpbiB0aGUgcm9vdCBhdCBvZmZzZXQgNToKICAgICAqCQl3cml0ZXIuaW5zZXJ0RWxlbWVudCggJ3BhcmFncmFwaCcsIHJvb3QsIDUgKTsKICAgICAqCQkvLyBJbnNlcnRzIHBhcmFncmFwaCBhdCB0aGUgZW5kIG9mIGEgYmxvY2txdW90ZToKICAgICAqCQl3cml0ZXIuaW5zZXJ0RWxlbWVudCggJ3BhcmFncmFwaCcsIGJsb2NrcXVvdGUsICdlbmQnICk7CiAgICAgKgkJLy8gSW5zZXJ0cyBhZnRlciBhbiBpbWFnZToKICAgICAqCQl3cml0ZXIuaW5zZXJ0RWxlbWVudCggJ3BhcmFncmFwaCcsIGltYWdlLCAnYWZ0ZXInICk7CiAgICAgKgogICAgICogVGhlc2UgcGFyYW1ldGVycyB3b3JrcyB0aGUgc2FtZSB3YXkgYXMge0BsaW5rICNjcmVhdGVQb3NpdGlvbkF0IGB3cml0ZXIuY3JlYXRlUG9zaXRpb25BdCgpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudHMgYXR0cmlidXRlcy4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaXRlbU9yUG9zaXRpb24KICAgICAqIEBwYXJhbSB7TnVtYmVyfCdlbmQnfCdiZWZvcmUnfCdhZnRlcid9IFtvZmZzZXRdIE9mZnNldCBvciBvbmUgb2YgdGhlIGZsYWdzLiBVc2VkIG9ubHkgd2hlbgogICAgICogdGhpcmQgcGFyYW1ldGVyIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICovCgogIH0sIHsKICAgIGtleTogImluc2VydEVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgaXRlbU9yUG9zaXRpb24sIG9mZnNldCkgewogICAgICBpZiAoYXR0cmlidXRlcyBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgfHwgYXR0cmlidXRlcyBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgYXR0cmlidXRlcyBpbnN0YW5jZW9mIFBvc2l0aW9uKSB7CiAgICAgICAgdGhpcy5pbnNlcnQodGhpcy5jcmVhdGVFbGVtZW50KG5hbWUpLCBhdHRyaWJ1dGVzLCBpdGVtT3JQb3NpdGlvbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5pbnNlcnQodGhpcy5jcmVhdGVFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpLCBpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBJbnNlcnRzIGl0ZW0gYXQgdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gcGFyZW50LgogICAgICoKICAgICAqCQljb25zdCBwYXJhZ3JhcGggPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgICAqCQl3cml0ZXIuYXBwZW5kKCBwYXJhZ3JhcGgsIHJvb3QgKTsKICAgICAqCiAgICAgKiBOb3RlIHRoYXQgaWYgdGhlIGl0ZW0gYWxyZWFkeSBoYXMgcGFyZW50IGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBwcmV2aW91cyBwYXJlbnQuCiAgICAgKgogICAgICogSWYgeW91IHdhbnQgdG8gbW92ZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZX0gaW5zdGVhZCBvZiBhbgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIGl0ZW19IHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI21vdmUgYFdyaXRlciNtb3ZlKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICogaXRlbSBJdGVtIG9yIGRvY3VtZW50IGZyYWdtZW50IHRvIGluc2VydC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHBhcmVudAogICAgICovCgogIH0sIHsKICAgIGtleTogImFwcGVuZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKGl0ZW0sIHBhcmVudCkgewogICAgICB0aGlzLmluc2VydChpdGVtLCBwYXJlbnQsICdlbmQnKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyB0ZXh0IG5vZGUgYW5kIGluc2VydHMgaXQgYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50LiBZb3UgY2FuIG9wdGlvbmFsbHkgc2V0IHRleHQgYXR0cmlidXRlczoKICAgICAqCiAgICAgKgkJd3JpdGVyLmFwcGVuZFRleHQoICdmb28nLCBwYXJhZ3JhcGggKTsKICAgICAqCQl3cml0ZXIuYXBwZW5kVGV4dCggJ2ZvbycsIHsgYm9sZDogdHJ1ZSB9LCBwYXJhZ3JhcGggKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IGRhdGEuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIFRleHQgYXR0cmlidXRlcy4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHBhcmVudAogICAgICovCgogIH0sIHsKICAgIGtleTogImFwcGVuZFRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFRleHQodGV4dCwgYXR0cmlidXRlcywgcGFyZW50KSB7CiAgICAgIGlmIChhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCBhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRWxlbWVudCkgewogICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuY3JlYXRlVGV4dCh0ZXh0KSwgYXR0cmlidXRlcywgJ2VuZCcpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuY3JlYXRlVGV4dCh0ZXh0LCBhdHRyaWJ1dGVzKSwgcGFyZW50LCAnZW5kJyk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBlbGVtZW50IGFuZCBpbnNlcnRzIGl0IGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudC4gWW91IGNhbiBvcHRpb25hbGx5IHNldCBhdHRyaWJ1dGVzOgogICAgICoKICAgICAqCQl3cml0ZXIuYXBwZW5kRWxlbWVudCggJ3BhcmFncmFwaCcsIHJvb3QgKTsKICAgICAqCQl3cml0ZXIuYXBwZW5kRWxlbWVudCggJ3BhcmFncmFwaCcsIHsgYWxpZ25tZW50OiAnY2VudGVyJyB9LCByb290ICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudHMgYXR0cmlidXRlcy4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHBhcmVudAogICAgICovCgogIH0sIHsKICAgIGtleTogImFwcGVuZEVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgcGFyZW50KSB7CiAgICAgIGlmIChhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCBhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRWxlbWVudCkgewogICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuY3JlYXRlRWxlbWVudChuYW1lKSwgYXR0cmlidXRlcywgJ2VuZCcpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuY3JlYXRlRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKSwgcGFyZW50LCAnZW5kJyk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU2V0cyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHdpdGggZ2l2ZW4ga2V5IG9uIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19CiAgICAgKiBvciBvbiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEF0dHJpYnV0ZSBrZXkuCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEF0dHJpYnV0ZSBuZXcgdmFsdWUuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IGl0ZW1PclJhbmdlCiAgICAgKiBNb2RlbCBpdGVtIG9yIHJhbmdlIG9uIHdoaWNoIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0QXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSwgaXRlbU9yUmFuZ2UpIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgaWYgKGl0ZW1PclJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHsKICAgICAgICB2YXIgcmFuZ2VzID0gaXRlbU9yUmFuZ2UuZ2V0TWluaW1hbEZsYXRSYW5nZXMoKTsKCiAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyYW5nZXMpLAogICAgICAgICAgICBfc3RlcDI7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykgewogICAgICAgICAgICB2YXIgcmFuZ2UgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgICAgIHNldEF0dHJpYnV0ZU9uUmFuZ2UodGhpcywga2V5LCB2YWx1ZSwgcmFuZ2UpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIF9pdGVyYXRvcjIuZigpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBzZXRBdHRyaWJ1dGVPbkl0ZW0odGhpcywga2V5LCB2YWx1ZSwgaXRlbU9yUmFuZ2UpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdmFsdWVzIG9mIGF0dHJpYnV0ZXMgb24gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0KICAgICAqIG9yIG9uIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UgcmFuZ2V9LgogICAgICoKICAgICAqCQl3cml0ZXIuc2V0QXR0cmlidXRlcyggewogICAgICoJCQlib2xkOiB0cnVlLAogICAgICoJCQlpdGFsaWM6IHRydWUKICAgICAqCQl9LCByYW5nZSApOwogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZXMga2V5cyBhbmQgdmFsdWVzLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpdGVtT3JSYW5nZQogICAgICogTW9kZWwgaXRlbSBvciByYW5nZSBvbiB3aGljaCB0aGUgYXR0cmlidXRlcyB3aWxsIGJlIHNldC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRBdHRyaWJ1dGVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGl0ZW1PclJhbmdlKSB7CiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodG9NYXAoYXR0cmlidXRlcykpLAogICAgICAgICAgX3N0ZXAzOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykgewogICAgICAgICAgdmFyIF9zdGVwMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMy52YWx1ZSwgMiksCiAgICAgICAgICAgICAga2V5ID0gX3N0ZXAzJHZhbHVlWzBdLAogICAgICAgICAgICAgIHZhbCA9IF9zdGVwMyR2YWx1ZVsxXTsKCiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHZhbCwgaXRlbU9yUmFuZ2UpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkgZnJvbSBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfQogICAgICogb3IgZnJvbSBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEF0dHJpYnV0ZSBrZXkuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IGl0ZW1PclJhbmdlCiAgICAgKiBNb2RlbCBpdGVtIG9yIHJhbmdlIGZyb20gd2hpY2ggdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoa2V5LCBpdGVtT3JSYW5nZSkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoaXRlbU9yUmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkgewogICAgICAgIHZhciByYW5nZXMgPSBpdGVtT3JSYW5nZS5nZXRNaW5pbWFsRmxhdFJhbmdlcygpOwoKICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJhbmdlcyksCiAgICAgICAgICAgIF9zdGVwNDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgIHZhciByYW5nZSA9IF9zdGVwNC52YWx1ZTsKICAgICAgICAgICAgc2V0QXR0cmlidXRlT25SYW5nZSh0aGlzLCBrZXksIG51bGwsIHJhbmdlKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3I0LmYoKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc2V0QXR0cmlidXRlT25JdGVtKHRoaXMsIGtleSwgbnVsbCwgaXRlbU9yUmFuZ2UpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIGF0dHJpYnV0ZXMgZnJvbSBhbGwgZWxlbWVudHMgaW4gdGhlIHJhbmdlIG9yIGZyb20gdGhlIGdpdmVuIGl0ZW0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpdGVtT3JSYW5nZQogICAgICogTW9kZWwgaXRlbSBvciByYW5nZSBmcm9tIHdoaWNoIGFsbCBhdHRyaWJ1dGVzIHdpbGwgYmUgcmVtb3ZlZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjbGVhckF0dHJpYnV0ZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQXR0cmlidXRlcyhpdGVtT3JSYW5nZSkgewogICAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgdmFyIHJlbW92ZUF0dHJpYnV0ZXNGcm9tSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZXNGcm9tSXRlbShpdGVtKSB7CiAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVtLmdldEF0dHJpYnV0ZUtleXMoKSksCiAgICAgICAgICAgIF9zdGVwNTsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBfc3RlcDUudmFsdWU7CgogICAgICAgICAgICBfdGhpcy5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlLCBpdGVtKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3I1LmYoKTsKICAgICAgICB9CiAgICAgIH07CgogICAgICBpZiAoIShpdGVtT3JSYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkgewogICAgICAgIHJlbW92ZUF0dHJpYnV0ZXNGcm9tSXRlbShpdGVtT3JSYW5nZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVtT3JSYW5nZS5nZXRJdGVtcygpKSwKICAgICAgICAgICAgX3N0ZXA2OwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDYudmFsdWU7CiAgICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZXNGcm9tSXRlbShpdGVtKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3I2LmYoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogTW92ZXMgYWxsIGl0ZW1zIGluIHRoZSBzb3VyY2UgcmFuZ2UgdG8gdGhlIHRhcmdldCBwb3NpdGlvbi4KICAgICAqCiAgICAgKgkJd3JpdGVyLm1vdmUoIHNvdXJjZVJhbmdlLCB0YXJnZXRQb3NpdGlvbiApOwogICAgICoKICAgICAqIEluc3RlYWQgb2YgdGhlIHRhcmdldCBwb3NpdGlvbiB5b3UgY2FuIHVzZSBwYXJlbnQgYW5kIG9mZnNldCBvciBkZWZpbmUgdGhhdCByYW5nZSBzaG91bGQgYmUgbW92ZWQgdG8gdGhlIGVuZAogICAgICogb3IgYmVmb3JlIG9yIGFmdGVyIGNob3NlbiBpdGVtOgogICAgICoKICAgICAqCQkvLyBNb3ZlcyBhbGwgaXRlbXMgaW4gdGhlIHJhbmdlIHRvIHRoZSBwYXJhZ3JhcGggYXQgb2Zmc2V0IDU6CiAgICAgKgkJd3JpdGVyLm1vdmUoIHNvdXJjZVJhbmdlLCBwYXJhZ3JhcGgsIDUgKTsKICAgICAqCQkvLyBNb3ZlcyBhbGwgaXRlbXMgaW4gdGhlIHJhbmdlIHRvIHRoZSBlbmQgb2YgYSBibG9ja3F1b3RlOgogICAgICoJCXdyaXRlci5tb3ZlKCBzb3VyY2VSYW5nZSwgYmxvY2txdW90ZSwgJ2VuZCcgKTsKICAgICAqCQkvLyBNb3ZlcyBhbGwgaXRlbXMgaW4gdGhlIHJhbmdlIHRvIGEgcG9zaXRpb24gYWZ0ZXIgYW4gaW1hZ2U6CiAgICAgKgkJd3JpdGVyLm1vdmUoIHNvdXJjZVJhbmdlLCBpbWFnZSwgJ2FmdGVyJyApOwogICAgICoKICAgICAqIFRoZXNlIHBhcmFtZXRlcnMgd29ya3MgdGhlIHNhbWUgd2F5IGFzIHtAbGluayAjY3JlYXRlUG9zaXRpb25BdCBgd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoKWB9LgogICAgICoKICAgICAqIE5vdGUgdGhhdCBpdGVtcyBjYW4gYmUgbW92ZWQgb25seSB3aXRoaW4gdGhlIHNhbWUgdHJlZS4gSXQgbWVhbnMgdGhhdCB5b3UgY2FuIG1vdmUgaXRlbXMgd2l0aGluIHRoZSBzYW1lIHJvb3QKICAgICAqIChlbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50KSBvciBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3Jvb3RzIGRvY3VtZW50cyByb290c30sCiAgICAgKiBidXQgeW91IGNhbiBub3QgbW92ZSBpdGVtcyBmcm9tIGRvY3VtZW50IGZyYWdtZW50IHRvIHRoZSBkb2N1bWVudCBvciBmcm9tIG9uZSBkZXRhY2hlZCBlbGVtZW50IHRvIGFub3RoZXIuIFVzZQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNpbnNlcnR9IGluIHN1Y2ggY2FzZXMuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBTb3VyY2UgcmFuZ2UuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgICAqIHNlY29uZCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibW92ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShyYW5nZSwgaXRlbU9yUG9zaXRpb24sIG9mZnNldCkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkgewogICAgICAgIC8qKgogICAgICAgICAqIEludmFsaWQgcmFuZ2UgdG8gbW92ZS4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItbW92ZS1pbnZhbGlkLXJhbmdlCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1tb3ZlLWludmFsaWQtcmFuZ2UnLCB0aGlzKTsKICAgICAgfQoKICAgICAgaWYgKCFyYW5nZS5pc0ZsYXQpIHsKICAgICAgICAvKioKICAgICAgICAgKiBSYW5nZSB0byBtb3ZlIGlzIG5vdCBmbGF0LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci1tb3ZlLXJhbmdlLW5vdC1mbGF0CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1tb3ZlLXJhbmdlLW5vdC1mbGF0JywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHZhciBwb3NpdGlvbiA9IFBvc2l0aW9uLl9jcmVhdGVBdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KTsgLy8gRG8gbm90IG1vdmUgYW55dGhpbmcgaWYgdGhlIG1vdmUgdGFyZ2V0IGlzIHNhbWUgYXMgbW92ZWQgcmFuZ2Ugc3RhcnQuCgoKICAgICAgaWYgKHBvc2l0aW9uLmlzRXF1YWwocmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIElmIHBhcnQgb2YgdGhlIG1hcmtlciBpcyByZW1vdmVkLCBjcmVhdGUgYWRkaXRpb25hbCBtYXJrZXIgb3BlcmF0aW9uIGZvciB1bmRvIHB1cnBvc2VzLgoKCiAgICAgIHRoaXMuX2FkZE9wZXJhdGlvbkZvckFmZmVjdGVkTWFya2VycygnbW92ZScsIHJhbmdlKTsKCiAgICAgIGlmICghaXNTYW1lVHJlZShyYW5nZS5yb290LCBwb3NpdGlvbi5yb290KSkgewogICAgICAgIC8qKgogICAgICAgICAqIFJhbmdlIGlzIGdvaW5nIHRvIGJlIG1vdmVkIHdpdGhpbiBub3QgdGhlIHNhbWUgZG9jdW1lbnQuIFBsZWFzZSB1c2UKICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2luc2VydCBpbnNlcnR9IGluc3RlYWQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLW1vdmUtZGlmZmVyZW50LWRvY3VtZW50CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1tb3ZlLWRpZmZlcmVudC1kb2N1bWVudCcsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgdmVyc2lvbiA9IHJhbmdlLnJvb3QuZG9jdW1lbnQgPyByYW5nZS5yb290LmRvY3VtZW50LnZlcnNpb24gOiBudWxsOwogICAgICB2YXIgb3BlcmF0aW9uID0gbmV3IE1vdmVPcGVyYXRpb24ocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZC5vZmZzZXQgLSByYW5nZS5zdGFydC5vZmZzZXQsIHBvc2l0aW9uLCB2ZXJzaW9uKTsKICAgICAgdGhpcy5iYXRjaC5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgICAgdGhpcy5tb2RlbC5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGdpdmVuIG1vZGVsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBpdGVtfSBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpdGVtT3JSYW5nZSBNb2RlbCBpdGVtIG9yIHJhbmdlIHRvIHJlbW92ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZW1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShpdGVtT3JSYW5nZSkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICB2YXIgcmFuZ2VUb1JlbW92ZSA9IGl0ZW1PclJhbmdlIGluc3RhbmNlb2YgUmFuZ2UgPyBpdGVtT3JSYW5nZSA6IFJhbmdlLl9jcmVhdGVPbihpdGVtT3JSYW5nZSk7CiAgICAgIHZhciByYW5nZXMgPSByYW5nZVRvUmVtb3ZlLmdldE1pbmltYWxGbGF0UmFuZ2VzKCkucmV2ZXJzZSgpOwoKICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyYW5nZXMpLAogICAgICAgICAgX3N0ZXA3OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGZsYXQgPSBfc3RlcDcudmFsdWU7CgogICAgICAgICAgLy8gSWYgcGFydCBvZiB0aGUgbWFya2VyIGlzIHJlbW92ZWQsIGNyZWF0ZSBhZGRpdGlvbmFsIG1hcmtlciBvcGVyYXRpb24gZm9yIHVuZG8gcHVycG9zZXMuCiAgICAgICAgICB0aGlzLl9hZGRPcGVyYXRpb25Gb3JBZmZlY3RlZE1hcmtlcnMoJ21vdmUnLCBmbGF0KTsKCiAgICAgICAgICBhcHBseVJlbW92ZU9wZXJhdGlvbihmbGF0LnN0YXJ0LCBmbGF0LmVuZC5vZmZzZXQgLSBmbGF0LnN0YXJ0Lm9mZnNldCwgdGhpcy5iYXRjaCwgdGhpcy5tb2RlbCk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I3LmYoKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBNZXJnZXMgdHdvIHNpYmxpbmdzIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBOb2RlIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHBvc2l0aW9uIGhhdmUgdG8gYmUgYW4gZWxlbWVudC4gT3RoZXJ3aXNlIGB3cml0ZXItbWVyZ2Utbm8tZWxlbWVudC1iZWZvcmVgIG9yCiAgICAgKiBgd3JpdGVyLW1lcmdlLW5vLWVsZW1lbnQtYWZ0ZXJgIGVycm9yIHdpbGwgYmUgdGhyb3duLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gYmV0d2VlbiBtZXJnZWQgZWxlbWVudHMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibWVyZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKHBvc2l0aW9uKSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIHZhciBub2RlQmVmb3JlID0gcG9zaXRpb24ubm9kZUJlZm9yZTsKICAgICAgdmFyIG5vZGVBZnRlciA9IHBvc2l0aW9uLm5vZGVBZnRlcjsgLy8gSWYgcGFydCBvZiB0aGUgbWFya2VyIGlzIHJlbW92ZWQsIGNyZWF0ZSBhZGRpdGlvbmFsIG1hcmtlciBvcGVyYXRpb24gZm9yIHVuZG8gcHVycG9zZXMuCgogICAgICB0aGlzLl9hZGRPcGVyYXRpb25Gb3JBZmZlY3RlZE1hcmtlcnMoJ21lcmdlJywgcG9zaXRpb24pOwoKICAgICAgaWYgKCEobm9kZUJlZm9yZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogTm9kZSBiZWZvcmUgbWVyZ2UgcG9zaXRpb24gbXVzdCBiZSBhbiBlbGVtZW50LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci1tZXJnZS1uby1lbGVtZW50LWJlZm9yZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItbWVyZ2Utbm8tZWxlbWVudC1iZWZvcmUnLCB0aGlzKTsKICAgICAgfQoKICAgICAgaWYgKCEobm9kZUFmdGVyIGluc3RhbmNlb2YgRWxlbWVudCkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBOb2RlIGFmdGVyIG1lcmdlIHBvc2l0aW9uIG11c3QgYmUgYW4gZWxlbWVudC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItbWVyZ2Utbm8tZWxlbWVudC1hZnRlcgogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItbWVyZ2Utbm8tZWxlbWVudC1hZnRlcicsIHRoaXMpOwogICAgICB9CgogICAgICBpZiAoIXBvc2l0aW9uLnJvb3QuZG9jdW1lbnQpIHsKICAgICAgICB0aGlzLl9tZXJnZURldGFjaGVkKHBvc2l0aW9uKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLl9tZXJnZShwb3NpdGlvbik7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU2hvcnRjdXQgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NyZWF0ZVBvc2l0aW9uRnJvbVBhdGggYE1vZGVsI2NyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHJvb3QgUm9vdCBvZiB0aGUgcG9zaXRpb24uCiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSBwYXRoIFBvc2l0aW9uIHBhdGguIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRofS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblN0aWNraW5lc3N9IFtzdGlja2luZXNzPSd0b05vbmUnXSBQb3NpdGlvbiBzdGlja2luZXNzLgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVQb3NpdGlvbkZyb21QYXRoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkZyb21QYXRoKHJvb3QsIHBhdGgsIHN0aWNraW5lc3MpIHsKICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aChyb290LCBwYXRoLCBzdGlja2luZXNzKTsKICAgIH0KICAgIC8qKgogICAgICogU2hvcnRjdXQgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NyZWF0ZVBvc2l0aW9uQXQgYE1vZGVsI2NyZWF0ZVBvc2l0aW9uQXQoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaXRlbU9yUG9zaXRpb24KICAgICAqIEBwYXJhbSB7TnVtYmVyfCdlbmQnfCdiZWZvcmUnfCdhZnRlcid9IFtvZmZzZXRdIE9mZnNldCBvciBvbmUgb2YgdGhlIGZsYWdzLiBVc2VkIG9ubHkgd2hlbgogICAgICogZmlyc3QgcGFyYW1ldGVyIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25BdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25BdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZVBvc2l0aW9uQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCk7CiAgICB9CiAgICAvKioKICAgICAqIFNob3J0Y3V0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkFmdGVyIGBNb2RlbCNjcmVhdGVQb3NpdGlvbkFmdGVyKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtIEl0ZW0gYWZ0ZXIgd2hpY2ggdGhlIHBvc2l0aW9uIHNob3VsZCBiZSBwbGFjZWQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVQb3NpdGlvbkFmdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkFmdGVyKGl0ZW0pIHsKICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY3JlYXRlUG9zaXRpb25BZnRlcihpdGVtKTsKICAgIH0KICAgIC8qKgogICAgICogU2hvcnRjdXQgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NyZWF0ZVBvc2l0aW9uQmVmb3JlIGBNb2RlbCNjcmVhdGVQb3NpdGlvbkJlZm9yZSgpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGFmdGVyIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgcGxhY2VkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25CZWZvcmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uQmVmb3JlKGl0ZW0pIHsKICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY3JlYXRlUG9zaXRpb25CZWZvcmUoaXRlbSk7CiAgICB9CiAgICAvKioKICAgICAqIFNob3J0Y3V0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVSYW5nZSBgTW9kZWwjY3JlYXRlUmFuZ2UoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gc3RhcnQgU3RhcnQgcG9zaXRpb24uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFtlbmRdIEVuZCBwb3NpdGlvbi4gSWYgbm90IHNldCwgcmFuZ2Ugd2lsbCBiZSBjb2xsYXBzZWQgYXQgYHN0YXJ0YCBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVJhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYW5nZShzdGFydCwgZW5kKSB7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZVJhbmdlKHN0YXJ0LCBlbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBTaG9ydGN1dCBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY3JlYXRlUmFuZ2VJbiBgTW9kZWwjY3JlYXRlUmFuZ2VJbigpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHdoaWNoIGlzIGEgcGFyZW50IGZvciB0aGUgcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVSYW5nZUluIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYW5nZUluKGVsZW1lbnQpIHsKICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY3JlYXRlUmFuZ2VJbihlbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogU2hvcnRjdXQgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NyZWF0ZVJhbmdlT24gYE1vZGVsI2NyZWF0ZVJhbmdlT24oKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB3aGljaCBpcyBhIHBhcmVudCBmb3IgdGhlIHJhbmdlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUmFuZ2VPbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmFuZ2VPbihlbGVtZW50KSB7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZVJhbmdlT24oZWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIFNob3J0Y3V0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVTZWxlY3Rpb24gYE1vZGVsI2NyZWF0ZVNlbGVjdGlvbigpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3RhYmxlfSBzZWxlY3RhYmxlCiAgICAgKiBAcGFyYW0ge051bWJlcnwnYmVmb3JlJ3wnZW5kJ3wnYWZ0ZXInfCdvbid8J2luJ30gW3BsYWNlT3JPZmZzZXRdIFNldHMgcGxhY2Ugb3Igb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb24uCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJhY2t3YXJkXSBTZXRzIHRoaXMgc2VsZWN0aW9uIGluc3RhbmNlIHRvIGJlIGJhY2t3YXJkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVTZWxlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbihzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKSB7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZVNlbGVjdGlvbihzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogUGVyZm9ybXMgbWVyZ2UgYWN0aW9uIGluIGEgZGV0YWNoZWQgdHJlZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiBiZXR3ZWVuIG1lcmdlZCBlbGVtZW50cy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfbWVyZ2VEZXRhY2hlZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21lcmdlRGV0YWNoZWQocG9zaXRpb24pIHsKICAgICAgdmFyIG5vZGVCZWZvcmUgPSBwb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgICB2YXIgbm9kZUFmdGVyID0gcG9zaXRpb24ubm9kZUFmdGVyOwogICAgICB0aGlzLm1vdmUoUmFuZ2UuX2NyZWF0ZUluKG5vZGVBZnRlciksIFBvc2l0aW9uLl9jcmVhdGVBdChub2RlQmVmb3JlLCAnZW5kJykpOwogICAgICB0aGlzLnJlbW92ZShub2RlQWZ0ZXIpOwogICAgfQogICAgLyoqCiAgICAgKiBQZXJmb3JtcyBtZXJnZSBhY3Rpb24gaW4gYSBub24tZGV0YWNoZWQgdHJlZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiBiZXR3ZWVuIG1lcmdlZCBlbGVtZW50cy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfbWVyZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tZXJnZShwb3NpdGlvbikgewogICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5fY3JlYXRlQXQocG9zaXRpb24ubm9kZUJlZm9yZSwgJ2VuZCcpOwoKICAgICAgdmFyIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUF0KHBvc2l0aW9uLm5vZGVBZnRlciwgMCk7CgogICAgICB2YXIgZ3JhdmV5YXJkID0gcG9zaXRpb24ucm9vdC5kb2N1bWVudC5ncmF2ZXlhcmQ7CiAgICAgIHZhciBncmF2ZXlhcmRQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihncmF2ZXlhcmQsIFswXSk7CiAgICAgIHZhciB2ZXJzaW9uID0gcG9zaXRpb24ucm9vdC5kb2N1bWVudC52ZXJzaW9uOwogICAgICB2YXIgbWVyZ2UgPSBuZXcgTWVyZ2VPcGVyYXRpb24oc291cmNlUG9zaXRpb24sIHBvc2l0aW9uLm5vZGVBZnRlci5tYXhPZmZzZXQsIHRhcmdldFBvc2l0aW9uLCBncmF2ZXlhcmRQb3NpdGlvbiwgdmVyc2lvbik7CiAgICAgIHRoaXMuYmF0Y2guYWRkT3BlcmF0aW9uKG1lcmdlKTsKICAgICAgdGhpcy5tb2RlbC5hcHBseU9wZXJhdGlvbihtZXJnZSk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbmFtZXMgdGhlIGdpdmVuIGVsZW1lbnQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byByZW5hbWUuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3TmFtZSBOZXcgZWxlbWVudCBuYW1lLgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlbmFtZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuYW1lKGVsZW1lbnQsIG5ld05hbWUpIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogVHJ5aW5nIHRvIHJlbmFtZSBhbiBvYmplY3Qgd2hpY2ggaXMgbm90IGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLXJlbmFtZS1ub3QtZWxlbWVudC1pbnN0YW5jZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItcmVuYW1lLW5vdC1lbGVtZW50LWluc3RhbmNlJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHZhciB2ZXJzaW9uID0gZWxlbWVudC5yb290LmRvY3VtZW50ID8gZWxlbWVudC5yb290LmRvY3VtZW50LnZlcnNpb24gOiBudWxsOwogICAgICB2YXIgcmVuYW1lT3BlcmF0aW9uID0gbmV3IFJlbmFtZU9wZXJhdGlvbihQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGVsZW1lbnQpLCBlbGVtZW50Lm5hbWUsIG5ld05hbWUsIHZlcnNpb24pOwogICAgICB0aGlzLmJhdGNoLmFkZE9wZXJhdGlvbihyZW5hbWVPcGVyYXRpb24pOwogICAgICB0aGlzLm1vZGVsLmFwcGx5T3BlcmF0aW9uKHJlbmFtZU9wZXJhdGlvbik7CiAgICB9CiAgICAvKioKICAgICAqIFNwbGl0cyBlbGVtZW50cyBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgZ29pbmcgdG8gdGhlIHRvcCBvZiB0aGUgbW9kZWwgdHJlZSBhcyBsb25nIGFzIGdpdmVuCiAgICAgKiBgbGltaXRFbGVtZW50YCBpcyByZWFjaGVkLiBXaGVuIGBsaW1pdEVsZW1lbnRgIGlzIG5vdCBkZWZpbmVkIHRoZW4gb25seSB0aGUgcGFyZW50IG9mIHRoZSBnaXZlbiBwb3NpdGlvbiB3aWxsIGJlIHNwbGl0LgogICAgICoKICAgICAqIFRoZSBlbGVtZW50IG5lZWRzIHRvIGhhdmUgYSBwYXJlbnQuIEl0IGNhbm5vdCBiZSBhIHJvb3QgZWxlbWVudCBub3IgYSBkb2N1bWVudCBmcmFnbWVudC4KICAgICAqIFRoZSBgd3JpdGVyLXNwbGl0LWVsZW1lbnQtbm8tcGFyZW50YCBlcnJvciB3aWxsIGJlIHRocm93biBpZiB5b3UgdHJ5IHRvIHNwbGl0IGFuIGVsZW1lbnQgd2l0aCBubyBwYXJlbnQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiBvZiBzcGxpdC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IFtsaW1pdEVsZW1lbnRdIFN0b3Agc3BsaXR0aW5nIHdoZW4gdGhpcyBlbGVtZW50IHdpbGwgYmUgcmVhY2hlZC4KICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3VsdCBTcGxpdCByZXN1bHQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcmVzdWx0LnBvc2l0aW9uIFBvc2l0aW9uIGJldHdlZW4gc3BsaXQgZWxlbWVudHMuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmVzdWx0LnJhbmdlIFJhbmdlIHRoYXQgc3RhcnMgZnJvbSB0aGUgZW5kIG9mIHRoZSBmaXJzdCBzcGxpdCBlbGVtZW50IGFuZCBlbmRzCiAgICAgKiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaXJzdCBjb3B5IGVsZW1lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic3BsaXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0KHBvc2l0aW9uLCBsaW1pdEVsZW1lbnQpIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgdmFyIHNwbGl0RWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgICAgIGlmICghc3BsaXRFbGVtZW50LnBhcmVudCkgewogICAgICAgIC8qKgogICAgICAgICAqIEVsZW1lbnQgd2l0aCBubyBwYXJlbnQgY2FuIG5vdCBiZSBzcGxpdC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItc3BsaXQtZWxlbWVudC1uby1wYXJlbnQKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLXNwbGl0LWVsZW1lbnQtbm8tcGFyZW50JywgdGhpcyk7CiAgICAgIH0gLy8gV2hlbiBsaW1pdCBlbGVtZW50IGlzIG5vdCBkZWZpbmVkIGxldHMgc2V0IHNwbGl0RWxlbWVudCBwYXJlbnQgYXMgbGltaXQuCgoKICAgICAgaWYgKCFsaW1pdEVsZW1lbnQpIHsKICAgICAgICBsaW1pdEVsZW1lbnQgPSBzcGxpdEVsZW1lbnQucGFyZW50OwogICAgICB9CgogICAgICBpZiAoIXBvc2l0aW9uLnBhcmVudC5nZXRBbmNlc3RvcnMoewogICAgICAgIGluY2x1ZGVTZWxmOiB0cnVlCiAgICAgIH0pLmluY2x1ZGVzKGxpbWl0RWxlbWVudCkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBMaW1pdCBlbGVtZW50IGlzIG5vdCBhIHBvc2l0aW9uIGFuY2VzdG9yLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci1zcGxpdC1pbnZhbGlkLWxpbWl0LWVsZW1lbnQKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLXNwbGl0LWludmFsaWQtbGltaXQtZWxlbWVudCcsIHRoaXMpOwogICAgICB9IC8vIFdlIG5lZWQgdG8gY2FjaGUgZWxlbWVudHMgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgYXMgYSByZXN1bHQgb2YgdGhlIGZpcnN0IHNwbGl0IGJlY2F1c2UKICAgICAgLy8gd2UgbmVlZCB0byBjcmVhdGUgYSByYW5nZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGZpcnN0IHNwbGl0IGVsZW1lbnQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUKICAgICAgLy8gZmlyc3QgY29weSBlbGVtZW50LiBUaGlzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IExpdmVSYW5nZSBidXQgaXQgZG9lc24ndCB3b3JrIG9uIGRldGFjaGVkIG5vZGVzLgoKCiAgICAgIHZhciBmaXJzdFNwbGl0RWxlbWVudCwgZmlyc3RDb3B5RWxlbWVudDsKCiAgICAgIGRvIHsKICAgICAgICB2YXIgdmVyc2lvbiA9IHNwbGl0RWxlbWVudC5yb290LmRvY3VtZW50ID8gc3BsaXRFbGVtZW50LnJvb3QuZG9jdW1lbnQudmVyc2lvbiA6IG51bGw7CiAgICAgICAgdmFyIGhvd01hbnkgPSBzcGxpdEVsZW1lbnQubWF4T2Zmc2V0IC0gcG9zaXRpb24ub2Zmc2V0OwogICAgICAgIHZhciBpbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKHBvc2l0aW9uKTsKICAgICAgICB2YXIgc3BsaXQgPSBuZXcgU3BsaXRPcGVyYXRpb24ocG9zaXRpb24sIGhvd01hbnksIGluc2VydGlvblBvc2l0aW9uLCBudWxsLCB2ZXJzaW9uKTsKICAgICAgICB0aGlzLmJhdGNoLmFkZE9wZXJhdGlvbihzcGxpdCk7CiAgICAgICAgdGhpcy5tb2RlbC5hcHBseU9wZXJhdGlvbihzcGxpdCk7IC8vIENhY2hlIHJlc3VsdCBvZiB0aGUgZmlyc3Qgc3BsaXQuCgogICAgICAgIGlmICghZmlyc3RTcGxpdEVsZW1lbnQgJiYgIWZpcnN0Q29weUVsZW1lbnQpIHsKICAgICAgICAgIGZpcnN0U3BsaXRFbGVtZW50ID0gc3BsaXRFbGVtZW50OwogICAgICAgICAgZmlyc3RDb3B5RWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudC5uZXh0U2libGluZzsKICAgICAgICB9CgogICAgICAgIHBvc2l0aW9uID0gdGhpcy5jcmVhdGVQb3NpdGlvbkFmdGVyKHBvc2l0aW9uLnBhcmVudCk7CiAgICAgICAgc3BsaXRFbGVtZW50ID0gcG9zaXRpb24ucGFyZW50OwogICAgICB9IHdoaWxlIChzcGxpdEVsZW1lbnQgIT09IGxpbWl0RWxlbWVudCk7CgogICAgICByZXR1cm4gewogICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbiwKICAgICAgICByYW5nZTogbmV3IFJhbmdlKFBvc2l0aW9uLl9jcmVhdGVBdChmaXJzdFNwbGl0RWxlbWVudCwgJ2VuZCcpLCBQb3NpdGlvbi5fY3JlYXRlQXQoZmlyc3RDb3B5RWxlbWVudCwgMCkpCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIFdyYXBzIHRoZSBnaXZlbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBlbGVtZW50IG9yIHdpdGggYSBuZXcgZWxlbWVudCAoaWYgYSBzdHJpbmcgd2FzIHBhc3NlZCkuCiAgICAgKgogICAgICogKipOb3RlOioqIHJhbmdlIHRvIHdyYXAgc2hvdWxkIGJlIGEgImZsYXQgcmFuZ2UiIChzZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UjaXNGbGF0IGBSYW5nZSNpc0ZsYXRgfSkuCiAgICAgKiBJZiBub3QsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2UgdG8gd3JhcC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8U3RyaW5nfSBlbGVtZW50T3JTdHJpbmcgRWxlbWVudCBvciBuYW1lIG9mIGVsZW1lbnQgdG8gd3JhcCB0aGUgcmFuZ2Ugd2l0aC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ3cmFwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB3cmFwKHJhbmdlLCBlbGVtZW50T3JTdHJpbmcpIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgaWYgKCFyYW5nZS5pc0ZsYXQpIHsKICAgICAgICAvKioKICAgICAgICAgKiBSYW5nZSB0byB3cmFwIGlzIG5vdCBmbGF0LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci13cmFwLXJhbmdlLW5vdC1mbGF0CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci13cmFwLXJhbmdlLW5vdC1mbGF0JywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudE9yU3RyaW5nIGluc3RhbmNlb2YgRWxlbWVudCA/IGVsZW1lbnRPclN0cmluZyA6IG5ldyBFbGVtZW50KGVsZW1lbnRPclN0cmluZyk7CgogICAgICBpZiAoZWxlbWVudC5jaGlsZENvdW50ID4gMCkgewogICAgICAgIC8qKgogICAgICAgICAqIEVsZW1lbnQgdG8gd3JhcCB3aXRoIGlzIG5vdCBlbXB0eS4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItd3JhcC1lbGVtZW50LW5vdC1lbXB0eQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItd3JhcC1lbGVtZW50LW5vdC1lbXB0eScsIHRoaXMpOwogICAgICB9CgogICAgICBpZiAoZWxlbWVudC5wYXJlbnQgIT09IG51bGwpIHsKICAgICAgICAvKioKICAgICAgICAgKiBFbGVtZW50IHRvIHdyYXAgd2l0aCBpcyBhbHJlYWR5IGF0dGFjaGVkIHRvIGEgdHJlZSBtb2RlbC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItd3JhcC1lbGVtZW50LWF0dGFjaGVkCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci13cmFwLWVsZW1lbnQtYXR0YWNoZWQnLCB0aGlzKTsKICAgICAgfQoKICAgICAgdGhpcy5pbnNlcnQoZWxlbWVudCwgcmFuZ2Uuc3RhcnQpOyAvLyBTaGlmdCB0aGUgcmFuZ2UtdG8td3JhcCBiZWNhdXNlIHdlIGp1c3QgaW5zZXJ0ZWQgYW4gZWxlbWVudCBiZWZvcmUgdGhhdCByYW5nZS4KCiAgICAgIHZhciBzaGlmdGVkUmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2Uuc3RhcnQuZ2V0U2hpZnRlZEJ5KDEpLCByYW5nZS5lbmQuZ2V0U2hpZnRlZEJ5KDEpKTsKICAgICAgdGhpcy5tb3ZlKHNoaWZ0ZWRSYW5nZSwgUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQsIDApKTsKICAgIH0KICAgIC8qKgogICAgICogVW53cmFwcyBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gZWxlbWVudCDigJMgYWxsIGl0cyBjaGlsZHJlbiBhcmUgbW92ZWQgYmVmb3JlIGl0IGFuZCB0aGVuIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQuCiAgICAgKiBUaHJvd3MgZXJyb3IgaWYgeW91IHRyeSB0byB1bndyYXAgYW4gZWxlbWVudCB3aGljaCBkb2VzIG5vdCBoYXZlIGEgcGFyZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB1bndyYXAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidW53cmFwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoZWxlbWVudCkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoZWxlbWVudC5wYXJlbnQgPT09IG51bGwpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUcnlpbmcgdG8gdW53cmFwIGFuIGVsZW1lbnQgd2hpY2ggaGFzIG5vIHBhcmVudC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItdW53cmFwLWVsZW1lbnQtbm8tcGFyZW50CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci11bndyYXAtZWxlbWVudC1uby1wYXJlbnQnLCB0aGlzKTsKICAgICAgfQoKICAgICAgdGhpcy5tb3ZlKFJhbmdlLl9jcmVhdGVJbihlbGVtZW50KSwgdGhpcy5jcmVhdGVQb3NpdGlvbkFmdGVyKGVsZW1lbnQpKTsKICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlciBtYXJrZXJ9LiBNYXJrZXIgaXMgYSBuYW1lZCByYW5nZSwgd2hpY2ggdHJhY2tzCiAgICAgKiBjaGFuZ2VzIGluIHRoZSBkb2N1bWVudCBhbmQgdXBkYXRlcyBpdHMgcmFuZ2UgYXV0b21hdGljYWxseSwgd2hlbiBtb2RlbCB0cmVlIGNoYW5nZXMuCiAgICAgKgogICAgICogQXMgdGhlIGZpcnN0IHBhcmFtZXRlciB5b3UgY2FuIHNldCBtYXJrZXIgbmFtZS4KICAgICAqCiAgICAgKiBUaGUgcmVxdWlyZWQgYG9wdGlvbnMudXNpbmdPcGVyYXRpb25gIHBhcmFtZXRlciBsZXRzIHlvdSBkZWNpZGUgaWYgdGhlIG1hcmtlciBzaG91bGQgYmUgbWFuYWdlZCBieSBvcGVyYXRpb25zIG9yIG5vdC4gU2VlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlciBtYXJrZXIgY2xhc3MgZGVzY3JpcHRpb259IHRvIGxlYXJuIGFib3V0IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4KICAgICAqIG1hcmtlcnMgbWFuYWdlZCBieSBvcGVyYXRpb25zIGFuZCBub3QtbWFuYWdlZCBieSBvcGVyYXRpb25zLgogICAgICoKICAgICAqIFRoZSBgb3B0aW9ucy5hZmZlY3RzRGF0YWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byBgZmFsc2VgLCBhbGxvd3MgeW91IHRvIGRlZmluZSBpZiBhIG1hcmtlciBhZmZlY3RzIHRoZSBkYXRhLiBJdCBzaG91bGQgYmUKICAgICAqIGB0cnVlYCB3aGVuIHRoZSBtYXJrZXIgY2hhbmdlIGNoYW5nZXMgdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmNvcmUvZWRpdG9yL3V0aWxzL2RhdGFhcGltaXhpbn5EYXRhQXBpI2dldERhdGEgYGVkaXRvci5nZXREYXRhKClgfSBtZXRob2QuCiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAgaXQgZmlyZXMgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I2V2ZW50OmNoYW5nZTpkYXRhIGBjaGFuZ2U6ZGF0YWB9IGV2ZW50LgogICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCBpdCBmaXJlcyB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjZXZlbnQ6Y2hhbmdlIGBjaGFuZ2VgfSBldmVudC4KICAgICAqCiAgICAgKiBDcmVhdGUgbWFya2VyIGRpcmVjdGx5IGJhc2Ugb24gbWFya2VyJ3MgbmFtZToKICAgICAqCiAgICAgKgkJYWRkTWFya2VyKCBtYXJrZXJOYW1lLCB7IHJhbmdlLCB1c2luZ09wZXJhdGlvbjogZmFsc2UgfSApOwogICAgICoKICAgICAqIENyZWF0ZSBtYXJrZXIgdXNpbmcgb3BlcmF0aW9uOgogICAgICoKICAgICAqCQlhZGRNYXJrZXIoIG1hcmtlck5hbWUsIHsgcmFuZ2UsIHVzaW5nT3BlcmF0aW9uOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBDcmVhdGUgbWFya2VyIHRoYXQgYWZmZWN0cyB0aGUgZWRpdG9yIGRhdGE6CiAgICAgKgogICAgICoJCWFkZE1hcmtlciggbWFya2VyTmFtZSwgeyByYW5nZSwgdXNpbmdPcGVyYXRpb246IGZhbHNlLCBhZmZlY3RzRGF0YTogdHJ1ZSB9ICk7CiAgICAgKgogICAgICogTm90ZTogRm9yIGVmZmljaWVuY3kgcmVhc29ucywgaXQncyBiZXN0IHRvIGNyZWF0ZSBhbmQga2VlcCBhcyBsaXR0bGUgbWFya2VycyBhcyBwb3NzaWJsZS4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgYSBtYXJrZXIgdG8gY3JlYXRlIC0gbXVzdCBiZSB1bmlxdWUuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucwogICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnVzaW5nT3BlcmF0aW9uIEZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZSBtYXJrZXIgc2hvdWxkIGJlIGFkZGVkIGJ5IE1hcmtlck9wZXJhdGlvbi4KICAgICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlciNtYW5hZ2VkVXNpbmdPcGVyYXRpb25zfS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gb3B0aW9ucy5yYW5nZSBNYXJrZXIgcmFuZ2UuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFmZmVjdHNEYXRhPWZhbHNlXSBGbGFnIGluZGljYXRpbmcgdGhhdCB0aGUgbWFya2VyIGNoYW5nZXMgdGhlIGVkaXRvciBkYXRhLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJ9IE1hcmtlciB0aGF0IHdhcyBzZXQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYWRkTWFya2VyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXJrZXIobmFtZSwgb3B0aW9ucykgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMudXNpbmdPcGVyYXRpb24gIT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIGBvcHRpb25zLnVzaW5nT3BlcmF0aW9uYCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiBhZGRpbmcgYSBuZXcgbWFya2VyLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci1hZGRtYXJrZXItbm8tdXNpbmdvcGVyYXRpb24KICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLWFkZG1hcmtlci1uby11c2luZ29wZXJhdGlvbicsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgdXNpbmdPcGVyYXRpb24gPSBvcHRpb25zLnVzaW5nT3BlcmF0aW9uOwogICAgICB2YXIgcmFuZ2UgPSBvcHRpb25zLnJhbmdlOwogICAgICB2YXIgYWZmZWN0c0RhdGEgPSBvcHRpb25zLmFmZmVjdHNEYXRhID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMuYWZmZWN0c0RhdGE7CgogICAgICBpZiAodGhpcy5tb2RlbC5tYXJrZXJzLmhhcyhuYW1lKSkgewogICAgICAgIC8qKgogICAgICAgICAqIE1hcmtlciB3aXRoIHByb3ZpZGVkIG5hbWUgYWxyZWFkeSBleGlzdHMuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLWFkZG1hcmtlci1tYXJrZXItZXhpc3RzCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1hZGRtYXJrZXItbWFya2VyLWV4aXN0cycsIHRoaXMpOwogICAgICB9CgogICAgICBpZiAoIXJhbmdlKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogUmFuZ2UgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gYWRkaW5nIGEgbmV3IG1hcmtlci4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItYWRkbWFya2VyLW5vLXJhbmdlCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1hZGRtYXJrZXItbm8tcmFuZ2UnLCB0aGlzKTsKICAgICAgfQoKICAgICAgaWYgKCF1c2luZ09wZXJhdGlvbikgewogICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm1hcmtlcnMuX3NldChuYW1lLCByYW5nZSwgdXNpbmdPcGVyYXRpb24sIGFmZmVjdHNEYXRhKTsKICAgICAgfQoKICAgICAgYXBwbHlNYXJrZXJPcGVyYXRpb24odGhpcywgbmFtZSwgbnVsbCwgcmFuZ2UsIGFmZmVjdHNEYXRhKTsKICAgICAgcmV0dXJuIHRoaXMubW9kZWwubWFya2Vycy5nZXQobmFtZSk7CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMsIHVwZGF0ZXMgb3IgcmVmcmVzaGVzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIgbWFya2VyfS4gTWFya2VyIGlzIGEgbmFtZWQgcmFuZ2UsIHdoaWNoIHRyYWNrcwogICAgICogY2hhbmdlcyBpbiB0aGUgZG9jdW1lbnQgYW5kIHVwZGF0ZXMgaXRzIHJhbmdlIGF1dG9tYXRpY2FsbHksIHdoZW4gbW9kZWwgdHJlZSBjaGFuZ2VzLiBTdGlsbCwgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZQogICAgICogbWFya2VyJ3MgcmFuZ2UgZGlyZWN0bHkgdXNpbmcgdGhpcyBtZXRob2QuCiAgICAgKgogICAgICogQXMgdGhlIGZpcnN0IHBhcmFtZXRlciB5b3UgY2FuIHNldCBtYXJrZXIgbmFtZSBvciBpbnN0YW5jZS4gSWYgbm9uZSBvZiB0aGVtIGlzIHByb3ZpZGVkLCBuZXcgbWFya2VyLCB3aXRoIGEgdW5pcXVlCiAgICAgKiBuYW1lIGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLgogICAgICoKICAgICAqIEFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHlvdSBjYW4gc2V0IHRoZSBuZXcgbWFya2VyIGRhdGEgb3IgbGVhdmUgdGhpcyBwYXJhbWV0ZXIgYXMgZW1wdHkgd2hpY2ggd2lsbCBqdXN0IHJlZnJlc2gKICAgICAqIHRoZSBtYXJrZXIgYnkgdHJpZ2dlcmluZyBkb3duY2FzdCBjb252ZXJzaW9uIGZvciBpdC4gUmVmcmVzaGluZyB0aGUgbWFya2VyIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGNoYW5nZQogICAgICogdGhlIG1hcmtlciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9IHdpdGhvdXQgY2hhbmdpbmcgYW55IG1hcmtlciBkYXRhLgogICAgICoKICAgICAqIAkJbGV0IGlzQ29tbWVudEFjdGl2ZSA9IGZhbHNlOwogICAgICoKICAgICAqIAkJbW9kZWwuY29udmVyc2lvbi5tYXJrZXJUb0hpZ2hsaWdodCggewogICAgICogCQkJbW9kZWw6ICdjb21tZW50JywKICAgICAqCQkJdmlldzogZGF0YSA9PiB7CiAgICAgKgkJCQljb25zdCBjbGFzc2VzID0gWyAnY29tbWVudC1tYXJrZXInIF07CiAgICAgKgogICAgICoJCQkJaWYgKCBpc0NvbW1lbnRBY3RpdmUgKSB7CiAgICAgKgkJCQkJY2xhc3Nlcy5wdXNoKCAnY29tbWVudC1tYXJrZXItLWFjdGl2ZScgKTsKICAgICAqCQkJCX0KICAgICAqCiAgICAgKgkJCQlyZXR1cm4geyBjbGFzc2VzIH07CiAgICAgKgkJCX0KICAgICAqIAkJfSApOwogICAgICoKICAgICAqIAkJLy8gQ2hhbmdlIHRoZSBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyBpZiBtYXJrZXIgaXMgZGlzcGxheWVkIGFzIGFjdGl2ZSBvciBub3QuCiAgICAgKiAJCWlzQ29tbWVudEFjdGl2ZSA9IHRydWU7CiAgICAgKgogICAgICogCQkvLyBBbmQgcmVmcmVzaCB0aGUgbWFya2VyIHRvIGNvbnZlcnQgaXQgd2l0aCBhZGRpdGlvbmFsIGNsYXNzLgogICAgICogCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB3cml0ZXIudXBkYXRlTWFya2VyKCAnY29tbWVudCcgKSApOwogICAgICoKICAgICAqIFRoZSBgb3B0aW9ucy51c2luZ09wZXJhdGlvbmAgcGFyYW1ldGVyIGxldHMgeW91IGNoYW5nZSBpZiB0aGUgbWFya2VyIHNob3VsZCBiZSBtYW5hZ2VkIGJ5IG9wZXJhdGlvbnMgb3Igbm90LiBTZWUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyIG1hcmtlciBjbGFzcyBkZXNjcmlwdGlvbn0gdG8gbGVhcm4gYWJvdXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbgogICAgICogbWFya2VycyBtYW5hZ2VkIGJ5IG9wZXJhdGlvbnMgYW5kIG5vdC1tYW5hZ2VkIGJ5IG9wZXJhdGlvbnMuIEl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGlzIG9wdGlvbiBmb3IgYW4gZXhpc3RpbmcgbWFya2VyLgogICAgICoKICAgICAqIFRoZSBgb3B0aW9ucy5hZmZlY3RzRGF0YWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byBgZmFsc2VgLCBhbGxvd3MgeW91IHRvIGRlZmluZSBpZiBhIG1hcmtlciBhZmZlY3RzIHRoZSBkYXRhLiBJdCBzaG91bGQgYmUKICAgICAqIGB0cnVlYCB3aGVuIHRoZSBtYXJrZXIgY2hhbmdlIGNoYW5nZXMgdGhlIGRhdGEgcmV0dXJuZWQgYnkKICAgICAqIHRoZSB7QGxpbmsgbW9kdWxlOmNvcmUvZWRpdG9yL3V0aWxzL2RhdGFhcGltaXhpbn5EYXRhQXBpI2dldERhdGEgYGVkaXRvci5nZXREYXRhKClgfSBtZXRob2QuCiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAgaXQgZmlyZXMgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I2V2ZW50OmNoYW5nZTpkYXRhIGBjaGFuZ2U6ZGF0YWB9IGV2ZW50LgogICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCBpdCBmaXJlcyB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjZXZlbnQ6Y2hhbmdlIGBjaGFuZ2VgfSBldmVudC4KICAgICAqCiAgICAgKiBVcGRhdGUgbWFya2VyIGRpcmVjdGx5IGJhc2Ugb24gbWFya2VyJ3MgbmFtZToKICAgICAqCiAgICAgKgkJdXBkYXRlTWFya2VyKCBtYXJrZXJOYW1lLCB7IHJhbmdlIH0gKTsKICAgICAqCiAgICAgKiBVcGRhdGUgbWFya2VyIHVzaW5nIG9wZXJhdGlvbjoKICAgICAqCiAgICAgKgkJdXBkYXRlTWFya2VyKCBtYXJrZXIsIHsgcmFuZ2UsIHVzaW5nT3BlcmF0aW9uOiB0cnVlIH0gKTsKICAgICAqCQl1cGRhdGVNYXJrZXIoIG1hcmtlck5hbWUsIHsgcmFuZ2UsIHVzaW5nT3BlcmF0aW9uOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBDaGFuZ2UgbWFya2VyJ3Mgb3B0aW9uIChzdGFydCB1c2luZyBvcGVyYXRpb25zIHRvIG1hbmFnZSBpdCk6CiAgICAgKgogICAgICoJCXVwZGF0ZU1hcmtlciggbWFya2VyLCB7IHVzaW5nT3BlcmF0aW9uOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBDaGFuZ2UgbWFya2VyJ3Mgb3B0aW9uIChpbmZvcm0gdGhlIGVuZ2luZSwgdGhhdCB0aGUgbWFya2VyIGRvZXMgbm90IGFmZmVjdCB0aGUgZGF0YSBhbnltb3JlKToKICAgICAqCiAgICAgKgkJdXBkYXRlTWFya2VyKCBtYXJrZXJOYW1lLCB7IGFmZmVjdHNEYXRhOiBmYWxzZSB9ICk7CiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyfSBtYXJrZXJPck5hbWUgTmFtZSBvZiBhIG1hcmtlciB0byB1cGRhdGUsIG9yIGEgbWFya2VyIGluc3RhbmNlLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBJZiBvcHRpb25zIG9iamVjdCBpcyBub3QgZGVmaW5lZCB0aGVuIG1hcmtlciB3aWxsIGJlIHJlZnJlc2hlZCBieSB0cmlnZ2VyaW5nCiAgICAgKiBkb3duY2FzdCBjb252ZXJzaW9uIGZvciB0aGlzIG1hcmtlciB3aXRoIHRoZSBzYW1lIGRhdGEuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IFtvcHRpb25zLnJhbmdlXSBNYXJrZXIgcmFuZ2UgdG8gdXBkYXRlLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2luZ09wZXJhdGlvbl0gRmxhZyBpbmRpY2F0ZWQgd2hldGhlciB0aGUgbWFya2VyIHNob3VsZCBiZSBhZGRlZCBieSBNYXJrZXJPcGVyYXRpb24uCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIjbWFuYWdlZFVzaW5nT3BlcmF0aW9uc30uCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFmZmVjdHNEYXRhXSBGbGFnIGluZGljYXRpbmcgdGhhdCB0aGUgbWFya2VyIGNoYW5nZXMgdGhlIGVkaXRvciBkYXRhLgogICAgICovCgogIH0sIHsKICAgIGtleTogInVwZGF0ZU1hcmtlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTWFya2VyKG1hcmtlck9yTmFtZSwgb3B0aW9ucykgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICB2YXIgbWFya2VyTmFtZSA9IHR5cGVvZiBtYXJrZXJPck5hbWUgPT0gJ3N0cmluZycgPyBtYXJrZXJPck5hbWUgOiBtYXJrZXJPck5hbWUubmFtZTsKICAgICAgdmFyIGN1cnJlbnRNYXJrZXIgPSB0aGlzLm1vZGVsLm1hcmtlcnMuZ2V0KG1hcmtlck5hbWUpOwoKICAgICAgaWYgKCFjdXJyZW50TWFya2VyKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogTWFya2VyIHdpdGggcHJvdmlkZWQgbmFtZSBkb2VzIG5vdCBleGlzdHMuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLXVwZGF0ZW1hcmtlci1tYXJrZXItbm90LWV4aXN0cwogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItdXBkYXRlbWFya2VyLW1hcmtlci1ub3QtZXhpc3RzJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIGlmICghb3B0aW9ucykgewogICAgICAgIHRoaXMubW9kZWwubWFya2Vycy5fcmVmcmVzaChjdXJyZW50TWFya2VyKTsKCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgaGFzVXNpbmdPcGVyYXRpb25EZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMudXNpbmdPcGVyYXRpb24gPT0gJ2Jvb2xlYW4nOwogICAgICB2YXIgYWZmZWN0c0RhdGFEZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMuYWZmZWN0c0RhdGEgPT0gJ2Jvb2xlYW4nOyAvLyBVc2UgcHJldmlvdXNseSBkZWZpbmVkIG1hcmtlcidzIGFmZmVjdHNEYXRhIGlmIHRoZSBwcm9wZXJ0eSBpcyBub3QgcHJvdmlkZWQuCgogICAgICB2YXIgYWZmZWN0c0RhdGEgPSBhZmZlY3RzRGF0YURlZmluZWQgPyBvcHRpb25zLmFmZmVjdHNEYXRhIDogY3VycmVudE1hcmtlci5hZmZlY3RzRGF0YTsKCiAgICAgIGlmICghaGFzVXNpbmdPcGVyYXRpb25EZWZpbmVkICYmICFvcHRpb25zLnJhbmdlICYmICFhZmZlY3RzRGF0YURlZmluZWQpIHsKICAgICAgICAvKioKICAgICAgICAgKiBPbmUgb2YgdGhlIG9wdGlvbnMgaXMgcmVxdWlyZWQgLSBwcm92aWRlIHJhbmdlLCB1c2luZ09wZXJhdGlvbnMgb3IgYWZmZWN0c0RhdGEuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLXVwZGF0ZW1hcmtlci13cm9uZy1vcHRpb25zCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci11cGRhdGVtYXJrZXItd3Jvbmctb3B0aW9ucycsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgY3VycmVudFJhbmdlID0gY3VycmVudE1hcmtlci5nZXRSYW5nZSgpOwogICAgICB2YXIgdXBkYXRlZFJhbmdlID0gb3B0aW9ucy5yYW5nZSA/IG9wdGlvbnMucmFuZ2UgOiBjdXJyZW50UmFuZ2U7CgogICAgICBpZiAoaGFzVXNpbmdPcGVyYXRpb25EZWZpbmVkICYmIG9wdGlvbnMudXNpbmdPcGVyYXRpb24gIT09IGN1cnJlbnRNYXJrZXIubWFuYWdlZFVzaW5nT3BlcmF0aW9ucykgewogICAgICAgIC8vIFRoZSBtYXJrZXIgdHlwZSBpcyBjaGFuZ2VkIHNvIGl0J3MgbmVjZXNzYXJ5IHRvIGNyZWF0ZSBwcm9wZXIgb3BlcmF0aW9ucy4KICAgICAgICBpZiAob3B0aW9ucy51c2luZ09wZXJhdGlvbikgewogICAgICAgICAgLy8gSWYgbWFya2VyIGNoYW5nZXMgdG8gYSBtYW5hZ2VkIG9uZSB0cmVhdCB0aGlzIGFzIHN5bmNocm9uaXppbmcgZXhpc3RpbmcgbWFya2VyLgogICAgICAgICAgLy8gQ3JlYXRlIGBNYXJrZXJPcGVyYXRpb25gIHdpdGggYG9sZFJhbmdlYCBzZXQgdG8gYG51bGxgLCBzbyByZXZlcnNlIG9wZXJhdGlvbiB3aWxsIHJlbW92ZSB0aGUgbWFya2VyLgogICAgICAgICAgYXBwbHlNYXJrZXJPcGVyYXRpb24odGhpcywgbWFya2VyTmFtZSwgbnVsbCwgdXBkYXRlZFJhbmdlLCBhZmZlY3RzRGF0YSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIElmIG1hcmtlciBjaGFuZ2VzIHRvIGEgbWFya2VyIHRoYXQgZG8gbm90IHVzZSBvcGVyYXRpb25zIHRoZW4gd2UgbmVlZCB0byBjcmVhdGUgYWRkaXRpb25hbCBvcGVyYXRpb24KICAgICAgICAgIC8vIHRoYXQgcmVtb3ZlcyB0aGF0IG1hcmtlciBmaXJzdC4KICAgICAgICAgIGFwcGx5TWFya2VyT3BlcmF0aW9uKHRoaXMsIG1hcmtlck5hbWUsIGN1cnJlbnRSYW5nZSwgbnVsbCwgYWZmZWN0c0RhdGEpOyAvLyBBbHRob3VnaCBub3QgbWFuYWdlZCB0aGUgbWFya2VyIGl0c2VsZiBzaG91bGQgc3RheSBpbiBtb2RlbCBhbmQgaXRzIHJhbmdlIHNob3VsZCBiZSBwcmVzZXJ2ZXIgb3IgY2hhbmdlZCB0byBwYXNzZWQgcmFuZ2UuCgogICAgICAgICAgdGhpcy5tb2RlbC5tYXJrZXJzLl9zZXQobWFya2VyTmFtZSwgdXBkYXRlZFJhbmdlLCB1bmRlZmluZWQsIGFmZmVjdHNEYXRhKTsKICAgICAgICB9CgogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBNYXJrZXIncyB0eXBlIGRvZXNuJ3QgY2hhbmdlIHNvIHVwZGF0ZSBpdCBhY2NvcmRpbmdseS4KCgogICAgICBpZiAoY3VycmVudE1hcmtlci5tYW5hZ2VkVXNpbmdPcGVyYXRpb25zKSB7CiAgICAgICAgYXBwbHlNYXJrZXJPcGVyYXRpb24odGhpcywgbWFya2VyTmFtZSwgY3VycmVudFJhbmdlLCB1cGRhdGVkUmFuZ2UsIGFmZmVjdHNEYXRhKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLm1vZGVsLm1hcmtlcnMuX3NldChtYXJrZXJOYW1lLCB1cGRhdGVkUmFuZ2UsIHVuZGVmaW5lZCwgYWZmZWN0c0RhdGEpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIgbWFya2VyfSBvciBtYXJrZXIgd2l0aCBnaXZlbiBuYW1lLgogICAgICogVGhlIG1hcmtlciBpcyByZW1vdmVkIGFjY29yZGluZ2x5IHRvIGhvdyBpdCBoYXMgYmVlbiBjcmVhdGVkLCBzbyBpZiB0aGUgbWFya2VyIHdhcyBjcmVhdGVkIHVzaW5nIG9wZXJhdGlvbiwKICAgICAqIGl0IHdpbGwgYmUgZGVzdHJveWVkIHVzaW5nIG9wZXJhdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJ8U3RyaW5nfSBtYXJrZXJPck5hbWUgTWFya2VyIG9yIG1hcmtlciBuYW1lIHRvIHJlbW92ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZW1vdmVNYXJrZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU1hcmtlcihtYXJrZXJPck5hbWUpIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgdmFyIG5hbWUgPSB0eXBlb2YgbWFya2VyT3JOYW1lID09ICdzdHJpbmcnID8gbWFya2VyT3JOYW1lIDogbWFya2VyT3JOYW1lLm5hbWU7CgogICAgICBpZiAoIXRoaXMubW9kZWwubWFya2Vycy5oYXMobmFtZSkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUcnlpbmcgdG8gcmVtb3ZlIG1hcmtlciB3aGljaCBkb2VzIG5vdCBleGlzdC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItcmVtb3ZlbWFya2VyLW5vLW1hcmtlcgogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItcmVtb3ZlbWFya2VyLW5vLW1hcmtlcicsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgbWFya2VyID0gdGhpcy5tb2RlbC5tYXJrZXJzLmdldChuYW1lKTsKCiAgICAgIGlmICghbWFya2VyLm1hbmFnZWRVc2luZ09wZXJhdGlvbnMpIHsKICAgICAgICB0aGlzLm1vZGVsLm1hcmtlcnMuX3JlbW92ZShuYW1lKTsKCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgb2xkUmFuZ2UgPSBtYXJrZXIuZ2V0UmFuZ2UoKTsKICAgICAgYXBwbHlNYXJrZXJPcGVyYXRpb24odGhpcywgbmFtZSwgb2xkUmFuZ2UsIG51bGwsIG1hcmtlci5hZmZlY3RzRGF0YSk7CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdGhlIGRvY3VtZW50J3Mgc2VsZWN0aW9uIChyYW5nZXMgYW5kIGRpcmVjdGlvbikgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBiYXNlZCBvbiB0aGUgZ2l2ZW4KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3RhYmxlIHNlbGVjdGFibGV9IG9yIGNyZWF0ZXMgYW4gZW1wdHkgc2VsZWN0aW9uIGlmIG5vIGFyZ3VtZW50cyB3ZXJlIHBhc3NlZC4KICAgICAqCiAgICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gdG8gdGhlIGdpdmVuIHJhbmdlLgogICAgICoJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydCwgZW5kICk7CiAgICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2UgKTsKICAgICAqCiAgICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gdG8gZ2l2ZW4gcmFuZ2VzLgogICAgICoJCWNvbnN0IHJhbmdlcyA9IFsgd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydDEsIGVuZDIgKSwgd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFyMiwgZW5kMiApIF07CiAgICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2VzICk7CiAgICAgKgogICAgICoJCS8vIFNldHMgc2VsZWN0aW9uIHRvIG90aGVyIHNlbGVjdGlvbi4KICAgICAqCQljb25zdCBvdGhlclNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBvdGhlclNlbGVjdGlvbiApOwogICAgICoKICAgICAqCQkvLyBTZXRzIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgc2VsZWN0aW9uLgogICAgICoJCWNvbnN0IGRvY3VtZW50U2VsZWN0aW9uID0gbW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uOwogICAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIGRvY3VtZW50U2VsZWN0aW9uICk7CiAgICAgKgogICAgICoJCS8vIFNldHMgY29sbGFwc2VkIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKgkJY29uc3QgcG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb24oIHJvb3QsIHBhdGggKTsKICAgICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBwb3NpdGlvbiApOwogICAgICoKICAgICAqCQkvLyBTZXRzIGNvbGxhcHNlZCBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBub2RlIGFuZCBhbiBvZmZzZXQuCiAgICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcGFyYWdyYXBoLCBvZmZzZXQgKTsKICAgICAqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZgogICAgCSAqIHRoYXQgZWxlbWVudCBhbmQgZW5kcyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQuCiAgICAgKgogICAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHBhcmFncmFwaCwgJ2luJyApOwogICAgICoKICAgICAqIENyZWF0ZXMgYSByYW5nZSBvbiBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gaXRlbX0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgaXRlbSBhbmQgZW5kcyBqdXN0IGFmdGVyIHRoZSBpdGVtLgogICAgICoKICAgICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBwYXJhZ3JhcGgsICdvbicgKTsKICAgICAqCiAgICAgKgkJLy8gUmVtb3ZlcyBhbGwgc2VsZWN0aW9uJ3MgcmFuZ2VzLgogICAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIG51bGwgKTsKICAgICAqCiAgICAgKiBgV3JpdGVyI3NldFNlbGVjdGlvbigpYCBhbGxvdyBwYXNzaW5nIGFkZGl0aW9uYWwgb3B0aW9ucyAoYGJhY2t3YXJkYCkgYXMgdGhlIGxhc3QgYXJndW1lbnQuCiAgICAgKgogICAgICoJCS8vIFNldHMgc2VsZWN0aW9uIGFzIGJhY2t3YXJkLgogICAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHJhbmdlLCB7IGJhY2t3YXJkOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBUaHJvd3MgYHdyaXRlci1pbmNvcnJlY3QtdXNlYCBlcnJvciB3aGVuIHRoZSB3cml0ZXIgaXMgdXNlZCBvdXRzaWRlIHRoZSBgY2hhbmdlKClgIGJsb2NrLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gc2VsZWN0YWJsZQogICAgICogQHBhcmFtIHtOdW1iZXJ8J2JlZm9yZSd8J2VuZCd8J2FmdGVyJ3wnb24nfCdpbid9IFtwbGFjZU9yT2Zmc2V0XSBTZXRzIHBsYWNlIG9yIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrd2FyZF0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBiYWNrd2FyZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRTZWxlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uLl9zZXRUbyhzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogTW92ZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb24jZm9jdXN9IHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uCiAgICAgKgogICAgICogVGhlIGxvY2F0aW9uIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIHNhbWUgZm9ybSBhcwogICAgICoge0BsaW5rICNjcmVhdGVQb3NpdGlvbkF0IGB3cml0ZXIuY3JlYXRlUG9zaXRpb25BdCgpYH0gcGFyYW1ldGVycy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0PTBdIE9mZnNldCBvciBvbmUgb2YgdGhlIGZsYWdzLiBVc2VkIG9ubHkgd2hlbgogICAgICogZmlyc3QgcGFyYW1ldGVyIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICovCgogIH0sIHsKICAgIGtleTogInNldFNlbGVjdGlvbkZvY3VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Gb2N1cyhpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uLl9zZXRGb2N1cyhpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogU2V0cyBhdHRyaWJ1dGUocykgb24gdGhlIHNlbGVjdGlvbi4gSWYgYXR0cmlidXRlIHdpdGggdGhlIHNhbWUga2V5IGFscmVhZHkgaXMgc2V0LCBpdCdzIHZhbHVlIGlzIG92ZXJ3cml0dGVuLgogICAgICoKICAgICAqIFVzaW5nIGtleSBhbmQgdmFsdWUgcGFpcjoKICAgICAqCiAgICAgKiAJd3JpdGVyLnNldFNlbGVjdGlvbkF0dHJpYnV0ZSggJ2l0YWxpYycsIHRydWUgKTsKICAgICAqCiAgICAgKiBVc2luZyBrZXktdmFsdWUgb2JqZWN0OgogICAgICoKICAgICAqIAl3cml0ZXIuc2V0U2VsZWN0aW9uQXR0cmlidXRlKCB7IGl0YWxpYzogdHJ1ZSwgYm9sZDogZmFsc2UgfSApOwogICAgICoKICAgICAqIFVzaW5nIGl0ZXJhYmxlIG9iamVjdDoKICAgICAqCiAgICAgKiAJd3JpdGVyLnNldFNlbGVjdGlvbkF0dHJpYnV0ZSggbmV3IE1hcCggWyBbICdpdGFsaWMnLCB0cnVlIF0gXSApICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEl0ZXJhYmxlLjwqPn0ga2V5T3JPYmplY3RPckl0ZXJhYmxlIEtleSBvZiB0aGUgYXR0cmlidXRlIHRvIHNldAogICAgICogb3Igb2JqZWN0IC8gaXRlcmFibGUgb2Yga2V5ID0+IHZhbHVlIGF0dHJpYnV0ZSBwYWlycy4KICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBBdHRyaWJ1dGUgdmFsdWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0U2VsZWN0aW9uQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5T3JPYmplY3RPckl0ZXJhYmxlLCB2YWx1ZSkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAodHlwZW9mIGtleU9yT2JqZWN0T3JJdGVyYWJsZSA9PT0gJ3N0cmluZycpIHsKICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5T3JPYmplY3RPckl0ZXJhYmxlLCB2YWx1ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0b01hcChrZXlPck9iamVjdE9ySXRlcmFibGUpKSwKICAgICAgICAgICAgX3N0ZXA4OwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIF9zdGVwOCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOC52YWx1ZSwgMiksCiAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcDgkdmFsdWVbMF0sCiAgICAgICAgICAgICAgICBfdmFsdWUgPSBfc3RlcDgkdmFsdWVbMV07CgogICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5LCBfdmFsdWUpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2l0ZXJhdG9yOC5lKGVycik7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIF9pdGVyYXRvcjguZigpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGF0dHJpYnV0ZShzKSB3aXRoIGdpdmVuIGtleShzKSBmcm9tIHRoZSBzZWxlY3Rpb24uCiAgICAgKgogICAgICogUmVtb3ZlIG9uZSBhdHRyaWJ1dGU6CiAgICAgKgogICAgICoJCXdyaXRlci5yZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUoICdpdGFsaWMnICk7CiAgICAgKgogICAgICogUmVtb3ZlIG11bHRpcGxlIGF0dHJpYnV0ZXM6CiAgICAgKgogICAgICoJCXdyaXRlci5yZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUoIFsgJ2l0YWxpYycsICdib2xkJyBdICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd8SXRlcmFibGUuPFN0cmluZz59IGtleU9ySXRlcmFibGVPZktleXMgS2V5IG9mIHRoZSBhdHRyaWJ1dGUgdG8gcmVtb3ZlIG9yIGFuIGl0ZXJhYmxlIG9mIGF0dHJpYnV0ZSBrZXlzIHRvIHJlbW92ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVNlbGVjdGlvbkF0dHJpYnV0ZShrZXlPckl0ZXJhYmxlT2ZLZXlzKSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIGlmICh0eXBlb2Yga2V5T3JJdGVyYWJsZU9mS2V5cyA9PT0gJ3N0cmluZycpIHsKICAgICAgICB0aGlzLl9yZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5T3JJdGVyYWJsZU9mS2V5cyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihrZXlPckl0ZXJhYmxlT2ZLZXlzKSwKICAgICAgICAgICAgX3N0ZXA5OwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3I5LnMoKTsgIShfc3RlcDkgPSBfaXRlcmF0b3I5Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwOS52YWx1ZTsKCiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNlbGVjdGlvbkF0dHJpYnV0ZShrZXkpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2l0ZXJhdG9yOS5lKGVycik7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIF9pdGVyYXRvcjkuZigpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBUZW1wb3JhcmlseSBjaGFuZ2VzIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbiNpc0dyYXZpdHlPdmVycmlkZGVuIGdyYXZpdHl9CiAgICAgKiBvZiB0aGUgc2VsZWN0aW9uIGZyb20gbGVmdCB0byByaWdodC4KICAgICAqCiAgICAgKiBUaGUgZ3Jhdml0eSBkZWZpbmVzIGZyb20gd2hpY2ggZGlyZWN0aW9uIHRoZSBzZWxlY3Rpb24gaW5oZXJpdHMgaXRzIGF0dHJpYnV0ZXMuIElmIGl0J3MgdGhlIGRlZmF1bHQgbGVmdCBncmF2aXR5LAogICAgICogdGhlbiB0aGUgc2VsZWN0aW9uIChhZnRlciBiZWluZyBtb3ZlZCBieSB0aGUgdXNlcikgaW5oZXJpdHMgYXR0cmlidXRlcyBmcm9tIGl0cyBsZWZ0LWhhbmQgc2lkZS4KICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB0byB0ZW1wb3JhcmlseSBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIGJ5IGZvcmNpbmcgdGhlIGdyYXZpdHkgdG8gdGhlIHJpZ2h0LgogICAgICoKICAgICAqIEZvciB0aGUgZm9sbG93aW5nIG1vZGVsIGZyYWdtZW50OgogICAgICoKICAgICAqCQk8JHRleHQgYm9sZD0idHJ1ZSIgbGlua0hyZWY9InVybCI+YmFyW108LyR0ZXh0PjwkdGV4dCBib2xkPSJ0cnVlIj5iaXo8LyR0ZXh0PgogICAgICoKICAgICAqICogRGVmYXVsdCBncmF2aXR5OiBzZWxlY3Rpb24gd2lsbCBoYXZlIHRoZSBgYm9sZGAgYW5kIGBsaW5rSHJlZmAgYXR0cmlidXRlcy4KICAgICAqICogT3ZlcnJpZGRlbiBncmF2aXR5OiBzZWxlY3Rpb24gd2lsbCBoYXZlIGBib2xkYCBhdHRyaWJ1dGUuCiAgICAgKgogICAgICogKipOb3RlKio6IEl0IHJldHVybnMgYW4gdW5pcXVlIGlkZW50aWZpZXIgd2hpY2ggaXMgcmVxdWlyZWQgdG8gcmVzdG9yZSB0aGUgZ3Jhdml0eS4gSXQgZ3VhcmFudGVlcyB0aGUgc3ltbWV0cnkKICAgICAqIG9mIHRoZSBwcm9jZXNzLgogICAgICoKICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB1bmlxdWUgaWQgd2hpY2ggYWxsb3dzIHJlc3RvcmluZyB0aGUgZ3Jhdml0eS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJvdmVycmlkZVNlbGVjdGlvbkdyYXZpdHkiLAogICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJyaWRlU2VsZWN0aW9uR3Jhdml0eSgpIHsKICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uLl9vdmVycmlkZUdyYXZpdHkoKTsKICAgIH0KICAgIC8qKgogICAgICogUmVzdG9yZXMge0BsaW5rIH5Xcml0ZXIjb3ZlcnJpZGVTZWxlY3Rpb25HcmF2aXR5fSBncmF2aXR5IHRvIGRlZmF1bHQuCiAgICAgKgogICAgICogUmVzdG9yaW5nIHRoZSBncmF2aXR5IGlzIG9ubHkgcG9zc2libGUgdXNpbmcgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIHJldHVybmVkIGJ5CiAgICAgKiB7QGxpbmsgfldyaXRlciNvdmVycmlkZVNlbGVjdGlvbkdyYXZpdHl9LiBOb3RlIHRoYXQgdGhlIGdyYXZpdHkgcmVtYWlucyBvdmVycmlkZGVuIGFzIGxvbmcgYXMgd29uJ3QgYmUgcmVzdG9yZWQKICAgICAqIHRoZSBzYW1lIG51bWJlciBvZiB0aW1lcyBpdCB3YXMgb3ZlcnJpZGRlbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdWlkIFRoZSB1bmlxdWUgaWQgcmV0dXJuZWQgYnkge0BsaW5rIH5Xcml0ZXIjb3ZlcnJpZGVTZWxlY3Rpb25HcmF2aXR5fS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZXN0b3JlU2VsZWN0aW9uR3Jhdml0eSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbkdyYXZpdHkodWlkKSB7CiAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uLl9yZXN0b3JlR3Jhdml0eSh1aWQpOwogICAgfQogICAgLyoqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgdGhlIGF0dHJpYnV0ZSB0byByZW1vdmUuCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfc2V0U2VsZWN0aW9uQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2VsZWN0aW9uQXR0cmlidXRlKGtleSwgdmFsdWUpIHsKICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMubW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uOyAvLyBTdG9yZSBhdHRyaWJ1dGUgaW4gcGFyZW50IGVsZW1lbnQgaWYgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQgaW4gYW4gZW1wdHkgbm9kZS4KCiAgICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQgJiYgc2VsZWN0aW9uLmFuY2hvci5wYXJlbnQuaXNFbXB0eSkgewogICAgICAgIHZhciBzdG9yZUtleSA9IERvY3VtZW50U2VsZWN0aW9uLl9nZXRTdG9yZUF0dHJpYnV0ZUtleShrZXkpOwoKICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShzdG9yZUtleSwgdmFsdWUsIHNlbGVjdGlvbi5hbmNob3IucGFyZW50KTsKICAgICAgfQoKICAgICAgc2VsZWN0aW9uLl9zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7CiAgICB9CiAgICAvKioKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlbW92ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcmVtb3ZlU2VsZWN0aW9uQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlU2VsZWN0aW9uQXR0cmlidXRlKGtleSkgewogICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5tb2RlbC5kb2N1bWVudC5zZWxlY3Rpb247IC8vIFJlbW92ZSBzdG9yZWQgYXR0cmlidXRlIGZyb20gcGFyZW50IGVsZW1lbnQgaWYgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQgaW4gYW4gZW1wdHkgbm9kZS4KCiAgICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQgJiYgc2VsZWN0aW9uLmFuY2hvci5wYXJlbnQuaXNFbXB0eSkgewogICAgICAgIHZhciBzdG9yZUtleSA9IERvY3VtZW50U2VsZWN0aW9uLl9nZXRTdG9yZUF0dHJpYnV0ZUtleShrZXkpOwoKICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShzdG9yZUtleSwgc2VsZWN0aW9uLmFuY2hvci5wYXJlbnQpOwogICAgICB9CgogICAgICBzZWxlY3Rpb24uX3JlbW92ZUF0dHJpYnV0ZShrZXkpOwogICAgfQogICAgLyoqCiAgICAgKiBUaHJvd3MgYHdyaXRlci1kZXRhY2hlZC13cml0ZXItdHJpZXMtdG8tbW9kaWZ5LW1vZGVsYCBlcnJvciB3aGVuIHRoZSB3cml0ZXIgaXMgdXNlZCBvdXRzaWRlIG9mIHRoZSBgY2hhbmdlKClgIGJsb2NrLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCkgewogICAgICAvKioKICAgICAgICogVHJ5aW5nIHRvIHVzZSBhIHdyaXRlciBvdXRzaWRlIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlIGBjaGFuZ2UoKWB9IG9yCiAgICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2VucXVldWVDaGFuZ2UgYGVucXVldWVDaGFuZ2UoKWB9IGJsb2Nrcy4KICAgICAgICoKICAgICAgICogVGhlIHdyaXRlciBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB0aGVzZSBibG9ja3Mgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBtb2RlbAogICAgICAgKiBjYW4gb25seSBiZSBjaGFuZ2VkIGR1cmluZyBzdWNoICJzZXNzaW9ucyIuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciB3cml0ZXItaW5jb3JyZWN0LXVzZQogICAgICAgKi8KICAgICAgaWYgKHRoaXMubW9kZWwuX2N1cnJlbnRXcml0ZXIgIT09IHRoaXMpIHsKICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLWluY29ycmVjdC11c2UnLCB0aGlzKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBGb3IgZ2l2ZW4gYWN0aW9uIGB0eXBlYCBhbmQgYHBvc2l0aW9uT3JSYW5nZWAgd2hlcmUgdGhlIGFjdGlvbiBoYXBwZW5zLCB0aGlzIGZ1bmN0aW9uIGZpbmRzIGFsbCBhZmZlY3RlZCBtYXJrZXJzCiAgICAgKiBhbmQgYXBwbGllcyBhIG1hcmtlciBvcGVyYXRpb24gd2l0aCB0aGUgbmV3IG1hcmtlciByYW5nZSBlcXVhbCB0byB0aGUgY3VycmVudCByYW5nZS4gVGhhbmtzIHRvIHRoaXMsIHRoZSBtYXJrZXIgcmFuZ2UKICAgICAqIGNhbiBiZSBsYXRlciBjb3JyZWN0bHkgcHJvY2Vzc2VkIGR1cmluZyB1bmRvLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0geydtb3ZlJ3wnbWVyZ2UnfSB0eXBlIFdyaXRlciBhY3Rpb24gdHlwZS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBwb3NpdGlvbk9yUmFuZ2UgUG9zaXRpb24gb3IgcmFuZ2UKICAgICAqIHdoZXJlIHRoZSB3cml0ZXIgYWN0aW9uIGhhcHBlbnMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2FkZE9wZXJhdGlvbkZvckFmZmVjdGVkTWFya2VycyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZE9wZXJhdGlvbkZvckFmZmVjdGVkTWFya2Vycyh0eXBlLCBwb3NpdGlvbk9yUmFuZ2UpIHsKICAgICAgdmFyIF9pdGVyYXRvcjEwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5tb2RlbC5tYXJrZXJzKSwKICAgICAgICAgIF9zdGVwMTA7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMTAucygpOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbWFya2VyID0gX3N0ZXAxMC52YWx1ZTsKCiAgICAgICAgICBpZiAoIW1hcmtlci5tYW5hZ2VkVXNpbmdPcGVyYXRpb25zKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQoKICAgICAgICAgIHZhciBtYXJrZXJSYW5nZSA9IG1hcmtlci5nZXRSYW5nZSgpOwogICAgICAgICAgdmFyIGlzQWZmZWN0ZWQgPSBmYWxzZTsKCiAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdmUnKSB7CiAgICAgICAgICAgIGlzQWZmZWN0ZWQgPSBwb3NpdGlvbk9yUmFuZ2UuY29udGFpbnNQb3NpdGlvbihtYXJrZXJSYW5nZS5zdGFydCkgfHwgcG9zaXRpb25PclJhbmdlLnN0YXJ0LmlzRXF1YWwobWFya2VyUmFuZ2Uuc3RhcnQpIHx8IHBvc2l0aW9uT3JSYW5nZS5jb250YWluc1Bvc2l0aW9uKG1hcmtlclJhbmdlLmVuZCkgfHwgcG9zaXRpb25PclJhbmdlLmVuZC5pc0VxdWFsKG1hcmtlclJhbmdlLmVuZCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBpZiB0eXBlID09PSAnbWVyZ2UnLgogICAgICAgICAgICB2YXIgZWxlbWVudEJlZm9yZSA9IHBvc2l0aW9uT3JSYW5nZS5ub2RlQmVmb3JlOwogICAgICAgICAgICB2YXIgZWxlbWVudEFmdGVyID0gcG9zaXRpb25PclJhbmdlLm5vZGVBZnRlcjsgLy8gICAgICAgICAgICAgICBTdGFydDogIDxwPkZvb1s8L3A+PHA+QmFyXTwvcD4KICAgICAgICAgICAgLy8gICAgICAgICBBZnRlciBtZXJnZTogIDxwPkZvb1tCYXJdPC9wPgogICAgICAgICAgICAvLyBBZnRlciB1bmRvaW5nIHNwbGl0OiAgPHA+Rm9vPC9wPjxwPltCYXJdPC9wPiAgICAgPC0tIGluY29ycmVjdCwgbmVlZHMgcmVtZW1iZXJpbmcgZm9yIHVuZG8uCiAgICAgICAgICAgIC8vCgogICAgICAgICAgICB2YXIgYWZmZWN0ZWRJbkxlZnRFbGVtZW50ID0gbWFya2VyUmFuZ2Uuc3RhcnQucGFyZW50ID09IGVsZW1lbnRCZWZvcmUgJiYgbWFya2VyUmFuZ2Uuc3RhcnQuaXNBdEVuZDsgLy8gICAgICAgICAgICAgICBTdGFydDogIDxwPltGb288L3A+PHA+XUJhcjwvcD4KICAgICAgICAgICAgLy8gICAgICAgICBBZnRlciBtZXJnZTogIDxwPltGb29dQmFyPC9wPgogICAgICAgICAgICAvLyBBZnRlciB1bmRvaW5nIHNwbGl0OiAgPHA+W0Zvb108L3A+PHA+QmFyPC9wPiAgICAgPC0tIGluY29ycmVjdCwgbmVlZHMgcmVtZW1iZXJpbmcgZm9yIHVuZG8uCiAgICAgICAgICAgIC8vCgogICAgICAgICAgICB2YXIgYWZmZWN0ZWRJblJpZ2h0RWxlbWVudCA9IG1hcmtlclJhbmdlLmVuZC5wYXJlbnQgPT0gZWxlbWVudEFmdGVyICYmIG1hcmtlclJhbmdlLmVuZC5vZmZzZXQgPT0gMDsgLy8gICAgICAgICAgICAgICBTdGFydDogIDxwPltGb288L3A+XTxwPkJhcjwvcD4KICAgICAgICAgICAgLy8gICAgICAgICBBZnRlciBtZXJnZTogIDxwPltGb29dQmFyPC9wPgogICAgICAgICAgICAvLyBBZnRlciB1bmRvaW5nIHNwbGl0OiAgPHA+W0Zvb108L3A+PHA+QmFyPC9wPiAgICAgPC0tIGluY29ycmVjdCwgbmVlZHMgcmVtZW1iZXJpbmcgZm9yIHVuZG8uCiAgICAgICAgICAgIC8vCgogICAgICAgICAgICB2YXIgYWZmZWN0ZWRBZnRlckxlZnRFbGVtZW50ID0gbWFya2VyUmFuZ2UuZW5kLm5vZGVBZnRlciA9PSBlbGVtZW50QWZ0ZXI7IC8vICAgICAgICAgICAgICAgU3RhcnQ6ICA8cD5Gb288L3A+WzxwPkJhcl08L3A+CiAgICAgICAgICAgIC8vICAgICAgICAgQWZ0ZXIgbWVyZ2U6ICA8cD5Gb29bQmFyXTwvcD4KICAgICAgICAgICAgLy8gQWZ0ZXIgdW5kb2luZyBzcGxpdDogIDxwPkZvbzwvcD48cD5bQmFyXTwvcD4gICAgIDwtLSBpbmNvcnJlY3QsIG5lZWRzIHJlbWVtYmVyaW5nIGZvciB1bmRvLgogICAgICAgICAgICAvLwoKICAgICAgICAgICAgdmFyIGFmZmVjdGVkQmVmb3JlUmlnaHRFbGVtZW50ID0gbWFya2VyUmFuZ2Uuc3RhcnQubm9kZUFmdGVyID09IGVsZW1lbnRBZnRlcjsKICAgICAgICAgICAgaXNBZmZlY3RlZCA9IGFmZmVjdGVkSW5MZWZ0RWxlbWVudCB8fCBhZmZlY3RlZEluUmlnaHRFbGVtZW50IHx8IGFmZmVjdGVkQWZ0ZXJMZWZ0RWxlbWVudCB8fCBhZmZlY3RlZEJlZm9yZVJpZ2h0RWxlbWVudDsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoaXNBZmZlY3RlZCkgewogICAgICAgICAgICB0aGlzLnVwZGF0ZU1hcmtlcihtYXJrZXIubmFtZSwgewogICAgICAgICAgICAgIHJhbmdlOiBtYXJrZXJSYW5nZQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjEwLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IxMC5mKCk7CiAgICAgIH0KICAgIH0KICB9XSk7CgogIHJldHVybiBXcml0ZXI7Cn0oKTsgLy8gU2V0cyBnaXZlbiBhdHRyaWJ1dGUgdG8gZWFjaCBub2RlIGluIGdpdmVuIHJhbmdlLiBXaGVuIGF0dHJpYnV0ZSB2YWx1ZSBpcyBudWxsIHRoZW4gYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZC4KLy8KLy8gQmVjYXVzZSBhdHRyaWJ1dGUgb3BlcmF0aW9uIG5lZWRzIHRvIGhhdmUgdGhlIHNhbWUgYXR0cmlidXRlIHZhbHVlIG9uIHRoZSB3aG9sZSByYW5nZSwgdGhpcyBmdW5jdGlvbiBzcGxpdHMKLy8gdGhlIHJhbmdlIGludG8gc21hbGxlciBwYXJ0cy4KLy8KLy8gR2l2ZW4gYHJhbmdlYCBtdXN0IGJlIGZsYXQuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSB3cml0ZXIKLy8gQHBhcmFtIHtTdHJpbmd9IGtleSBBdHRyaWJ1dGUga2V5LgovLyBAcGFyYW0geyp9IHZhbHVlIEF0dHJpYnV0ZSBuZXcgdmFsdWUuCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UgTW9kZWwgcmFuZ2Ugb24gd2hpY2ggdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldC4KCgpleHBvcnQgeyBXcml0ZXIgYXMgZGVmYXVsdCB9OwoKZnVuY3Rpb24gc2V0QXR0cmlidXRlT25SYW5nZSh3cml0ZXIsIGtleSwgdmFsdWUsIHJhbmdlKSB7CiAgdmFyIG1vZGVsID0gd3JpdGVyLm1vZGVsOwogIHZhciBkb2MgPSBtb2RlbC5kb2N1bWVudDsgLy8gUG9zaXRpb24gb2YgdGhlIGxhc3Qgc3BsaXQsIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyByYW5nZS4KCiAgdmFyIGxhc3RTcGxpdFBvc2l0aW9uID0gcmFuZ2Uuc3RhcnQ7IC8vIEN1cnJlbnRseSBwb3NpdGlvbiBpbiB0aGUgc2Nhbm5pbmcgcmFuZ2UuIEJlY2F1c2Ugd2UgbmVlZCB2YWx1ZSBhZnRlciB0aGUgcG9zaXRpb24sIGl0IGlzIG5vdCBhIGN1cnJlbnQKICAvLyBwb3NpdGlvbiBvZiB0aGUgaXRlcmF0b3IgYnV0IHRoZSBwcmV2aW91cyBvbmUgKHdlIG5lZWQgdG8gaXRlcmF0ZSBvbmUgbW9yZSB0aW1lIHRvIGdldCB0aGUgdmFsdWUgYWZ0ZXIpLgoKICB2YXIgcG9zaXRpb247IC8vIFZhbHVlIGJlZm9yZSB0aGUgY3VycmVudGx5IHBvc2l0aW9uLgoKICB2YXIgdmFsdWVCZWZvcmU7IC8vIFZhbHVlIGFmdGVyIHRoZSBjdXJyZW50bHkgcG9zaXRpb24uCgogIHZhciB2YWx1ZUFmdGVyOwoKICB2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyYW5nZS5nZXRXYWxrZXIoewogICAgc2hhbGxvdzogdHJ1ZQogIH0pKSwKICAgICAgX3N0ZXAxMTsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMTEucygpOyAhKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciB2YWwgPSBfc3RlcDExLnZhbHVlOwogICAgICB2YWx1ZUFmdGVyID0gdmFsLml0ZW0uZ2V0QXR0cmlidXRlKGtleSk7IC8vIEF0IHRoZSBmaXJzdCBydW4gb2YgdGhlIGl0ZXJhdG9yIHRoZSBwb3NpdGlvbiBpbiB1bmRlZmluZWQuIFdlIGFsc28gZG8gbm90IGhhdmUgYSB2YWx1ZUJlZm9yZSwgYnV0CiAgICAgIC8vIGJlY2F1c2UgdmFsdWVBZnRlciBtYXkgYmUgbnVsbCwgdmFsdWVCZWZvcmUgbWF5IGJlIGVxdWFsIHZhbHVlQWZ0ZXIgKCB1bmRlZmluZWQgPT0gbnVsbCApLgoKICAgICAgaWYgKHBvc2l0aW9uICYmIHZhbHVlQmVmb3JlICE9IHZhbHVlQWZ0ZXIpIHsKICAgICAgICAvLyBpZiB2YWx1ZUJlZm9yZSA9PSB2YWx1ZSB0aGVyZSBpcyBub3RoaW5nIHRvIGNoYW5nZSwgc28gd2UgYWRkIG9wZXJhdGlvbiBvbmx5IGlmIHRoZXNlIHZhbHVlcyBhcmUgZGlmZmVyZW50LgogICAgICAgIGlmICh2YWx1ZUJlZm9yZSAhPSB2YWx1ZSkgewogICAgICAgICAgYWRkT3BlcmF0aW9uKCk7CiAgICAgICAgfQoKICAgICAgICBsYXN0U3BsaXRQb3NpdGlvbiA9IHBvc2l0aW9uOwogICAgICB9CgogICAgICBwb3NpdGlvbiA9IHZhbC5uZXh0UG9zaXRpb247CiAgICAgIHZhbHVlQmVmb3JlID0gdmFsdWVBZnRlcjsKICAgIH0gLy8gQmVjYXVzZSBwb3NpdGlvbiBpbiB0aGUgbG9vcCBpcyBub3QgdGhlIGl0ZXJhdG9yIHBvc2l0aW9uIChzZWUgbGV0IHBvc2l0aW9uIGNvbW1lbnQpLCB0aGUgbGFzdCBwb3NpdGlvbiBpbgogICAgLy8gdGhlIHdoaWxlIGxvb3Agd2lsbCBiZSBsYXN0IGJ1dCBvbmUgcG9zaXRpb24gaW4gdGhlIHJhbmdlLiBXZSBuZWVkIHRvIGNoZWNrIHRoZSBsYXN0IHBvc2l0aW9uIG1hbnVhbGx5LgoKICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjExLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yMTEuZigpOwogIH0KCiAgaWYgKHBvc2l0aW9uIGluc3RhbmNlb2YgUG9zaXRpb24gJiYgcG9zaXRpb24gIT0gbGFzdFNwbGl0UG9zaXRpb24gJiYgdmFsdWVCZWZvcmUgIT0gdmFsdWUpIHsKICAgIGFkZE9wZXJhdGlvbigpOwogIH0KCiAgZnVuY3Rpb24gYWRkT3BlcmF0aW9uKCkgewogICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKGxhc3RTcGxpdFBvc2l0aW9uLCBwb3NpdGlvbik7CiAgICB2YXIgdmVyc2lvbiA9IHJhbmdlLnJvb3QuZG9jdW1lbnQgPyBkb2MudmVyc2lvbiA6IG51bGw7CiAgICB2YXIgb3BlcmF0aW9uID0gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwga2V5LCB2YWx1ZUJlZm9yZSwgdmFsdWUsIHZlcnNpb24pOwogICAgd3JpdGVyLmJhdGNoLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pOwogICAgbW9kZWwuYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKTsKICB9Cn0gLy8gU2V0cyBnaXZlbiBhdHRyaWJ1dGUgdG8gdGhlIGdpdmVuIG5vZGUuIFdoZW4gYXR0cmlidXRlIHZhbHVlIGlzIG51bGwgdGhlbiBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyCi8vIEBwYXJhbSB7U3RyaW5nfSBrZXkgQXR0cmlidXRlIGtleS4KLy8gQHBhcmFtIHsqfSB2YWx1ZSBBdHRyaWJ1dGUgbmV3IHZhbHVlLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtIE1vZGVsIGl0ZW0gb24gd2hpY2ggdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldC4KCgpmdW5jdGlvbiBzZXRBdHRyaWJ1dGVPbkl0ZW0od3JpdGVyLCBrZXksIHZhbHVlLCBpdGVtKSB7CiAgdmFyIG1vZGVsID0gd3JpdGVyLm1vZGVsOwogIHZhciBkb2MgPSBtb2RlbC5kb2N1bWVudDsKICB2YXIgcHJldmlvdXNWYWx1ZSA9IGl0ZW0uZ2V0QXR0cmlidXRlKGtleSk7CiAgdmFyIHJhbmdlLCBvcGVyYXRpb247CgogIGlmIChwcmV2aW91c1ZhbHVlICE9IHZhbHVlKSB7CiAgICB2YXIgaXNSb290Q2hhbmdlZCA9IGl0ZW0ucm9vdCA9PT0gaXRlbTsKCiAgICBpZiAoaXNSb290Q2hhbmdlZCkgewogICAgICAvLyBJZiB3ZSBjaGFuZ2UgYXR0cmlidXRlcyBvZiByb290IGVsZW1lbnQsIHdlIGhhdmUgdG8gdXNlIGBSb290QXR0cmlidXRlT3BlcmF0aW9uYC4KICAgICAgdmFyIHZlcnNpb24gPSBpdGVtLmRvY3VtZW50ID8gZG9jLnZlcnNpb24gOiBudWxsOwogICAgICBvcGVyYXRpb24gPSBuZXcgUm9vdEF0dHJpYnV0ZU9wZXJhdGlvbihpdGVtLCBrZXksIHByZXZpb3VzVmFsdWUsIHZhbHVlLCB2ZXJzaW9uKTsKICAgIH0gZWxzZSB7CiAgICAgIHJhbmdlID0gbmV3IFJhbmdlKFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSksIHdyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKGl0ZW0pKTsKCiAgICAgIHZhciBfdmVyc2lvbiA9IHJhbmdlLnJvb3QuZG9jdW1lbnQgPyBkb2MudmVyc2lvbiA6IG51bGw7CgogICAgICBvcGVyYXRpb24gPSBuZXcgQXR0cmlidXRlT3BlcmF0aW9uKHJhbmdlLCBrZXksIHByZXZpb3VzVmFsdWUsIHZhbHVlLCBfdmVyc2lvbik7CiAgICB9CgogICAgd3JpdGVyLmJhdGNoLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pOwogICAgbW9kZWwuYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKTsKICB9Cn0gLy8gQ3JlYXRlcyBhbmQgYXBwbGllcyBtYXJrZXIgb3BlcmF0aW9uIHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uIG9wZXJhdGlvbn0uCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSB3cml0ZXIKLy8gQHBhcmFtIHtTdHJpbmd9IG5hbWUgTWFya2VyIG5hbWUuCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gb2xkUmFuZ2UgTWFya2VyIHJhbmdlIGJlZm9yZSB0aGUgY2hhbmdlLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG5ld1JhbmdlIE1hcmtlciByYW5nZSBhZnRlciB0aGUgY2hhbmdlLgovLyBAcGFyYW0ge0Jvb2xlYW59IGFmZmVjdHNEYXRhCgoKZnVuY3Rpb24gYXBwbHlNYXJrZXJPcGVyYXRpb24od3JpdGVyLCBuYW1lLCBvbGRSYW5nZSwgbmV3UmFuZ2UsIGFmZmVjdHNEYXRhKSB7CiAgdmFyIG1vZGVsID0gd3JpdGVyLm1vZGVsOwogIHZhciBkb2MgPSBtb2RlbC5kb2N1bWVudDsKICB2YXIgb3BlcmF0aW9uID0gbmV3IE1hcmtlck9wZXJhdGlvbihuYW1lLCBvbGRSYW5nZSwgbmV3UmFuZ2UsIG1vZGVsLm1hcmtlcnMsIGFmZmVjdHNEYXRhLCBkb2MudmVyc2lvbik7CiAgd3JpdGVyLmJhdGNoLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pOwogIG1vZGVsLmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbik7Cn0gLy8gQ3JlYXRlcyBgTW92ZU9wZXJhdGlvbmAgb3IgYERldGFjaE9wZXJhdGlvbmAgdGhhdCByZW1vdmVzIGBob3dNYW55YCBub2RlcyBzdGFydGluZyBmcm9tIGBwb3NpdGlvbmAuCi8vIFRoZSBvcGVyYXRpb24gd2lsbCBiZSBhcHBsaWVkIG9uIGdpdmVuIG1vZGVsIGluc3RhbmNlIGFuZCBhZGRlZCB0byBnaXZlbiBvcGVyYXRpb24gaW5zdGFuY2UuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gZnJvbSB3aGljaCBub2RlcyBhcmUgcmVtb3ZlZC4KLy8gQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgTnVtYmVyIG9mIG5vZGVzIHRvIHJlbW92ZS4KLy8gQHBhcmFtIHtCYXRjaH0gYmF0Y2ggQmF0Y2ggdG8gd2hpY2ggdGhlIG9wZXJhdGlvbiB3aWxsIGJlIGFkZGVkLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9IG1vZGVsIE1vZGVsIGluc3RhbmNlIG9uIHdoaWNoIG9wZXJhdGlvbiB3aWxsIGJlIGFwcGxpZWQuCgoKZnVuY3Rpb24gYXBwbHlSZW1vdmVPcGVyYXRpb24ocG9zaXRpb24sIGhvd01hbnksIGJhdGNoLCBtb2RlbCkgewogIHZhciBvcGVyYXRpb247CgogIGlmIChwb3NpdGlvbi5yb290LmRvY3VtZW50KSB7CiAgICB2YXIgZG9jID0gbW9kZWwuZG9jdW1lbnQ7CiAgICB2YXIgZ3JhdmV5YXJkUG9zaXRpb24gPSBuZXcgUG9zaXRpb24oZG9jLmdyYXZleWFyZCwgWzBdKTsKICAgIG9wZXJhdGlvbiA9IG5ldyBNb3ZlT3BlcmF0aW9uKHBvc2l0aW9uLCBob3dNYW55LCBncmF2ZXlhcmRQb3NpdGlvbiwgZG9jLnZlcnNpb24pOwogIH0gZWxzZSB7CiAgICBvcGVyYXRpb24gPSBuZXcgRGV0YWNoT3BlcmF0aW9uKHBvc2l0aW9uLCBob3dNYW55KTsKICB9CgogIGJhdGNoLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pOwogIG1vZGVsLmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbik7Cn0gLy8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCByb290IGVsZW1lbnRzIGFyZSB0aGUgc2FtZSBlbGVtZW50IG9yIGJvdGggYXJlIGRvY3VtZW50cyByb290IGVsZW1lbnRzLgovLwovLyBFbGVtZW50cyBpbiB0aGUgc2FtZSB0cmVlIGNhbiBiZSBtb3ZlZCAoZm9yIGluc3RhbmNlIHlvdSBjYW4gbW92ZSBlbGVtZW50IGZvcm0gb25lIGRvY3VtZW50cyByb290IHRvIGFub3RoZXIsIG9yCi8vIHdpdGhpbiB0aGUgc2FtZSBkb2N1bWVudCBmcmFnbWVudCksIGJ1dCB3aGVuIGVsZW1lbnQgc3VwcG9zZWQgdG8gYmUgbW92ZWQgZnJvbSBkb2N1bWVudCBmcmFnbWVudCB0byB0aGUgZG9jdW1lbnQsIG9yCi8vIHRvIGFub3RoZXIgZG9jdW1lbnQgaXQgc2hvdWxkIGJlIHJlbW92ZWQgYW5kIGluc2VydGVkIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggT1QuIFRoaXMgaXMgYmVjYXVzZSBmZWF0dXJlcyBsaWtlIHVuZG8gb3IKLy8gY29sbGFib3JhdGlvbiBtYXkgdHJhY2sgY2hhbmdlcyBvbiB0aGUgZG9jdW1lbnQgYnV0IGlnbm9yZSBjaGFuZ2VzIG9uIGRldGFjaGVkIGZyYWdtZW50cyBhbmQgc2hvdWxkIG5vdCBnZXQKLy8gdW5leHBlY3RlZCBgbW92ZWAgb3BlcmF0aW9uLgoKCmZ1bmN0aW9uIGlzU2FtZVRyZWUocm9vdEEsIHJvb3RCKSB7CiAgLy8gSWYgaXQgaXMgdGhlIHNhbWUgcm9vdCB0aGlzIGlzIHRoZSBzYW1lIHRyZWUuCiAgaWYgKHJvb3RBID09PSByb290QikgewogICAgcmV0dXJuIHRydWU7CiAgfSAvLyBJZiBib3RoIHJvb3RzIGFyZSBkb2N1bWVudHMgcm9vdCBpdCBpcyBvcGVyYXRpb24gd2l0aGluIHRoZSBkb2N1bWVudCB3aGF0IHdlIHN0aWxsIHRyZWF0IGFzIHRoZSBzYW1lIHRyZWUuCgoKICBpZiAocm9vdEEgaW5zdGFuY2VvZiBSb290RWxlbWVudCAmJiByb290QiBpbnN0YW5jZW9mIFJvb3RFbGVtZW50KSB7CiAgICByZXR1cm4gdHJ1ZTsKICB9CgogIHJldHVybiBmYWxzZTsKfQ=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js"],"names":["AttributeOperation","DetachOperation","InsertOperation","MarkerOperation","MoveOperation","RenameOperation","RootAttributeOperation","SplitOperation","MergeOperation","DocumentFragment","Text","Element","RootElement","Position","Range","DocumentSelection","toMap","CKEditorError","Writer","model","batch","data","attributes","name","element","deep","_clone","item","itemOrPosition","offset","_assertWriterUsedCorrectly","position","_createAt","parent","isSameTree","root","move","_createOn","document","remove","version","insert","shouldReceiveAttributes","addOperation","applyOperation","markers","markerName","markerRange","rangeRootPosition","range","start","_getCombined","end","options","usingOperation","affectsData","has","updateMarker","addMarker","text","createText","createElement","key","value","itemOrRange","ranges","getMinimalFlatRanges","setAttributeOnRange","setAttributeOnItem","val","setAttribute","removeAttributesFromItem","getAttributeKeys","attribute","removeAttribute","getItems","isFlat","isEqual","_addOperationForAffectedMarkers","operation","rangeToRemove","reverse","flat","applyRemoveOperation","nodeBefore","nodeAfter","_mergeDetached","_merge","path","stickiness","createPositionFromPath","createPositionAt","createPositionAfter","createPositionBefore","createRange","createRangeIn","createRangeOn","selectable","placeOrOffset","createSelection","_createIn","targetPosition","sourcePosition","graveyard","graveyardPosition","merge","maxOffset","newName","renameOperation","_createBefore","limitElement","splitElement","getAncestors","includeSelf","includes","firstSplitElement","firstCopyElement","howMany","insertionPosition","getInsertionPosition","split","nextSibling","elementOrString","childCount","shiftedRange","getShiftedBy","undefined","_set","applyMarkerOperation","get","markerOrName","currentMarker","_refresh","hasUsingOperationDefined","affectsDataDefined","currentRange","getRange","updatedRange","managedUsingOperations","marker","_remove","oldRange","selection","_setTo","_setFocus","keyOrObjectOrIterable","_setSelectionAttribute","keyOrIterableOfKeys","_removeSelectionAttribute","_overrideGravity","uid","_restoreGravity","isCollapsed","anchor","isEmpty","storeKey","_getStoreAttributeKey","_setAttribute","_removeAttribute","_currentWriter","type","positionOrRange","isAffected","containsPosition","elementBefore","elementAfter","affectedInLeftElement","isAtEnd","affectedInRightElement","affectedAfterLeftElement","affectedBeforeRightElement","writer","doc","lastSplitPosition","valueBefore","valueAfter","getWalker","shallow","getAttribute","nextPosition","previousValue","isRootChanged","newRange","rootA","rootB"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/writer\n */\n\nimport AttributeOperation from './operation/attributeoperation';\nimport DetachOperation from './operation/detachoperation';\nimport InsertOperation from './operation/insertoperation';\nimport MarkerOperation from './operation/markeroperation';\nimport MoveOperation from './operation/moveoperation';\nimport RenameOperation from './operation/renameoperation';\nimport RootAttributeOperation from './operation/rootattributeoperation';\nimport SplitOperation from './operation/splitoperation';\nimport MergeOperation from './operation/mergeoperation';\n\nimport DocumentFragment from './documentfragment';\nimport Text from './text';\nimport Element from './element';\nimport RootElement from './rootelement';\nimport Position from './position';\nimport Range from './range.js';\nimport DocumentSelection from './documentselection';\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible\n * to create incorrect model structures by using the writer. Read more about in\n * {@glink framework/guides/deep-dive/schema#who-checks-the-schema \"Who checks the schema?\"}.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\nexport default class Writer {\n\t/**\n\t * Creates a writer instance.\n\t *\n\t * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n\t * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/model~Model} model\n\t * @param {module:engine/model/batch~Batch} batch\n\t */\n\tconstructor( model, batch ) {\n\t\t/**\n\t\t * Instance of the model on which this writer operates.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The batch to which this writer will add changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/batch~Batch}\n\t\t */\n\t\tthis.batch = batch;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\t\twriter.createText( 'foo', { bold: true } );\n\t *\n\t * @param {String} data Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @returns {module:engine/model/text~Text} Created text node.\n\t */\n\tcreateText( data, attributes ) {\n\t\treturn new Text( data, attributes );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/element~Element element}.\n\t *\n\t *\t\twriter.createElement( 'paragraph' );\n\t *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/model/element~Element} Created element.\n\t */\n\tcreateElement( name, attributes ) {\n\t\treturn new Element( name, attributes );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n\t *\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n\t */\n\tcreateDocumentFragment() {\n\t\treturn new DocumentFragment();\n\t}\n\n\t/**\n\t * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.\n\t * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n\t *\n\t * @param {module:engine/model/element~Element} element The element to clone.\n\t * @param {Boolean} [deep=true] If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any child.\n\t */\n\tcloneElement( element, deep = true ) {\n\t\treturn element._clone( deep );\n\t}\n\n\t/**\n\t * Inserts item on given position.\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.insert( paragraph, position );\n\t *\n\t * Instead of using position you can use parent and offset:\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\twriter.insert( text, paragraph, 5 );\n\t *\n\t * You can also use `end` instead of the offset to insert at the end:\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\twriter.insert( text, paragraph, 'end' );\n\t *\n\t * Or insert before or after another element:\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * Note that if the item already has parent it will be removed from the previous parent.\n\t *\n\t * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n\t * `model-writer-insert-forbidden-move` is thrown.\n\t *\n\t * If you want to move {@link module:engine/model/range~Range range} instead of an\n\t * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n\t *\n\t * **Note:** For a paste-like content insertion mechanism see\n\t * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n\t * fragment to insert.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * second parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsert( item, itemOrPosition, offset = 0 ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( item instanceof Text && item.data == '' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst position = Position._createAt( itemOrPosition, offset );\n\n\t\t// If item has a parent already.\n\t\tif ( item.parent ) {\n\t\t\t// We need to check if item is going to be inserted within the same document.\n\t\t\tif ( isSameTree( item.root, position.root ) ) {\n\t\t\t\t// If it's we just need to move it.\n\t\t\t\tthis.move( Range._createOn( item ), position );\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If it isn't the same root.\n\t\t\telse {\n\t\t\t\tif ( item.root.document ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * Cannot move a node from a document to a different tree.\n\t\t\t\t\t * It is forbidden to move a node that was already in a document outside of it.\n\t\t\t\t\t *\n\t\t\t\t\t * @error model-writer-insert-forbidden-move\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t'model-writer-insert-forbidden-move',\n\t\t\t\t\t\tthis\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Move between two different document fragments or from document fragment to a document is possible.\n\t\t\t\t\t// In that case, remove the item from it's original parent.\n\t\t\t\t\tthis.remove( item );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst version = position.root.document ? position.root.document.version : null;\n\n\t\tconst insert = new InsertOperation( position, item, version );\n\n\t\tif ( item instanceof Text ) {\n\t\t\tinsert.shouldReceiveAttributes = true;\n\t\t}\n\n\t\tthis.batch.addOperation( insert );\n\t\tthis.model.applyOperation( insert );\n\n\t\t// When element is a DocumentFragment we need to move its markers to Document#markers.\n\t\tif ( item instanceof DocumentFragment ) {\n\t\t\tfor ( const [ markerName, markerRange ] of item.markers ) {\n\t\t\t\t// We need to migrate marker range from DocumentFragment to Document.\n\t\t\t\tconst rangeRootPosition = Position._createAt( markerRange.root, 0 );\n\t\t\t\tconst range = new Range(\n\t\t\t\t\tmarkerRange.start._getCombined( rangeRootPosition, position ),\n\t\t\t\t\tmarkerRange.end._getCombined( rangeRootPosition, position )\n\t\t\t\t);\n\n\t\t\t\tconst options = { range, usingOperation: true, affectsData: true };\n\n\t\t\t\tif ( this.model.markers.has( markerName ) ) {\n\t\t\t\t\tthis.updateMarker( markerName, options );\n\t\t\t\t} else {\n\t\t\t\t\tthis.addMarker( markerName, options );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates and inserts text on given position. You can optionally set text attributes:\n\t *\n\t *\t\twriter.insertText( 'foo', position );\n\t *\t\twriter.insertText( 'foo', { bold: true }, position );\n\t *\n\t * Instead of using position you can use parent and offset or define that text should be inserted at the end\n\t * or before or after other node:\n\t *\n\t *\t\t// Inserts 'foo' in paragraph, at offset 5:\n\t *\t\twriter.insertText( 'foo', paragraph, 5 );\n\t *\t\t// Inserts 'foo' at the end of a paragraph:\n\t *\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t// Inserts 'foo' after an image:\n\t *\t\twriter.insertText( 'foo', image, 'after' );\n\t *\n\t * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * @param {String} data Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * third parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsertText( text, attributes, itemOrPosition, offset ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position ) {\n\t\t\tthis.insert( this.createText( text ), attributes, itemOrPosition );\n\t\t} else {\n\t\t\tthis.insert( this.createText( text, attributes ), itemOrPosition, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Creates and inserts element on given position. You can optionally set attributes:\n\t *\n\t *\t\twriter.insertElement( 'paragraph', position );\n\t *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n\t *\n\t * Instead of using position you can use parent and offset or define that text should be inserted at the end\n\t * or before or after other node:\n\t *\n\t *\t\t// Inserts paragraph in the root at offset 5:\n\t *\t\twriter.insertElement( 'paragraph', root, 5 );\n\t *\t\t// Inserts paragraph at the end of a blockquote:\n\t *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n\t *\t\t// Inserts after an image:\n\t *\t\twriter.insertElement( 'paragraph', image, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * third parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsertElement( name, attributes, itemOrPosition, offset ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position ) {\n\t\t\tthis.insert( this.createElement( name ), attributes, itemOrPosition );\n\t\t} else {\n\t\t\tthis.insert( this.createElement( name, attributes ), itemOrPosition, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Inserts item at the end of the given parent.\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.append( paragraph, root );\n\t *\n\t * Note that if the item already has parent it will be removed from the previous parent.\n\t *\n\t * If you want to move {@link module:engine/model/range~Range range} instead of an\n\t * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n\t * item Item or document fragment to insert.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappend( item, parent ) {\n\t\tthis.insert( item, parent, 'end' );\n\t}\n\n\t/**\n\t * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n\t *\n\t *\t\twriter.appendText( 'foo', paragraph );\n\t *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n\t *\n\t * @param {String} text Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappendText( text, attributes, parent ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element ) {\n\t\t\tthis.insert( this.createText( text ), attributes, 'end' );\n\t\t} else {\n\t\t\tthis.insert( this.createText( text, attributes ), parent, 'end' );\n\t\t}\n\t}\n\n\t/**\n\t * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n\t *\n\t *\t\twriter.appendElement( 'paragraph', root );\n\t *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappendElement( name, attributes, parent ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element ) {\n\t\t\tthis.insert( this.createElement( name ), attributes, 'end' );\n\t\t} else {\n\t\t\tthis.insert( this.createElement( name, attributes ), parent, 'end' );\n\t\t}\n\t}\n\n\t/**\n\t * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n\t * or on a {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {*} value Attribute new value.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range on which the attribute will be set.\n\t */\n\tsetAttribute( key, value, itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\tconst ranges = itemOrRange.getMinimalFlatRanges();\n\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tsetAttributeOnRange( this, key, value, range );\n\t\t\t}\n\t\t} else {\n\t\t\tsetAttributeOnItem( this, key, value, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n\t * or on a {@link module:engine/model/range~Range range}.\n\t *\n\t *\t\twriter.setAttributes( {\n\t *\t\t\tbold: true,\n\t *\t\t\titalic: true\n\t *\t\t}, range );\n\t *\n\t * @param {Object} attributes Attributes keys and values.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range on which the attributes will be set.\n\t */\n\tsetAttributes( attributes, itemOrRange ) {\n\t\tfor ( const [ key, val ] of toMap( attributes ) ) {\n\t\t\tthis.setAttribute( key, val, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n\t * or from a {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range from which the attribute will be removed.\n\t */\n\tremoveAttribute( key, itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\tconst ranges = itemOrRange.getMinimalFlatRanges();\n\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tsetAttributeOnRange( this, key, null, range );\n\t\t\t}\n\t\t} else {\n\t\t\tsetAttributeOnItem( this, key, null, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Removes all attributes from all elements in the range or from the given item.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range from which all attributes will be removed.\n\t */\n\tclearAttributes( itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst removeAttributesFromItem = item => {\n\t\t\tfor ( const attribute of item.getAttributeKeys() ) {\n\t\t\t\tthis.removeAttribute( attribute, item );\n\t\t\t}\n\t\t};\n\n\t\tif ( !( itemOrRange instanceof Range ) ) {\n\t\t\tremoveAttributesFromItem( itemOrRange );\n\t\t} else {\n\t\t\tfor ( const item of itemOrRange.getItems() ) {\n\t\t\t\tremoveAttributesFromItem( item );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves all items in the source range to the target position.\n\t *\n\t *\t\twriter.move( sourceRange, targetPosition );\n\t *\n\t * Instead of the target position you can use parent and offset or define that range should be moved to the end\n\t * or before or after chosen item:\n\t *\n\t *\t\t// Moves all items in the range to the paragraph at offset 5:\n\t *\t\twriter.move( sourceRange, paragraph, 5 );\n\t *\t\t// Moves all items in the range to the end of a blockquote:\n\t *\t\twriter.move( sourceRange, blockquote, 'end' );\n\t *\t\t// Moves all items in the range to a position after an image:\n\t *\t\twriter.move( sourceRange, image, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * Note that items can be moved only within the same tree. It means that you can move items within the same root\n\t * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n\t * but you can not move items from document fragment to the document or from one detached element to another. Use\n\t * {@link module:engine/model/writer~Writer#insert} in such cases.\n\t *\n\t * @param {module:engine/model/range~Range} range Source range.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * second parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tmove( range, itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !( range instanceof Range ) ) {\n\t\t\t/**\n\t\t\t * Invalid range to move.\n\t\t\t *\n\t\t\t * @error writer-move-invalid-range\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-invalid-range', this );\n\t\t}\n\n\t\tif ( !range.isFlat ) {\n\t\t\t/**\n\t\t\t * Range to move is not flat.\n\t\t\t *\n\t\t\t * @error writer-move-range-not-flat\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-range-not-flat', this );\n\t\t}\n\n\t\tconst position = Position._createAt( itemOrPosition, offset );\n\n\t\t// Do not move anything if the move target is same as moved range start.\n\t\tif ( position.isEqual( range.start ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\tthis._addOperationForAffectedMarkers( 'move', range );\n\n\t\tif ( !isSameTree( range.root, position.root ) ) {\n\t\t\t/**\n\t\t\t * Range is going to be moved within not the same document. Please use\n\t\t\t * {@link module:engine/model/writer~Writer#insert insert} instead.\n\t\t\t *\n\t\t\t * @error writer-move-different-document\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-different-document', this );\n\t\t}\n\n\t\tconst version = range.root.document ? range.root.document.version : null;\n\t\tconst operation = new MoveOperation( range.start, range.end.offset - range.start.offset, position, version );\n\n\t\tthis.batch.addOperation( operation );\n\t\tthis.model.applyOperation( operation );\n\t}\n\n\t/**\n\t * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n\t */\n\tremove( itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn( itemOrRange );\n\t\tconst ranges = rangeToRemove.getMinimalFlatRanges().reverse();\n\n\t\tfor ( const flat of ranges ) {\n\t\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\t\tthis._addOperationForAffectedMarkers( 'move', flat );\n\n\t\t\tapplyRemoveOperation( flat.start, flat.end.offset - flat.start.offset, this.batch, this.model );\n\t\t}\n\t}\n\n\t/**\n\t * Merges two siblings at the given position.\n\t *\n\t * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n\t * `writer-merge-no-element-after` error will be thrown.\n\t *\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\tmerge( position ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst nodeBefore = position.nodeBefore;\n\t\tconst nodeAfter = position.nodeAfter;\n\n\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\tthis._addOperationForAffectedMarkers( 'merge', position );\n\n\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Node before merge position must be an element.\n\t\t\t *\n\t\t\t * @error writer-merge-no-element-before\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-merge-no-element-before', this );\n\t\t}\n\n\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Node after merge position must be an element.\n\t\t\t *\n\t\t\t * @error writer-merge-no-element-after\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-merge-no-element-after', this );\n\t\t}\n\n\t\tif ( !position.root.document ) {\n\t\t\tthis._mergeDetached( position );\n\t\t} else {\n\t\t\tthis._merge( position );\n\t\t}\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionFromPath( root, path, stickiness ) {\n\t\treturn this.model.createPositionFromPath( root, path, stickiness );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn this.model.createPositionAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn this.model.createPositionAfter( item );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn this.model.createPositionBefore( item );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn this.model.createRange( start, end );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn this.model.createRangeIn( element );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeOn( element ) {\n\t\treturn this.model.createRangeOn( element );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @returns {module:engine/model/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn this.model.createSelection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Performs merge action in a detached tree.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\t_mergeDetached( position ) {\n\t\tconst nodeBefore = position.nodeBefore;\n\t\tconst nodeAfter = position.nodeAfter;\n\n\t\tthis.move( Range._createIn( nodeAfter ), Position._createAt( nodeBefore, 'end' ) );\n\t\tthis.remove( nodeAfter );\n\t}\n\n\t/**\n\t * Performs merge action in a non-detached tree.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\t_merge( position ) {\n\t\tconst targetPosition = Position._createAt( position.nodeBefore, 'end' );\n\t\tconst sourcePosition = Position._createAt( position.nodeAfter, 0 );\n\n\t\tconst graveyard = position.root.document.graveyard;\n\t\tconst graveyardPosition = new Position( graveyard, [ 0 ] );\n\n\t\tconst version = position.root.document.version;\n\n\t\tconst merge = new MergeOperation( sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version );\n\n\t\tthis.batch.addOperation( merge );\n\t\tthis.model.applyOperation( merge );\n\t}\n\n\t/**\n\t * Renames the given element.\n\t *\n\t * @param {module:engine/model/element~Element} element The element to rename.\n\t * @param {String} newName New element name.\n\t */\n\trename( element, newName ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !( element instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Trying to rename an object which is not an instance of Element.\n\t\t\t *\n\t\t\t * @error writer-rename-not-element-instance\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-rename-not-element-instance',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tconst version = element.root.document ? element.root.document.version : null;\n\t\tconst renameOperation = new RenameOperation( Position._createBefore( element ), element.name, newName, version );\n\n\t\tthis.batch.addOperation( renameOperation );\n\t\tthis.model.applyOperation( renameOperation );\n\t}\n\n\t/**\n\t * Splits elements starting from the given position and going to the top of the model tree as long as given\n\t * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n\t *\n\t * The element needs to have a parent. It cannot be a root element nor a document fragment.\n\t * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n\t *\n\t * @param {module:engine/model/position~Position} position Position of split.\n\t * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n\t * @returns {Object} result Split result.\n\t * @returns {module:engine/model/position~Position} result.position Position between split elements.\n\t * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends\n\t * at the beginning of the first copy element.\n\t */\n\tsplit( position, limitElement ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tlet splitElement = position.parent;\n\n\t\tif ( !splitElement.parent ) {\n\t\t\t/**\n\t\t\t * Element with no parent can not be split.\n\t\t\t *\n\t\t\t * @error writer-split-element-no-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-split-element-no-parent', this );\n\t\t}\n\n\t\t// When limit element is not defined lets set splitElement parent as limit.\n\t\tif ( !limitElement ) {\n\t\t\tlimitElement = splitElement.parent;\n\t\t}\n\n\t\tif ( !position.parent.getAncestors( { includeSelf: true } ).includes( limitElement ) ) {\n\t\t\t/**\n\t\t\t * Limit element is not a position ancestor.\n\t\t\t *\n\t\t\t * @error writer-split-invalid-limit-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-split-invalid-limit-element', this );\n\t\t}\n\n\t\t// We need to cache elements that will be created as a result of the first split because\n\t\t// we need to create a range from the end of the first split element to the beginning of the\n\t\t// first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n\t\tlet firstSplitElement, firstCopyElement;\n\n\t\tdo {\n\t\t\tconst version = splitElement.root.document ? splitElement.root.document.version : null;\n\t\t\tconst howMany = splitElement.maxOffset - position.offset;\n\n\t\t\tconst insertionPosition = SplitOperation.getInsertionPosition( position );\n\t\t\tconst split = new SplitOperation( position, howMany, insertionPosition, null, version );\n\n\t\t\tthis.batch.addOperation( split );\n\t\t\tthis.model.applyOperation( split );\n\n\t\t\t// Cache result of the first split.\n\t\t\tif ( !firstSplitElement && !firstCopyElement ) {\n\t\t\t\tfirstSplitElement = splitElement;\n\t\t\t\tfirstCopyElement = position.parent.nextSibling;\n\t\t\t}\n\n\t\t\tposition = this.createPositionAfter( position.parent );\n\t\t\tsplitElement = position.parent;\n\t\t} while ( splitElement !== limitElement );\n\n\t\treturn {\n\t\t\tposition,\n\t\t\trange: new Range( Position._createAt( firstSplitElement, 'end' ), Position._createAt( firstCopyElement, 0 ) )\n\t\t};\n\t}\n\n\t/**\n\t * Wraps the given range with the given element or with a new element (if a string was passed).\n\t *\n\t * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n\t * If not, an error will be thrown.\n\t *\n\t * @param {module:engine/model/range~Range} range Range to wrap.\n\t * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n\t */\n\twrap( range, elementOrString ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !range.isFlat ) {\n\t\t\t/**\n\t\t\t * Range to wrap is not flat.\n\t\t\t *\n\t\t\t * @error writer-wrap-range-not-flat\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-range-not-flat', this );\n\t\t}\n\n\t\tconst element = elementOrString instanceof Element ? elementOrString : new Element( elementOrString );\n\n\t\tif ( element.childCount > 0 ) {\n\t\t\t/**\n\t\t\t * Element to wrap with is not empty.\n\t\t\t *\n\t\t\t * @error writer-wrap-element-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-element-not-empty', this );\n\t\t}\n\n\t\tif ( element.parent !== null ) {\n\t\t\t/**\n\t\t\t * Element to wrap with is already attached to a tree model.\n\t\t\t *\n\t\t\t * @error writer-wrap-element-attached\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-element-attached', this );\n\t\t}\n\n\t\tthis.insert( element, range.start );\n\n\t\t// Shift the range-to-wrap because we just inserted an element before that range.\n\t\tconst shiftedRange = new Range( range.start.getShiftedBy( 1 ), range.end.getShiftedBy( 1 ) );\n\n\t\tthis.move( shiftedRange, Position._createAt( element, 0 ) );\n\t}\n\n\t/**\n\t * Unwraps children of the given element  all its children are moved before it and then the element is removed.\n\t * Throws error if you try to unwrap an element which does not have a parent.\n\t *\n\t * @param {module:engine/model/element~Element} element Element to unwrap.\n\t */\n\tunwrap( element ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( element.parent === null ) {\n\t\t\t/**\n\t\t\t * Trying to unwrap an element which has no parent.\n\t\t\t *\n\t\t\t * @error writer-unwrap-element-no-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-unwrap-element-no-parent', this );\n\t\t}\n\n\t\tthis.move( Range._createIn( element ), this.createPositionAfter( element ) );\n\t\tthis.remove( element );\n\t}\n\n\t/**\n\t * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n\t * changes in the document and updates its range automatically, when model tree changes.\n\t *\n\t * As the first parameter you can set marker name.\n\t *\n\t * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n\t * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n\t * markers managed by operations and not-managed by operations.\n\t *\n\t * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n\t * `true` when the marker change changes the data returned by the\n\t * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n\t * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n\t * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n\t *\n\t * Create marker directly base on marker's name:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: false } );\n\t *\n\t * Create marker using operation:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: true } );\n\t *\n\t * Create marker that affects the editor data:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n\t *\n\t * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n\t *\n\t * @see module:engine/model/markercollection~Marker\n\t * @param {String} name Name of a marker to create - must be unique.\n\t * @param {Object} options\n\t * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n\t * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n\t * @param {module:engine/model/range~Range} options.range Marker range.\n\t * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n\t * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n\t */\n\taddMarker( name, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !options || typeof options.usingOperation != 'boolean' ) {\n\t\t\t/**\n\t\t\t * The `options.usingOperation` parameter is required when adding a new marker.\n\t\t\t *\n\t\t\t * @error writer-addmarker-no-usingoperation\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addmarker-no-usingoperation', this );\n\t\t}\n\n\t\tconst usingOperation = options.usingOperation;\n\t\tconst range = options.range;\n\t\tconst affectsData = options.affectsData === undefined ? false : options.affectsData;\n\n\t\tif ( this.model.markers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Marker with provided name already exists.\n\t\t\t *\n\t\t\t * @error writer-addmarker-marker-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addmarker-marker-exists', this );\n\t\t}\n\n\t\tif ( !range ) {\n\t\t\t/**\n\t\t\t * Range parameter is required when adding a new marker.\n\t\t\t *\n\t\t\t * @error writer-addmarker-no-range\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addmarker-no-range', this );\n\t\t}\n\n\t\tif ( !usingOperation ) {\n\t\t\treturn this.model.markers._set( name, range, usingOperation, affectsData );\n\t\t}\n\n\t\tapplyMarkerOperation( this, name, null, range, affectsData );\n\n\t\treturn this.model.markers.get( name );\n\t}\n\n\t/**\n\t * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n\t * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n\t * marker's range directly using this method.\n\t *\n\t * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n\t * name is created and returned.\n\t *\n\t * As the second parameter you can set the new marker data or leave this parameter as empty which will just refresh\n\t * the marker by triggering downcast conversion for it. Refreshing the marker is useful when you want to change\n\t * the marker {@link module:engine/view/element~Element view element} without changing any marker data.\n\t *\n\t * \t\tlet isCommentActive = false;\n\t *\n\t * \t\tmodel.conversion.markerToHighlight( {\n\t * \t\t\tmodel: 'comment',\n\t *\t\t\tview: data => {\n\t *\t\t\t\tconst classes = [ 'comment-marker' ];\n\t *\n\t *\t\t\t\tif ( isCommentActive ) {\n\t *\t\t\t\t\tclasses.push( 'comment-marker--active' );\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\treturn { classes };\n\t *\t\t\t}\n\t * \t\t} );\n\t *\n\t * \t\t// Change the property that indicates if marker is displayed as active or not.\n\t * \t\tisCommentActive = true;\n\t *\n\t * \t\t// And refresh the marker to convert it with additional class.\n\t * \t\tmodel.change( writer => writer.updateMarker( 'comment' ) );\n\t *\n\t * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n\t * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n\t * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n\t *\n\t * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n\t * `true` when the marker change changes the data returned by\n\t * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n\t * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n\t * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n\t *\n\t * Update marker directly base on marker's name:\n\t *\n\t *\t\tupdateMarker( markerName, { range } );\n\t *\n\t * Update marker using operation:\n\t *\n\t *\t\tupdateMarker( marker, { range, usingOperation: true } );\n\t *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n\t *\n\t * Change marker's option (start using operations to manage it):\n\t *\n\t *\t\tupdateMarker( marker, { usingOperation: true } );\n\t *\n\t * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n\t *\n\t *\t\tupdateMarker( markerName, { affectsData: false } );\n\t *\n\t * @see module:engine/model/markercollection~Marker\n\t * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.\n\t * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering\n\t * downcast conversion for this marker with the same data.\n\t * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n\t * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n\t * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n\t * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n\t */\n\tupdateMarker( markerOrName, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\t\tconst currentMarker = this.model.markers.get( markerName );\n\n\t\tif ( !currentMarker ) {\n\t\t\t/**\n\t\t\t * Marker with provided name does not exists.\n\t\t\t *\n\t\t\t * @error writer-updatemarker-marker-not-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-updatemarker-marker-not-exists', this );\n\t\t}\n\n\t\tif ( !options ) {\n\t\t\tthis.model.markers._refresh( currentMarker );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n\t\tconst affectsDataDefined = typeof options.affectsData == 'boolean';\n\n\t\t// Use previously defined marker's affectsData if the property is not provided.\n\t\tconst affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n\n\t\tif ( !hasUsingOperationDefined && !options.range && !affectsDataDefined ) {\n\t\t\t/**\n\t\t\t * One of the options is required - provide range, usingOperations or affectsData.\n\t\t\t *\n\t\t\t * @error writer-updatemarker-wrong-options\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-updatemarker-wrong-options', this );\n\t\t}\n\n\t\tconst currentRange = currentMarker.getRange();\n\t\tconst updatedRange = options.range ? options.range : currentRange;\n\n\t\tif ( hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations ) {\n\t\t\t// The marker type is changed so it's necessary to create proper operations.\n\t\t\tif ( options.usingOperation ) {\n\t\t\t\t// If marker changes to a managed one treat this as synchronizing existing marker.\n\t\t\t\t// Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n\t\t\t\tapplyMarkerOperation( this, markerName, null, updatedRange, affectsData );\n\t\t\t} else {\n\t\t\t\t// If marker changes to a marker that do not use operations then we need to create additional operation\n\t\t\t\t// that removes that marker first.\n\t\t\t\tapplyMarkerOperation( this, markerName, currentRange, null, affectsData );\n\n\t\t\t\t// Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n\t\t\t\tthis.model.markers._set( markerName, updatedRange, undefined, affectsData );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Marker's type doesn't change so update it accordingly.\n\t\tif ( currentMarker.managedUsingOperations ) {\n\t\t\tapplyMarkerOperation( this, markerName, currentRange, updatedRange, affectsData );\n\t\t} else {\n\t\t\tthis.model.markers._set( markerName, updatedRange, undefined, affectsData );\n\t\t}\n\t}\n\n\t/**\n\t * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n\t * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n\t * it will be destroyed using operation.\n\t *\n\t * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n\t */\n\tremoveMarker( markerOrName ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\n\t\tif ( !this.model.markers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Trying to remove marker which does not exist.\n\t\t\t *\n\t\t\t * @error writer-removemarker-no-marker\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-removemarker-no-marker', this );\n\t\t}\n\n\t\tconst marker = this.model.markers.get( name );\n\n\t\tif ( !marker.managedUsingOperations ) {\n\t\t\tthis.model.markers._remove( name );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldRange = marker.getRange();\n\n\t\tapplyMarkerOperation( this, name, oldRange, null, marker.affectsData );\n\t}\n\n\t/**\n\t * Sets the document's selection (ranges and direction) to the specified location based on the given\n\t * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\twriter.setSelection( ranges );\n\t *\n\t *\t\t// Sets selection to other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t *\t\t// Sets selection to the given document selection.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\twriter.setSelection( documentSelection );\n\t *\n\t *\t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPosition( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t *\t\t// Sets collapsed selection at the position of the given node and an offset.\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t *\t\t// Removes all selection's ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tthis.model.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as\n\t * {@link #createPositionAt `writer.createPositionAt()`} parameters.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tthis.model.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * Using key and value pair:\n\t *\n\t * \twriter.setSelectionAttribute( 'italic', true );\n\t *\n\t * Using key-value object:\n\t *\n\t * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n\t *\n\t * Using iterable object:\n\t *\n\t * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n\t *\n\t * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n\t * or object / iterable of key => value attribute pairs.\n\t * @param {*} [value] Attribute value.\n\t */\n\tsetSelectionAttribute( keyOrObjectOrIterable, value ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( typeof keyOrObjectOrIterable === 'string' ) {\n\t\t\tthis._setSelectionAttribute( keyOrObjectOrIterable, value );\n\t\t} else {\n\t\t\tfor ( const [ key, value ] of toMap( keyOrObjectOrIterable ) ) {\n\t\t\t\tthis._setSelectionAttribute( key, value );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute(s) with given key(s) from the selection.\n\t *\n\t * Remove one attribute:\n\t *\n\t *\t\twriter.removeSelectionAttribute( 'italic' );\n\t *\n\t * Remove multiple attributes:\n\t *\n\t *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n\t *\n\t * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n\t */\n\tremoveSelectionAttribute( keyOrIterableOfKeys ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( typeof keyOrIterableOfKeys === 'string' ) {\n\t\t\tthis._removeSelectionAttribute( keyOrIterableOfKeys );\n\t\t} else {\n\t\t\tfor ( const key of keyOrIterableOfKeys ) {\n\t\t\t\tthis._removeSelectionAttribute( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n\t * of the selection from left to right.\n\t *\n\t * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n\t * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n\t * This method allows to temporarily override this behavior by forcing the gravity to the right.\n\t *\n\t * For the following model fragment:\n\t *\n\t *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n\t *\n\t * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n\t * * Overridden gravity: selection will have `bold` attribute.\n\t *\n\t * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n\t * of the process.\n\t *\n\t * @returns {String} The unique id which allows restoring the gravity.\n\t */\n\toverrideSelectionGravity() {\n\t\treturn this.model.document.selection._overrideGravity();\n\t}\n\n\t/**\n\t * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n\t *\n\t * Restoring the gravity is only possible using the unique identifier returned by\n\t * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n\t * the same number of times it was overridden.\n\t *\n\t * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n\t */\n\trestoreSelectionGravity( uid ) {\n\t\tthis.model.document.selection._restoreGravity( uid );\n\t}\n\n\t/**\n\t * @private\n\t * @param {String} key Key of the attribute to remove.\n\t * @param {*} value Attribute value.\n\t */\n\t_setSelectionAttribute( key, value ) {\n\t\tconst selection = this.model.document.selection;\n\n\t\t// Store attribute in parent element if the selection is collapsed in an empty node.\n\t\tif ( selection.isCollapsed && selection.anchor.parent.isEmpty ) {\n\t\t\tconst storeKey = DocumentSelection._getStoreAttributeKey( key );\n\n\t\t\tthis.setAttribute( storeKey, value, selection.anchor.parent );\n\t\t}\n\n\t\tselection._setAttribute( key, value );\n\t}\n\n\t/**\n\t * @private\n\t * @param {String} key Key of the attribute to remove.\n\t */\n\t_removeSelectionAttribute( key ) {\n\t\tconst selection = this.model.document.selection;\n\n\t\t// Remove stored attribute from parent element if the selection is collapsed in an empty node.\n\t\tif ( selection.isCollapsed && selection.anchor.parent.isEmpty ) {\n\t\t\tconst storeKey = DocumentSelection._getStoreAttributeKey( key );\n\n\t\t\tthis.removeAttribute( storeKey, selection.anchor.parent );\n\t\t}\n\n\t\tselection._removeAttribute( key );\n\t}\n\n\t/**\n\t * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n\t *\n\t * @private\n\t */\n\t_assertWriterUsedCorrectly() {\n\t\t/**\n\t\t * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()`} or\n\t\t * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n\t\t *\n\t\t * The writer can only be used inside these blocks which ensures that the model\n\t\t * can only be changed during such \"sessions\".\n\t\t *\n\t\t * @error writer-incorrect-use\n\t\t */\n\t\tif ( this.model._currentWriter !== this ) {\n\t\t\tthrow new CKEditorError( 'writer-incorrect-use', this );\n\t\t}\n\t}\n\n\t/**\n\t * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers\n\t * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range\n\t * can be later correctly processed during undo.\n\t *\n\t * @private\n\t * @param {'move'|'merge'} type Writer action type.\n\t * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range\n\t * where the writer action happens.\n\t */\n\t_addOperationForAffectedMarkers( type, positionOrRange ) {\n\t\tfor ( const marker of this.model.markers ) {\n\t\t\tif ( !marker.managedUsingOperations ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst markerRange = marker.getRange();\n\t\t\tlet isAffected = false;\n\n\t\t\tif ( type === 'move' ) {\n\t\t\t\tisAffected =\n\t\t\t\t\tpositionOrRange.containsPosition( markerRange.start ) ||\n\t\t\t\t\tpositionOrRange.start.isEqual( markerRange.start ) ||\n\t\t\t\t\tpositionOrRange.containsPosition( markerRange.end ) ||\n\t\t\t\t\tpositionOrRange.end.isEqual( markerRange.end );\n\t\t\t} else {\n\t\t\t\t// if type === 'merge'.\n\t\t\t\tconst elementBefore = positionOrRange.nodeBefore;\n\t\t\t\tconst elementAfter = positionOrRange.nodeAfter;\n\n\t\t\t\t//               Start:  <p>Foo[</p><p>Bar]</p>\n\t\t\t\t//         After merge:  <p>Foo[Bar]</p>\n\t\t\t\t// After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;\n\n\t\t\t\t//               Start:  <p>[Foo</p><p>]Bar</p>\n\t\t\t\t//         After merge:  <p>[Foo]Bar</p>\n\t\t\t\t// After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;\n\n\t\t\t\t//               Start:  <p>[Foo</p>]<p>Bar</p>\n\t\t\t\t//         After merge:  <p>[Foo]Bar</p>\n\t\t\t\t// After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;\n\n\t\t\t\t//               Start:  <p>Foo</p>[<p>Bar]</p>\n\t\t\t\t//         After merge:  <p>Foo[Bar]</p>\n\t\t\t\t// After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;\n\n\t\t\t\tisAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;\n\t\t\t}\n\n\t\t\tif ( isAffected ) {\n\t\t\t\tthis.updateMarker( marker.name, { range: markerRange } );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// Given `range` must be flat.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\nfunction setAttributeOnRange( writer, key, value, range ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\n\t// Position of the last split, the beginning of the new range.\n\tlet lastSplitPosition = range.start;\n\n\t// Currently position in the scanning range. Because we need value after the position, it is not a current\n\t// position of the iterator but the previous one (we need to iterate one more time to get the value after).\n\tlet position;\n\n\t// Value before the currently position.\n\tlet valueBefore;\n\n\t// Value after the currently position.\n\tlet valueAfter;\n\n\tfor ( const val of range.getWalker( { shallow: true } ) ) {\n\t\tvalueAfter = val.item.getAttribute( key );\n\n\t\t// At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n\t\t// because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n\t\tif ( position && valueBefore != valueAfter ) {\n\t\t\t// if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n\t\t\tif ( valueBefore != value ) {\n\t\t\t\taddOperation();\n\t\t\t}\n\n\t\t\tlastSplitPosition = position;\n\t\t}\n\n\t\tposition = val.nextPosition;\n\t\tvalueBefore = valueAfter;\n\t}\n\n\t// Because position in the loop is not the iterator position (see let position comment), the last position in\n\t// the while loop will be last but one position in the range. We need to check the last position manually.\n\tif ( position instanceof Position && position != lastSplitPosition && valueBefore != value ) {\n\t\taddOperation();\n\t}\n\n\tfunction addOperation() {\n\t\tconst range = new Range( lastSplitPosition, position );\n\t\tconst version = range.root.document ? doc.version : null;\n\t\tconst operation = new AttributeOperation( range, key, valueBefore, value, version );\n\n\t\twriter.batch.addOperation( operation );\n\t\tmodel.applyOperation( operation );\n\t}\n}\n\n// Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\nfunction setAttributeOnItem( writer, key, value, item ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\tconst previousValue = item.getAttribute( key );\n\tlet range, operation;\n\n\tif ( previousValue != value ) {\n\t\tconst isRootChanged = item.root === item;\n\n\t\tif ( isRootChanged ) {\n\t\t\t// If we change attributes of root element, we have to use `RootAttributeOperation`.\n\t\t\tconst version = item.document ? doc.version : null;\n\n\t\t\toperation = new RootAttributeOperation( item, key, previousValue, value, version );\n\t\t} else {\n\t\t\trange = new Range( Position._createBefore( item ), writer.createPositionAfter( item ) );\n\n\t\t\tconst version = range.root.document ? doc.version : null;\n\n\t\t\toperation = new AttributeOperation( range, key, previousValue, value, version );\n\t\t}\n\n\t\twriter.batch.addOperation( operation );\n\t\tmodel.applyOperation( operation );\n\t}\n}\n\n// Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\nfunction applyMarkerOperation( writer, name, oldRange, newRange, affectsData ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\n\tconst operation = new MarkerOperation( name, oldRange, newRange, model.markers, affectsData, doc.version );\n\n\twriter.batch.addOperation( operation );\n\tmodel.applyOperation( operation );\n}\n\n// Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given operation instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {Batch} batch Batch to which the operation will be added.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\nfunction applyRemoveOperation( position, howMany, batch, model ) {\n\tlet operation;\n\n\tif ( position.root.document ) {\n\t\tconst doc = model.document;\n\t\tconst graveyardPosition = new Position( doc.graveyard, [ 0 ] );\n\n\t\toperation = new MoveOperation( position, howMany, graveyardPosition, doc.version );\n\t} else {\n\t\toperation = new DetachOperation( position, howMany );\n\t}\n\n\tbatch.addOperation( operation );\n\tmodel.applyOperation( operation );\n}\n\n// Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\nfunction isSameTree( rootA, rootB ) {\n\t// If it is the same root this is the same tree.\n\tif ( rootA === rootB ) {\n\t\treturn true;\n\t}\n\n\t// If both roots are documents root it is operation within the document what we still treat as the same tree.\n\tif ( rootA instanceof RootElement && rootB instanceof RootElement ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"]}]}