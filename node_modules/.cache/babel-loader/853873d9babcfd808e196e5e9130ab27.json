{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/node.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/node.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvbW9kZWwvbm9kZQogKi8KaW1wb3J0IHRvTWFwIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL3RvbWFwJzsKaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7CmltcG9ydCBjb21wYXJlQXJyYXlzIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NvbXBhcmVhcnJheXMnOyAvLyBUbyBjaGVjayBpZiBjb21wb25lbnQgaXMgbG9hZGVkIG1vcmUgdGhhbiBvbmNlLgoKaW1wb3J0ICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy92ZXJzaW9uJzsKLyoqCiAqIE1vZGVsIG5vZGUuIE1vc3QgYmFzaWMgc3RydWN0dXJlIG9mIG1vZGVsIHRyZWUuCiAqCiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBpcyBhIGJhc2UgZm9yIG90aGVyIGNsYXNzZXMgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBub2RlcyBpbiBtb2RlbC4KICoKICogKipOb3RlOioqIElmIGEgbm9kZSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBtb2RlbCB0cmVlLCB5b3UgY2FuIG1hbmlwdWxhdGUgaXQgdXNpbmcgaXQncyBBUEkuCiAqIEhvd2V2ZXIsIGl0IGlzICoqdmVyeSBpbXBvcnRhbnQqKiB0aGF0IG5vZGVzIGFscmVhZHkgYXR0YWNoZWQgdG8gbW9kZWwgdHJlZSBzaG91bGQgYmUgb25seSBjaGFuZ2VkIHRocm91Z2gKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciBXcml0ZXIgQVBJfS4KICoKICogQ2hhbmdlcyBkb25lIGJ5IGBOb2RlYCBtZXRob2RzLCBsaWtlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCNfaW5zZXJ0Q2hpbGQgX2luc2VydENoaWxkfSBvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjX3NldEF0dHJpYnV0ZSBfc2V0QXR0cmlidXRlfQogKiBkbyBub3QgZ2VuZXJhdGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9uc30KICogd2hpY2ggYXJlIGVzc2VudGlhbCBmb3IgY29ycmVjdCBlZGl0b3Igd29yayBpZiB5b3UgbW9kaWZ5IG5vZGVzIGluIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50IGRvY3VtZW50fSByb290LgogKgogKiBUaGUgZmxvdyBvZiB3b3JraW5nIG9uIGBOb2RlYCAoYW5kIGNsYXNzZXMgdGhhdCBpbmhlcml0cyBmcm9tIGl0KSBpcyBhcyBzdWNoOgogKiAxLiBZb3UgY2FuIGNyZWF0ZSBhIGBOb2RlYCBpbnN0YW5jZSwgbW9kaWZ5IGl0IHVzaW5nIGl0J3MgQVBJLgogKiAyLiBBZGQgYE5vZGVgIHRvIHRoZSBtb2RlbCB1c2luZyBgQmF0Y2hgIEFQSS4KICogMy4gQ2hhbmdlIGBOb2RlYCB0aGF0IHdhcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBtb2RlbCB1c2luZyBgQmF0Y2hgIEFQSS4KICoKICogU2ltaWxhcmx5LCB5b3UgY2Fubm90IHVzZSBgQmF0Y2hgIEFQSSBvbiBhIG5vZGUgdGhhdCBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhlIG1vZGVsIHRyZWUsIHdpdGggdGhlIGV4Y2VwdGlvbgogKiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2luc2VydCBpbnNlcnRpbmd9IHRoYXQgbm9kZSB0byB0aGUgbW9kZWwgdHJlZS4KICoKICogQmUgYXdhcmUgdGhhdCB1c2luZyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI3JlbW92ZSByZW1vdmUgZnJvbSBCYXRjaCBBUEl9IGRvZXMgbm90IGFsbG93IHRvIHVzZSBgTm9kZWAgQVBJIGJlY2F1c2UKICogdGhlIGluZm9ybWF0aW9uIGFib3V0IGBOb2RlYCBpcyBzdGlsbCBrZXB0IGluIG1vZGVsIGRvY3VtZW50LgogKgogKiBJbiBjYXNlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50IG5vZGV9LCBhZGRpbmcgYW5kIHJlbW92aW5nIGNoaWxkcmVuIGFsc28gY291bnRzIGFzIGNoYW5naW5nIGEgbm9kZSBhbmQKICogZm9sbG93cyBzYW1lIHJ1bGVzLgogKi8KCnZhciBOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGEgbW9kZWwgbm9kZS4KICAgKgogICAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MsIHNvIHRoaXMgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LgogICAqCiAgICogQGFic3RyYWN0CiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyc10gTm9kZSdzIGF0dHJpYnV0ZXMuIFNlZSB7QGxpbmsgbW9kdWxlOnV0aWxzL3RvbWFwfnRvTWFwfSBmb3IgYSBsaXN0IG9mIGFjY2VwdGVkIHZhbHVlcy4KICAgKi8KICBmdW5jdGlvbiBOb2RlKGF0dHJzKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7CgogICAgLyoqCiAgICAgKiBQYXJlbnQgb2YgdGhpcyBub2RlLiBJdCBjb3VsZCBiZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9CiAgICAgKiBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9LgogICAgICogRXF1YWxzIHRvIGBudWxsYCBpZiB0aGUgbm9kZSBoYXMgbm8gcGFyZW50LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bnVsbH0KICAgICAqLwogICAgdGhpcy5wYXJlbnQgPSBudWxsOwogICAgLyoqCiAgICAgKiBBdHRyaWJ1dGVzIHNldCBvbiB0aGlzIG5vZGUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge01hcH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjX2F0dHJzCiAgICAgKi8KCiAgICB0aGlzLl9hdHRycyA9IHRvTWFwKGF0dHJzKTsKICB9CiAgLyoqCiAgICogSW5kZXggb2YgdGhpcyBub2RlIGluIGl0J3MgcGFyZW50IG9yIGBudWxsYCBpZiB0aGUgbm9kZSBoYXMgbm8gcGFyZW50LgogICAqCiAgICogQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgdGhyb3dzIGFuIGVycm9yIGlmIHRoaXMgbm9kZSdzIHBhcmVudCBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXQuCiAgICogVGhpcyBtZWFucyB0aGF0IG1vZGVsIHRyZWUgZ290IGJyb2tlbi4KICAgKgogICAqIEByZWFkb25seQogICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH0KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhOb2RlLCBbewogICAga2V5OiAiaW5kZXgiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHZhciBwb3M7CgogICAgICBpZiAoIXRoaXMucGFyZW50KSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIGlmICgocG9zID0gdGhpcy5wYXJlbnQuZ2V0Q2hpbGRJbmRleCh0aGlzKSkgPT09IG51bGwpIHsKICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtbm9kZS1ub3QtZm91bmQtaW4tcGFyZW50JywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHJldHVybiBwb3M7CiAgICB9CiAgICAvKioKICAgICAqIE9mZnNldCBhdCB3aGljaCB0aGlzIG5vZGUgc3RhcnRzIGluIGl0J3MgcGFyZW50LiBJdCBpcyBlcXVhbCB0byB0aGUgc3VtIG9mIHtAbGluayAjb2Zmc2V0U2l6ZSBvZmZzZXRTaXplfQogICAgICogb2YgYWxsIGl0J3MgcHJldmlvdXMgc2libGluZ3MuIEVxdWFscyB0byBgbnVsbGAgaWYgbm9kZSBoYXMgbm8gcGFyZW50LgogICAgICoKICAgICAqIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IHRocm93cyBhbiBlcnJvciBpZiB0aGlzIG5vZGUncyBwYXJlbnQgZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0LgogICAgICogVGhpcyBtZWFucyB0aGF0IG1vZGVsIHRyZWUgZ290IGJyb2tlbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzdGFydE9mZnNldCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIHBvczsKCiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgaWYgKChwb3MgPSB0aGlzLnBhcmVudC5nZXRDaGlsZFN0YXJ0T2Zmc2V0KHRoaXMpKSA9PT0gbnVsbCkgewogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1ub2RlLW5vdC1mb3VuZC1pbi1wYXJlbnQnLCB0aGlzKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHBvczsKICAgIH0KICAgIC8qKgogICAgICogT2Zmc2V0IHNpemUgb2YgdGhpcyBub2RlLiBSZXByZXNlbnRzIGhvdyBtdWNoICJvZmZzZXQgc3BhY2UiIGlzIG9jY3VwaWVkIGJ5IHRoZSBub2RlIGluIGl0J3MgcGFyZW50LgogICAgICogSXQgaXMgaW1wb3J0YW50IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0uIFdoZW4gbm9kZSBoYXMgYG9mZnNldFNpemVgIGdyZWF0ZXIgdGhhbiBgMWAsIHBvc2l0aW9uCiAgICAgKiBjYW4gYmUgcGxhY2VkIGJldHdlZW4gdGhhdCBub2RlIHN0YXJ0IGFuZCBlbmQuIGBvZmZzZXRTaXplYCBncmVhdGVyIHRoYW4gYDFgIGlzIGZvciBub2RlcyB0aGF0IHJlcHJlc2VudHMgbW9yZQogICAgICogdGhhbiBvbmUgZW50aXR5LCBpLmUuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCB0ZXh0IG5vZGV9LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge051bWJlcn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJvZmZzZXRTaXplIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gMTsKICAgIH0KICAgIC8qKgogICAgICogT2Zmc2V0IGF0IHdoaWNoIHRoaXMgbm9kZSBlbmRzIGluIGl0J3MgcGFyZW50LiBJdCBpcyBlcXVhbCB0byB0aGUgc3VtIG9mIHRoaXMgbm9kZSdzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjc3RhcnRPZmZzZXQgc3RhcnQgb2Zmc2V0fSBhbmQge0BsaW5rICNvZmZzZXRTaXplIG9mZnNldCBzaXplfS4KICAgICAqIEVxdWFscyB0byBgbnVsbGAgaWYgdGhlIG5vZGUgaGFzIG5vIHBhcmVudC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJlbmRPZmZzZXQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZmZzZXQgKyB0aGlzLm9mZnNldFNpemU7CiAgICB9CiAgICAvKioKICAgICAqIE5vZGUncyBuZXh0IHNpYmxpbmcgb3IgYG51bGxgIGlmIHRoZSBub2RlIGlzIGEgbGFzdCBjaGlsZCBvZiBpdCdzIHBhcmVudCBvciBpZiB0aGUgbm9kZSBoYXMgbm8gcGFyZW50LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibmV4dFNpYmxpbmciLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7CiAgICAgIHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiB0aGlzLnBhcmVudC5nZXRDaGlsZChpbmRleCArIDEpIHx8IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIE5vZGUncyBwcmV2aW91cyBzaWJsaW5nIG9yIGBudWxsYCBpZiB0aGUgbm9kZSBpcyBhIGZpcnN0IGNoaWxkIG9mIGl0J3MgcGFyZW50IG9yIGlmIHRoZSBub2RlIGhhcyBubyBwYXJlbnQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJwcmV2aW91c1NpYmxpbmciLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7CiAgICAgIHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiB0aGlzLnBhcmVudC5nZXRDaGlsZChpbmRleCAtIDEpIHx8IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIFRoZSB0b3AtbW9zdCBhbmNlc3RvciBvZiB0aGUgbm9kZS4gSWYgbm9kZSBoYXMgbm8gcGFyZW50IGl0IGlzIHRoZSByb290IGl0c2VsZi4gSWYgdGhlIG5vZGUgaXMgYSBwYXJ0CiAgICAgKiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9LCBpdCdzIGByb290YCBpcyBlcXVhbCB0byB0aGF0IGBEb2N1bWVudEZyYWdtZW50YC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyb290IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICB2YXIgcm9vdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzCgogICAgICB3aGlsZSAocm9vdC5wYXJlbnQpIHsKICAgICAgICByb290ID0gcm9vdC5wYXJlbnQ7CiAgICAgIH0KCiAgICAgIHJldHVybiByb290OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgaW4gYSB0cmVlIHJvb3RlZCBpbiB0aGUgZG9jdW1lbnQgKGlzIGEgZGVzY2VuZGFudCBvZiBvbmUgb2YgaXRzIHJvb3RzKS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0F0dGFjaGVkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0F0dGFjaGVkKCkgewogICAgICByZXR1cm4gdGhpcy5yb290LmlzKCdyb290RWxlbWVudCcpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHBhdGggdG8gdGhlIG5vZGUuIFRoZSBwYXRoIGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgc3RhcnRpbmcgb2Zmc2V0cyBvZiBjb25zZWN1dGl2ZSBhbmNlc3RvcnMgb2YgdGhpcyBub2RlLAogICAgICogYmVnaW5uaW5nIGZyb20ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI3Jvb3Qgcm9vdH0sIGRvd24gdG8gdGhpcyBub2RlJ3Mgc3RhcnRpbmcgb2Zmc2V0LiBUaGUgcGF0aCBjYW4gYmUgdXNlZCB0bwogICAgICogY3JlYXRlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIFBvc2l0aW9ufSBpbnN0YW5jZS4KICAgICAqCiAgICAgKgkJY29uc3QgYWJjID0gbmV3IFRleHQoICdhYmMnICk7CiAgICAgKgkJY29uc3QgZm9vID0gbmV3IFRleHQoICdmb28nICk7CiAgICAgKgkJY29uc3QgaDEgPSBuZXcgRWxlbWVudCggJ2gxJywgbnVsbCwgbmV3IFRleHQoICdoZWFkZXInICkgKTsKICAgICAqCQljb25zdCBwID0gbmV3IEVsZW1lbnQoICdwJywgbnVsbCwgWyBhYmMsIGZvbyBdICk7CiAgICAgKgkJY29uc3QgZGl2ID0gbmV3IEVsZW1lbnQoICdkaXYnLCBudWxsLCBbIGgxLCBwIF0gKTsKICAgICAqCQlmb28uZ2V0UGF0aCgpOyAvLyBSZXR1cm5zIFsgMSwgMyBdLiBgZm9vYCBpcyBpbiBgcGAgd2hpY2ggaXMgaW4gYGRpdmAuIGBwYCBzdGFydHMgYXQgb2Zmc2V0IDEsIHdoaWxlIGBmb29gIGF0IDMuCiAgICAgKgkJaDEuZ2V0UGF0aCgpOyAvLyBSZXR1cm5zIFsgMCBdLgogICAgICoJCWRpdi5nZXRQYXRoKCk7IC8vIFJldHVybnMgW10uCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5LjxOdW1iZXI+fSBUaGUgcGF0aC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRQYXRoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXRoKCkgewogICAgICB2YXIgcGF0aCA9IFtdOwogICAgICB2YXIgbm9kZSA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzCgogICAgICB3aGlsZSAobm9kZS5wYXJlbnQpIHsKICAgICAgICBwYXRoLnVuc2hpZnQobm9kZS5zdGFydE9mZnNldCk7CiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50OwogICAgICB9CgogICAgICByZXR1cm4gcGF0aDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbmNlc3RvcnMgYXJyYXkgb2YgdGhpcyBub2RlLgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlU2VsZj1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIHRoaXMgbm9kZSB3aWxsIGJlIGFsc28gaW5jbHVkZWQgaW4gcGFyZW50J3MgYXJyYXkuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBhcmVudEZpcnN0PWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAsIGFycmF5IHdpbGwgYmUgc29ydGVkIGZyb20gbm9kZSdzIHBhcmVudCB0byByb290IGVsZW1lbnQsCiAgICAgKiBvdGhlcndpc2Ugcm9vdCBlbGVtZW50IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5LgogICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGFuY2VzdG9ycy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRBbmNlc3RvcnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFuY2VzdG9ycygpIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsKICAgICAgICBpbmNsdWRlU2VsZjogZmFsc2UsCiAgICAgICAgcGFyZW50Rmlyc3Q6IGZhbHNlCiAgICAgIH07CiAgICAgIHZhciBhbmNlc3RvcnMgPSBbXTsKICAgICAgdmFyIHBhcmVudCA9IG9wdGlvbnMuaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy5wYXJlbnQ7CgogICAgICB3aGlsZSAocGFyZW50KSB7CiAgICAgICAgYW5jZXN0b3JzW29wdGlvbnMucGFyZW50Rmlyc3QgPyAncHVzaCcgOiAndW5zaGlmdCddKHBhcmVudCk7CiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDsKICAgICAgfQoKICAgICAgcmV0dXJuIGFuY2VzdG9yczsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICogd2hpY2ggaXMgYSBjb21tb24gYW5jZXN0b3Igb2YgYm90aCBub2Rlcy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlIFRoZSBzZWNvbmQgbm9kZS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlU2VsZj1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIGJvdGggbm9kZXMgd2lsbCBiZSBjb25zaWRlcmVkICJhbmNlc3RvcnMiIHRvby4KICAgICAqIFdoaWNoIG1lYW5zIHRoYXQgaWYgZS5nLiBub2RlIEEgaXMgaW5zaWRlIEIsIHRoZW4gdGhlaXIgY29tbW9uIGFuY2VzdG9yIHdpbGwgYmUgQi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENvbW1vbkFuY2VzdG9yIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21tb25BbmNlc3Rvcihub2RlKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTsKICAgICAgdmFyIGFuY2VzdG9yc0EgPSB0aGlzLmdldEFuY2VzdG9ycyhvcHRpb25zKTsKICAgICAgdmFyIGFuY2VzdG9yc0IgPSBub2RlLmdldEFuY2VzdG9ycyhvcHRpb25zKTsKICAgICAgdmFyIGkgPSAwOwoKICAgICAgd2hpbGUgKGFuY2VzdG9yc0FbaV0gPT0gYW5jZXN0b3JzQltpXSAmJiBhbmNlc3RvcnNBW2ldKSB7CiAgICAgICAgaSsrOwogICAgICB9CgogICAgICByZXR1cm4gaSA9PT0gMCA/IG51bGwgOiBhbmNlc3RvcnNBW2kgLSAxXTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSBpcyBiZWZvcmUgZ2l2ZW4gbm9kZS4gYGZhbHNlYCBpcyByZXR1cm5lZCBpZiBub2RlcyBhcmUgaW4gZGlmZmVyZW50IHRyZWVzIChmb3IgZXhhbXBsZSwKICAgICAqIGluIGRpZmZlcmVudCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9cykuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZX0gbm9kZSBOb2RlIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQmVmb3JlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JlZm9yZShub2RlKSB7CiAgICAgIC8vIEdpdmVuIG5vZGUgaXMgbm90IGJlZm9yZSB0aGlzIG5vZGUgaWYgdGhleSBhcmUgc2FtZS4KICAgICAgaWYgKHRoaXMgPT0gbm9kZSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBSZXR1cm4gYGZhbHNlYCBpZiBpdCBpcyBpbXBvc3NpYmxlIHRvIGNvbXBhcmUgbm9kZXMuCgoKICAgICAgaWYgKHRoaXMucm9vdCAhPT0gbm9kZS5yb290KSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICB2YXIgdGhpc1BhdGggPSB0aGlzLmdldFBhdGgoKTsKICAgICAgdmFyIG5vZGVQYXRoID0gbm9kZS5nZXRQYXRoKCk7CiAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXJyYXlzKHRoaXNQYXRoLCBub2RlUGF0aCk7CgogICAgICBzd2l0Y2ggKHJlc3VsdCkgewogICAgICAgIGNhc2UgJ3ByZWZpeCc6CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgICAgY2FzZSAnZXh0ZW5zaW9uJzoKICAgICAgICAgIHJldHVybiBmYWxzZTsKCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJldHVybiB0aGlzUGF0aFtyZXN1bHRdIDwgbm9kZVBhdGhbcmVzdWx0XTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBub2RlIGlzIGFmdGVyIGdpdmVuIG5vZGUuIGBmYWxzZWAgaXMgcmV0dXJuZWQgaWYgbm9kZXMgYXJlIGluIGRpZmZlcmVudCB0cmVlcyAoZm9yIGV4YW1wbGUsCiAgICAgKiBpbiBkaWZmZXJlbnQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fXMpLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IG5vZGUgTm9kZSB0byBjb21wYXJlIHdpdGguCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0FmdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FmdGVyKG5vZGUpIHsKICAgICAgLy8gR2l2ZW4gbm9kZSBpcyBub3QgYmVmb3JlIHRoaXMgbm9kZSBpZiB0aGV5IGFyZSBzYW1lLgogICAgICBpZiAodGhpcyA9PSBub2RlKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9IC8vIFJldHVybiBgZmFsc2VgIGlmIGl0IGlzIGltcG9zc2libGUgdG8gY29tcGFyZSBub2Rlcy4KCgogICAgICBpZiAodGhpcy5yb290ICE9PSBub2RlLnJvb3QpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gSW4gb3RoZXIgY2FzZXMsIGp1c3QgY2hlY2sgaWYgdGhlIGBub2RlYCBpcyBiZWZvcmUsIGFuZCByZXR1cm4gdGhlIG9wcG9zaXRlLgoKCiAgICAgIHJldHVybiAhdGhpcy5pc0JlZm9yZShub2RlKTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIGlmIHRoZSBub2RlIGhhcyBhbiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgYXR0cmlidXRlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkgaXMgc2V0IG9uIG5vZGUsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImhhc0F0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQXR0cmlidXRlKGtleSkgewogICAgICByZXR1cm4gdGhpcy5fYXR0cnMuaGFzKGtleSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgYW4gYXR0cmlidXRlIHZhbHVlIGZvciBnaXZlbiBrZXkgb3IgYHVuZGVmaW5lZGAgaWYgdGhhdCBhdHRyaWJ1dGUgaXMgbm90IHNldCBvbiBub2RlLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG9mIGF0dHJpYnV0ZSB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHsqfSBBdHRyaWJ1dGUgdmFsdWUgb3IgYHVuZGVmaW5lZGAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0QXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoa2V5KSB7CiAgICAgIHJldHVybiB0aGlzLl9hdHRycy5nZXQoa2V5KTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBpdGVyYXRvciB0aGF0IGl0ZXJhdGVzIG92ZXIgdGhpcyBub2RlJ3MgYXR0cmlidXRlcy4KICAgICAqCiAgICAgKiBBdHRyaWJ1dGVzIGFyZSByZXR1cm5lZCBhcyBhcnJheXMgY29udGFpbmluZyB0d28gaXRlbXMuIEZpcnN0IG9uZSBpcyBhdHRyaWJ1dGUga2V5IGFuZCBzZWNvbmQgaXMgYXR0cmlidXRlIHZhbHVlLgogICAgICogVGhpcyBmb3JtYXQgaXMgYWNjZXB0ZWQgYnkgbmF0aXZlIGBNYXBgIG9iamVjdCBhbmQgYWxzbyBjYW4gYmUgcGFzc2VkIGluIGBOb2RlYCBjb25zdHJ1Y3Rvci4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPCo+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEF0dHJpYnV0ZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoKSB7CiAgICAgIHJldHVybiB0aGlzLl9hdHRycy5lbnRyaWVzKCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgaXRlcmF0b3IgdGhhdCBpdGVyYXRlcyBvdmVyIHRoaXMgbm9kZSdzIGF0dHJpYnV0ZSBrZXlzLgogICAgICoKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48U3RyaW5nPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRBdHRyaWJ1dGVLZXlzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVLZXlzKCkgewogICAgICByZXR1cm4gdGhpcy5fYXR0cnMua2V5cygpOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBgTm9kZWAgdG8gcGxhaW4gb2JqZWN0IGFuZCByZXR1cm5zIGl0LgogICAgICoKICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGBOb2RlYCBjb252ZXJ0ZWQgdG8gcGxhaW4gb2JqZWN0LgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvSlNPTiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkgewogICAgICB2YXIganNvbiA9IHt9OyAvLyBTZXJpYWxpemVzIGF0dHJpYnV0ZXMgdG8gdGhlIG9iamVjdC4KICAgICAgLy8gYXR0cmlidXRlcyA9IHsgYTogJ2ZvbycsIGI6IDEsIGM6IHRydWUgfS4KCiAgICAgIGlmICh0aGlzLl9hdHRycy5zaXplKSB7CiAgICAgICAganNvbi5hdHRyaWJ1dGVzID0gQXJyYXkuZnJvbSh0aGlzLl9hdHRycykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGF0dHIpIHsKICAgICAgICAgIHJlc3VsdFthdHRyWzBdXSA9IGF0dHJbMV07CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0sIHt9KTsKICAgICAgfQoKICAgICAgcmV0dXJuIGpzb247CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIHByb2Nlc3NpbmcgbW9kZWwgb2JqZWN0cyB0aGF0IGFyZSBvZiB1bmtub3duIHR5cGUuIEZvciBleGFtcGxlLCBhIGZ1bmN0aW9uCiAgICAgKiBtYXkgcmV0dXJuIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBvciBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZX0KICAgICAqIHRoYXQgY2FuIGJlIGVpdGhlciBhIHRleHQgbm9kZSBvciBhbiBlbGVtZW50LiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBjaGVjayB3aGF0IGtpbmQgb2Ygb2JqZWN0IGlzIHJldHVybmVkLgogICAgICoKICAgICAqCQlzb21lT2JqZWN0LmlzKCAnZWxlbWVudCcgKTsgLy8gLT4gdHJ1ZSBpZiB0aGlzIGlzIGFuIGVsZW1lbnQKICAgICAqCQlzb21lT2JqZWN0LmlzKCAnbm9kZScgKTsgLy8gLT4gdHJ1ZSBpZiB0aGlzIGlzIGEgbm9kZSAoYSB0ZXh0IG5vZGUgb3IgYW4gZWxlbWVudCkKICAgICAqCQlzb21lT2JqZWN0LmlzKCAnZG9jdW1lbnRGcmFnbWVudCcgKTsgLy8gLT4gdHJ1ZSBpZiB0aGlzIGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQKICAgICAqCiAgICAgKiBTaW5jZSB0aGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBvbiBhIHJhbmdlIG9mIHZpZXcgb2JqZWN0cywgeW91IGNhbiBwcmVmaXggdGhlIHR5cGUgb2YgdGhlIG9iamVjdCB3aXRoCiAgICAgKiBgbW9kZWw6YCBvciBgdmlldzpgIHRvIGNoZWNrLCBmb3IgZXhhbXBsZSwgaWYgdGhpcyBpcyB0aGUgbW9kZWwncyBvciB2aWV3J3MgZWxlbWVudDoKICAgICAqCiAgICAgKgkJbW9kZWxFbGVtZW50LmlzKCAnbW9kZWw6ZWxlbWVudCcgKTsgLy8gLT4gdHJ1ZQogICAgICoJCW1vZGVsRWxlbWVudC5pcyggJ3ZpZXc6ZWxlbWVudCcgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKiBCeSB1c2luZyB0aGlzIG1ldGhvZCBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGNoZWNrIGEgbmFtZSBvZiBhbiBlbGVtZW50OgogICAgICoKICAgICAqCQlpbWFnZUVsZW1lbnQuaXMoICdlbGVtZW50JywgJ2ltYWdlJyApOyAvLyAtPiB0cnVlCiAgICAgKgkJaW1hZ2VFbGVtZW50LmlzKCAnZWxlbWVudCcsICdpbWFnZScgKTsgLy8gLT4gc2FtZSBhcyBhYm92ZQogICAgICoJCWltYWdlRWxlbWVudC5pcyggJ21vZGVsOmVsZW1lbnQnLCAnaW1hZ2UnICk7IC8vIC0+IHNhbWUgYXMgYWJvdmUsIGJ1dCBtb3JlIHByZWNpc2UKICAgICAqCiAgICAgKiBUaGUgbGlzdCBvZiBtb2RlbCBvYmplY3RzIHdoaWNoIGltcGxlbWVudCB0aGUgYGlzKClgIG1ldGhvZDoKICAgICAqCiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNpcyBgTm9kZSNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0I2lzIGBUZXh0I2lzKClgfQogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQjaXMgYEVsZW1lbnQjaXMoKWB9CiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Jvb3RlbGVtZW50flJvb3RFbGVtZW50I2lzIGBSb290RWxlbWVudCNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jaXMgYFBvc2l0aW9uI2lzKClgfQogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9saXZlcG9zaXRpb25+TGl2ZVBvc2l0aW9uI2lzIGBMaXZlUG9zaXRpb24jaXMoKWB9CiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlI2lzIGBSYW5nZSNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXJhbmdlfkxpdmVSYW5nZSNpcyBgTGl2ZVJhbmdlI2lzKClgfQogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQjaXMgYERvY3VtZW50RnJhZ21lbnQjaXMoKWB9CiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb24jaXMgYFNlbGVjdGlvbiNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb24jaXMgYERvY3VtZW50U2VsZWN0aW9uI2lzKClgfQogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlciNpcyBgTWFya2VyI2lzKClgfQogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5I2lzIGBUZXh0UHJveHkjaXMoKWB9CiAgICAgKgogICAgICogQG1ldGhvZCAjaXMKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXModHlwZSkgewogICAgICByZXR1cm4gdHlwZSA9PT0gJ25vZGUnIHx8IHR5cGUgPT09ICdtb2RlbDpub2RlJzsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBub2RlLCB0aGF0IGlzIGEgbm9kZSB3aXRoIGV4YWN0bHkgc2FtZSBhdHRyaWJ1dGVzLCBhbmQgcmV0dXJucyBpdC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IE5vZGUgd2l0aCBzYW1lIGF0dHJpYnV0ZXMgYXMgdGhpcyBub2RlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jbG9uZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2Nsb25lKCkgewogICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy5fYXR0cnMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIHRoaXMgbm9kZSBmcm9tIGl0J3MgcGFyZW50LgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI3JlbW92ZQogICAgICogQHByb3RlY3RlZAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmUoKSB7CiAgICAgIHRoaXMucGFyZW50Ll9yZW1vdmVDaGlsZHJlbih0aGlzLmluZGV4KTsKICAgIH0KICAgIC8qKgogICAgICogU2V0cyBhdHRyaWJ1dGUgb24gdGhlIG5vZGUuIElmIGF0dHJpYnV0ZSB3aXRoIHRoZSBzYW1lIGtleSBhbHJlYWR5IGlzIHNldCwgaXQncyB2YWx1ZSBpcyBvdmVyd3JpdHRlbi4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNzZXRBdHRyaWJ1dGUKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG9mIGF0dHJpYnV0ZSB0byBzZXQuCiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfc2V0QXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpIHsKICAgICAgdGhpcy5fYXR0cnMuc2V0KGtleSwgdmFsdWUpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIG5vZGUgYW5kIHNldHMgZ2l2ZW4gYXR0cmlidXRlcy4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNzZXRBdHRyaWJ1dGVzCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJzXSBBdHRyaWJ1dGVzIHRvIHNldC4gU2VlIHtAbGluayBtb2R1bGU6dXRpbHMvdG9tYXB+dG9NYXB9IGZvciBhIGxpc3Qgb2YgYWNjZXB0ZWQgdmFsdWVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9zZXRBdHRyaWJ1dGVzVG8iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBdHRyaWJ1dGVzVG8oYXR0cnMpIHsKICAgICAgdGhpcy5fYXR0cnMgPSB0b01hcChhdHRycyk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIHdpdGggZ2l2ZW4ga2V5IGZyb20gdGhlIG5vZGUuCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjcmVtb3ZlQXR0cmlidXRlCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleSBvZiBhdHRyaWJ1dGUgdG8gcmVtb3ZlLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIHdhcyBzZXQgb24gdGhlIGVsZW1lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmVBdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUoa2V5KSB7CiAgICAgIHJldHVybiB0aGlzLl9hdHRycy5kZWxldGUoa2V5KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBub2RlLgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NsZWFyQXR0cmlidXRlcwogICAgICogQHByb3RlY3RlZAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jbGVhckF0dHJpYnV0ZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhckF0dHJpYnV0ZXMoKSB7CiAgICAgIHRoaXMuX2F0dHJzLmNsZWFyKCk7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gTm9kZTsKfSgpOwovKioKICogVGhlIG5vZGUncyBwYXJlbnQgZG9lcyBub3QgY29udGFpbiB0aGlzIG5vZGUuCiAqCiAqIEBlcnJvciBtb2RlbC1ub2RlLW5vdC1mb3VuZC1pbi1wYXJlbnQKICovCgoKZXhwb3J0IHsgTm9kZSBhcyBkZWZhdWx0IH07"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/node.js"],"names":["toMap","CKEditorError","compareArrays","Node","attrs","parent","_attrs","pos","getChildIndex","getChildStartOffset","startOffset","offsetSize","index","getChild","root","is","path","node","unshift","options","includeSelf","parentFirst","ancestors","ancestorsA","getAncestors","ancestorsB","i","thisPath","getPath","nodePath","result","isBefore","key","has","get","entries","keys","json","size","attributes","Array","from","reduce","attr","type","_removeChildren","value","set","delete","clear"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,KAAP,MAAkB,qCAAlB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,aAAP,MAA0B,6CAA1B,C,CACA;;AACA,OAAO,uCAAP;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,I;AACpB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACC,gBAAaC,KAAb,EAAqB;AAAA;;AACpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,MAAL,GAAc,IAAd;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,MAAL,GAAcN,KAAK,CAAEI,KAAF,CAAnB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;SACC,eAAY;AACX,UAAIG,GAAJ;;AAEA,UAAK,CAAC,KAAKF,MAAX,EAAoB;AACnB,eAAO,IAAP;AACA;;AAED,UAAK,CAAEE,GAAG,GAAG,KAAKF,MAAL,CAAYG,aAAZ,CAA2B,IAA3B,CAAR,MAAgD,IAArD,EAA4D;AAC3D,cAAM,IAAIP,aAAJ,CAAmB,gCAAnB,EAAqD,IAArD,CAAN;AACA;;AAED,aAAOM,GAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACC,eAAkB;AACjB,UAAIA,GAAJ;;AAEA,UAAK,CAAC,KAAKF,MAAX,EAAoB;AACnB,eAAO,IAAP;AACA;;AAED,UAAK,CAAEE,GAAG,GAAG,KAAKF,MAAL,CAAYI,mBAAZ,CAAiC,IAAjC,CAAR,MAAsD,IAA3D,EAAkE;AACjE,cAAM,IAAIR,aAAJ,CAAmB,gCAAnB,EAAqD,IAArD,CAAN;AACA;;AAED,aAAOM,GAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACC,eAAiB;AAChB,aAAO,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACC,eAAgB;AACf,UAAK,CAAC,KAAKF,MAAX,EAAoB;AACnB,eAAO,IAAP;AACA;;AAED,aAAO,KAAKK,WAAL,GAAmB,KAAKC,UAA/B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAkB;AACjB,UAAMC,KAAK,GAAG,KAAKA,KAAnB;AAEA,aAASA,KAAK,KAAK,IAAV,IAAkB,KAAKP,MAAL,CAAYQ,QAAZ,CAAsBD,KAAK,GAAG,CAA9B,CAApB,IAA2D,IAAlE;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAsB;AACrB,UAAMA,KAAK,GAAG,KAAKA,KAAnB;AAEA,aAASA,KAAK,KAAK,IAAV,IAAkB,KAAKP,MAAL,CAAYQ,QAAZ,CAAsBD,KAAK,GAAG,CAA9B,CAApB,IAA2D,IAAlE;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;SACC,eAAW;AACV,UAAIE,IAAI,GAAG,IAAX,CADU,CACO;;AAEjB,aAAQA,IAAI,CAACT,MAAb,EAAsB;AACrBS,QAAAA,IAAI,GAAGA,IAAI,CAACT,MAAZ;AACA;;AAED,aAAOS,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;;WACC,sBAAa;AACZ,aAAO,KAAKA,IAAL,CAAUC,EAAV,CAAc,aAAd,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,mBAAU;AACT,UAAMC,IAAI,GAAG,EAAb;AACA,UAAIC,IAAI,GAAG,IAAX,CAFS,CAEQ;;AAEjB,aAAQA,IAAI,CAACZ,MAAb,EAAsB;AACrBW,QAAAA,IAAI,CAACE,OAAL,CAAcD,IAAI,CAACP,WAAnB;AACAO,QAAAA,IAAI,GAAGA,IAAI,CAACZ,MAAZ;AACA;;AAED,aAAOW,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,wBAAqE;AAAA,UAAvDG,OAAuD,uEAA7C;AAAEC,QAAAA,WAAW,EAAE,KAAf;AAAsBC,QAAAA,WAAW,EAAE;AAAnC,OAA6C;AACpE,UAAMC,SAAS,GAAG,EAAlB;AACA,UAAIjB,MAAM,GAAGc,OAAO,CAACC,WAAR,GAAsB,IAAtB,GAA6B,KAAKf,MAA/C;;AAEA,aAAQA,MAAR,EAAiB;AAChBiB,QAAAA,SAAS,CAAEH,OAAO,CAACE,WAAR,GAAsB,MAAtB,GAA+B,SAAjC,CAAT,CAAuDhB,MAAvD;AACAA,QAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACA;;AAED,aAAOiB,SAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,2BAAmBL,IAAnB,EAAwC;AAAA,UAAfE,OAAe,uEAAL,EAAK;AACvC,UAAMI,UAAU,GAAG,KAAKC,YAAL,CAAmBL,OAAnB,CAAnB;AACA,UAAMM,UAAU,GAAGR,IAAI,CAACO,YAAL,CAAmBL,OAAnB,CAAnB;AAEA,UAAIO,CAAC,GAAG,CAAR;;AAEA,aAAQH,UAAU,CAAEG,CAAF,CAAV,IAAmBD,UAAU,CAAEC,CAAF,CAA7B,IAAsCH,UAAU,CAAEG,CAAF,CAAxD,EAAgE;AAC/DA,QAAAA,CAAC;AACD;;AAED,aAAOA,CAAC,KAAK,CAAN,GAAU,IAAV,GAAiBH,UAAU,CAAEG,CAAC,GAAG,CAAN,CAAlC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,kBAAUT,IAAV,EAAiB;AAChB;AACA,UAAK,QAAQA,IAAb,EAAoB;AACnB,eAAO,KAAP;AACA,OAJe,CAMhB;;;AACA,UAAK,KAAKH,IAAL,KAAcG,IAAI,CAACH,IAAxB,EAA+B;AAC9B,eAAO,KAAP;AACA;;AAED,UAAMa,QAAQ,GAAG,KAAKC,OAAL,EAAjB;AACA,UAAMC,QAAQ,GAAGZ,IAAI,CAACW,OAAL,EAAjB;AAEA,UAAME,MAAM,GAAG5B,aAAa,CAAEyB,QAAF,EAAYE,QAAZ,CAA5B;;AAEA,cAASC,MAAT;AACC,aAAK,QAAL;AACC,iBAAO,IAAP;;AAED,aAAK,WAAL;AACC,iBAAO,KAAP;;AAED;AACC,iBAAOH,QAAQ,CAAEG,MAAF,CAAR,GAAqBD,QAAQ,CAAEC,MAAF,CAApC;AARF;AAUA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAASb,IAAT,EAAgB;AACf;AACA,UAAK,QAAQA,IAAb,EAAoB;AACnB,eAAO,KAAP;AACA,OAJc,CAMf;;;AACA,UAAK,KAAKH,IAAL,KAAcG,IAAI,CAACH,IAAxB,EAA+B;AAC9B,eAAO,KAAP;AACA,OATc,CAWf;;;AACA,aAAO,CAAC,KAAKiB,QAAL,CAAed,IAAf,CAAR;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,sBAAce,GAAd,EAAoB;AACnB,aAAO,KAAK1B,MAAL,CAAY2B,GAAZ,CAAiBD,GAAjB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,sBAAcA,GAAd,EAAoB;AACnB,aAAO,KAAK1B,MAAL,CAAY4B,GAAZ,CAAiBF,GAAjB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAgB;AACf,aAAO,KAAK1B,MAAL,CAAY6B,OAAZ,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;;WACC,4BAAmB;AAClB,aAAO,KAAK7B,MAAL,CAAY8B,IAAZ,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;;WACC,kBAAS;AACR,UAAMC,IAAI,GAAG,EAAb,CADQ,CAGR;AACA;;AACA,UAAK,KAAK/B,MAAL,CAAYgC,IAAjB,EAAwB;AACvBD,QAAAA,IAAI,CAACE,UAAL,GAAkBC,KAAK,CAACC,IAAN,CAAY,KAAKnC,MAAjB,EAA0BoC,MAA1B,CAAkC,UAAEZ,MAAF,EAAUa,IAAV,EAAoB;AACvEb,UAAAA,MAAM,CAAEa,IAAI,CAAE,CAAF,CAAN,CAAN,GAAsBA,IAAI,CAAE,CAAF,CAA1B;AAEA,iBAAOb,MAAP;AACA,SAJiB,EAIf,EAJe,CAAlB;AAKA;;AAED,aAAOO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,YAAIO,IAAJ,EAAW;AACV,aAAOA,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,YAAnC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,kBAAS;AACR,aAAO,IAAIzC,IAAJ,CAAU,KAAKG,MAAf,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,mBAAU;AACT,WAAKD,MAAL,CAAYwC,eAAZ,CAA6B,KAAKjC,KAAlC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeoB,GAAf,EAAoBc,KAApB,EAA4B;AAC3B,WAAKxC,MAAL,CAAYyC,GAAZ,CAAiBf,GAAjB,EAAsBc,KAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,0BAAkB1C,KAAlB,EAA0B;AACzB,WAAKE,MAAL,GAAcN,KAAK,CAAEI,KAAF,CAAnB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,0BAAkB4B,GAAlB,EAAwB;AACvB,aAAO,KAAK1B,MAAL,CAAY0C,MAAZ,CAAoBhB,GAApB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,4BAAmB;AAClB,WAAK1B,MAAL,CAAY2C,KAAZ;AACA;;;;;AAGF;AACA;AACA;AACA;AACA;;;SA/cqB9C,I","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/node\n */\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Model node. Most basic structure of model tree.\n *\n * This is an abstract class that is a base for other classes representing different nodes in model.\n *\n * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.\n * However, it is **very important** that nodes already attached to model tree should be only changed through\n * {@link module:engine/model/writer~Writer Writer API}.\n *\n * Changes done by `Node` methods, like {@link module:engine/model/element~Element#_insertChild _insertChild} or\n * {@link module:engine/model/node~Node#_setAttribute _setAttribute}\n * do not generate {@link module:engine/model/operation/operation~Operation operations}\n * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.\n *\n * The flow of working on `Node` (and classes that inherits from it) is as such:\n * 1. You can create a `Node` instance, modify it using it's API.\n * 2. Add `Node` to the model using `Batch` API.\n * 3. Change `Node` that was already added to the model using `Batch` API.\n *\n * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception\n * of {@link module:engine/model/writer~Writer#insert inserting} that node to the model tree.\n *\n * Be aware that using {@link module:engine/model/writer~Writer#remove remove from Batch API} does not allow to use `Node` API because\n * the information about `Node` is still kept in model document.\n *\n * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and\n * follows same rules.\n */\nexport default class Node {\n\t/**\n\t * Creates a model node.\n\t *\n\t * This is an abstract class, so this constructor should not be used directly.\n\t *\n\t * @abstract\n\t * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\tconstructor( attrs ) {\n\t\t/**\n\t\t * Parent of this node. It could be {@link module:engine/model/element~Element}\n\t\t * or {@link module:engine/model/documentfragment~DocumentFragment}.\n\t\t * Equals to `null` if the node has no parent.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t\t */\n\t\tthis.parent = null;\n\n\t\t/**\n\t\t * Attributes set on this node.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/node~Node#_attrs\n\t\t */\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Index of this node in it's parent or `null` if the node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget index() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildIndex( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent', this );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}\n\t * of all it's previous siblings. Equals to `null` if node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget startOffset() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildStartOffset( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent', this );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset size of this node. Represents how much \"offset space\" is occupied by the node in it's parent.\n\t * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position\n\t * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more\n\t * than one entity, i.e. {@link module:engine/model/text~Text text node}.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget offsetSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Offset at which this node ends in it's parent. It is equal to the sum of this node's\n\t * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.\n\t * Equals to `null` if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget endOffset() {\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.startOffset + this.offsetSize;\n\t}\n\n\t/**\n\t * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nextSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index + 1 ) ) || null;\n\t}\n\n\t/**\n\t * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget previousSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index - 1 ) ) || null;\n\t}\n\n\t/**\n\t * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part\n\t * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\tlet root = this; // eslint-disable-line consistent-this\n\n\t\twhile ( root.parent ) {\n\t\t\troot = root.parent;\n\t\t}\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).\n\t *\n\t * @returns {Boolean}\n\t */\n\tisAttached() {\n\t\treturn this.root.is( 'rootElement' );\n\t}\n\n\t/**\n\t * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,\n\t * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to\n\t * create {@link module:engine/model/position~Position Position} instance.\n\t *\n\t *\t\tconst abc = new Text( 'abc' );\n\t *\t\tconst foo = new Text( 'foo' );\n\t *\t\tconst h1 = new Element( 'h1', null, new Text( 'header' ) );\n\t *\t\tconst p = new Element( 'p', null, [ abc, foo ] );\n\t *\t\tconst div = new Element( 'div', null, [ h1, p ] );\n\t *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n\t *\t\th1.getPath(); // Returns [ 0 ].\n\t *\t\tdiv.getPath(); // Returns [].\n\t *\n\t * @returns {Array.<Number>} The path.\n\t */\n\tgetPath() {\n\t\tconst path = [];\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\twhile ( node.parent ) {\n\t\t\tpath.unshift( node.startOffset );\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Returns ancestors array of this node.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n\t * otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both nodes.\n\t *\n\t * @param {module:engine/model/node~Node} node The second node.\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n\t * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( node, options = {} ) {\n\t\tconst ancestorsA = this.getAncestors( options );\n\t\tconst ancestorsB = node.getAncestors( options );\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisBefore( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisPath = this.getPath();\n\t\tconst nodePath = node.getPath();\n\n\t\tconst result = compareArrays( thisPath, nodePath );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'prefix':\n\t\t\t\treturn true;\n\n\t\t\tcase 'extension':\n\t\t\t\treturn false;\n\n\t\t\tdefault:\n\t\t\t\treturn thisPath[ result ] < nodePath[ result ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisAfter( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In other cases, just check if the `node` is before, and return the opposite.\n\t\treturn !this.isBefore( node );\n\t}\n\n\t/**\n\t * Checks if the node has an attribute with given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on node.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._attrs.entries();\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._attrs.keys();\n\t}\n\n\t/**\n\t * Converts `Node` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = {};\n\n\t\t// Serializes attributes to the object.\n\t\t// attributes = { a: 'foo', b: 1, c: true }.\n\t\tif ( this._attrs.size ) {\n\t\t\tjson.attributes = Array.from( this._attrs ).reduce( ( result, attr ) => {\n\t\t\t\tresult[ attr[ 0 ] ] = attr[ 1 ];\n\n\t\t\t\treturn result;\n\t\t\t}, {} );\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t * This method is useful when processing model objects that are of unknown type. For example, a function\n\t * may return a {@link module:engine/model/documentfragment~DocumentFragment} or a {@link module:engine/model/node~Node}\n\t * that can be either a text node or an element. This method can be used to check what kind of object is returned.\n\t *\n\t *\t\tsomeObject.is( 'element' ); // -> true if this is an element\n\t *\t\tsomeObject.is( 'node' ); // -> true if this is a node (a text node or an element)\n\t *\t\tsomeObject.is( 'documentFragment' ); // -> true if this is a document fragment\n\t *\n\t * Since this method is also available on a range of view objects, you can prefix the type of the object with\n\t * `model:` or `view:` to check, for example, if this is the model's or view's element:\n\t *\n\t *\t\tmodelElement.is( 'model:element' ); // -> true\n\t *\t\tmodelElement.is( 'view:element' ); // -> false\n\t *\n\t * By using this method it is also possible to check a name of an element:\n\t *\n\t *\t\timageElement.is( 'element', 'image' ); // -> true\n\t *\t\timageElement.is( 'element', 'image' ); // -> same as above\n\t *\t\timageElement.is( 'model:element', 'image' ); // -> same as above, but more precise\n\t *\n\t * The list of model objects which implement the `is()` method:\n\t *\n\t * * {@link module:engine/model/node~Node#is `Node#is()`}\n\t * * {@link module:engine/model/text~Text#is `Text#is()`}\n\t * * {@link module:engine/model/element~Element#is `Element#is()`}\n\t * * {@link module:engine/model/rootelement~RootElement#is `RootElement#is()`}\n\t * * {@link module:engine/model/position~Position#is `Position#is()`}\n\t * * {@link module:engine/model/liveposition~LivePosition#is `LivePosition#is()`}\n\t * * {@link module:engine/model/range~Range#is `Range#is()`}\n\t * * {@link module:engine/model/liverange~LiveRange#is `LiveRange#is()`}\n\t * * {@link module:engine/model/documentfragment~DocumentFragment#is `DocumentFragment#is()`}\n\t * * {@link module:engine/model/selection~Selection#is `Selection#is()`}\n\t * * {@link module:engine/model/documentselection~DocumentSelection#is `DocumentSelection#is()`}\n\t * * {@link module:engine/model/markercollection~Marker#is `Marker#is()`}\n\t * * {@link module:engine/model/textproxy~TextProxy#is `TextProxy#is()`}\n\t *\n\t * @method #is\n\t * @param {String} type Type to check.\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'node' || type === 'model:node';\n\t}\n\n\t/**\n\t * Creates a copy of this node, that is a node with exactly same attributes, and returns it.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/node~Node} Node with same attributes as this node.\n\t */\n\t_clone() {\n\t\treturn new Node( this._attrs );\n\t}\n\n\t/**\n\t * Removes this node from it's parent.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t */\n\t_remove() {\n\t\tthis.parent._removeChildren( this.index );\n\t}\n\n\t/**\n\t * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\t_setAttribute( key, value ) {\n\t\tthis._attrs.set( key, value );\n\t}\n\n\t/**\n\t * Removes all attributes from the node and sets given attributes.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttributes\n\t * @protected\n\t * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\t_setAttributesTo( attrs ) {\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#removeAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to remove.\n\t * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.\n\t */\n\t_removeAttribute( key ) {\n\t\treturn this._attrs.delete( key );\n\t}\n\n\t/**\n\t * Removes all attributes from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#clearAttributes\n\t * @protected\n\t */\n\t_clearAttributes() {\n\t\tthis._attrs.clear();\n\t}\n}\n\n/**\n * The node's parent does not contain this node.\n *\n * @error model-node-not-found-in-parent\n */\n"]}]}