{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGUKICovCmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gtZXMnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKLyoqCiAqIENsYXNzIHVzZWQgZm9yIGhhbmRsaW5nIGNvbnN1bXB0aW9uIG9mIHZpZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgZWxlbWVudHN9LAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGVzfSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgZG9jdW1lbnQgZnJhZ21lbnRzfS4KICogRWxlbWVudCdzIG5hbWUgYW5kIGl0cyBwYXJ0cyAoYXR0cmlidXRlcywgY2xhc3NlcyBhbmQgc3R5bGVzKSBjYW4gYmUgY29uc3VtZWQgc2VwYXJhdGVseS4gQ29uc3VtaW5nIGFuIGVsZW1lbnQncyBuYW1lCiAqIGRvZXMgbm90IGNvbnN1bWUgaXRzIGF0dHJpYnV0ZXMsIGNsYXNzZXMgYW5kIHN0eWxlcy4KICogVG8gYWRkIGl0ZW1zIGZvciBjb25zdW1wdGlvbiB1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZSNhZGQgYWRkIG1ldGhvZH0uCiAqIFRvIHRlc3QgaXRlbXMgdXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0NvbnN1bWFibGUjdGVzdCB0ZXN0IG1ldGhvZH0uCiAqIFRvIGNvbnN1bWUgaXRlbXMgdXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0NvbnN1bWFibGUjY29uc3VtZSBjb25zdW1lIG1ldGhvZH0uCiAqIFRvIHJldmVydCBhbHJlYWR5IGNvbnN1bWVkIGl0ZW1zIHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3ZpZXdjb25zdW1hYmxlflZpZXdDb25zdW1hYmxlI3JldmVydCByZXZlcnQgbWV0aG9kfS4KICoKICoJCXZpZXdDb25zdW1hYmxlLmFkZCggZWxlbWVudCwgeyBuYW1lOiB0cnVlIH0gKTsgLy8gQWRkcyBlbGVtZW50J3MgbmFtZSBhcyByZWFkeSB0byBiZSBjb25zdW1lZC4KICoJCXZpZXdDb25zdW1hYmxlLmFkZCggdGV4dE5vZGUgKTsgLy8gQWRkcyB0ZXh0IG5vZGUgZm9yIGNvbnN1bXB0aW9uLgogKgkJdmlld0NvbnN1bWFibGUuYWRkKCBkb2NGcmFnbWVudCApOyAvLyBBZGRzIGRvY3VtZW50IGZyYWdtZW50IGZvciBjb25zdW1wdGlvbi4KICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIGVsZW1lbnQsIHsgbmFtZTogdHJ1ZSB9ICApOyAvLyBUZXN0cyBpZiBlbGVtZW50J3MgbmFtZSBjYW4gYmUgY29uc3VtZWQuCiAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCB0ZXh0Tm9kZSApOyAvLyBUZXN0cyBpZiB0ZXh0IG5vZGUgY2FuIGJlIGNvbnN1bWVkLgogKgkJdmlld0NvbnN1bWFibGUudGVzdCggZG9jRnJhZ21lbnQgKTsgLy8gVGVzdHMgaWYgZG9jdW1lbnQgZnJhZ21lbnQgY2FuIGJlIGNvbnN1bWVkLgogKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggZWxlbWVudCwgeyBuYW1lOiB0cnVlIH0gICk7IC8vIENvbnN1bWUgZWxlbWVudCdzIG5hbWUuCiAqCQl2aWV3Q29uc3VtYWJsZS5jb25zdW1lKCB0ZXh0Tm9kZSApOyAvLyBDb25zdW1lIHRleHQgbm9kZS4KICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIGRvY0ZyYWdtZW50ICk7IC8vIENvbnN1bWUgZG9jdW1lbnQgZnJhZ21lbnQuCiAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIGVsZW1lbnQsIHsgbmFtZTogdHJ1ZSB9ICApOyAvLyBSZXZlcnQgYWxyZWFkeSBjb25zdW1lZCBlbGVtZW50J3MgbmFtZS4KICoJCXZpZXdDb25zdW1hYmxlLnJldmVydCggdGV4dE5vZGUgKTsgLy8gUmV2ZXJ0IGFscmVhZHkgY29uc3VtZWQgdGV4dCBub2RlLgogKgkJdmlld0NvbnN1bWFibGUucmV2ZXJ0KCBkb2NGcmFnbWVudCApOyAvLyBSZXZlcnQgYWxyZWFkeSBjb25zdW1lZCBkb2N1bWVudCBmcmFnbWVudC4KICovCgp2YXIgVmlld0NvbnN1bWFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgbmV3IFZpZXdDb25zdW1hYmxlLgogICAqLwogIGZ1bmN0aW9uIFZpZXdDb25zdW1hYmxlKCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZXdDb25zdW1hYmxlKTsKCiAgICAvKioKICAgICAqIE1hcCBvZiBjb25zdW1hYmxlIGVsZW1lbnRzLiBJZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSBpcyB1c2VkIGFzIGEga2V5LAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3RWxlbWVudENvbnN1bWFibGVzIFZpZXdFbGVtZW50Q29uc3VtYWJsZXN9IGluc3RhbmNlIGlzIHN0b3JlZCBhcyB2YWx1ZS4KICAgICAqIEZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGVzfSBhbmQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IGRvY3VtZW50IGZyYWdtZW50c30gYm9vbGVhbiB2YWx1ZSBpcyBzdG9yZWQgYXMgdmFsdWUuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQG1lbWJlciB7TWFwLjxtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0VsZW1lbnRDb25zdW1hYmxlc3xCb29sZWFuPn0KICAgICovCiAgICB0aGlzLl9jb25zdW1hYmxlcyA9IG5ldyBNYXAoKTsKICB9CiAgLyoqCiAgICogQWRkcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9LCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGV9IG9yCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgZG9jdW1lbnQgZnJhZ21lbnR9IGFzIHJlYWR5IHRvIGJlIGNvbnN1bWVkLgogICAqCiAgICoJCXZpZXdDb25zdW1hYmxlLmFkZCggcCwgeyBuYW1lOiB0cnVlIH0gKTsgLy8gQWRkcyBlbGVtZW50J3MgbmFtZSB0byBjb25zdW1lLgogICAqCQl2aWV3Q29uc3VtYWJsZS5hZGQoIHAsIHsgYXR0cmlidXRlczogJ25hbWUnIH0gKTsgLy8gQWRkcyBlbGVtZW50J3MgYXR0cmlidXRlLgogICAqCQl2aWV3Q29uc3VtYWJsZS5hZGQoIHAsIHsgY2xhc3NlczogJ2Zvb2JhcicgfSApOyAvLyBBZGRzIGVsZW1lbnQncyBjbGFzcy4KICAgKgkJdmlld0NvbnN1bWFibGUuYWRkKCBwLCB7IHN0eWxlczogJ2NvbG9yJyB9ICk7IC8vIEFkZHMgZWxlbWVudCdzIHN0eWxlCiAgICoJCXZpZXdDb25zdW1hYmxlLmFkZCggcCwgeyBhdHRyaWJ1dGVzOiAnbmFtZScsIHN0eWxlczogJ2NvbG9yJyB9ICk7IC8vIEFkZHMgYXR0cmlidXRlIGFuZCBzdHlsZS4KICAgKgkJdmlld0NvbnN1bWFibGUuYWRkKCBwLCB7IGNsYXNzZXM6IFsgJ2JheicsICdiYXInIF0gfSApOyAvLyBNdWx0aXBsZSBjb25zdW1hYmxlcyBjYW4gYmUgcHJvdmlkZWQuCiAgICoJCXZpZXdDb25zdW1hYmxlLmFkZCggdGV4dE5vZGUgKTsgLy8gQWRkcyB0ZXh0IG5vZGUgdG8gY29uc3VtZS4KICAgKgkJdmlld0NvbnN1bWFibGUuYWRkKCBkb2NGcmFnbWVudCApOyAvLyBBZGRzIGRvY3VtZW50IGZyYWdtZW50IHRvIGNvbnN1bWUuCiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXdjb25zdW1hYmxlLWludmFsaWQtYXR0cmlidXRlYCB3aGVuIGBjbGFzc2Agb3IgYHN0eWxlYAogICAqIGF0dHJpYnV0ZSBpcyBwcm92aWRlZCAtIGl0IHNob3VsZCBiZSBoYW5kbGVkIHNlcGFyYXRlbHkgYnkgcHJvdmlkaW5nIGFjdHVhbCBzdHlsZS9jbGFzcy4KICAgKgogICAqCQl2aWV3Q29uc3VtYWJsZS5hZGQoIHAsIHsgYXR0cmlidXRlczogJ3N0eWxlJyB9ICk7IC8vIFRoaXMgY2FsbCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi4KICAgKgkJdmlld0NvbnN1bWFibGUuYWRkKCBwLCB7IHN0eWxlczogJ2NvbG9yJyB9ICk7IC8vIFRoaXMgaXMgcHJvcGVybHkgaGFuZGxlZCBzdHlsZS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGVsZW1lbnQKICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnN1bWFibGVzXSBVc2VkIG9ubHkgaWYgZmlyc3QgcGFyYW1ldGVyIGlzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gaW5zdGFuY2UuCiAgICogQHBhcmFtIHtCb29sZWFufSBjb25zdW1hYmxlcy5uYW1lIElmIHNldCB0byB0cnVlIGVsZW1lbnQncyBuYW1lIHdpbGwgYmUgaW5jbHVkZWQuCiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmF0dHJpYnV0ZXMgQXR0cmlidXRlIG5hbWUgb3IgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzLgogICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMuCiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLnN0eWxlcyBTdHlsZSBuYW1lIG9yIGFycmF5IG9mIHN0eWxlIG5hbWVzLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFZpZXdDb25zdW1hYmxlLCBbewogICAga2V5OiAiYWRkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZWxlbWVudCwgY29uc3VtYWJsZXMpIHsKICAgICAgdmFyIGVsZW1lbnRDb25zdW1hYmxlczsgLy8gRm9yIHRleHQgbm9kZXMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyBqdXN0IG1hcmsgdGhlbSBhcyBjb25zdW1hYmxlLgoKICAgICAgaWYgKGVsZW1lbnQuaXMoJyR0ZXh0JykgfHwgZWxlbWVudC5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgdGhpcy5fY29uc3VtYWJsZXMuc2V0KGVsZW1lbnQsIHRydWUpOwoKICAgICAgICByZXR1cm47CiAgICAgIH0gLy8gRm9yIGVsZW1lbnRzIGNyZWF0ZSBuZXcgVmlld0VsZW1lbnRDb25zdW1hYmxlcyBvciB1cGRhdGUgYWxyZWFkeSBleGlzdGluZyBvbmUuCgoKICAgICAgaWYgKCF0aGlzLl9jb25zdW1hYmxlcy5oYXMoZWxlbWVudCkpIHsKICAgICAgICBlbGVtZW50Q29uc3VtYWJsZXMgPSBuZXcgVmlld0VsZW1lbnRDb25zdW1hYmxlcyhlbGVtZW50KTsKCiAgICAgICAgdGhpcy5fY29uc3VtYWJsZXMuc2V0KGVsZW1lbnQsIGVsZW1lbnRDb25zdW1hYmxlcyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZWxlbWVudENvbnN1bWFibGVzID0gdGhpcy5fY29uc3VtYWJsZXMuZ2V0KGVsZW1lbnQpOwogICAgICB9CgogICAgICBlbGVtZW50Q29uc3VtYWJsZXMuYWRkKGNvbnN1bWFibGVzKTsKICAgIH0KICAgIC8qKgogICAgICogVGVzdHMgaWYge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fSwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgdGV4dCBub2RlfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgZG9jdW1lbnQgZnJhZ21lbnR9IGNhbiBiZSBjb25zdW1lZC4KICAgICAqIEl0IHJldHVybnMgYHRydWVgIHdoZW4gYWxsIGl0ZW1zIGluY2x1ZGVkIGluIG1ldGhvZCdzIGNhbGwgY2FuIGJlIGNvbnN1bWVkLiBSZXR1cm5zIGBmYWxzZWAgd2hlbgogICAgICogZmlyc3QgYWxyZWFkeSBjb25zdW1lZCBpdGVtIGlzIGZvdW5kIGFuZCBgbnVsbGAgd2hlbiBmaXJzdCBub24tY29uc3VtYWJsZSBpdGVtIGlzIGZvdW5kLgogICAgICoKICAgICAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBwLCB7IG5hbWU6IHRydWUgfSApOyAvLyBUZXN0cyBlbGVtZW50J3MgbmFtZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBwLCB7IGF0dHJpYnV0ZXM6ICduYW1lJyB9ICk7IC8vIFRlc3RzIGF0dHJpYnV0ZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBwLCB7IGNsYXNzZXM6ICdmb29iYXInIH0gKTsgLy8gVGVzdHMgY2xhc3MuCiAgICAgKgkJdmlld0NvbnN1bWFibGUudGVzdCggcCwgeyBzdHlsZXM6ICdjb2xvcicgfSApOyAvLyBUZXN0cyBzdHlsZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBwLCB7IGF0dHJpYnV0ZXM6ICduYW1lJywgc3R5bGVzOiAnY29sb3InIH0gKTsgLy8gVGVzdHMgYXR0cmlidXRlIGFuZCBzdHlsZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBwLCB7IGNsYXNzZXM6IFsgJ2JheicsICdiYXInIF0gfSApOyAvLyBNdWx0aXBsZSBjb25zdW1hYmxlcyBjYW4gYmUgdGVzdGVkLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHRleHROb2RlICk7IC8vIFRlc3RzIHRleHQgbm9kZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBkb2NGcmFnbWVudCApOyAvLyBUZXN0cyBkb2N1bWVudCBmcmFnbWVudC4KICAgICAqCiAgICAgKiBUZXN0aW5nIGNsYXNzZXMgYW5kIHN0eWxlcyBhcyBhdHRyaWJ1dGUgd2lsbCB0ZXN0IGlmIGFsbCBhZGRlZCBjbGFzc2VzL3N0eWxlcyBjYW4gYmUgY29uc3VtZWQuCiAgICAgKgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHAsIHsgYXR0cmlidXRlczogJ2NsYXNzJyB9ICk7IC8vIFRlc3RzIGlmIGFsbCBhZGRlZCBjbGFzc2VzIGNhbiBiZSBjb25zdW1lZC4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBwLCB7IGF0dHJpYnV0ZXM6ICdzdHlsZScgfSApOyAvLyBUZXN0cyBpZiBhbGwgYWRkZWQgc3R5bGVzIGNhbiBiZSBjb25zdW1lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBlbGVtZW50CiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnN1bWFibGVzXSBVc2VkIG9ubHkgaWYgZmlyc3QgcGFyYW1ldGVyIGlzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gaW5zdGFuY2UuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnN1bWFibGVzLm5hbWUgSWYgc2V0IHRvIHRydWUgZWxlbWVudCdzIG5hbWUgd2lsbCBiZSBpbmNsdWRlZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5hdHRyaWJ1dGVzIEF0dHJpYnV0ZSBuYW1lIG9yIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcy4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuc3R5bGVzIFN0eWxlIG5hbWUgb3IgYXJyYXkgb2Ygc3R5bGUgbmFtZXMuCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxudWxsfSBSZXR1cm5zIGB0cnVlYCB3aGVuIGFsbCBpdGVtcyBpbmNsdWRlZCBpbiBtZXRob2QncyBjYWxsIGNhbiBiZSBjb25zdW1lZC4gUmV0dXJucyBgZmFsc2VgCiAgICAgKiB3aGVuIGZpcnN0IGFscmVhZHkgY29uc3VtZWQgaXRlbSBpcyBmb3VuZCBhbmQgYG51bGxgIHdoZW4gZmlyc3Qgbm9uLWNvbnN1bWFibGUgaXRlbSBpcyBmb3VuZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0ZXN0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXN0KGVsZW1lbnQsIGNvbnN1bWFibGVzKSB7CiAgICAgIHZhciBlbGVtZW50Q29uc3VtYWJsZXMgPSB0aGlzLl9jb25zdW1hYmxlcy5nZXQoZWxlbWVudCk7CgogICAgICBpZiAoZWxlbWVudENvbnN1bWFibGVzID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfSAvLyBGb3IgdGV4dCBub2RlcyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIHJldHVybiBzdG9yZWQgYm9vbGVhbiB2YWx1ZS4KCgogICAgICBpZiAoZWxlbWVudC5pcygnJHRleHQnKSB8fCBlbGVtZW50LmlzKCdkb2N1bWVudEZyYWdtZW50JykpIHsKICAgICAgICByZXR1cm4gZWxlbWVudENvbnN1bWFibGVzOwogICAgICB9IC8vIEZvciBlbGVtZW50cyB0ZXN0IGNvbnN1bWFibGVzIG9iamVjdC4KCgogICAgICByZXR1cm4gZWxlbWVudENvbnN1bWFibGVzLnRlc3QoY29uc3VtYWJsZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBDb25zdW1lcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9LCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGV9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBkb2N1bWVudCBmcmFnbWVudH0uCiAgICAgKiBJdCByZXR1cm5zIGB0cnVlYCB3aGVuIGFsbCBpdGVtcyBpbmNsdWRlZCBpbiBtZXRob2QncyBjYWxsIGNhbiBiZSBjb25zdW1lZCwgb3RoZXJ3aXNlIHJldHVybnMgYGZhbHNlYC4KICAgICAqCiAgICAgKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggcCwgeyBuYW1lOiB0cnVlIH0gKTsgLy8gQ29uc3VtZXMgZWxlbWVudCdzIG5hbWUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggcCwgeyBhdHRyaWJ1dGVzOiAnbmFtZScgfSApOyAvLyBDb25zdW1lcyBlbGVtZW50J3MgYXR0cmlidXRlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHAsIHsgY2xhc3NlczogJ2Zvb2JhcicgfSApOyAvLyBDb25zdW1lcyBlbGVtZW50J3MgY2xhc3MuCiAgICAgKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggcCwgeyBzdHlsZXM6ICdjb2xvcicgfSApOyAvLyBDb25zdW1lcyBlbGVtZW50J3Mgc3R5bGUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggcCwgeyBhdHRyaWJ1dGVzOiAnbmFtZScsIHN0eWxlczogJ2NvbG9yJyB9ICk7IC8vIENvbnN1bWVzIGF0dHJpYnV0ZSBhbmQgc3R5bGUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggcCwgeyBjbGFzc2VzOiBbICdiYXonLCAnYmFyJyBdIH0gKTsgLy8gTXVsdGlwbGUgY29uc3VtYWJsZXMgY2FuIGJlIGNvbnN1bWVkLgogICAgICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHRleHROb2RlICk7IC8vIENvbnN1bWVzIHRleHQgbm9kZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS5jb25zdW1lKCBkb2NGcmFnbWVudCApOyAvLyBDb25zdW1lcyBkb2N1bWVudCBmcmFnbWVudC4KICAgICAqCiAgICAgKiBDb25zdW1pbmcgY2xhc3NlcyBhbmQgc3R5bGVzIGFzIGF0dHJpYnV0ZSB3aWxsIHRlc3QgaWYgYWxsIGFkZGVkIGNsYXNzZXMvc3R5bGVzIGNhbiBiZSBjb25zdW1lZC4KICAgICAqCiAgICAgKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggcCwgeyBhdHRyaWJ1dGVzOiAnY2xhc3MnIH0gKTsgLy8gQ29uc3VtZSBvbmx5IGlmIGFsbCBhZGRlZCBjbGFzc2VzIGNhbiBiZSBjb25zdW1lZC4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS5jb25zdW1lKCBwLCB7IGF0dHJpYnV0ZXM6ICdzdHlsZScgfSApOyAvLyBDb25zdW1lIG9ubHkgaWYgYWxsIGFkZGVkIHN0eWxlcyBjYW4gYmUgY29uc3VtZWQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gZWxlbWVudAogICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25zdW1hYmxlc10gVXNlZCBvbmx5IGlmIGZpcnN0IHBhcmFtZXRlciBpcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9IGluc3RhbmNlLgogICAgICogQHBhcmFtIHtCb29sZWFufSBjb25zdW1hYmxlcy5uYW1lIElmIHNldCB0byB0cnVlIGVsZW1lbnQncyBuYW1lIHdpbGwgYmUgaW5jbHVkZWQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuYXR0cmlidXRlcyBBdHRyaWJ1dGUgbmFtZSBvciBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuY2xhc3NlcyBDbGFzcyBuYW1lIG9yIGFycmF5IG9mIGNsYXNzIG5hbWVzLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLnN0eWxlcyBTdHlsZSBuYW1lIG9yIGFycmF5IG9mIHN0eWxlIG5hbWVzLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIHdoZW4gYWxsIGl0ZW1zIGluY2x1ZGVkIGluIG1ldGhvZCdzIGNhbGwgY2FuIGJlIGNvbnN1bWVkLAogICAgICogb3RoZXJ3aXNlIHJldHVybnMgYGZhbHNlYC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjb25zdW1lIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKGVsZW1lbnQsIGNvbnN1bWFibGVzKSB7CiAgICAgIGlmICh0aGlzLnRlc3QoZWxlbWVudCwgY29uc3VtYWJsZXMpKSB7CiAgICAgICAgaWYgKGVsZW1lbnQuaXMoJyR0ZXh0JykgfHwgZWxlbWVudC5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgICAvLyBGb3IgdGV4dCBub2RlcyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIHNldCB2YWx1ZSB0byBmYWxzZS4KICAgICAgICAgIHRoaXMuX2NvbnN1bWFibGVzLnNldChlbGVtZW50LCBmYWxzZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIEZvciBlbGVtZW50cyAtIGNvbnN1bWUgY29uc3VtYWJsZXMgb2JqZWN0LgogICAgICAgICAgdGhpcy5fY29uc3VtYWJsZXMuZ2V0KGVsZW1lbnQpLmNvbnN1bWUoY29uc3VtYWJsZXMpOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogUmV2ZXJ0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9LCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGV9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBkb2N1bWVudCBmcmFnbWVudH0gc28gdGhleSBjYW4gYmUgY29uc3VtZWQgb25jZSBhZ2Fpbi4KICAgICAqIE1ldGhvZCBkb2VzIG5vdCByZXZlcnQgaXRlbXMgdGhhdCB3ZXJlIG5ldmVyIHByZXZpb3VzbHkgYWRkZWQgZm9yIGNvbnN1bXB0aW9uLCBldmVuIGlmIHRoZXkgYXJlIGluY2x1ZGVkIGluCiAgICAgKiBtZXRob2QncyBjYWxsLgogICAgICoKICAgICAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIHAsIHsgbmFtZTogdHJ1ZSB9ICk7IC8vIFJldmVydHMgZWxlbWVudCdzIG5hbWUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUucmV2ZXJ0KCBwLCB7IGF0dHJpYnV0ZXM6ICduYW1lJyB9ICk7IC8vIFJldmVydHMgZWxlbWVudCdzIGF0dHJpYnV0ZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIHAsIHsgY2xhc3NlczogJ2Zvb2JhcicgfSApOyAvLyBSZXZlcnRzIGVsZW1lbnQncyBjbGFzcy4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIHAsIHsgc3R5bGVzOiAnY29sb3InIH0gKTsgLy8gUmV2ZXJ0cyBlbGVtZW50J3Mgc3R5bGUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUucmV2ZXJ0KCBwLCB7IGF0dHJpYnV0ZXM6ICduYW1lJywgc3R5bGVzOiAnY29sb3InIH0gKTsgLy8gUmV2ZXJ0cyBhdHRyaWJ1dGUgYW5kIHN0eWxlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnJldmVydCggcCwgeyBjbGFzc2VzOiBbICdiYXonLCAnYmFyJyBdIH0gKTsgLy8gTXVsdGlwbGUgbmFtZXMgY2FuIGJlIHJldmVydGVkLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnJldmVydCggdGV4dE5vZGUgKTsgLy8gUmV2ZXJ0cyB0ZXh0IG5vZGUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUucmV2ZXJ0KCBkb2NGcmFnbWVudCApOyAvLyBSZXZlcnRzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIFJldmVydGluZyBjbGFzc2VzIGFuZCBzdHlsZXMgYXMgYXR0cmlidXRlIHdpbGwgcmV2ZXJ0IGFsbCBjbGFzc2VzL3N0eWxlcyB0aGF0IHdlcmUgcHJldmlvdXNseSBhZGRlZCBmb3IKICAgICAqIGNvbnN1bXB0aW9uLgogICAgICoKICAgICAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIHAsIHsgYXR0cmlidXRlczogJ2NsYXNzJyB9ICk7IC8vIFJldmVydHMgYWxsIGNsYXNzZXMgYWRkZWQgZm9yIGNvbnN1bXB0aW9uLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnJldmVydCggcCwgeyBhdHRyaWJ1dGVzOiAnc3R5bGUnIH0gKTsgLy8gUmV2ZXJ0cyBhbGwgc3R5bGVzIGFkZGVkIGZvciBjb25zdW1wdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBlbGVtZW50CiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnN1bWFibGVzXSBVc2VkIG9ubHkgaWYgZmlyc3QgcGFyYW1ldGVyIGlzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gaW5zdGFuY2UuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnN1bWFibGVzLm5hbWUgSWYgc2V0IHRvIHRydWUgZWxlbWVudCdzIG5hbWUgd2lsbCBiZSBpbmNsdWRlZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5hdHRyaWJ1dGVzIEF0dHJpYnV0ZSBuYW1lIG9yIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcy4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuc3R5bGVzIFN0eWxlIG5hbWUgb3IgYXJyYXkgb2Ygc3R5bGUgbmFtZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmV2ZXJ0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnQoZWxlbWVudCwgY29uc3VtYWJsZXMpIHsKICAgICAgdmFyIGVsZW1lbnRDb25zdW1hYmxlcyA9IHRoaXMuX2NvbnN1bWFibGVzLmdldChlbGVtZW50KTsKCiAgICAgIGlmIChlbGVtZW50Q29uc3VtYWJsZXMgIT09IHVuZGVmaW5lZCkgewogICAgICAgIGlmIChlbGVtZW50LmlzKCckdGV4dCcpIHx8IGVsZW1lbnQuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICAgICAgLy8gRm9yIHRleHQgbm9kZXMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyAtIHNldCBjb25zdW1hYmxlIHRvIHRydWUuCiAgICAgICAgICB0aGlzLl9jb25zdW1hYmxlcy5zZXQoZWxlbWVudCwgdHJ1ZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIEZvciBlbGVtZW50cyAtIHJldmVydCBpdGVtcyBmcm9tIGNvbnN1bWFibGVzIG9iamVjdC4KICAgICAgICAgIGVsZW1lbnRDb25zdW1hYmxlcy5yZXZlcnQoY29uc3VtYWJsZXMpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGNvbnN1bWFibGUgb2JqZWN0IGZyb20ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fS4gQ29uc3VtYWJsZSBvYmplY3Qgd2lsbCBpbmNsdWRlCiAgICAgKiBlbGVtZW50J3MgbmFtZSBhbmQgYWxsIGl0cyBhdHRyaWJ1dGVzLCBjbGFzc2VzIGFuZCBzdHlsZXMuCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25zdW1hYmxlcwogICAgICovCgogIH1dLCBbewogICAga2V5OiAiY29uc3VtYWJsZXNGcm9tRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtYWJsZXNGcm9tRWxlbWVudChlbGVtZW50KSB7CiAgICAgIHZhciBjb25zdW1hYmxlcyA9IHsKICAgICAgICBlbGVtZW50OiBlbGVtZW50LAogICAgICAgIG5hbWU6IHRydWUsCiAgICAgICAgYXR0cmlidXRlczogW10sCiAgICAgICAgY2xhc3NlczogW10sCiAgICAgICAgc3R5bGVzOiBbXQogICAgICB9OwogICAgICB2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlS2V5cygpOwoKICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGF0dHJpYnV0ZXMpLAogICAgICAgICAgX3N0ZXA7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgYXR0cmlidXRlID0gX3N0ZXAudmFsdWU7CgogICAgICAgICAgLy8gU2tpcCBjbGFzc2VzIGFuZCBzdHlsZXMgLSB3aWxsIGJlIGFkZGVkIHNlcGFyYXRlbHkuCiAgICAgICAgICBpZiAoYXR0cmlidXRlID09ICdzdHlsZScgfHwgYXR0cmlidXRlID09ICdjbGFzcycpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3VtYWJsZXMuYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvci5mKCk7CiAgICAgIH0KCiAgICAgIHZhciBjbGFzc2VzID0gZWxlbWVudC5nZXRDbGFzc05hbWVzKCk7CgogICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNsYXNzZXMpLAogICAgICAgICAgX3N0ZXAyOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgIGNvbnN1bWFibGVzLmNsYXNzZXMucHVzaChjbGFzc05hbWUpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7CiAgICAgIH0KCiAgICAgIHZhciBzdHlsZXMgPSBlbGVtZW50LmdldFN0eWxlTmFtZXMoKTsKCiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3R5bGVzKSwKICAgICAgICAgIF9zdGVwMzsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBzdHlsZSA9IF9zdGVwMy52YWx1ZTsKICAgICAgICAgIGNvbnN1bWFibGVzLnN0eWxlcy5wdXNoKHN0eWxlKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjMuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjMuZigpOwogICAgICB9CgogICAgICByZXR1cm4gY29uc3VtYWJsZXM7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZSBWaWV3Q29uc3VtYWJsZX0gaW5zdGFuY2UgZnJvbQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgbm9kZX0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgZG9jdW1lbnQgZnJhZ21lbnR9LgogICAgICogSW5zdGFuY2Ugd2lsbCBjb250YWluIGFsbCBlbGVtZW50cywgY2hpbGQgbm9kZXMsIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgY2xhc3NlcyBhZGRlZCBmb3IgY29uc3VtcHRpb24uCiAgICAgKgogICAgICogQHN0YXRpYwogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGZyb20gVmlldyBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50CiAgICAgKiBmcm9tIHdoaWNoIGBWaWV3Q29uc3VtYWJsZWAgd2lsbCBiZSBjcmVhdGVkLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0NvbnN1bWFibGV9IFtpbnN0YW5jZV0gSWYgcHJvdmlkZWQsIGdpdmVuIGBWaWV3Q29uc3VtYWJsZWAgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkCiAgICAgKiB0byBhZGQgYWxsIGNvbnN1bWFibGVzLiBJdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYSBuZXcgaW5zdGFuY2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlRnJvbSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRnJvbShmcm9tLCBpbnN0YW5jZSkgewogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgaW5zdGFuY2UgPSBuZXcgVmlld0NvbnN1bWFibGUoZnJvbSk7CiAgICAgIH0KCiAgICAgIGlmIChmcm9tLmlzKCckdGV4dCcpKSB7CiAgICAgICAgaW5zdGFuY2UuYWRkKGZyb20pOwogICAgICAgIHJldHVybiBpbnN0YW5jZTsKICAgICAgfSAvLyBBZGQgYGZyb21gIGl0c2VsZiwgaWYgaXQgaXMgYW4gZWxlbWVudC4KCgogICAgICBpZiAoZnJvbS5pcygnZWxlbWVudCcpKSB7CiAgICAgICAgaW5zdGFuY2UuYWRkKGZyb20sIFZpZXdDb25zdW1hYmxlLmNvbnN1bWFibGVzRnJvbUVsZW1lbnQoZnJvbSkpOwogICAgICB9CgogICAgICBpZiAoZnJvbS5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgaW5zdGFuY2UuYWRkKGZyb20pOwogICAgICB9CgogICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZyb20uZ2V0Q2hpbGRyZW4oKSksCiAgICAgICAgICBfc3RlcDQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcDQudmFsdWU7CiAgICAgICAgICBpbnN0YW5jZSA9IFZpZXdDb25zdW1hYmxlLmNyZWF0ZUZyb20oY2hpbGQsIGluc3RhbmNlKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjQuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjQuZigpOwogICAgICB9CgogICAgICByZXR1cm4gaW5zdGFuY2U7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gVmlld0NvbnN1bWFibGU7Cn0oKTsKLyoqCiAqIFRoaXMgaXMgYSBwcml2YXRlIGhlbHBlci1jbGFzcyBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZX0uCiAqIEl0IHJlcHJlc2VudHMgYW5kIG1hbmlwdWxhdGVzIGNvbnN1bWFibGUgcGFydHMgb2YgYSBzaW5nbGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9LgogKgogKiBAcHJpdmF0ZQogKi8KCgpleHBvcnQgeyBWaWV3Q29uc3VtYWJsZSBhcyBkZWZhdWx0IH07Cgp2YXIgVmlld0VsZW1lbnRDb25zdW1hYmxlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBWaWV3RWxlbWVudENvbnN1bWFibGVzIGluc3RhbmNlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGZyb20gVmlldyBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50CiAgICogZnJvbSB3aGljaCBgVmlld0VsZW1lbnRDb25zdW1hYmxlc2AgaXMgYmVpbmcgY3JlYXRlZC4KICAgKi8KICBmdW5jdGlvbiBWaWV3RWxlbWVudENvbnN1bWFibGVzKGZyb20pIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3RWxlbWVudENvbnN1bWFibGVzKTsKCiAgICAvKioKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICovCiAgICB0aGlzLmVsZW1lbnQgPSBmcm9tOwogICAgLyoqCiAgICAgKiBGbGFnIGluZGljYXRpbmcgaWYgbmFtZSBvZiB0aGUgZWxlbWVudCBjYW4gYmUgY29uc3VtZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge0Jvb2xlYW59CiAgICAgKi8KCiAgICB0aGlzLl9jYW5Db25zdW1lTmFtZSA9IG51bGw7CiAgICAvKioKICAgICAqIENvbnRhaW5zIG1hcHMgb2YgZWxlbWVudCdzIGNvbnN1bWFibGVzOiBhdHRyaWJ1dGVzLCBjbGFzc2VzIGFuZCBzdHlsZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge09iamVjdH0KICAgICAqLwoKICAgIHRoaXMuX2NvbnN1bWFibGVzID0gewogICAgICBhdHRyaWJ1dGVzOiBuZXcgTWFwKCksCiAgICAgIHN0eWxlczogbmV3IE1hcCgpLAogICAgICBjbGFzc2VzOiBuZXcgTWFwKCkKICAgIH07CiAgfQogIC8qKgogICAqIEFkZHMgY29uc3VtYWJsZSBwYXJ0cyBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fS4KICAgKiBFbGVtZW50J3MgbmFtZSBpdHNlbGYgY2FuIGJlIG1hcmtlZCB0byBiZSBjb25zdW1lZCAod2hlbiBlbGVtZW50J3MgbmFtZSBpcyBjb25zdW1lZCBpdHMgYXR0cmlidXRlcywgY2xhc3NlcyBhbmQKICAgKiBzdHlsZXMgc3RpbGwgY291bGQgYmUgY29uc3VtZWQpOgogICAqCiAgICoJCWNvbnN1bWFibGVzLmFkZCggeyBuYW1lOiB0cnVlIH0gKTsKICAgKgogICAqIEF0dHJpYnV0ZXMgY2xhc3NlcyBhbmQgc3R5bGVzOgogICAqCiAgICoJCWNvbnN1bWFibGVzLmFkZCggeyBhdHRyaWJ1dGVzOiAndGl0bGUnLCBjbGFzc2VzOiAnZm9vJywgc3R5bGVzOiAnY29sb3InIH0gKTsKICAgKgkJY29uc3VtYWJsZXMuYWRkKCB7IGF0dHJpYnV0ZXM6IFsgJ3RpdGxlJywgJ25hbWUnIF0sIGNsYXNzZXM6IFsgJ2ZvbycsICdiYXInIF0gKTsKICAgKgogICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlld2NvbnN1bWFibGUtaW52YWxpZC1hdHRyaWJ1dGVgIHdoZW4gYGNsYXNzYCBvciBgc3R5bGVgCiAgICogYXR0cmlidXRlIGlzIHByb3ZpZGVkIC0gaXQgc2hvdWxkIGJlIGhhbmRsZWQgc2VwYXJhdGVseSBieSBwcm92aWRpbmcgYHN0eWxlYCBhbmQgYGNsYXNzYCBpbiBjb25zdW1hYmxlcyBvYmplY3QuCiAgICoKICAgKiBAcGFyYW0ge09iamVjdH0gY29uc3VtYWJsZXMgT2JqZWN0IGRlc2NyaWJpbmcgd2hpY2ggcGFydHMgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIGNvbnN1bWVkLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uc3VtYWJsZXMubmFtZSBJZiBzZXQgdG8gYHRydWVgIGVsZW1lbnQncyBuYW1lIHdpbGwgYmUgYWRkZWQgYXMgY29uc3VtYWJsZS4KICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuYXR0cmlidXRlcyBBdHRyaWJ1dGUgbmFtZSBvciBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWRkIGFzIGNvbnN1bWFibGUuCiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmNsYXNzZXMgQ2xhc3MgbmFtZSBvciBhcnJheSBvZiBjbGFzcyBuYW1lcyB0byBhZGQgYXMgY29uc3VtYWJsZS4KICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuc3R5bGVzIFN0eWxlIG5hbWUgb3IgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgdG8gYWRkIGFzIGNvbnN1bWFibGUuCiAgICovCgoKICBfY3JlYXRlQ2xhc3MoVmlld0VsZW1lbnRDb25zdW1hYmxlcywgW3sKICAgIGtleTogImFkZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGNvbnN1bWFibGVzKSB7CiAgICAgIGlmIChjb25zdW1hYmxlcy5uYW1lKSB7CiAgICAgICAgdGhpcy5fY2FuQ29uc3VtZU5hbWUgPSB0cnVlOwogICAgICB9CgogICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuX2NvbnN1bWFibGVzKSB7CiAgICAgICAgaWYgKHR5cGUgaW4gY29uc3VtYWJsZXMpIHsKICAgICAgICAgIHRoaXMuX2FkZCh0eXBlLCBjb25zdW1hYmxlc1t0eXBlXSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFRlc3RzIGlmIHBhcnRzIG9mIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZSB2aWV3IG5vZGV9IGNhbiBiZSBjb25zdW1lZC4KICAgICAqCiAgICAgKiBFbGVtZW50J3MgbmFtZSBjYW4gYmUgdGVzdGVkOgogICAgICoKICAgICAqCQljb25zdW1hYmxlcy50ZXN0KCB7IG5hbWU6IHRydWUgfSApOwogICAgICoKICAgICAqIEF0dHJpYnV0ZXMgY2xhc3NlcyBhbmQgc3R5bGVzOgogICAgICoKICAgICAqCQljb25zdW1hYmxlcy50ZXN0KCB7IGF0dHJpYnV0ZXM6ICd0aXRsZScsIGNsYXNzZXM6ICdmb28nLCBzdHlsZXM6ICdjb2xvcicgfSApOwogICAgICoJCWNvbnN1bWFibGVzLnRlc3QoIHsgYXR0cmlidXRlczogWyAndGl0bGUnLCAnbmFtZScgXSwgY2xhc3NlczogWyAnZm9vJywgJ2JhcicgXSApOwogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdW1hYmxlcyBPYmplY3QgZGVzY3JpYmluZyB3aGljaCBwYXJ0cyBvZiB0aGUgZWxlbWVudCBzaG91bGQgYmUgdGVzdGVkLgogICAgICogQHBhcmFtIHtCb29sZWFufSBjb25zdW1hYmxlcy5uYW1lIElmIHNldCB0byBgdHJ1ZWAgZWxlbWVudCdzIG5hbWUgd2lsbCBiZSB0ZXN0ZWQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuYXR0cmlidXRlcyBBdHRyaWJ1dGUgbmFtZSBvciBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gdGVzdC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gdGVzdC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5zdHlsZXMgU3R5bGUgbmFtZSBvciBhcnJheSBvZiBzdHlsZSBuYW1lcyB0byB0ZXN0LgogICAgICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gYHRydWVgIHdoZW4gYWxsIHRlc3RlZCBpdGVtcyBjYW4gYmUgY29uc3VtZWQsIGBudWxsYCB3aGVuIGV2ZW4gb25lIG9mIHRoZSBpdGVtcwogICAgICogd2FzIG5ldmVyIG1hcmtlZCBmb3IgY29uc3VtcHRpb24gYW5kIGBmYWxzZWAgd2hlbiBldmVuIG9uZSBvZiB0aGUgaXRlbXMgd2FzIGFscmVhZHkgY29uc3VtZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidGVzdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdChjb25zdW1hYmxlcykgewogICAgICAvLyBDaGVjayBpZiBuYW1lIGNhbiBiZSBjb25zdW1lZC4KICAgICAgaWYgKGNvbnN1bWFibGVzLm5hbWUgJiYgIXRoaXMuX2NhbkNvbnN1bWVOYW1lKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbkNvbnN1bWVOYW1lOwogICAgICB9CgogICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuX2NvbnN1bWFibGVzKSB7CiAgICAgICAgaWYgKHR5cGUgaW4gY29uc3VtYWJsZXMpIHsKICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3Rlc3QodHlwZSwgY29uc3VtYWJsZXNbdHlwZV0pOwoKICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkgewogICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIFJldHVybiB0cnVlIG9ubHkgaWYgYWxsIGNhbiBiZSBjb25zdW1lZC4KCgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQ29uc3VtZXMgcGFydHMgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fS4gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVjayBpZiBjb25zdW1hYmxlIGl0ZW0KICAgICAqIGlzIGFscmVhZHkgY29uc3VtZWQgLSBpdCBjb25zdW1lcyBhbGwgY29uc3VtYWJsZSBpdGVtcyBwcm92aWRlZC4KICAgICAqIEVsZW1lbnQncyBuYW1lIGNhbiBiZSBjb25zdW1lZDoKICAgICAqCiAgICAgKgkJY29uc3VtYWJsZXMuY29uc3VtZSggeyBuYW1lOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBBdHRyaWJ1dGVzIGNsYXNzZXMgYW5kIHN0eWxlczoKICAgICAqCiAgICAgKgkJY29uc3VtYWJsZXMuY29uc3VtZSggeyBhdHRyaWJ1dGVzOiAndGl0bGUnLCBjbGFzc2VzOiAnZm9vJywgc3R5bGVzOiAnY29sb3InIH0gKTsKICAgICAqCQljb25zdW1hYmxlcy5jb25zdW1lKCB7IGF0dHJpYnV0ZXM6IFsgJ3RpdGxlJywgJ25hbWUnIF0sIGNsYXNzZXM6IFsgJ2ZvbycsICdiYXInIF0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uc3VtYWJsZXMgT2JqZWN0IGRlc2NyaWJpbmcgd2hpY2ggcGFydHMgb2YgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGNvbnN1bWVkLgogICAgICogQHBhcmFtIHtCb29sZWFufSBjb25zdW1hYmxlcy5uYW1lIElmIHNldCB0byBgdHJ1ZWAgZWxlbWVudCdzIG5hbWUgd2lsbCBiZSBjb25zdW1lZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5hdHRyaWJ1dGVzIEF0dHJpYnV0ZSBuYW1lIG9yIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBjb25zdW1lLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmNsYXNzZXMgQ2xhc3MgbmFtZSBvciBhcnJheSBvZiBjbGFzcyBuYW1lcyB0byBjb25zdW1lLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLnN0eWxlcyBTdHlsZSBuYW1lIG9yIGFycmF5IG9mIHN0eWxlIG5hbWVzIHRvIGNvbnN1bWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29uc3VtZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShjb25zdW1hYmxlcykgewogICAgICBpZiAoY29uc3VtYWJsZXMubmFtZSkgewogICAgICAgIHRoaXMuX2NhbkNvbnN1bWVOYW1lID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5fY29uc3VtYWJsZXMpIHsKICAgICAgICBpZiAodHlwZSBpbiBjb25zdW1hYmxlcykgewogICAgICAgICAgdGhpcy5fY29uc3VtZSh0eXBlLCBjb25zdW1hYmxlc1t0eXBlXSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJldmVydCBhbHJlYWR5IGNvbnN1bWVkIHBhcnRzIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgRWxlbWVudH0sIHNvIHRoZXkgY2FuIGJlIGNvbnN1bWVkIG9uY2UgYWdhaW4uCiAgICAgKiBFbGVtZW50J3MgbmFtZSBjYW4gYmUgcmV2ZXJ0ZWQ6CiAgICAgKgogICAgICoJCWNvbnN1bWFibGVzLnJldmVydCggeyBuYW1lOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBBdHRyaWJ1dGVzIGNsYXNzZXMgYW5kIHN0eWxlczoKICAgICAqCiAgICAgKgkJY29uc3VtYWJsZXMucmV2ZXJ0KCB7IGF0dHJpYnV0ZXM6ICd0aXRsZScsIGNsYXNzZXM6ICdmb28nLCBzdHlsZXM6ICdjb2xvcicgfSApOwogICAgICoJCWNvbnN1bWFibGVzLnJldmVydCggeyBhdHRyaWJ1dGVzOiBbICd0aXRsZScsICduYW1lJyBdLCBjbGFzc2VzOiBbICdmb28nLCAnYmFyJyBdICk7CiAgICAgKgogICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnN1bWFibGVzIE9iamVjdCBkZXNjcmliaW5nIHdoaWNoIHBhcnRzIG9mIHRoZSBlbGVtZW50IHNob3VsZCBiZSByZXZlcnRlZC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uc3VtYWJsZXMubmFtZSBJZiBzZXQgdG8gYHRydWVgIGVsZW1lbnQncyBuYW1lIHdpbGwgYmUgcmV2ZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuYXR0cmlidXRlcyBBdHRyaWJ1dGUgbmFtZSBvciBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gcmV2ZXJ0LgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmNsYXNzZXMgQ2xhc3MgbmFtZSBvciBhcnJheSBvZiBjbGFzcyBuYW1lcyB0byByZXZlcnQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuc3R5bGVzIFN0eWxlIG5hbWUgb3IgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgdG8gcmV2ZXJ0LgogICAgICovCgogIH0sIHsKICAgIGtleTogInJldmVydCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJ0KGNvbnN1bWFibGVzKSB7CiAgICAgIGlmIChjb25zdW1hYmxlcy5uYW1lKSB7CiAgICAgICAgdGhpcy5fY2FuQ29uc3VtZU5hbWUgPSB0cnVlOwogICAgICB9CgogICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuX2NvbnN1bWFibGVzKSB7CiAgICAgICAgaWYgKHR5cGUgaW4gY29uc3VtYWJsZXMpIHsKICAgICAgICAgIHRoaXMuX3JldmVydCh0eXBlLCBjb25zdW1hYmxlc1t0eXBlXSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCBhZGRzIGNvbnN1bWFibGVzIG9mIGEgZ2l2ZW4gdHlwZTogYXR0cmlidXRlLCBjbGFzcyBvciBzdHlsZS4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXdjb25zdW1hYmxlLWludmFsaWQtYXR0cmlidXRlYCB3aGVuIGBjbGFzc2Agb3IgYHN0eWxlYAogICAgICogdHlwZSBpcyBwcm92aWRlZCAtIGl0IHNob3VsZCBiZSBoYW5kbGVkIHNlcGFyYXRlbHkgYnkgcHJvdmlkaW5nIGFjdHVhbCBzdHlsZS9jbGFzcyB0eXBlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHRoZSBjb25zdW1hYmxlIGl0ZW06IGBhdHRyaWJ1dGVzYCwgYGNsYXNzZXNgIG9yIGBzdHlsZXNgLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGl0ZW0gQ29uc3VtYWJsZSBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9hZGQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGQodHlwZSwgaXRlbSkgewogICAgICB2YXIgaXRlbXMgPSBpc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXTsKICAgICAgdmFyIGNvbnN1bWFibGVzID0gdGhpcy5fY29uc3VtYWJsZXNbdHlwZV07CgogICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGl0ZW1zKSwKICAgICAgICAgIF9zdGVwNTsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBuYW1lID0gX3N0ZXA1LnZhbHVlOwoKICAgICAgICAgIGlmICh0eXBlID09PSAnYXR0cmlidXRlcycgJiYgKG5hbWUgPT09ICdjbGFzcycgfHwgbmFtZSA9PT0gJ3N0eWxlJykpIHsKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIENsYXNzIGFuZCBzdHlsZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBoYW5kbGVkIHNlcGFyYXRlbHkgaW4KICAgICAgICAgICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZSNhZGQgYFZpZXdDb25zdW1hYmxlI2FkZCgpYH0uCiAgICAgICAgICAgICAqCiAgICAgICAgICAgICAqIFdoYXQgeW91IGhhdmUgZG9uZSBpcyB0cnlpbmcgdG8gdXNlOgogICAgICAgICAgICAgKgogICAgICAgICAgICAgKgkJY29uc3VtYWJsZXMuYWRkKCB7IGF0dHJpYnV0ZXM6IFsgJ2NsYXNzJywgJ3N0eWxlJyBdIH0gKTsKICAgICAgICAgICAgICoKICAgICAgICAgICAgICogV2hpbGUgZWFjaCBjbGFzcyBhbmQgc3R5bGUgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgc2VwYXJhdGVseToKICAgICAgICAgICAgICoKICAgICAgICAgICAgICoJCWNvbnN1bWFibGVzLmFkZCggeyBjbGFzc2VzOiAnc29tZS1jbGFzcycsIHN0eWxlczogJ2ZvbnQtd2VpZ2h0JyB9ICk7CiAgICAgICAgICAgICAqCiAgICAgICAgICAgICAqIEBlcnJvciB2aWV3Y29uc3VtYWJsZS1pbnZhbGlkLWF0dHJpYnV0ZQogICAgICAgICAgICAgKi8KICAgICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXdjb25zdW1hYmxlLWludmFsaWQtYXR0cmlidXRlJywgdGhpcyk7CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3VtYWJsZXMuc2V0KG5hbWUsIHRydWUpOwoKICAgICAgICAgIGlmICh0eXBlID09PSAnc3R5bGVzJykgewogICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZWxlbWVudC5kb2N1bWVudC5zdHlsZXNQcm9jZXNzb3IuZ2V0UmVsYXRlZFN0eWxlcyhuYW1lKSksCiAgICAgICAgICAgICAgICBfc3RlcDY7CgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgICAgICB2YXIgYWxzb05hbWUgPSBfc3RlcDYudmFsdWU7CiAgICAgICAgICAgICAgICBjb25zdW1hYmxlcy5zZXQoYWxzb05hbWUsIHRydWUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5mKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjUuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjUuZigpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCB0ZXN0cyBjb25zdW1hYmxlcyBvZiBhIGdpdmVuIHR5cGU6IGF0dHJpYnV0ZSwgY2xhc3Mgb3Igc3R5bGUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgdGhlIGNvbnN1bWFibGUgaXRlbTogYGF0dHJpYnV0ZXNgLCBgY2xhc3Nlc2Agb3IgYHN0eWxlc2AuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaXRlbSBDb25zdW1hYmxlIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMuCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxudWxsfSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgaXRlbXMgY2FuIGJlIGNvbnN1bWVkLCBgbnVsbGAgd2hlbiBvbmUgb2YgdGhlIGl0ZW1zIGNhbm5vdCBiZQogICAgICogY29uc3VtZWQgYW5kIGBmYWxzZWAgd2hlbiBvbmUgb2YgdGhlIGl0ZW1zIGlzIGFscmVhZHkgY29uc3VtZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3Rlc3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF90ZXN0KHR5cGUsIGl0ZW0pIHsKICAgICAgdmFyIGl0ZW1zID0gaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV07CiAgICAgIHZhciBjb25zdW1hYmxlcyA9IHRoaXMuX2NvbnN1bWFibGVzW3R5cGVdOwoKICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVtcyksCiAgICAgICAgICBfc3RlcDc7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbmFtZSA9IF9zdGVwNy52YWx1ZTsKCiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIChuYW1lID09PSAnY2xhc3MnIHx8IG5hbWUgPT09ICdzdHlsZScpKSB7CiAgICAgICAgICAgIHZhciBjb25zdW1hYmxlTmFtZSA9IG5hbWUgPT0gJ2NsYXNzJyA/ICdjbGFzc2VzJyA6ICdzdHlsZXMnOyAvLyBDaGVjayBhbGwgY2xhc3Nlcy9zdHlsZXMgaWYgY2xhc3Mvc3R5bGUgYXR0cmlidXRlIGlzIHRlc3RlZC4KCiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3Rlc3QoY29uc3VtYWJsZU5hbWUsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9jb25zdW1hYmxlc1tjb25zdW1hYmxlTmFtZV0ua2V5cygpKSk7CgogICAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHsKICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBfdmFsdWUgPSBjb25zdW1hYmxlcy5nZXQobmFtZSk7IC8vIFJldHVybiBudWxsIGlmIGF0dHJpYnV0ZSBpcyBub3QgZm91bmQuCgoKICAgICAgICAgICAgaWYgKF92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmICghX3ZhbHVlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I3LmYoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCBjb25zdW1lcyBpdGVtcyBvZiBhIGdpdmVuIHR5cGU6IGF0dHJpYnV0ZSwgY2xhc3Mgb3Igc3R5bGUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgdGhlIGNvbnN1bWFibGUgaXRlbTogYGF0dHJpYnV0ZXNgLCBgY2xhc3Nlc2Agb3IgYHN0eWxlc2AuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaXRlbSBDb25zdW1hYmxlIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NvbnN1bWUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25zdW1lKHR5cGUsIGl0ZW0pIHsKICAgICAgdmFyIGl0ZW1zID0gaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV07CiAgICAgIHZhciBjb25zdW1hYmxlcyA9IHRoaXMuX2NvbnN1bWFibGVzW3R5cGVdOwoKICAgICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVtcyksCiAgICAgICAgICBfc3RlcDg7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbmFtZSA9IF9zdGVwOC52YWx1ZTsKCiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIChuYW1lID09PSAnY2xhc3MnIHx8IG5hbWUgPT09ICdzdHlsZScpKSB7CiAgICAgICAgICAgIHZhciBjb25zdW1hYmxlTmFtZSA9IG5hbWUgPT0gJ2NsYXNzJyA/ICdjbGFzc2VzJyA6ICdzdHlsZXMnOyAvLyBJZiBjbGFzcyBvciBzdHlsZSBpcyBwcm92aWRlZCBmb3IgY29uc3VtcHRpb24gLSBjb25zdW1lIHRoZW0gYWxsLgoKICAgICAgICAgICAgdGhpcy5fY29uc3VtZShjb25zdW1hYmxlTmFtZSwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX2NvbnN1bWFibGVzW2NvbnN1bWFibGVOYW1lXS5rZXlzKCkpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN1bWFibGVzLnNldChuYW1lLCBmYWxzZSk7CgogICAgICAgICAgICBpZiAodHlwZSA9PSAnc3R5bGVzJykgewogICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5lbGVtZW50LmRvY3VtZW50LnN0eWxlc1Byb2Nlc3Nvci5nZXRSZWxhdGVkU3R5bGVzKG5hbWUpKSwKICAgICAgICAgICAgICAgICAgX3N0ZXA5OwoKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I5LnMoKTsgIShfc3RlcDkgPSBfaXRlcmF0b3I5Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICAgICAgdmFyIHRvQ29uc3VtZSA9IF9zdGVwOS52YWx1ZTsKICAgICAgICAgICAgICAgICAgY29uc3VtYWJsZXMuc2V0KHRvQ29uc3VtZSwgZmFsc2UpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5lKGVycik7CiAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgIF9pdGVyYXRvcjkuZigpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yOC5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yOC5mKCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIG1ldGhvZCB0aGF0IHJldmVydHMgaXRlbXMgb2YgYSBnaXZlbiB0eXBlOiBhdHRyaWJ1dGUsIGNsYXNzIG9yIHN0eWxlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHRoZSBjb25zdW1hYmxlIGl0ZW06IGBhdHRyaWJ1dGVzYCwgYGNsYXNzZXNgIG9yICwgYHN0eWxlc2AuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaXRlbSBDb25zdW1hYmxlIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3JldmVydCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldmVydCh0eXBlLCBpdGVtKSB7CiAgICAgIHZhciBpdGVtcyA9IGlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dOwogICAgICB2YXIgY29uc3VtYWJsZXMgPSB0aGlzLl9jb25zdW1hYmxlc1t0eXBlXTsKCiAgICAgIHZhciBfaXRlcmF0b3IxMCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGl0ZW1zKSwKICAgICAgICAgIF9zdGVwMTA7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMTAucygpOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbmFtZSA9IF9zdGVwMTAudmFsdWU7CgogICAgICAgICAgaWYgKHR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiAobmFtZSA9PT0gJ2NsYXNzJyB8fCBuYW1lID09PSAnc3R5bGUnKSkgewogICAgICAgICAgICB2YXIgY29uc3VtYWJsZU5hbWUgPSBuYW1lID09ICdjbGFzcycgPyAnY2xhc3NlcycgOiAnc3R5bGVzJzsgLy8gSWYgY2xhc3Mgb3Igc3R5bGUgaXMgcHJvdmlkZWQgZm9yIHJldmVydGluZyAtIHJldmVydCB0aGVtIGFsbC4KCiAgICAgICAgICAgIHRoaXMuX3JldmVydChjb25zdW1hYmxlTmFtZSwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX2NvbnN1bWFibGVzW2NvbnN1bWFibGVOYW1lXS5rZXlzKCkpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnN1bWFibGVzLmdldChuYW1lKTsKCiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHsKICAgICAgICAgICAgICBjb25zdW1hYmxlcy5zZXQobmFtZSwgdHJ1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjEwLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IxMC5mKCk7CiAgICAgIH0KICAgIH0KICB9XSk7CgogIHJldHVybiBWaWV3RWxlbWVudENvbnN1bWFibGVzOwp9KCk7"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js"],"names":["isArray","CKEditorError","ViewConsumable","_consumables","Map","element","consumables","elementConsumables","is","set","has","ViewElementConsumables","get","add","undefined","test","consume","revert","name","attributes","classes","styles","getAttributeKeys","attribute","push","getClassNames","className","getStyleNames","style","from","instance","consumablesFromElement","getChildren","child","createFrom","_canConsumeName","type","_add","value","_test","_consume","_revert","item","items","document","stylesProcessor","getRelatedStyles","alsoName","consumableName","keys","toConsume"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,OAAT,QAAwB,WAAxB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,c;AACpB;AACD;AACA;AACC,4BAAc;AAAA;;AACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,YAAL,GAAoB,IAAIC,GAAJ,EAApB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACC,aAAKC,OAAL,EAAcC,WAAd,EAA4B;AAC3B,UAAIC,kBAAJ,CAD2B,CAG3B;;AACA,UAAKF,OAAO,CAACG,EAAR,CAAY,OAAZ,KAAyBH,OAAO,CAACG,EAAR,CAAY,kBAAZ,CAA9B,EAAiE;AAChE,aAAKL,YAAL,CAAkBM,GAAlB,CAAuBJ,OAAvB,EAAgC,IAAhC;;AAEA;AACA,OAR0B,CAU3B;;;AACA,UAAK,CAAC,KAAKF,YAAL,CAAkBO,GAAlB,CAAuBL,OAAvB,CAAN,EAAyC;AACxCE,QAAAA,kBAAkB,GAAG,IAAII,sBAAJ,CAA4BN,OAA5B,CAArB;;AACA,aAAKF,YAAL,CAAkBM,GAAlB,CAAuBJ,OAAvB,EAAgCE,kBAAhC;AACA,OAHD,MAGO;AACNA,QAAAA,kBAAkB,GAAG,KAAKJ,YAAL,CAAkBS,GAAlB,CAAuBP,OAAvB,CAArB;AACA;;AAEDE,MAAAA,kBAAkB,CAACM,GAAnB,CAAwBP,WAAxB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,cAAMD,OAAN,EAAeC,WAAf,EAA6B;AAC5B,UAAMC,kBAAkB,GAAG,KAAKJ,YAAL,CAAkBS,GAAlB,CAAuBP,OAAvB,CAA3B;;AAEA,UAAKE,kBAAkB,KAAKO,SAA5B,EAAwC;AACvC,eAAO,IAAP;AACA,OAL2B,CAO5B;;;AACA,UAAKT,OAAO,CAACG,EAAR,CAAY,OAAZ,KAAyBH,OAAO,CAACG,EAAR,CAAY,kBAAZ,CAA9B,EAAiE;AAChE,eAAOD,kBAAP;AACA,OAV2B,CAY5B;;;AACA,aAAOA,kBAAkB,CAACQ,IAAnB,CAAyBT,WAAzB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAASD,OAAT,EAAkBC,WAAlB,EAAgC;AAC/B,UAAK,KAAKS,IAAL,CAAWV,OAAX,EAAoBC,WAApB,CAAL,EAAyC;AACxC,YAAKD,OAAO,CAACG,EAAR,CAAY,OAAZ,KAAyBH,OAAO,CAACG,EAAR,CAAY,kBAAZ,CAA9B,EAAiE;AAChE;AACA,eAAKL,YAAL,CAAkBM,GAAlB,CAAuBJ,OAAvB,EAAgC,KAAhC;AACA,SAHD,MAGO;AACN;AACA,eAAKF,YAAL,CAAkBS,GAAlB,CAAuBP,OAAvB,EAAiCW,OAAjC,CAA0CV,WAA1C;AACA;;AAED,eAAO,IAAP;AACA;;AAED,aAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gBAAQD,OAAR,EAAiBC,WAAjB,EAA+B;AAC9B,UAAMC,kBAAkB,GAAG,KAAKJ,YAAL,CAAkBS,GAAlB,CAAuBP,OAAvB,CAA3B;;AAEA,UAAKE,kBAAkB,KAAKO,SAA5B,EAAwC;AACvC,YAAKT,OAAO,CAACG,EAAR,CAAY,OAAZ,KAAyBH,OAAO,CAACG,EAAR,CAAY,kBAAZ,CAA9B,EAAiE;AAChE;AACA,eAAKL,YAAL,CAAkBM,GAAlB,CAAuBJ,OAAvB,EAAgC,IAAhC;AACA,SAHD,MAGO;AACN;AACAE,UAAAA,kBAAkB,CAACU,MAAnB,CAA2BX,WAA3B;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gCAA+BD,OAA/B,EAAyC;AACxC,UAAMC,WAAW,GAAG;AACnBD,QAAAA,OAAO,EAAPA,OADmB;AAEnBa,QAAAA,IAAI,EAAE,IAFa;AAGnBC,QAAAA,UAAU,EAAE,EAHO;AAInBC,QAAAA,OAAO,EAAE,EAJU;AAKnBC,QAAAA,MAAM,EAAE;AALW,OAApB;AAQA,UAAMF,UAAU,GAAGd,OAAO,CAACiB,gBAAR,EAAnB;;AATwC,iDAWfH,UAXe;AAAA;;AAAA;AAWxC,4DAAsC;AAAA,cAA1BI,SAA0B;;AACrC;AACA,cAAKA,SAAS,IAAI,OAAb,IAAwBA,SAAS,IAAI,OAA1C,EAAoD;AACnD;AACA;;AAEDjB,UAAAA,WAAW,CAACa,UAAZ,CAAuBK,IAAvB,CAA6BD,SAA7B;AACA;AAlBuC;AAAA;AAAA;AAAA;AAAA;;AAoBxC,UAAMH,OAAO,GAAGf,OAAO,CAACoB,aAAR,EAAhB;;AApBwC,kDAsBfL,OAtBe;AAAA;;AAAA;AAsBxC,+DAAmC;AAAA,cAAvBM,SAAuB;AAClCpB,UAAAA,WAAW,CAACc,OAAZ,CAAoBI,IAApB,CAA0BE,SAA1B;AACA;AAxBuC;AAAA;AAAA;AAAA;AAAA;;AA0BxC,UAAML,MAAM,GAAGhB,OAAO,CAACsB,aAAR,EAAf;;AA1BwC,kDA4BnBN,MA5BmB;AAAA;;AAAA;AA4BxC,+DAA8B;AAAA,cAAlBO,KAAkB;AAC7BtB,UAAAA,WAAW,CAACe,MAAZ,CAAmBG,IAAnB,CAAyBI,KAAzB;AACA;AA9BuC;AAAA;AAAA;AAAA;AAAA;;AAgCxC,aAAOtB,WAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,oBAAmBuB,IAAnB,EAAyBC,QAAzB,EAAoC;AACnC,UAAK,CAACA,QAAN,EAAiB;AAChBA,QAAAA,QAAQ,GAAG,IAAI5B,cAAJ,CAAoB2B,IAApB,CAAX;AACA;;AAED,UAAKA,IAAI,CAACrB,EAAL,CAAS,OAAT,CAAL,EAA0B;AACzBsB,QAAAA,QAAQ,CAACjB,GAAT,CAAcgB,IAAd;AAEA,eAAOC,QAAP;AACA,OATkC,CAWnC;;;AACA,UAAKD,IAAI,CAACrB,EAAL,CAAS,SAAT,CAAL,EAA4B;AAC3BsB,QAAAA,QAAQ,CAACjB,GAAT,CAAcgB,IAAd,EAAoB3B,cAAc,CAAC6B,sBAAf,CAAuCF,IAAvC,CAApB;AACA;;AAED,UAAKA,IAAI,CAACrB,EAAL,CAAS,kBAAT,CAAL,EAAqC;AACpCsB,QAAAA,QAAQ,CAACjB,GAAT,CAAcgB,IAAd;AACA;;AAlBkC,kDAoBdA,IAAI,CAACG,WAAL,EApBc;AAAA;;AAAA;AAoBnC,+DAA0C;AAAA,cAA9BC,KAA8B;AACzCH,UAAAA,QAAQ,GAAG5B,cAAc,CAACgC,UAAf,CAA2BD,KAA3B,EAAkCH,QAAlC,CAAX;AACA;AAtBkC;AAAA;AAAA;AAAA;AAAA;;AAwBnC,aAAOA,QAAP;AACA;;;;;AAGF;AACA;AACA;AACA;AACA;AACA;;;SA1RqB5B,c;;IA2RfS,sB;AACL;AACD;AACA;AACA;AACA;AACA;AACC,kCAAakB,IAAb,EAAoB;AAAA;;AACnB;AACF;AACA;AACA;AACE,SAAKxB,OAAL,GAAewB,IAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKM,eAAL,GAAuB,IAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKhC,YAAL,GAAoB;AACnBgB,MAAAA,UAAU,EAAE,IAAIf,GAAJ,EADO;AAEnBiB,MAAAA,MAAM,EAAE,IAAIjB,GAAJ,EAFW;AAGnBgB,MAAAA,OAAO,EAAE,IAAIhB,GAAJ;AAHU,KAApB;AAKA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACC,aAAKE,WAAL,EAAmB;AAClB,UAAKA,WAAW,CAACY,IAAjB,EAAwB;AACvB,aAAKiB,eAAL,GAAuB,IAAvB;AACA;;AAED,WAAM,IAAMC,IAAZ,IAAoB,KAAKjC,YAAzB,EAAwC;AACvC,YAAKiC,IAAI,IAAI9B,WAAb,EAA2B;AAC1B,eAAK+B,IAAL,CAAWD,IAAX,EAAiB9B,WAAW,CAAE8B,IAAF,CAA5B;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,cAAM9B,WAAN,EAAoB;AACnB;AACA,UAAKA,WAAW,CAACY,IAAZ,IAAoB,CAAC,KAAKiB,eAA/B,EAAiD;AAChD,eAAO,KAAKA,eAAZ;AACA;;AAED,WAAM,IAAMC,IAAZ,IAAoB,KAAKjC,YAAzB,EAAwC;AACvC,YAAKiC,IAAI,IAAI9B,WAAb,EAA2B;AAC1B,cAAMgC,KAAK,GAAG,KAAKC,KAAL,CAAYH,IAAZ,EAAkB9B,WAAW,CAAE8B,IAAF,CAA7B,CAAd;;AAEA,cAAKE,KAAK,KAAK,IAAf,EAAsB;AACrB,mBAAOA,KAAP;AACA;AACD;AACD,OAdkB,CAgBnB;;;AACA,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAAShC,WAAT,EAAuB;AACtB,UAAKA,WAAW,CAACY,IAAjB,EAAwB;AACvB,aAAKiB,eAAL,GAAuB,KAAvB;AACA;;AAED,WAAM,IAAMC,IAAZ,IAAoB,KAAKjC,YAAzB,EAAwC;AACvC,YAAKiC,IAAI,IAAI9B,WAAb,EAA2B;AAC1B,eAAKkC,QAAL,CAAeJ,IAAf,EAAqB9B,WAAW,CAAE8B,IAAF,CAAhC;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gBAAQ9B,WAAR,EAAsB;AACrB,UAAKA,WAAW,CAACY,IAAjB,EAAwB;AACvB,aAAKiB,eAAL,GAAuB,IAAvB;AACA;;AAED,WAAM,IAAMC,IAAZ,IAAoB,KAAKjC,YAAzB,EAAwC;AACvC,YAAKiC,IAAI,IAAI9B,WAAb,EAA2B;AAC1B,eAAKmC,OAAL,CAAcL,IAAd,EAAoB9B,WAAW,CAAE8B,IAAF,CAA/B;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,cAAMA,IAAN,EAAYM,IAAZ,EAAmB;AAClB,UAAMC,KAAK,GAAG3C,OAAO,CAAE0C,IAAF,CAAP,GAAkBA,IAAlB,GAAyB,CAAEA,IAAF,CAAvC;AACA,UAAMpC,WAAW,GAAG,KAAKH,YAAL,CAAmBiC,IAAnB,CAApB;;AAFkB,kDAIEO,KAJF;AAAA;;AAAA;AAIlB,+DAA4B;AAAA,cAAhBzB,IAAgB;;AAC3B,cAAKkB,IAAI,KAAK,YAAT,KAA2BlB,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,OAAxD,CAAL,EAAyE;AACxE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,kBAAM,IAAIjB,aAAJ,CAAmB,kCAAnB,EAAuD,IAAvD,CAAN;AACA;;AAEDK,UAAAA,WAAW,CAACG,GAAZ,CAAiBS,IAAjB,EAAuB,IAAvB;;AAEA,cAAKkB,IAAI,KAAK,QAAd,EAAyB;AAAA,wDACA,KAAK/B,OAAL,CAAauC,QAAb,CAAsBC,eAAtB,CAAsCC,gBAAtC,CAAwD5B,IAAxD,CADA;AAAA;;AAAA;AACxB,qEAAyF;AAAA,oBAA7E6B,QAA6E;AACxFzC,gBAAAA,WAAW,CAACG,GAAZ,CAAiBsC,QAAjB,EAA2B,IAA3B;AACA;AAHuB;AAAA;AAAA;AAAA;AAAA;AAIxB;AACD;AA9BiB;AAAA;AAAA;AAAA;AAAA;AA+BlB;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,eAAOX,IAAP,EAAaM,IAAb,EAAoB;AACnB,UAAMC,KAAK,GAAG3C,OAAO,CAAE0C,IAAF,CAAP,GAAkBA,IAAlB,GAAyB,CAAEA,IAAF,CAAvC;AACA,UAAMpC,WAAW,GAAG,KAAKH,YAAL,CAAmBiC,IAAnB,CAApB;;AAFmB,kDAICO,KAJD;AAAA;;AAAA;AAInB,+DAA4B;AAAA,cAAhBzB,IAAgB;;AAC3B,cAAKkB,IAAI,KAAK,YAAT,KAA2BlB,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,OAAxD,CAAL,EAAyE;AACxE,gBAAM8B,cAAc,GAAG9B,IAAI,IAAI,OAAR,GAAkB,SAAlB,GAA8B,QAArD,CADwE,CAGxE;;AACA,gBAAMoB,KAAK,GAAG,KAAKC,KAAL,CAAYS,cAAZ,qBAAiC,KAAK7C,YAAL,CAAmB6C,cAAnB,EAAoCC,IAApC,EAAjC,EAAd;;AAEA,gBAAKX,KAAK,KAAK,IAAf,EAAsB;AACrB,qBAAOA,KAAP;AACA;AACD,WATD,MASO;AACN,gBAAMA,MAAK,GAAGhC,WAAW,CAACM,GAAZ,CAAiBM,IAAjB,CAAd,CADM,CAEN;;;AACA,gBAAKoB,MAAK,KAAKxB,SAAf,EAA2B;AAC1B,qBAAO,IAAP;AACA;;AAED,gBAAK,CAACwB,MAAN,EAAc;AACb,qBAAO,KAAP;AACA;AACD;AACD;AAzBkB;AAAA;AAAA;AAAA;AAAA;;AA2BnB,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,kBAAUF,IAAV,EAAgBM,IAAhB,EAAuB;AACtB,UAAMC,KAAK,GAAG3C,OAAO,CAAE0C,IAAF,CAAP,GAAkBA,IAAlB,GAAyB,CAAEA,IAAF,CAAvC;AACA,UAAMpC,WAAW,GAAG,KAAKH,YAAL,CAAmBiC,IAAnB,CAApB;;AAFsB,kDAIFO,KAJE;AAAA;;AAAA;AAItB,+DAA4B;AAAA,cAAhBzB,IAAgB;;AAC3B,cAAKkB,IAAI,KAAK,YAAT,KAA2BlB,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,OAAxD,CAAL,EAAyE;AACxE,gBAAM8B,cAAc,GAAG9B,IAAI,IAAI,OAAR,GAAkB,SAAlB,GAA8B,QAArD,CADwE,CAGxE;;AACA,iBAAKsB,QAAL,CAAeQ,cAAf,qBAAoC,KAAK7C,YAAL,CAAmB6C,cAAnB,EAAoCC,IAApC,EAApC;AACA,WALD,MAKO;AACN3C,YAAAA,WAAW,CAACG,GAAZ,CAAiBS,IAAjB,EAAuB,KAAvB;;AAEA,gBAAKkB,IAAI,IAAI,QAAb,EAAwB;AAAA,0DACE,KAAK/B,OAAL,CAAauC,QAAb,CAAsBC,eAAtB,CAAsCC,gBAAtC,CAAwD5B,IAAxD,CADF;AAAA;;AAAA;AACvB,uEAA0F;AAAA,sBAA9EgC,SAA8E;AACzF5C,kBAAAA,WAAW,CAACG,GAAZ,CAAiByC,SAAjB,EAA4B,KAA5B;AACA;AAHsB;AAAA;AAAA;AAAA;AAAA;AAIvB;AACD;AACD;AAnBqB;AAAA;AAAA;AAAA;AAAA;AAoBtB;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAASd,IAAT,EAAeM,IAAf,EAAsB;AACrB,UAAMC,KAAK,GAAG3C,OAAO,CAAE0C,IAAF,CAAP,GAAkBA,IAAlB,GAAyB,CAAEA,IAAF,CAAvC;AACA,UAAMpC,WAAW,GAAG,KAAKH,YAAL,CAAmBiC,IAAnB,CAApB;;AAFqB,mDAIDO,KAJC;AAAA;;AAAA;AAIrB,kEAA4B;AAAA,cAAhBzB,IAAgB;;AAC3B,cAAKkB,IAAI,KAAK,YAAT,KAA2BlB,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,OAAxD,CAAL,EAAyE;AACxE,gBAAM8B,cAAc,GAAG9B,IAAI,IAAI,OAAR,GAAkB,SAAlB,GAA8B,QAArD,CADwE,CAGxE;;AACA,iBAAKuB,OAAL,CAAcO,cAAd,qBAAmC,KAAK7C,YAAL,CAAmB6C,cAAnB,EAAoCC,IAApC,EAAnC;AACA,WALD,MAKO;AACN,gBAAMX,KAAK,GAAGhC,WAAW,CAACM,GAAZ,CAAiBM,IAAjB,CAAd;;AAEA,gBAAKoB,KAAK,KAAK,KAAf,EAAuB;AACtBhC,cAAAA,WAAW,CAACG,GAAZ,CAAiBS,IAAjB,EAAuB,IAAvB;AACA;AACD;AACD;AAjBoB;AAAA;AAAA;AAAA;AAAA;AAkBrB","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/viewconsumable\n */\n\nimport { isArray } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Class used for handling consumption of view {@link module:engine/view/element~Element elements},\n * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.\n * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name\n * does not consume its attributes, classes and styles.\n * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.\n * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.\n * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.\n * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.\n *\n *\t\tviewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.\n *\t\tviewConsumable.add( textNode ); // Adds text node for consumption.\n *\t\tviewConsumable.add( docFragment ); // Adds document fragment for consumption.\n *\t\tviewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.\n *\t\tviewConsumable.test( textNode ); // Tests if text node can be consumed.\n *\t\tviewConsumable.test( docFragment ); // Tests if document fragment can be consumed.\n *\t\tviewConsumable.consume( element, { name: true }  ); // Consume element's name.\n *\t\tviewConsumable.consume( textNode ); // Consume text node.\n *\t\tviewConsumable.consume( docFragment ); // Consume document fragment.\n *\t\tviewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.\n *\t\tviewConsumable.revert( textNode ); // Revert already consumed text node.\n *\t\tviewConsumable.revert( docFragment ); // Revert already consumed document fragment.\n */\nexport default class ViewConsumable {\n\t/**\n\t * Creates new ViewConsumable.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,\n\t\t * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.\n\t\t * For {@link module:engine/view/text~Text text nodes} and\n\t\t * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}\n\t\t*/\n\t\tthis._consumables = new Map();\n\t}\n\n\t/**\n\t * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.\n\t *\n\t *\t\tviewConsumable.add( p, { name: true } ); // Adds element's name to consume.\n\t *\t\tviewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.\n\t *\t\tviewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.\n\t *\t\tviewConsumable.add( p, { styles: 'color' } ); // Adds element's style\n\t *\t\tviewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.\n\t *\t\tviewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.\n\t *\t\tviewConsumable.add( textNode ); // Adds text node to consume.\n\t *\t\tviewConsumable.add( docFragment ); // Adds document fragment to consume.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * attribute is provided - it should be handled separately by providing actual style/class.\n\t *\n\t *\t\tviewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.\n\t *\t\tviewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t */\n\tadd( element, consumables ) {\n\t\tlet elementConsumables;\n\n\t\t// For text nodes and document fragments just mark them as consumable.\n\t\tif ( element.is( '$text' ) || element.is( 'documentFragment' ) ) {\n\t\t\tthis._consumables.set( element, true );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// For elements create new ViewElementConsumables or update already existing one.\n\t\tif ( !this._consumables.has( element ) ) {\n\t\t\telementConsumables = new ViewElementConsumables( element );\n\t\t\tthis._consumables.set( element, elementConsumables );\n\t\t} else {\n\t\t\telementConsumables = this._consumables.get( element );\n\t\t}\n\n\t\telementConsumables.add( consumables );\n\t}\n\n\t/**\n\t * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.\n\t * It returns `true` when all items included in method's call can be consumed. Returns `false` when\n\t * first already consumed item is found and `null` when first non-consumable item is found.\n\t *\n\t *\t\tviewConsumable.test( p, { name: true } ); // Tests element's name.\n\t *\t\tviewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.\n\t *\t\tviewConsumable.test( p, { classes: 'foobar' } ); // Tests class.\n\t *\t\tviewConsumable.test( p, { styles: 'color' } ); // Tests style.\n\t *\t\tviewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.\n\t *\t\tviewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.\n\t *\t\tviewConsumable.test( textNode ); // Tests text node.\n\t *\t\tviewConsumable.test( docFragment ); // Tests document fragment.\n\t *\n\t * Testing classes and styles as attribute will test if all added classes/styles can be consumed.\n\t *\n\t *\t\tviewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.\n\t *\t\tviewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`\n\t * when first already consumed item is found and `null` when first non-consumable item is found.\n\t */\n\ttest( element, consumables ) {\n\t\tconst elementConsumables = this._consumables.get( element );\n\n\t\tif ( elementConsumables === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// For text nodes and document fragments return stored boolean value.\n\t\tif ( element.is( '$text' ) || element.is( 'documentFragment' ) ) {\n\t\t\treturn elementConsumables;\n\t\t}\n\n\t\t// For elements test consumables object.\n\t\treturn elementConsumables.test( consumables );\n\t}\n\n\t/**\n\t * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.\n\t *\n\t *\t\tviewConsumable.consume( p, { name: true } ); // Consumes element's name.\n\t *\t\tviewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.\n\t *\t\tviewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.\n\t *\t\tviewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.\n\t *\t\tviewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.\n\t *\t\tviewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.\n\t *\t\tviewConsumable.consume( textNode ); // Consumes text node.\n\t *\t\tviewConsumable.consume( docFragment ); // Consumes document fragment.\n\t *\n\t * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.\n\t *\n\t *\t\tviewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.\n\t *\t\tviewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,\n\t * otherwise returns `false`.\n\t */\n\tconsume( element, consumables ) {\n\t\tif ( this.test( element, consumables ) ) {\n\t\t\tif ( element.is( '$text' ) || element.is( 'documentFragment' ) ) {\n\t\t\t\t// For text nodes and document fragments set value to false.\n\t\t\t\tthis._consumables.set( element, false );\n\t\t\t} else {\n\t\t\t\t// For elements - consume consumables object.\n\t\t\t\tthis._consumables.get( element ).consume( consumables );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.\n\t * Method does not revert items that were never previously added for consumption, even if they are included in\n\t * method's call.\n\t *\n\t *\t\tviewConsumable.revert( p, { name: true } ); // Reverts element's name.\n\t *\t\tviewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.\n\t *\t\tviewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.\n\t *\t\tviewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.\n\t *\t\tviewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.\n\t *\t\tviewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.\n\t *\t\tviewConsumable.revert( textNode ); // Reverts text node.\n\t *\t\tviewConsumable.revert( docFragment ); // Reverts document fragment.\n\t *\n\t * Reverting classes and styles as attribute will revert all classes/styles that were previously added for\n\t * consumption.\n\t *\n\t *\t\tviewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.\n\t *\t\tviewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t */\n\trevert( element, consumables ) {\n\t\tconst elementConsumables = this._consumables.get( element );\n\n\t\tif ( elementConsumables !== undefined ) {\n\t\t\tif ( element.is( '$text' ) || element.is( 'documentFragment' ) ) {\n\t\t\t\t// For text nodes and document fragments - set consumable to true.\n\t\t\t\tthis._consumables.set( element, true );\n\t\t\t} else {\n\t\t\t\t// For elements - revert items from consumables object.\n\t\t\t\telementConsumables.revert( consumables );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include\n\t * element's name and all its attributes, classes and styles.\n\t *\n\t * @static\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Object} consumables\n\t */\n\tstatic consumablesFromElement( element ) {\n\t\tconst consumables = {\n\t\t\telement,\n\t\t\tname: true,\n\t\t\tattributes: [],\n\t\t\tclasses: [],\n\t\t\tstyles: []\n\t\t};\n\n\t\tconst attributes = element.getAttributeKeys();\n\n\t\tfor ( const attribute of attributes ) {\n\t\t\t// Skip classes and styles - will be added separately.\n\t\t\tif ( attribute == 'style' || attribute == 'class' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconsumables.attributes.push( attribute );\n\t\t}\n\n\t\tconst classes = element.getClassNames();\n\n\t\tfor ( const className of classes ) {\n\t\t\tconsumables.classes.push( className );\n\t\t}\n\n\t\tconst styles = element.getStyleNames();\n\n\t\tfor ( const style of styles ) {\n\t\t\tconsumables.styles.push( style );\n\t\t}\n\n\t\treturn consumables;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from\n\t * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.\n\t *\n\t * @static\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n\t * from which `ViewConsumable` will be created.\n\t * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used\n\t * to add all consumables. It will be returned instead of a new instance.\n\t */\n\tstatic createFrom( from, instance ) {\n\t\tif ( !instance ) {\n\t\t\tinstance = new ViewConsumable( from );\n\t\t}\n\n\t\tif ( from.is( '$text' ) ) {\n\t\t\tinstance.add( from );\n\n\t\t\treturn instance;\n\t\t}\n\n\t\t// Add `from` itself, if it is an element.\n\t\tif ( from.is( 'element' ) ) {\n\t\t\tinstance.add( from, ViewConsumable.consumablesFromElement( from ) );\n\t\t}\n\n\t\tif ( from.is( 'documentFragment' ) ) {\n\t\t\tinstance.add( from );\n\t\t}\n\n\t\tfor ( const child of from.getChildren() ) {\n\t\t\tinstance = ViewConsumable.createFrom( child, instance );\n\t\t}\n\n\t\treturn instance;\n\t}\n}\n\n/**\n * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.\n * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.\n *\n * @private\n */\nclass ViewElementConsumables {\n\t/**\n\t * Creates ViewElementConsumables instance.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n\t * from which `ViewElementConsumables` is being created.\n\t */\n\tconstructor( from ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t\t */\n\t\tthis.element = from;\n\n\t\t/**\n\t\t * Flag indicating if name of the element can be consumed.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._canConsumeName = null;\n\n\t\t/**\n\t\t * Contains maps of element's consumables: attributes, classes and styles.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._consumables = {\n\t\t\tattributes: new Map(),\n\t\t\tstyles: new Map(),\n\t\t\tclasses: new Map()\n\t\t};\n\t}\n\n\t/**\n\t * Adds consumable parts of the {@link module:engine/view/element~Element view element}.\n\t * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and\n\t * styles still could be consumed):\n\t *\n\t *\t\tconsumables.add( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.\n\t *\n\t * @param {Object} consumables Object describing which parts of the element can be consumed.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to add as consumable.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to add as consumable.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to add as consumable.\n\t */\n\tadd( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = true;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._add( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.\n\t *\n\t * Element's name can be tested:\n\t *\n\t *\t\tconsumables.test( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be tested.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be tested.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to test.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to test.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to test.\n\t * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items\n\t * was never marked for consumption and `false` when even one of the items was already consumed.\n\t */\n\ttest( consumables ) {\n\t\t// Check if name can be consumed.\n\t\tif ( consumables.name && !this._canConsumeName ) {\n\t\t\treturn this._canConsumeName;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tconst value = this._test( type, consumables[ type ] );\n\n\t\t\t\tif ( value !== true ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return true only if all can be consumed.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item\n\t * is already consumed - it consumes all consumable items provided.\n\t * Element's name can be consumed:\n\t *\n\t *\t\tconsumables.consume( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be consumed.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be consumed.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to consume.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to consume.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to consume.\n\t */\n\tconsume( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = false;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._consume( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.\n\t * Element's name can be reverted:\n\t *\n\t *\t\tconsumables.revert( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be reverted.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be reverted.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to revert.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to revert.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to revert.\n\t */\n\trevert( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = true;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._revert( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that adds consumables of a given type: attribute, class or style.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * type is provided - it should be handled separately by providing actual style/class type.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_add( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Class and style attributes should be handled separately in\n\t\t\t\t * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.\n\t\t\t\t *\n\t\t\t\t * What you have done is trying to use:\n\t\t\t\t *\n\t\t\t\t *\t\tconsumables.add( { attributes: [ 'class', 'style' ] } );\n\t\t\t\t *\n\t\t\t\t * While each class and style should be registered separately:\n\t\t\t\t *\n\t\t\t\t *\t\tconsumables.add( { classes: 'some-class', styles: 'font-weight' } );\n\t\t\t\t *\n\t\t\t\t * @error viewconsumable-invalid-attribute\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'viewconsumable-invalid-attribute', this );\n\t\t\t}\n\n\t\t\tconsumables.set( name, true );\n\n\t\t\tif ( type === 'styles' ) {\n\t\t\t\tfor ( const alsoName of this.element.document.stylesProcessor.getRelatedStyles( name ) ) {\n\t\t\t\t\tconsumables.set( alsoName, true );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that tests consumables of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be\n\t * consumed and `false` when one of the items is already consumed.\n\t */\n\t_test( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// Check all classes/styles if class/style attribute is tested.\n\t\t\t\tconst value = this._test( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\n\t\t\t\tif ( value !== true ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst value = consumables.get( name );\n\t\t\t\t// Return null if attribute is not found.\n\t\t\t\tif ( value === undefined ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif ( !value ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper method that consumes items of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_consume( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// If class or style is provided for consumption - consume them all.\n\t\t\t\tthis._consume( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\t\t\t} else {\n\t\t\t\tconsumables.set( name, false );\n\n\t\t\t\tif ( type == 'styles' ) {\n\t\t\t\t\tfor ( const toConsume of this.element.document.stylesProcessor.getRelatedStyles( name ) ) {\n\t\t\t\t\t\tconsumables.set( toConsume, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that reverts items of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or , `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_revert( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// If class or style is provided for reverting - revert them all.\n\t\t\t\tthis._revert( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\t\t\t} else {\n\t\t\t\tconst value = consumables.get( name );\n\n\t\t\t\tif ( value === false ) {\n\t\t\t\t\tconsumables.set( name, true );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}]}