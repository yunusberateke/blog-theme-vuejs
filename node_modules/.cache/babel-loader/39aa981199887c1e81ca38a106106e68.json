{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9jb250cm9sbGVyL2RhdGFjb250cm9sbGVyCiAqLwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7CmltcG9ydCBPYnNlcnZhYmxlTWl4aW4gZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvb2JzZXJ2YWJsZW1peGluJzsKaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7CmltcG9ydCBNYXBwZXIgZnJvbSAnLi4vY29udmVyc2lvbi9tYXBwZXInOwppbXBvcnQgRG93bmNhc3REaXNwYXRjaGVyIGZyb20gJy4uL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyJzsKaW1wb3J0IHsgaW5zZXJ0VGV4dCB9IGZyb20gJy4uL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzJzsKaW1wb3J0IFVwY2FzdERpc3BhdGNoZXIgZnJvbSAnLi4vY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyJzsKaW1wb3J0IHsgY29udmVydFRleHQsIGNvbnZlcnRUb01vZGVsRnJhZ21lbnQgfSBmcm9tICcuLi9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnMnOwppbXBvcnQgVmlld0RvY3VtZW50RnJhZ21lbnQgZnJvbSAnLi4vdmlldy9kb2N1bWVudGZyYWdtZW50JzsKaW1wb3J0IFZpZXdEb2N1bWVudCBmcm9tICcuLi92aWV3L2RvY3VtZW50JzsKaW1wb3J0IFZpZXdEb3duY2FzdFdyaXRlciBmcm9tICcuLi92aWV3L2Rvd25jYXN0d3JpdGVyJzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi4vbW9kZWwvcmFuZ2UnOwppbXBvcnQgeyBhdXRvUGFyYWdyYXBoRW1wdHlSb290cyB9IGZyb20gJy4uL21vZGVsL3V0aWxzL2F1dG9wYXJhZ3JhcGhpbmcnOwppbXBvcnQgSHRtbERhdGFQcm9jZXNzb3IgZnJvbSAnLi4vZGF0YXByb2Nlc3Nvci9odG1sZGF0YXByb2Nlc3Nvcic7Ci8qKgogKiBDb250cm9sbGVyIGZvciB0aGUgZGF0YSBwaXBlbGluZS4gVGhlIGRhdGEgcGlwZWxpbmUgY29udHJvbHMgaG93IGRhdGEgaXMgcmV0cmlldmVkIGZyb20gdGhlIGRvY3VtZW50CiAqIGFuZCBzZXQgaW5zaWRlIGl0LiBIZW5jZSwgdGhlIGNvbnRyb2xsZXIgZmVhdHVyZXMgdHdvIG1ldGhvZHMgd2hpY2ggYWxsb3cgdG8ge0BsaW5rIH5EYXRhQ29udHJvbGxlciNnZXQgZ2V0fQogKiBhbmQge0BsaW5rIH5EYXRhQ29udHJvbGxlciNzZXQgc2V0fSBkYXRhIG9mIHRoZSB7QGxpbmsgfkRhdGFDb250cm9sbGVyI21vZGVsIG1vZGVsfQogKiB1c2luZyBnaXZlbjoKICoKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9kYXRhcHJvY2Vzc29yL2RhdGFwcm9jZXNzb3J+RGF0YVByb2Nlc3NvciBkYXRhIHByb2Nlc3Nvcn0sCiAqICogZG93bmNhc3QgY29udmVydGVycywKICogKiB1cGNhc3QgY29udmVydGVycy4KICoKICogQW4gaW5zdGFuY2Ugb2YgdGhlIGRhdGEgY29udHJvbGxlciBpcyBhbHdheXMgYXZhaWxhYmxlIGluIHRoZSB7QGxpbmsgbW9kdWxlOmNvcmUvZWRpdG9yL2VkaXRvcn5FZGl0b3IjZGF0YSBgZWRpdG9yLmRhdGFgfQogKiBwcm9wZXJ0eToKICoKICoJCWVkaXRvci5kYXRhLmdldCggeyByb290TmFtZTogJ2N1c3RvbVJvb3QnIH0gKTsgLy8gLT4gJzxwPkhlbGxvITwvcD4nCiAqCiAqIEBtaXhlcyBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbgogKi8KCnZhciBEYXRhQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIGRhdGEgY29udHJvbGxlciBpbnN0YW5jZS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0gbW9kZWwgRGF0YSBtb2RlbC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+U3R5bGVzUHJvY2Vzc29yfSBzdHlsZXNQcm9jZXNzb3IgVGhlIHN0eWxlcyBwcm9jZXNzb3IgaW5zdGFuY2UuCiAgICovCiAgZnVuY3Rpb24gRGF0YUNvbnRyb2xsZXIobW9kZWwsIHN0eWxlc1Byb2Nlc3NvcikgewogICAgdmFyIF90aGlzID0gdGhpczsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YUNvbnRyb2xsZXIpOwoKICAgIC8qKgogICAgICogRGF0YSBtb2RlbC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9CiAgICAgKi8KICAgIHRoaXMubW9kZWwgPSBtb2RlbDsKICAgIC8qKgogICAgICogTWFwcGVyIHVzZWQgZm9yIHRoZSBjb252ZXJzaW9uLiBJdCBoYXMgbm8gcGVybWFuZW50IGJpbmRpbmdzLCBiZWNhdXNlIHRoZXkgYXJlIGNyZWF0ZWQgd2hlbiBnZXR0aW5nIGRhdGEgYW5kCiAgICAgKiBjbGVhcmVkIGRpcmVjdGx5IGFmdGVyIHRoZSBkYXRhIGFyZSBjb252ZXJ0ZWQuIEhvd2V2ZXIsIHRoZSBtYXBwZXIgaXMgZGVmaW5lZCBhcyBhIGNsYXNzIHByb3BlcnR5LCBiZWNhdXNlCiAgICAgKiBpdCBuZWVkcyB0byBiZSBwYXNzZWQgdG8gdGhlIGBEb3duY2FzdERpc3BhdGNoZXJgIGFzIGEgY29udmVyc2lvbiBBUEkuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlcn0KICAgICAqLwoKICAgIHRoaXMubWFwcGVyID0gbmV3IE1hcHBlcigpOwogICAgLyoqCiAgICAgKiBEb3duY2FzdCBkaXNwYXRjaGVyIHVzZWQgYnkgdGhlIHtAbGluayAjZ2V0IGdldCBtZXRob2R9LiBEb3duY2FzdCBjb252ZXJ0ZXJzIHNob3VsZCBiZSBhdHRhY2hlZCB0byBpdC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfQogICAgICovCgogICAgdGhpcy5kb3duY2FzdERpc3BhdGNoZXIgPSBuZXcgRG93bmNhc3REaXNwYXRjaGVyKHsKICAgICAgbWFwcGVyOiB0aGlzLm1hcHBlciwKICAgICAgc2NoZW1hOiBtb2RlbC5zY2hlbWEKICAgIH0pOwogICAgdGhpcy5kb3duY2FzdERpc3BhdGNoZXIub24oJ2luc2VydDokdGV4dCcsIGluc2VydFRleHQoKSwgewogICAgICBwcmlvcml0eTogJ2xvd2VzdCcKICAgIH0pOwogICAgLyoqCiAgICAgKiBVcGNhc3QgZGlzcGF0Y2hlciB1c2VkIGJ5IHRoZSB7QGxpbmsgI3NldCBzZXQgbWV0aG9kfS4gVXBjYXN0IGNvbnZlcnRlcnMgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIGl0LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlcn0KICAgICAqLwoKICAgIHRoaXMudXBjYXN0RGlzcGF0Y2hlciA9IG5ldyBVcGNhc3REaXNwYXRjaGVyKHsKICAgICAgc2NoZW1hOiBtb2RlbC5zY2hlbWEKICAgIH0pOwogICAgLyoqCiAgICAgKiBUaGUgdmlldyBkb2N1bWVudCB1c2VkIGJ5IHRoZSBkYXRhIGNvbnRyb2xsZXIuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnR+RG9jdW1lbnR9CiAgICAgKi8KCiAgICB0aGlzLnZpZXdEb2N1bWVudCA9IG5ldyBWaWV3RG9jdW1lbnQoc3R5bGVzUHJvY2Vzc29yKTsKICAgIC8qKgogICAgICogU3R5bGVzIHByb2Nlc3NvciB1c2VkIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+U3R5bGVzUHJvY2Vzc29yfQogICAgICovCgogICAgdGhpcy5zdHlsZXNQcm9jZXNzb3IgPSBzdHlsZXNQcm9jZXNzb3I7CiAgICAvKioKICAgICAqIERhdGEgcHJvY2Vzc29yIHVzZWQgc3BlY2lmaWNhbGx5IGZvciBIVE1MIGNvbnZlcnNpb24uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL2RhdGFwcm9jZXNzb3IvaHRtbGRhdGFwcm9jZXNzb3J+SHRtbERhdGFQcm9jZXNzb3J9ICNodG1sUHJvY2Vzc29yCiAgICAgKi8KCiAgICB0aGlzLmh0bWxQcm9jZXNzb3IgPSBuZXcgSHRtbERhdGFQcm9jZXNzb3IodGhpcy52aWV3RG9jdW1lbnQpOwogICAgLyoqCiAgICAgKiBEYXRhIHByb2Nlc3NvciB1c2VkIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgICAqIFNhbWUgaW5zdGFuY2UgYXMge0BsaW5rICNodG1sUHJvY2Vzc29yfSBieSBkZWZhdWx0LiBDYW4gYmUgcmVwbGFjZWQgYXQgcnVuIHRpbWUgdG8gaGFuZGxlIGRpZmZlcmVudCBmb3JtYXQsIGUuZy4gWE1MIG9yIE1hcmtkb3duLgogICAgICoKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvZGF0YXByb2Nlc3Nvci9kYXRhcHJvY2Vzc29yfkRhdGFQcm9jZXNzb3J9ICNwcm9jZXNzb3IKICAgICAqLwoKICAgIHRoaXMucHJvY2Vzc29yID0gdGhpcy5odG1sUHJvY2Vzc29yOwogICAgLyoqCiAgICAgKiBUaGUgdmlldyBkb3duY2FzdCB3cml0ZXIganVzdCBmb3IgZGF0YSBjb252ZXJzaW9uIHB1cnBvc2VzLCBpLmUuIHRvIG1vZGlmeQogICAgICogdGhlIHtAbGluayAjdmlld0RvY3VtZW50fS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXJ9CiAgICAgKi8KCiAgICB0aGlzLl92aWV3V3JpdGVyID0gbmV3IFZpZXdEb3duY2FzdFdyaXRlcih0aGlzLnZpZXdEb2N1bWVudCk7IC8vIERlZmluZSBkZWZhdWx0IGNvbnZlcnRlcnMgZm9yIHRleHQgYW5kIGVsZW1lbnRzLgogICAgLy8KICAgIC8vIE5vdGUgdGhhdCBpZiB0aGVyZSBpcyBubyBkZWZhdWx0IGNvbnZlcnRlciBmb3IgdGhlIGVsZW1lbnQgaXQgd2lsbCBiZSBza2lwcGVkLCBmb3IgaW5zdGFuY2UgYDxiPmZvbzwvYj5gIHdpbGwgYmUKICAgIC8vIGNvbnZlcnRlZCB0byBub3RoaW5nLiBXZSB0aGVyZWZvcmUgYWRkIGBjb252ZXJ0VG9Nb2RlbEZyYWdtZW50YCBhcyBhIGxhc3QgY29udmVydGVyIHNvIGl0IGNvbnZlcnRzIGNoaWxkcmVuIG9mIHRoYXQKICAgIC8vIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50IGZyYWdtZW50IGFuZCBzbyBgPGI+Zm9vPC9iPmAgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYGZvb2AgaWYgdGhlcmUgaXMgbm8gY29udmVydGVyIGZvciBgPGI+YC4KCiAgICB0aGlzLnVwY2FzdERpc3BhdGNoZXIub24oJ3RleHQnLCBjb252ZXJ0VGV4dCgpLCB7CiAgICAgIHByaW9yaXR5OiAnbG93ZXN0JwogICAgfSk7CiAgICB0aGlzLnVwY2FzdERpc3BhdGNoZXIub24oJ2VsZW1lbnQnLCBjb252ZXJ0VG9Nb2RlbEZyYWdtZW50KCksIHsKICAgICAgcHJpb3JpdHk6ICdsb3dlc3QnCiAgICB9KTsKICAgIHRoaXMudXBjYXN0RGlzcGF0Y2hlci5vbignZG9jdW1lbnRGcmFnbWVudCcsIGNvbnZlcnRUb01vZGVsRnJhZ21lbnQoKSwgewogICAgICBwcmlvcml0eTogJ2xvd2VzdCcKICAgIH0pOwogICAgdGhpcy5kZWNvcmF0ZSgnaW5pdCcpOwogICAgdGhpcy5kZWNvcmF0ZSgnc2V0Jyk7IC8vIEZpcmUgdGhlIGByZWFkeWAgZXZlbnQgd2hlbiB0aGUgaW5pdGlhbGl6YXRpb24gaGFzIGNvbXBsZXRlZC4gU3VjaCBsb3ctbGV2ZWwgbGlzdGVuZXIgZ2l2ZXMgcG9zc2liaWxpdHkKICAgIC8vIHRvIHBsdWcgaW50byB0aGUgaW5pdGlhbGl6YXRpb24gcGlwZWxpbmUgd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGluaXRpYWxpemF0aW9uIGZsb3cuCgogICAgdGhpcy5vbignaW5pdCcsIGZ1bmN0aW9uICgpIHsKICAgICAgX3RoaXMuZmlyZSgncmVhZHknKTsKICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdsb3dlc3QnCiAgICB9KTsgLy8gRml4IGVtcHR5IHJvb3RzIGFmdGVyIERhdGFDb250cm9sbGVyIGlzICdyZWFkeScgKG5vdGUgdGhhdCBpbml0IG1ldGhvZCBjb3VsZCBiZSBkZWNvcmF0ZWQgYW5kIHN0b3BwZWQpLgogICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgdGhpcyBldmVudCBiZWNhdXNlIGluaXRpYWwgZGF0YSBjb3VsZCBiZSBlbXB0eSBhbmQgcG9zdC1maXhlciB3b3VsZCBub3QgZ2V0IHRyaWdnZXJlZC4KCiAgICB0aGlzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICgpIHsKICAgICAgX3RoaXMubW9kZWwuZW5xdWV1ZUNoYW5nZSgndHJhbnNwYXJlbnQnLCBhdXRvUGFyYWdyYXBoRW1wdHlSb290cyk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnbG93ZXN0JwogICAgfSk7CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIG1vZGVsJ3MgZGF0YSBjb252ZXJ0ZWQgYnkgZG93bmNhc3QgZGlzcGF0Y2hlcnMgYXR0YWNoZWQgdG8ge0BsaW5rICNkb3duY2FzdERpc3BhdGNoZXJ9IGFuZAogICAqIGZvcm1hdHRlZCBieSB0aGUge0BsaW5rICNwcm9jZXNzb3IgZGF0YSBwcm9jZXNzb3J9LgogICAqCiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSByZXRyaWV2ZWQgZGF0YS4gYERhdGFDb250cm9sbGVyYCBwcm92aWRlcyB0d28gb3B0aW9uYWwKICAgKiBwcm9wZXJ0aWVzOiBgcm9vdE5hbWVgIGFuZCBgdHJpbWAuIE90aGVyIHByb3BlcnRpZXMgb2YgdGhpcyBvYmplY3QgYXJlIHNwZWNpZmllZCBieSB2YXJpb3VzIGVkaXRvciBmZWF0dXJlcy4KICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucm9vdE5hbWU9J21haW4nXSBSb290IG5hbWUuCiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRyaW09J2VtcHR5J10gV2hldGhlciByZXR1cm5lZCBkYXRhIHNob3VsZCBiZSB0cmltbWVkLiBUaGlzIG9wdGlvbiBpcyBzZXQgdG8gYGVtcHR5YCBieSBkZWZhdWx0LAogICAqIHdoaWNoIG1lYW5zIHdoZW5ldmVyIGVkaXRvciBjb250ZW50IGlzIGNvbnNpZGVyZWQgZW1wdHksIGFuIGVtcHR5IHN0cmluZyB3aWxsIGJlIHJldHVybmVkLiBUbyB0dXJuIG9mZiB0cmltbWluZyBjb21wbGV0ZWx5CiAgICogdXNlIGAnbm9uZSdgLiBJbiBzdWNoIGNhc2VzIGV4YWN0IGNvbnRlbnQgd2lsbCBiZSByZXR1cm5lZCAoZm9yIGV4YW1wbGUgYDxwPiZuYnNwOzwvcD5gIGZvciBhbiBlbXB0eSBlZGl0b3IpLgogICAqIEByZXR1cm5zIHtTdHJpbmd9IE91dHB1dCBkYXRhLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKERhdGFDb250cm9sbGVyLCBbewogICAga2V5OiAiZ2V0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKICAgICAgdmFyIF9vcHRpb25zJHJvb3ROYW1lID0gb3B0aW9ucy5yb290TmFtZSwKICAgICAgICAgIHJvb3ROYW1lID0gX29wdGlvbnMkcm9vdE5hbWUgPT09IHZvaWQgMCA/ICdtYWluJyA6IF9vcHRpb25zJHJvb3ROYW1lLAogICAgICAgICAgX29wdGlvbnMkdHJpbSA9IG9wdGlvbnMudHJpbSwKICAgICAgICAgIHRyaW0gPSBfb3B0aW9ucyR0cmltID09PSB2b2lkIDAgPyAnZW1wdHknIDogX29wdGlvbnMkdHJpbTsKCiAgICAgIGlmICghdGhpcy5fY2hlY2tJZlJvb3RzRXhpc3RzKFtyb290TmFtZV0pKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IGdldCBkYXRhIGZyb20gYSBub24tZXhpc3Rpbmcgcm9vdC4gVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiB7QGxpbmsgI2dldCBEYXRhQ29udHJvbGxlciNnZXQoKSBtZXRob2R9CiAgICAgICAgICogaXMgY2FsbGVkIHdpdGggbm9uLWV4aXN0ZW50IHJvb3QgbmFtZS4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGlzIGFuIGVkaXRvciBpbnN0YW5jZSB3aXRoIG9ubHkgYG1haW5gIHJvb3QsCiAgICAgICAgICogY2FsbGluZyB7QGxpbmsgI2dldH0gbGlrZToKICAgICAgICAgKgogICAgICAgICAqCQlkYXRhLmdldCggeyByb290TmFtZTogJ3Jvb3QyJyB9ICk7CiAgICAgICAgICoKICAgICAgICAgKiB3aWxsIHRocm93IHRoaXMgZXJyb3IuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgZGF0YWNvbnRyb2xsZXItZ2V0LW5vbi1leGlzdGVudC1yb290CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2RhdGFjb250cm9sbGVyLWdldC1ub24tZXhpc3RlbnQtcm9vdCcsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgcm9vdCA9IHRoaXMubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdChyb290TmFtZSk7CgogICAgICBpZiAodHJpbSA9PT0gJ2VtcHR5JyAmJiAhdGhpcy5tb2RlbC5oYXNDb250ZW50KHJvb3QsIHsKICAgICAgICBpZ25vcmVXaGl0ZXNwYWNlczogdHJ1ZQogICAgICB9KSkgewogICAgICAgIHJldHVybiAnJzsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KHJvb3QsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgbW9kZWwncyBlbGVtZW50fSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGRvY3VtZW50IGZyYWdtZW50fSBjb252ZXJ0ZWQgYnkgdGhlIGRvd25jYXN0IGNvbnZlcnRlcnMKICAgICAqIGF0dGFjaGVkIHRvIHtAbGluayAjZG93bmNhc3REaXNwYXRjaGVyfSBhbmQgZm9ybWF0dGVkIGJ5IHRoZSB7QGxpbmsgI3Byb2Nlc3NvciBkYXRhIHByb2Nlc3Nvcn0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gbW9kZWxFbGVtZW50T3JGcmFnbWVudAogICAgICogRWxlbWVudCB3aG9zZSBjb250ZW50IHdpbGwgYmUgc3RyaW5naWZpZWQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBwYXNzZWQgdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IE91dHB1dCBkYXRhLgogICAgICovCgogIH0sIHsKICAgIGtleTogInN0cmluZ2lmeSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyaW5naWZ5KG1vZGVsRWxlbWVudE9yRnJhZ21lbnQpIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9OwogICAgICAvLyBNb2RlbCAtPiB2aWV3LgogICAgICB2YXIgdmlld0RvY3VtZW50RnJhZ21lbnQgPSB0aGlzLnRvVmlldyhtb2RlbEVsZW1lbnRPckZyYWdtZW50LCBvcHRpb25zKTsgLy8gVmlldyAtPiBkYXRhLgoKICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yLnRvRGF0YSh2aWV3RG9jdW1lbnRGcmFnbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBtb2RlbCBlbGVtZW50fSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGRvY3VtZW50IGZyYWdtZW50fSBjb252ZXJ0ZWQgYnkgdGhlIGRvd25jYXN0CiAgICAgKiBjb252ZXJ0ZXJzIGF0dGFjaGVkIHRvIHtAbGluayAjZG93bmNhc3REaXNwYXRjaGVyfSB0byBhCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCB2aWV3IGRvY3VtZW50IGZyYWdtZW50fS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBtb2RlbEVsZW1lbnRPckZyYWdtZW50CiAgICAgKiBFbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50IHdob3NlIGNvbnRlbnQgd2lsbCBiZSBjb252ZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB0aGF0IHdpbGwgYmUgYXZhaWxhYmxlIHRocm91Z2gKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0Q29udmVyc2lvbkFwaSNvcHRpb25zfSBkdXJpbmcgdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBPdXRwdXQgdmlldyBEb2N1bWVudEZyYWdtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvVmlldyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9WaWV3KG1vZGVsRWxlbWVudE9yRnJhZ21lbnQpIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9OwogICAgICB2YXIgdmlld0RvY3VtZW50ID0gdGhpcy52aWV3RG9jdW1lbnQ7CiAgICAgIHZhciB2aWV3V3JpdGVyID0gdGhpcy5fdmlld1dyaXRlcjsgLy8gQ2xlYXIgYmluZGluZ3Mgc28gdGhlIGNhbGwgdG8gdGhpcyBtZXRob2QgZ2l2ZXMgY29ycmVjdCByZXN1bHRzLgoKICAgICAgdGhpcy5tYXBwZXIuY2xlYXJCaW5kaW5ncygpOyAvLyBGaXJzdCwgY29udmVydCBlbGVtZW50cy4KCiAgICAgIHZhciBtb2RlbFJhbmdlID0gTW9kZWxSYW5nZS5fY3JlYXRlSW4obW9kZWxFbGVtZW50T3JGcmFnbWVudCk7CgogICAgICB2YXIgdmlld0RvY3VtZW50RnJhZ21lbnQgPSBuZXcgVmlld0RvY3VtZW50RnJhZ21lbnQodmlld0RvY3VtZW50KTsKICAgICAgdGhpcy5tYXBwZXIuYmluZEVsZW1lbnRzKG1vZGVsRWxlbWVudE9yRnJhZ21lbnQsIHZpZXdEb2N1bWVudEZyYWdtZW50KTsgLy8gTWFrZSBhZGRpdGlvbmFsIG9wdGlvbnMgYXZhaWxhYmxlIGR1cmluZyBjb252ZXJzaW9uIHByb2Nlc3MgdGhyb3VnaCBgY29udmVyc2lvbkFwaWAuCgogICAgICB0aGlzLmRvd25jYXN0RGlzcGF0Y2hlci5jb252ZXJzaW9uQXBpLm9wdGlvbnMgPSBvcHRpb25zOyAvLyBXZSBoYXZlIG5vIHZpZXcgY29udHJvbGxlciBhbmQgcmVuZGVyaW5nIHRvIERPTSBpbiBEYXRhQ29udHJvbGxlciBzbyB2aWV3LmNoYW5nZSgpIGJsb2NrIGlzIG5vdCB1c2VkIGhlcmUuCgogICAgICB0aGlzLmRvd25jYXN0RGlzcGF0Y2hlci5jb252ZXJ0SW5zZXJ0KG1vZGVsUmFuZ2UsIHZpZXdXcml0ZXIpOyAvLyBDb252ZXJ0IG1hcmtlcnMuCiAgICAgIC8vIEZvciBkb2N1bWVudCBmcmFnbWVudCwgc2ltcGx5IHRha2UgdGhlIG1hcmtlcnMgYXNzaWduZWQgdG8gdGhpcyBkb2N1bWVudCBmcmFnbWVudC4KICAgICAgLy8gRm9yIG1vZGVsIHJvb3QsIGFsbCBtYXJrZXJzIGluIHRoYXQgcm9vdCB3aWxsIGJlIHRha2VuLgogICAgICAvLyBGb3IgbW9kZWwgZWxlbWVudCwgd2UgbmVlZCB0byBjaGVjayB3aGljaCBtYXJrZXJzIGFyZSBpbnRlcnNlY3Rpbmcgd2l0aCB0aGlzIGVsZW1lbnQgYW5kIHJlbGF0aXZlbHkgbW9kaWZ5IHRoZSBtYXJrZXJzJyByYW5nZXMuCgogICAgICB2YXIgbWFya2VycyA9IG1vZGVsRWxlbWVudE9yRnJhZ21lbnQuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSA/IEFycmF5LmZyb20obW9kZWxFbGVtZW50T3JGcmFnbWVudC5tYXJrZXJzKSA6IF9nZXRNYXJrZXJzUmVsYXRpdmVUb0VsZW1lbnQobW9kZWxFbGVtZW50T3JGcmFnbWVudCk7CgogICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobWFya2VycyksCiAgICAgICAgICBfc3RlcDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSwKICAgICAgICAgICAgICBuYW1lID0gX3N0ZXAkdmFsdWVbMF0sCiAgICAgICAgICAgICAgcmFuZ2UgPSBfc3RlcCR2YWx1ZVsxXTsKCiAgICAgICAgICB0aGlzLmRvd25jYXN0RGlzcGF0Y2hlci5jb252ZXJ0TWFya2VyQWRkKG5hbWUsIHJhbmdlLCB2aWV3V3JpdGVyKTsKICAgICAgICB9IC8vIENsZWFuIGBjb252ZXJzaW9uQXBpYC4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvci5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yLmYoKTsKICAgICAgfQoKICAgICAgZGVsZXRlIHRoaXMuZG93bmNhc3REaXNwYXRjaGVyLmNvbnZlcnNpb25BcGkub3B0aW9uczsKICAgICAgcmV0dXJuIHZpZXdEb2N1bWVudEZyYWdtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGluaXRpYWwgaW5wdXQgZGF0YSBwYXJzZWQgYnkgdGhlIHtAbGluayAjcHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yfSBhbmQKICAgICAqIGNvbnZlcnRlZCBieSB0aGUge0BsaW5rICN1cGNhc3REaXNwYXRjaGVyIHZpZXctdG8tbW9kZWwgY29udmVydGVyc30uCiAgICAgKiBJbml0aWFsIGRhdGEgY2FuIGJlIHNldCBvbmx5IHRvIGRvY3VtZW50IHRoYXQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjdmVyc2lvbn0gaXMgZXF1YWwgMC4KICAgICAqCiAgICAgKiAqKk5vdGUqKiBUaGlzIG1ldGhvZCBpcyB7QGxpbmsgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4jZGVjb3JhdGUgZGVjb3JhdGVkfSB3aGljaCBpcwogICAgICogdXNlZCBieSBlLmcuIGNvbGxhYm9yYXRpdmUgZWRpdGluZyBwbHVnaW4gdGhhdCBzeW5jcyByZW1vdGUgZGF0YSBvbiBpbml0LgogICAgICoKICAgICAqIFdoZW4gZGF0YSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcgaXQgaXMgaW5pdGlhbGl6ZWQgb24gYSBkZWZhdWx0IGBtYWluYCByb290OgogICAgICoKICAgICAqCQlkYXRhQ29udHJvbGxlci5pbml0KCAnPHA+Rm9vPC9wPicgKTsgLy8gSW5pdGlhbGl6ZXMgZGF0YSBvbiB0aGUgYG1haW5gIHJvb3QuCiAgICAgKgogICAgICogVG8gaW5pdGlhbGl6ZSBkYXRhIG9uIGEgZGlmZmVyZW50IHJvb3Qgb3IgbXVsdGlwbGUgcm9vdHMgYXQgb25jZSwgb2JqZWN0IGNvbnRhaW5pbmcgYHJvb3ROYW1lYCAtIGBkYXRhYCBwYWlycyBzaG91bGQgYmUgcGFzc2VkOgogICAgICoKICAgICAqCQlkYXRhQ29udHJvbGxlci5pbml0KCB7IG1haW46ICc8cD5Gb288L3A+JywgdGl0bGU6ICc8aDE+QmFyPC9oMT4nIH0gKTsgLy8gSW5pdGlhbGl6ZXMgZGF0YSBvbiB0aGUgYG1haW5gIGFuZCBgdGl0bGVgIHJvb3RzLgogICAgICoKICAgICAqIEBmaXJlcyBpbml0CiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZyxTdHJpbmc+fSBkYXRhIElucHV0IGRhdGEgYXMgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHJvb3ROYW1lYCAtIGBkYXRhYAogICAgICogcGFpcnMgdG8gaW5pdGlhbGl6ZSBkYXRhIG9uIG11bHRpcGxlIHJvb3RzIGF0IG9uY2UuCiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIGFmdGVyIHRoZSBkYXRhIGlzIHNldCBvbiB0aGUgZWRpdG9yLgogICAgICovCgogIH0sIHsKICAgIGtleTogImluaXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZGF0YSkgewogICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgIGlmICh0aGlzLm1vZGVsLmRvY3VtZW50LnZlcnNpb24pIHsKICAgICAgICAvKioKICAgICAgICAgKiBDYW5ub3Qgc2V0IGluaXRpYWwgZGF0YSB0byBub3QgZW1wdHkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9LgogICAgICAgICAqIEluaXRpYWwgZGF0YSBzaG91bGQgYmUgc2V0IG9uY2UsIGR1cmluZyB7QGxpbmsgbW9kdWxlOmNvcmUvZWRpdG9yL2VkaXRvcn5FZGl0b3J9IGluaXRpYWxpemF0aW9uLAogICAgICAgICAqIHdoZW4gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3ZlcnNpb259IGlzIGVxdWFsIDAuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgZGF0YWNvbnRyb2xsZXItaW5pdC1kb2N1bWVudC1ub3QtZW1wdHkKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignZGF0YWNvbnRyb2xsZXItaW5pdC1kb2N1bWVudC1ub3QtZW1wdHknLCB0aGlzKTsKICAgICAgfQoKICAgICAgdmFyIGluaXRpYWxEYXRhID0ge307CgogICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgaW5pdGlhbERhdGEubWFpbiA9IGRhdGE7IC8vIERlZmF1bHQgcm9vdCBpcyAnbWFpbicuIFRvIGluaXRpYXRlIGRhdGEgb24gYSBkaWZmZXJlbnQgcm9vdCwgb2JqZWN0IHNob3VsZCBiZSBwYXNzZWQuCiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW5pdGlhbERhdGEgPSBkYXRhOwogICAgICB9CgogICAgICBpZiAoIXRoaXMuX2NoZWNrSWZSb290c0V4aXN0cyhPYmplY3Qua2V5cyhpbml0aWFsRGF0YSkpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IGluaXQgZGF0YSBvbiBhIG5vbi1leGlzdGluZyByb290LiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIHtAbGluayAjaW5pdCBEYXRhQ29udHJvbGxlciNpbml0KCkgbWV0aG9kfQogICAgICAgICAqIGlzIGNhbGxlZCB3aXRoIG5vbi1leGlzdGVudCByb290IG5hbWUuIEZvciBleGFtcGxlLCBpZiB0aGVyZSBpcyBhbiBlZGl0b3IgaW5zdGFuY2Ugd2l0aCBvbmx5IGBtYWluYCByb290LAogICAgICAgICAqIGNhbGxpbmcge0BsaW5rICNpbml0fSBsaWtlOgogICAgICAgICAqCiAgICAgICAgICogCQlkYXRhLmluaXQoIHsgbWFpbjogJzxwPkZvbzwvcD4nLCByb290MjogJzxwPkJhcjwvcD4nIH0gKTsKICAgICAgICAgKgogICAgICAgICAqIHdpbGwgdGhyb3cgdGhpcyBlcnJvci4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBkYXRhY29udHJvbGxlci1pbml0LW5vbi1leGlzdGVudC1yb290CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2RhdGFjb250cm9sbGVyLWluaXQtbm9uLWV4aXN0ZW50LXJvb3QnLCB0aGlzKTsKICAgICAgfQoKICAgICAgdGhpcy5tb2RlbC5lbnF1ZXVlQ2hhbmdlKCd0cmFuc3BhcmVudCcsIGZ1bmN0aW9uICh3cml0ZXIpIHsKICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKGluaXRpYWxEYXRhKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICB2YXIgcm9vdE5hbWUgPSBfT2JqZWN0JGtleXNbX2ldOwoKICAgICAgICAgIHZhciBtb2RlbFJvb3QgPSBfdGhpczIubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdChyb290TmFtZSk7CgogICAgICAgICAgd3JpdGVyLmluc2VydChfdGhpczIucGFyc2UoaW5pdGlhbERhdGFbcm9vdE5hbWVdLCBtb2RlbFJvb3QpLCBtb2RlbFJvb3QsIDApOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsKICAgIH0KICAgIC8qKgogICAgICogU2V0cyBpbnB1dCBkYXRhIHBhcnNlZCBieSB0aGUge0BsaW5rICNwcm9jZXNzb3IgZGF0YSBwcm9jZXNzb3J9IGFuZAogICAgICogY29udmVydGVkIGJ5IHRoZSB7QGxpbmsgI3VwY2FzdERpc3BhdGNoZXIgdmlldy10by1tb2RlbCBjb252ZXJ0ZXJzfS4KICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGFueSB0aW1lIHRvIHJlcGxhY2UgZXhpc3RpbmcgZWRpdG9yIGRhdGEgYnkgdGhlIG5ldyBvbmUgd2l0aG91dCBjbGVhcmluZyB0aGUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I2hpc3RvcnkgZG9jdW1lbnQgaGlzdG9yeX0uCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgYWxzbyBjcmVhdGVzIGEgYmF0Y2ggd2l0aCBhbGwgdGhlIGNoYW5nZXMgYXBwbGllZC4gSWYgYWxsIHlvdSBuZWVkIGlzIHRvIHBhcnNlIGRhdGEsIHVzZQogICAgICogdGhlIHtAbGluayAjcGFyc2V9IG1ldGhvZC4KICAgICAqCiAgICAgKiBXaGVuIGRhdGEgaXMgcGFzc2VkIGFzIGEgc3RyaW5nIGl0IGlzIHNldCBvbiBhIGRlZmF1bHQgYG1haW5gIHJvb3Q6CiAgICAgKgogICAgICoJCWRhdGFDb250cm9sbGVyLnNldCggJzxwPkZvbzwvcD4nICk7IC8vIFNldHMgZGF0YSBvbiB0aGUgYG1haW5gIHJvb3QuCiAgICAgKgogICAgICogVG8gc2V0IGRhdGEgb24gYSBkaWZmZXJlbnQgcm9vdCBvciBtdWx0aXBsZSByb290cyBhdCBvbmNlLCBvYmplY3QgY29udGFpbmluZyBgcm9vdE5hbWVgIC0gYGRhdGFgIHBhaXJzIHNob3VsZCBiZSBwYXNzZWQ6CiAgICAgKgogICAgICoJCWRhdGFDb250cm9sbGVyLnNldCggeyBtYWluOiAnPHA+Rm9vPC9wPicsIHRpdGxlOiAnPGgxPkJhcjwvaDE+JyB9ICk7IC8vIFNldHMgZGF0YSBvbiB0aGUgYG1haW5gIGFuZCBgdGl0bGVgIHJvb3RzLgogICAgICoKICAgICAqIEBmaXJlcyBzZXQKICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLFN0cmluZz59IGRhdGEgSW5wdXQgZGF0YSBhcyBhIHN0cmluZyBvciBhbiBvYmplY3QgY29udGFpbmluZyBgcm9vdE5hbWVgIC0gYGRhdGFgCiAgICAgKiBwYWlycyB0byBzZXQgZGF0YSBvbiBtdWx0aXBsZSByb290cyBhdCBvbmNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogInNldCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGRhdGEpIHsKICAgICAgdmFyIF90aGlzMyA9IHRoaXM7CgogICAgICB2YXIgbmV3RGF0YSA9IHt9OwoKICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgewogICAgICAgIG5ld0RhdGEubWFpbiA9IGRhdGE7IC8vIERlZmF1bHQgcm9vdCBpcyAnbWFpbicuIFRvIHNldCBkYXRhIG9uIGEgZGlmZmVyZW50IHJvb3QsIG9iamVjdCBzaG91bGQgYmUgcGFzc2VkLgogICAgICB9IGVsc2UgewogICAgICAgIG5ld0RhdGEgPSBkYXRhOwogICAgICB9CgogICAgICBpZiAoIXRoaXMuX2NoZWNrSWZSb290c0V4aXN0cyhPYmplY3Qua2V5cyhuZXdEYXRhKSkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBDYW5ub3Qgc2V0IGRhdGEgb24gYSBub24tZXhpc3Rpbmcgcm9vdC4gVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiB7QGxpbmsgI3NldCBEYXRhQ29udHJvbGxlciNzZXQoKSBtZXRob2R9CiAgICAgICAgICogaXMgY2FsbGVkIHdpdGggbm9uLWV4aXN0ZW50IHJvb3QgbmFtZS4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGlzIGFuIGVkaXRvciBpbnN0YW5jZSB3aXRoIG9ubHkgYG1haW5gIHJvb3QsCiAgICAgICAgICogY2FsbGluZyB7QGxpbmsgI3NldH0gbGlrZToKICAgICAgICAgKgogICAgICAgICAqIAkJZGF0YS5zZXQoIHsgbWFpbjogJzxwPkZvbzwvcD4nLCByb290MjogJzxwPkJhcjwvcD4nIH0gKTsKICAgICAgICAgKgogICAgICAgICAqIHdpbGwgdGhyb3cgdGhpcyBlcnJvci4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBkYXRhY29udHJvbGxlci1zZXQtbm9uLWV4aXN0ZW50LXJvb3QKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignZGF0YWNvbnRyb2xsZXItc2V0LW5vbi1leGlzdGVudC1yb290JywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHRoaXMubW9kZWwuZW5xdWV1ZUNoYW5nZSgndHJhbnNwYXJlbnQnLCBmdW5jdGlvbiAod3JpdGVyKSB7CiAgICAgICAgd3JpdGVyLnNldFNlbGVjdGlvbihudWxsKTsKICAgICAgICB3cml0ZXIucmVtb3ZlU2VsZWN0aW9uQXR0cmlidXRlKF90aGlzMy5tb2RlbC5kb2N1bWVudC5zZWxlY3Rpb24uZ2V0QXR0cmlidXRlS2V5cygpKTsKCiAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKG5ld0RhdGEpOyBfaTIgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICAgIHZhciByb290TmFtZSA9IF9PYmplY3Qka2V5czJbX2kyXTsKCiAgICAgICAgICAvLyBTYXZlIHRvIG1vZGVsLgogICAgICAgICAgdmFyIG1vZGVsUm9vdCA9IF90aGlzMy5tb2RlbC5kb2N1bWVudC5nZXRSb290KHJvb3ROYW1lKTsKCiAgICAgICAgICB3cml0ZXIucmVtb3ZlKHdyaXRlci5jcmVhdGVSYW5nZUluKG1vZGVsUm9vdCkpOwogICAgICAgICAgd3JpdGVyLmluc2VydChfdGhpczMucGFyc2UobmV3RGF0YVtyb290TmFtZV0sIG1vZGVsUm9vdCksIG1vZGVsUm9vdCwgMCk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB0aGUgZGF0YSBwYXJzZWQgYnkgdGhlIHtAbGluayAjcHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yfSBhbmQgdGhlbiBjb252ZXJ0ZWQgYnkgdXBjYXN0IGNvbnZlcnRlcnMKICAgICAqIGF0dGFjaGVkIHRvIHRoZSB7QGxpbmsgI3VwY2FzdERpc3BhdGNoZXJ9LgogICAgICoKICAgICAqIEBzZWUgI3NldAogICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgRGF0YSB0byBwYXJzZS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb259IFtjb250ZXh0PSckcm9vdCddIEJhc2UgY29udGV4dCBpbiB3aGljaCB0aGUgdmlldyB3aWxsCiAgICAgKiBiZSBjb252ZXJ0ZWQgdG8gdGhlIG1vZGVsLiBTZWU6IHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2NvbnZlcnR9LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBQYXJzZWQgZGF0YS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJwYXJzZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoZGF0YSkgewogICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyRyb290JzsKICAgICAgLy8gZGF0YSAtPiB2aWV3CiAgICAgIHZhciB2aWV3RG9jdW1lbnRGcmFnbWVudCA9IHRoaXMucHJvY2Vzc29yLnRvVmlldyhkYXRhKTsgLy8gdmlldyAtPiBtb2RlbAoKICAgICAgcmV0dXJuIHRoaXMudG9Nb2RlbCh2aWV3RG9jdW1lbnRGcmFnbWVudCwgY29udGV4dCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgdmlldyBkb2N1bWVudCBmcmFnbWVudH0gY29udmVydGVkIGJ5IHRoZQogICAgICoge0BsaW5rICN1cGNhc3REaXNwYXRjaGVyIHZpZXctdG8tbW9kZWwgY29udmVydGVyc30sIHdyYXBwZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fS4KICAgICAqCiAgICAgKiBXaGVuIG1hcmtlciBlbGVtZW50cyB3ZXJlIGNvbnZlcnRlZCBkdXJpbmcgdGhlIGNvbnZlcnNpb24gcHJvY2VzcywgaXQgd2lsbCBiZSBzZXQgYXMgYSBkb2N1bWVudCBmcmFnbWVudCdzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQjbWFya2VycyBzdGF0aWMgbWFya2VycyBtYXB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSB2aWV3RWxlbWVudE9yRnJhZ21lbnQKICAgICAqIEVsZW1lbnQgb3IgZG9jdW1lbnQgZnJhZ21lbnQgd2hvc2UgY29udGVudCB3aWxsIGJlIGNvbnZlcnRlZC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb259IFtjb250ZXh0PSckcm9vdCddIEJhc2UgY29udGV4dCBpbiB3aGljaCB0aGUgdmlldyB3aWxsCiAgICAgKiBiZSBjb252ZXJ0ZWQgdG8gdGhlIG1vZGVsLiBTZWU6IHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2NvbnZlcnR9LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBPdXRwdXQgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9Nb2RlbCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Nb2RlbCh2aWV3RWxlbWVudE9yRnJhZ21lbnQpIHsKICAgICAgdmFyIF90aGlzNCA9IHRoaXM7CgogICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyRyb290JzsKICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY2hhbmdlKGZ1bmN0aW9uICh3cml0ZXIpIHsKICAgICAgICByZXR1cm4gX3RoaXM0LnVwY2FzdERpc3BhdGNoZXIuY29udmVydCh2aWV3RWxlbWVudE9yRnJhZ21lbnQsIHdyaXRlciwgY29udGV4dCk7CiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBBZGRzIGEgc3R5bGUgcHJvY2Vzc29yIG5vcm1hbGl6YXRpb24gcnVsZXMuCiAgICAgKgogICAgICogWW91IGNhbiBpbXBsZW1lbnQgeW91ciBvd24gcnVsZXMgYXMgd2VsbCBhcyB1c2Ugb25lIG9mIHRoZSBhdmFpbGFibGUgcHJvY2Vzc29yIHJ1bGVzOgogICAgICoKICAgICAqICogYmFja2dyb3VuZDoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXMvYmFja2dyb3VuZH5hZGRCYWNrZ3JvdW5kUnVsZXN9CiAgICAgKiAqIGJvcmRlcjoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXMvYm9yZGVyfmFkZEJvcmRlclJ1bGVzfQogICAgICogKiBtYXJnaW46IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzL21hcmdpbn5hZGRNYXJnaW5SdWxlc30KICAgICAqICogcGFkZGluZzoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXMvcGFkZGluZ35hZGRQYWRkaW5nUnVsZXN9CiAgICAgKgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJhZGRTdHlsZVByb2Nlc3NvclJ1bGVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdHlsZVByb2Nlc3NvclJ1bGVzKGNhbGxiYWNrKSB7CiAgICAgIGNhbGxiYWNrKHRoaXMuc3R5bGVzUHJvY2Vzc29yKTsKICAgIH0KICAgIC8qKgogICAgICogUmVnaXN0ZXJzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBvbiB7QGxpbmsgI2h0bWxQcm9jZXNzb3IgaHRtbFByb2Nlc3Nvcn0KICAgICAqIGFuZCB7QGxpbmsgI3Byb2Nlc3NvciBwcm9jZXNzb3J9IGZvciB2aWV3IGVsZW1lbnRzIHdob3NlIGNvbnRlbnQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSByYXcgZGF0YQogICAgICogYW5kIG5vdCBwcm9jZXNzZWQgZHVyaW5nIGNvbnZlcnNpb24gZnJvbSBET00gdG8gdmlldyBlbGVtZW50cy4KICAgICAqCiAgICAgKiBUaGUgcmF3IGRhdGEgY2FuIGJlIGxhdGVyIGFjY2Vzc2VkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50I2dldEN1c3RvbVByb3BlcnR5IHZpZXcgZWxlbWVudCBjdXN0b20gcHJvcGVydHl9CiAgICAgKiBgIiRyYXdDb250ZW50ImAuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybn0gcGF0dGVybiBQYXR0ZXJuIG1hdGNoaW5nIGFsbCB2aWV3IGVsZW1lbnRzIHdob3NlIGNvbnRlbnQgc2hvdWxkCiAgICAgKiBiZSB0cmVhdGVkIGFzIGEgcmF3IGRhdGEuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVnaXN0ZXJSYXdDb250ZW50TWF0Y2hlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJSYXdDb250ZW50TWF0Y2hlcihwYXR0ZXJuKSB7CiAgICAgIC8vIE5vIG5lZWQgdG8gcmVnaXN0ZXIgdGhlIHBhdHRlcm4gaWYgYm90aCBgaHRtbFByb2Nlc3NvcmAgYW5kIGBwcm9jZXNzb3JgIGFyZSB0aGUgc2FtZSBpbnN0YW5jZXMuCiAgICAgIGlmICh0aGlzLnByb2Nlc3NvciAmJiB0aGlzLnByb2Nlc3NvciAhPT0gdGhpcy5odG1sUHJvY2Vzc29yKSB7CiAgICAgICAgdGhpcy5wcm9jZXNzb3IucmVnaXN0ZXJSYXdDb250ZW50TWF0Y2hlcihwYXR0ZXJuKTsKICAgICAgfQoKICAgICAgdGhpcy5odG1sUHJvY2Vzc29yLnJlZ2lzdGVyUmF3Q29udGVudE1hdGNoZXIocGF0dGVybik7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycyBzZXQgYnkgdGhlIERhdGFDb250cm9sbGVyLgogICAgICovCgogIH0sIHsKICAgIGtleTogImRlc3Ryb3kiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7CiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYWxsIHByb3ZpZGVkIHJvb3QgbmFtZXMgYXJlIGV4aXN0aW5nIGVkaXRvciByb290cy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gcm9vdE5hbWVzIFJvb3QgbmFtZXMgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciBhbGwgcHJvdmlkZWQgcm9vdCBuYW1lcyBhcmUgZXhpc3RpbmcgZWRpdG9yIHJvb3RzLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jaGVja0lmUm9vdHNFeGlzdHMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0lmUm9vdHNFeGlzdHMocm9vdE5hbWVzKSB7CiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocm9vdE5hbWVzKSwKICAgICAgICAgIF9zdGVwMjsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciByb290TmFtZSA9IF9zdGVwMi52YWx1ZTsKCiAgICAgICAgICBpZiAoIXRoaXMubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdE5hbWVzKCkuaW5jbHVkZXMocm9vdE5hbWUpKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjIuZigpOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogRXZlbnQgZmlyZWQgb25jZSB0aGUgZGF0YSBpbml0aWFsaXphdGlvbiBoYXMgZmluaXNoZWQuCiAgICAgKgogICAgICogQGV2ZW50IHJlYWR5CiAgICAgKi8KCiAgICAvKioKICAgICAqIEV2ZW50IGZpcmVkIGFmdGVyIHRoZSB7QGxpbmsgI2luaXQgYGluaXQoKWAgbWV0aG9kfSB3YXMgcnVuLiBJdCBjYW4gYmUge0BsaW5rICNsaXN0ZW5UbyBsaXN0ZW5lZCB0b30gaW4gb3JkZXIgdG8gYWRqdXN0IG9yIG1vZGlmeQogICAgICogdGhlIGluaXRpYWxpemF0aW9uIGZsb3cuIEhvd2V2ZXIsIGlmIHRoZSBgaW5pdGAgZXZlbnQgaXMgc3RvcHBlZCBvciBwcmV2ZW50ZWQsIHRoZSB7QGxpbmsgI2V2ZW50OnJlYWR5IGByZWFkeWAgZXZlbnR9CiAgICAgKiBzaG91bGQgYmUgZmlyZWQgbWFudWFsbHkuCiAgICAgKgogICAgICogVGhlIGBpbml0YCBldmVudCBpcyBmaXJlZCBieSB0aGUgZGVjb3JhdGVkIHtAbGluayAjaW5pdH0gbWV0aG9kLgogICAgICogU2VlIHtAbGluayBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbiNkZWNvcmF0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIHNhbXBsZXMuCiAgICAgKgogICAgICogQGV2ZW50IGluaXQKICAgICAqLwoKICAgIC8qKgogICAgICogRXZlbnQgZmlyZWQgYWZ0ZXIge0BsaW5rICNzZXQgc2V0KCkgbWV0aG9kfSBoYXMgYmVlbiBydW4uCiAgICAgKgogICAgICogVGhlIGBzZXRgIGV2ZW50IGlzIGZpcmVkIGJ5IGRlY29yYXRlZCB7QGxpbmsgI3NldH0gbWV0aG9kLgogICAgICogU2VlIHtAbGluayBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbiNkZWNvcmF0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIHNhbXBsZXMuCiAgICAgKgogICAgICogQGV2ZW50IHNldAogICAgICovCgogIH1dKTsKCiAgcmV0dXJuIERhdGFDb250cm9sbGVyOwp9KCk7CgpleHBvcnQgeyBEYXRhQ29udHJvbGxlciBhcyBkZWZhdWx0IH07Cm1peChEYXRhQ29udHJvbGxlciwgT2JzZXJ2YWJsZU1peGluKTsgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBkb3duY2FzdCBjb252ZXJzaW9uLgovLwovLyBUYWtlcyBhIGRvY3VtZW50IGVsZW1lbnQgKGVsZW1lbnQgdGhhdCBpcyBhZGRlZCB0byBhIG1vZGVsIGRvY3VtZW50KSBhbmQgY2hlY2tzIHdoaWNoIG1hcmtlcnMgYXJlIGluc2lkZSBpdAovLyBhbmQgd2hpY2ggbWFya2VycyBhcmUgY29udGFpbmluZyBpdC4gSWYgdGhlIG1hcmtlciBpcyBpbnRlcnNlY3Rpbmcgd2l0aCBlbGVtZW50LCB0aGUgaW50ZXJzZWN0aW9uIGlzIHJldHVybmVkLgoKZnVuY3Rpb24gX2dldE1hcmtlcnNSZWxhdGl2ZVRvRWxlbWVudChlbGVtZW50KSB7CiAgdmFyIHJlc3VsdCA9IFtdOwogIHZhciBkb2MgPSBlbGVtZW50LnJvb3QuZG9jdW1lbnQ7CgogIGlmICghZG9jKSB7CiAgICByZXR1cm4gW107CiAgfQoKICB2YXIgZWxlbWVudFJhbmdlID0gTW9kZWxSYW5nZS5fY3JlYXRlSW4oZWxlbWVudCk7CgogIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZG9jLm1vZGVsLm1hcmtlcnMpLAogICAgICBfc3RlcDM7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykgewogICAgICB2YXIgbWFya2VyID0gX3N0ZXAzLnZhbHVlOwogICAgICB2YXIgaW50ZXJzZWN0aW9uID0gZWxlbWVudFJhbmdlLmdldEludGVyc2VjdGlvbihtYXJrZXIuZ2V0UmFuZ2UoKSk7CgogICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7CiAgICAgICAgcmVzdWx0LnB1c2goW21hcmtlci5uYW1lLCBpbnRlcnNlY3Rpb25dKTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjMuZigpOwogIH0KCiAgcmV0dXJuIHJlc3VsdDsKfQ=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js"],"names":["mix","ObservableMixin","CKEditorError","Mapper","DowncastDispatcher","insertText","UpcastDispatcher","convertText","convertToModelFragment","ViewDocumentFragment","ViewDocument","ViewDowncastWriter","ModelRange","autoParagraphEmptyRoots","HtmlDataProcessor","DataController","model","stylesProcessor","mapper","downcastDispatcher","schema","on","priority","upcastDispatcher","viewDocument","htmlProcessor","processor","_viewWriter","decorate","fire","enqueueChange","options","rootName","trim","_checkIfRootsExists","root","document","getRoot","hasContent","ignoreWhitespaces","stringify","modelElementOrFragment","viewDocumentFragment","toView","toData","viewWriter","clearBindings","modelRange","_createIn","bindElements","conversionApi","convertInsert","markers","is","Array","from","_getMarkersRelativeToElement","name","range","convertMarkerAdd","data","version","initialData","main","Object","keys","writer","modelRoot","insert","parse","Promise","resolve","newData","setSelection","removeSelectionAttribute","selection","getAttributeKeys","remove","createRangeIn","context","toModel","viewElementOrFragment","change","convert","callback","pattern","registerRawContentMatcher","stopListening","rootNames","getRootNames","includes","element","result","doc","elementRange","marker","intersection","getIntersection","getRange","push"],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,GAAP,MAAgB,mCAAhB;AACA,OAAOC,eAAP,MAA4B,+CAA5B;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AAEA,OAAOC,MAAP,MAAmB,sBAAnB;AAEA,OAAOC,kBAAP,MAA+B,kCAA/B;AACA,SAASC,UAAT,QAA2B,+BAA3B;AAEA,OAAOC,gBAAP,MAA6B,gCAA7B;AACA,SAASC,WAAT,EAAsBC,sBAAtB,QAAoD,6BAApD;AAEA,OAAOC,oBAAP,MAAiC,0BAAjC;AACA,OAAOC,YAAP,MAAyB,kBAAzB;AACA,OAAOC,kBAAP,MAA+B,wBAA/B;AAEA,OAAOC,UAAP,MAAuB,gBAAvB;AACA,SAASC,uBAAT,QAAwC,iCAAxC;AACA,OAAOC,iBAAP,MAA8B,oCAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,c;AACpB;AACD;AACA;AACA;AACA;AACA;AACC,0BAAaC,KAAb,EAAoBC,eAApB,EAAsC;AAAA;;AAAA;;AACrC;AACF;AACA;AACA;AACA;AACA;AACE,SAAKD,KAAL,GAAaA,KAAb;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKE,MAAL,GAAc,IAAIf,MAAJ,EAAd;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKgB,kBAAL,GAA0B,IAAIf,kBAAJ,CAAwB;AACjDc,MAAAA,MAAM,EAAE,KAAKA,MADoC;AAEjDE,MAAAA,MAAM,EAAEJ,KAAK,CAACI;AAFmC,KAAxB,CAA1B;AAIA,SAAKD,kBAAL,CAAwBE,EAAxB,CAA4B,cAA5B,EAA4ChB,UAAU,EAAtD,EAA0D;AAAEiB,MAAAA,QAAQ,EAAE;AAAZ,KAA1D;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,gBAAL,GAAwB,IAAIjB,gBAAJ,CAAsB;AAC7Cc,MAAAA,MAAM,EAAEJ,KAAK,CAACI;AAD+B,KAAtB,CAAxB;AAIA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKI,YAAL,GAAoB,IAAId,YAAJ,CAAkBO,eAAlB,CAApB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKA,eAAL,GAAuBA,eAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKQ,aAAL,GAAqB,IAAIX,iBAAJ,CAAuB,KAAKU,YAA5B,CAArB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKE,SAAL,GAAiB,KAAKD,aAAtB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKE,WAAL,GAAmB,IAAIhB,kBAAJ,CAAwB,KAAKa,YAA7B,CAAnB,CAjFqC,CAmFrC;AACA;AACA;AACA;AACA;;AACA,SAAKD,gBAAL,CAAsBF,EAAtB,CAA0B,MAA1B,EAAkCd,WAAW,EAA7C,EAAiD;AAAEe,MAAAA,QAAQ,EAAE;AAAZ,KAAjD;AACA,SAAKC,gBAAL,CAAsBF,EAAtB,CAA0B,SAA1B,EAAqCb,sBAAsB,EAA3D,EAA+D;AAAEc,MAAAA,QAAQ,EAAE;AAAZ,KAA/D;AACA,SAAKC,gBAAL,CAAsBF,EAAtB,CAA0B,kBAA1B,EAA8Cb,sBAAsB,EAApE,EAAwE;AAAEc,MAAAA,QAAQ,EAAE;AAAZ,KAAxE;AAEA,SAAKM,QAAL,CAAe,MAAf;AACA,SAAKA,QAAL,CAAe,KAAf,EA7FqC,CA+FrC;AACA;;AACA,SAAKP,EAAL,CAAS,MAAT,EAAiB,YAAM;AACtB,MAAA,KAAI,CAACQ,IAAL,CAAW,OAAX;AACA,KAFD,EAEG;AAAEP,MAAAA,QAAQ,EAAE;AAAZ,KAFH,EAjGqC,CAqGrC;AACA;;AACA,SAAKD,EAAL,CAAS,OAAT,EAAkB,YAAM;AACvB,MAAA,KAAI,CAACL,KAAL,CAAWc,aAAX,CAA0B,aAA1B,EAAyCjB,uBAAzC;AACA,KAFD,EAEG;AAAES,MAAAA,QAAQ,EAAE;AAAZ,KAFH;AAGA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACC,eAAoB;AAAA,UAAfS,OAAe,uEAAL,EAAK;AAAA,8BAC2BA,OAD3B,CACXC,QADW;AAAA,UACXA,QADW,kCACA,MADA;AAAA,0BAC2BD,OAD3B,CACQE,IADR;AAAA,UACQA,IADR,8BACe,OADf;;AAGnB,UAAK,CAAC,KAAKC,mBAAL,CAA0B,CAAEF,QAAF,CAA1B,CAAN,EAAiD;AAChD;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG,cAAM,IAAI9B,aAAJ,CAAmB,sCAAnB,EAA2D,IAA3D,CAAN;AACA;;AAED,UAAMiC,IAAI,GAAG,KAAKnB,KAAL,CAAWoB,QAAX,CAAoBC,OAApB,CAA6BL,QAA7B,CAAb;;AAEA,UAAKC,IAAI,KAAK,OAAT,IAAoB,CAAC,KAAKjB,KAAL,CAAWsB,UAAX,CAAuBH,IAAvB,EAA6B;AAAEI,QAAAA,iBAAiB,EAAE;AAArB,OAA7B,CAA1B,EAAuF;AACtF,eAAO,EAAP;AACA;;AAED,aAAO,KAAKC,SAAL,CAAgBL,IAAhB,EAAsBJ,OAAtB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,mBAAWU,sBAAX,EAAkD;AAAA,UAAfV,OAAe,uEAAL,EAAK;AACjD;AACA,UAAMW,oBAAoB,GAAG,KAAKC,MAAL,CAAaF,sBAAb,EAAqCV,OAArC,CAA7B,CAFiD,CAIjD;;AACA,aAAO,KAAKL,SAAL,CAAekB,MAAf,CAAuBF,oBAAvB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gBAAQD,sBAAR,EAA+C;AAAA,UAAfV,OAAe,uEAAL,EAAK;AAC9C,UAAMP,YAAY,GAAG,KAAKA,YAA1B;AACA,UAAMqB,UAAU,GAAG,KAAKlB,WAAxB,CAF8C,CAI9C;;AACA,WAAKT,MAAL,CAAY4B,aAAZ,GAL8C,CAO9C;;AACA,UAAMC,UAAU,GAAGnC,UAAU,CAACoC,SAAX,CAAsBP,sBAAtB,CAAnB;;AACA,UAAMC,oBAAoB,GAAG,IAAIjC,oBAAJ,CAA0Be,YAA1B,CAA7B;AAEA,WAAKN,MAAL,CAAY+B,YAAZ,CAA0BR,sBAA1B,EAAkDC,oBAAlD,EAX8C,CAa9C;;AACA,WAAKvB,kBAAL,CAAwB+B,aAAxB,CAAsCnB,OAAtC,GAAgDA,OAAhD,CAd8C,CAgB9C;;AACA,WAAKZ,kBAAL,CAAwBgC,aAAxB,CAAuCJ,UAAvC,EAAmDF,UAAnD,EAjB8C,CAmB9C;AACA;AACA;AACA;;AACA,UAAMO,OAAO,GAAGX,sBAAsB,CAACY,EAAvB,CAA2B,kBAA3B,IACfC,KAAK,CAACC,IAAN,CAAYd,sBAAsB,CAACW,OAAnC,CADe,GAEfI,4BAA4B,CAAEf,sBAAF,CAF7B;;AAvB8C,iDA2BfW,OA3Be;AAAA;;AAAA;AA2B9C,4DAAyC;AAAA;AAAA,cAA3BK,IAA2B;AAAA,cAArBC,KAAqB;;AACxC,eAAKvC,kBAAL,CAAwBwC,gBAAxB,CAA0CF,IAA1C,EAAgDC,KAAhD,EAAuDb,UAAvD;AACA,SA7B6C,CA+B9C;;AA/B8C;AAAA;AAAA;AAAA;AAAA;;AAgC9C,aAAO,KAAK1B,kBAAL,CAAwB+B,aAAxB,CAAsCnB,OAA7C;AAEA,aAAOW,oBAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,cAAMkB,IAAN,EAAa;AAAA;;AACZ,UAAK,KAAK5C,KAAL,CAAWoB,QAAX,CAAoByB,OAAzB,EAAmC;AAClC;AACH;AACA;AACA;AACA;AACA;AACA;AACG,cAAM,IAAI3D,aAAJ,CAAmB,wCAAnB,EAA6D,IAA7D,CAAN;AACA;;AAED,UAAI4D,WAAW,GAAG,EAAlB;;AACA,UAAK,OAAOF,IAAP,KAAgB,QAArB,EAAgC;AAC/BE,QAAAA,WAAW,CAACC,IAAZ,GAAmBH,IAAnB,CAD+B,CACN;AACzB,OAFD,MAEO;AACNE,QAAAA,WAAW,GAAGF,IAAd;AACA;;AAED,UAAK,CAAC,KAAK1B,mBAAL,CAA0B8B,MAAM,CAACC,IAAP,CAAaH,WAAb,CAA1B,CAAN,EAA+D;AAC9D;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG,cAAM,IAAI5D,aAAJ,CAAmB,uCAAnB,EAA4D,IAA5D,CAAN;AACA;;AAED,WAAKc,KAAL,CAAWc,aAAX,CAA0B,aAA1B,EAAyC,UAAAoC,MAAM,EAAI;AAClD,wCAAwBF,MAAM,CAACC,IAAP,CAAaH,WAAb,CAAxB,kCAAqD;AAA/C,cAAM9B,QAAQ,mBAAd;;AACL,cAAMmC,SAAS,GAAG,MAAI,CAACnD,KAAL,CAAWoB,QAAX,CAAoBC,OAApB,CAA6BL,QAA7B,CAAlB;;AACAkC,UAAAA,MAAM,CAACE,MAAP,CAAe,MAAI,CAACC,KAAL,CAAYP,WAAW,CAAE9B,QAAF,CAAvB,EAAqCmC,SAArC,CAAf,EAAiEA,SAAjE,EAA4E,CAA5E;AACA;AACD,OALD;AAOA,aAAOG,OAAO,CAACC,OAAR,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,aAAKX,IAAL,EAAY;AAAA;;AACX,UAAIY,OAAO,GAAG,EAAd;;AAEA,UAAK,OAAOZ,IAAP,KAAgB,QAArB,EAAgC;AAC/BY,QAAAA,OAAO,CAACT,IAAR,GAAeH,IAAf,CAD+B,CACV;AACrB,OAFD,MAEO;AACNY,QAAAA,OAAO,GAAGZ,IAAV;AACA;;AAED,UAAK,CAAC,KAAK1B,mBAAL,CAA0B8B,MAAM,CAACC,IAAP,CAAaO,OAAb,CAA1B,CAAN,EAA2D;AAC1D;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG,cAAM,IAAItE,aAAJ,CAAmB,sCAAnB,EAA2D,IAA3D,CAAN;AACA;;AAED,WAAKc,KAAL,CAAWc,aAAX,CAA0B,aAA1B,EAAyC,UAAAoC,MAAM,EAAI;AAClDA,QAAAA,MAAM,CAACO,YAAP,CAAqB,IAArB;AACAP,QAAAA,MAAM,CAACQ,wBAAP,CAAiC,MAAI,CAAC1D,KAAL,CAAWoB,QAAX,CAAoBuC,SAApB,CAA8BC,gBAA9B,EAAjC;;AAEA,0CAAwBZ,MAAM,CAACC,IAAP,CAAaO,OAAb,CAAxB,qCAAiD;AAA3C,cAAMxC,QAAQ,qBAAd;;AACL;AACA,cAAMmC,SAAS,GAAG,MAAI,CAACnD,KAAL,CAAWoB,QAAX,CAAoBC,OAApB,CAA6BL,QAA7B,CAAlB;;AAEAkC,UAAAA,MAAM,CAACW,MAAP,CAAeX,MAAM,CAACY,aAAP,CAAsBX,SAAtB,CAAf;AACAD,UAAAA,MAAM,CAACE,MAAP,CAAe,MAAI,CAACC,KAAL,CAAYG,OAAO,CAAExC,QAAF,CAAnB,EAAiCmC,SAAjC,CAAf,EAA6DA,SAA7D,EAAwE,CAAxE;AACA;AACD,OAXD;AAYA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,eAAOP,IAAP,EAAiC;AAAA,UAApBmB,OAAoB,uEAAV,OAAU;AAChC;AACA,UAAMrC,oBAAoB,GAAG,KAAKhB,SAAL,CAAeiB,MAAf,CAAuBiB,IAAvB,CAA7B,CAFgC,CAIhC;;AACA,aAAO,KAAKoB,OAAL,CAActC,oBAAd,EAAoCqC,OAApC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAASE,qBAAT,EAAoD;AAAA;;AAAA,UAApBF,OAAoB,uEAAV,OAAU;AACnD,aAAO,KAAK/D,KAAL,CAAWkE,MAAX,CAAmB,UAAAhB,MAAM,EAAI;AACnC,eAAO,MAAI,CAAC3C,gBAAL,CAAsB4D,OAAtB,CAA+BF,qBAA/B,EAAsDf,MAAtD,EAA8Da,OAA9D,CAAP;AACA,OAFM,CAAP;AAGA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gCAAwBK,QAAxB,EAAmC;AAClCA,MAAAA,QAAQ,CAAE,KAAKnE,eAAP,CAAR;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,mCAA2BoE,OAA3B,EAAqC;AACpC;AACA,UAAK,KAAK3D,SAAL,IAAkB,KAAKA,SAAL,KAAmB,KAAKD,aAA/C,EAA+D;AAC9D,aAAKC,SAAL,CAAe4D,yBAAf,CAA0CD,OAA1C;AACA;;AAED,WAAK5D,aAAL,CAAmB6D,yBAAnB,CAA8CD,OAA9C;AACA;AAED;AACD;AACA;;;;WACC,mBAAU;AACT,WAAKE,aAAL;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,6BAAqBC,SAArB,EAAiC;AAAA,kDACRA,SADQ;AAAA;;AAAA;AAChC,+DAAoC;AAAA,cAAxBxD,QAAwB;;AACnC,cAAK,CAAC,KAAKhB,KAAL,CAAWoB,QAAX,CAAoBqD,YAApB,GAAmCC,QAAnC,CAA6C1D,QAA7C,CAAN,EAAgE;AAC/D,mBAAO,KAAP;AACA;AACD;AAL+B;AAAA;AAAA;AAAA;AAAA;;AAOhC,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;SAndqBjB,c;AAsdrBf,GAAG,CAAEe,cAAF,EAAkBd,eAAlB,CAAH,C,CAEA;AACA;AACA;AACA;;AACA,SAASuD,4BAAT,CAAuCmC,OAAvC,EAAiD;AAChD,MAAMC,MAAM,GAAG,EAAf;AACA,MAAMC,GAAG,GAAGF,OAAO,CAACxD,IAAR,CAAaC,QAAzB;;AAEA,MAAK,CAACyD,GAAN,EAAY;AACX,WAAO,EAAP;AACA;;AAED,MAAMC,YAAY,GAAGlF,UAAU,CAACoC,SAAX,CAAsB2C,OAAtB,CAArB;;AARgD,8CAU1BE,GAAG,CAAC7E,KAAJ,CAAUoC,OAVgB;AAAA;;AAAA;AAUhD,2DAA0C;AAAA,UAA9B2C,MAA8B;AACzC,UAAMC,YAAY,GAAGF,YAAY,CAACG,eAAb,CAA8BF,MAAM,CAACG,QAAP,EAA9B,CAArB;;AAEA,UAAKF,YAAL,EAAoB;AACnBJ,QAAAA,MAAM,CAACO,IAAP,CAAa,CAAEJ,MAAM,CAACtC,IAAT,EAAeuC,YAAf,CAAb;AACA;AACD;AAhB+C;AAAA;AAAA;AAAA;AAAA;;AAkBhD,SAAOJ,MAAP;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport Mapper from '../conversion/mapper';\n\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText } from '../conversion/downcasthelpers';\n\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\n\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\n\nimport ModelRange from '../model/range';\nimport { autoParagraphEmptyRoots } from '../model/utils/autoparagraphing';\nimport HtmlDataProcessor from '../dataprocessor/htmldataprocessor';\n\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class DataController {\n\t/**\n\t * Creates a data controller instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Data model.\n\t * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n\t */\n\tconstructor( model, stylesProcessor ) {\n\t\t/**\n\t\t * Data model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and\n\t\t * cleared directly after the data are converted. However, the mapper is defined as a class property, because\n\t\t * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/mapper~Mapper}\n\t\t */\n\t\tthis.mapper = new Mapper();\n\n\t\t/**\n\t\t * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n\t\t */\n\t\tthis.downcastDispatcher = new DowncastDispatcher( {\n\t\t\tmapper: this.mapper,\n\t\t\tschema: model.schema\n\t\t} );\n\t\tthis.downcastDispatcher.on( 'insert:$text', insertText(), { priority: 'lowest' } );\n\n\t\t/**\n\t\t * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t\t */\n\t\tthis.upcastDispatcher = new UpcastDispatcher( {\n\t\t\tschema: model.schema\n\t\t} );\n\n\t\t/**\n\t\t * The view document used by the data controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document}\n\t\t */\n\t\tthis.viewDocument = new ViewDocument( stylesProcessor );\n\n\t\t/**\n\t\t * Styles processor used during the conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis.stylesProcessor = stylesProcessor;\n\n\t\t/**\n\t\t * Data processor used specifically for HTML conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #htmlProcessor\n\t\t */\n\t\tthis.htmlProcessor = new HtmlDataProcessor( this.viewDocument );\n\n\t\t/**\n\t\t * Data processor used during the conversion.\n\t\t * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.\n\t\t *\n\t\t * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n\t\t */\n\t\tthis.processor = this.htmlProcessor;\n\n\t\t/**\n\t\t * The view downcast writer just for data conversion purposes, i.e. to modify\n\t\t * the {@link #viewDocument}.\n\t\t *\n\t\t * @private\n\t\t * @readonly\n\t\t * @member {module:engine/view/downcastwriter~DowncastWriter}\n\t\t */\n\t\tthis._viewWriter = new ViewDowncastWriter( this.viewDocument );\n\n\t\t// Define default converters for text and elements.\n\t\t//\n\t\t// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n\t\t// converted to nothing. We therefore add `convertToModelFragment` as a last converter so it converts children of that\n\t\t// element to the document fragment and so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.\n\t\tthis.upcastDispatcher.on( 'text', convertText(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'element', convertToModelFragment(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'documentFragment', convertToModelFragment(), { priority: 'lowest' } );\n\n\t\tthis.decorate( 'init' );\n\t\tthis.decorate( 'set' );\n\n\t\t// Fire the `ready` event when the initialization has completed. Such low-level listener gives possibility\n\t\t// to plug into the initialization pipeline without interrupting the initialization flow.\n\t\tthis.on( 'init', () => {\n\t\t\tthis.fire( 'ready' );\n\t\t}, { priority: 'lowest' } );\n\n\t\t// Fix empty roots after DataController is 'ready' (note that init method could be decorated and stopped).\n\t\t// We need to handle this event because initial data could be empty and post-fixer would not get triggered.\n\t\tthis.on( 'ready', () => {\n\t\t\tthis.model.enqueueChange( 'transparent', autoParagraphEmptyRoots );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n\t * formatted by the {@link #processor data processor}.\n\t *\n\t * @param {Object} [options] Additional configuration for the retrieved data. `DataController` provides two optional\n\t * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.\n\t * @param {String} [options.rootName='main'] Root name.\n\t * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n\t * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n\t * use `'none'`. In such cases exact content will be returned (for example `<p>&nbsp;</p>` for an empty editor).\n\t * @returns {String} Output data.\n\t */\n\tget( options = {} ) {\n\t\tconst { rootName = 'main', trim = 'empty' } = options;\n\n\t\tif ( !this._checkIfRootsExists( [ rootName ] ) ) {\n\t\t\t/**\n\t\t\t * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #get} like:\n\t\t\t *\n\t\t\t *\t\tdata.get( { rootName: 'root2' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-get-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-get-non-existent-root', this );\n\t\t}\n\n\t\tconst root = this.model.document.getRoot( rootName );\n\n\t\tif ( trim === 'empty' && !this.model.hasContent( root, { ignoreWhitespaces: true } ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.stringify( root, options );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n\t * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element whose content will be stringified.\n\t * @param {Object} [options] Additional configuration passed to the conversion process.\n\t * @returns {String} Output data.\n\t */\n\tstringify( modelElementOrFragment, options = {} ) {\n\t\t// Model -> view.\n\t\tconst viewDocumentFragment = this.toView( modelElementOrFragment, options );\n\n\t\t// View -> data.\n\t\treturn this.processor.toData( viewDocumentFragment );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n\t * converters attached to {@link #downcastDispatcher} to a\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {Object} [options={}] Additional configuration that will be available through\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n\t */\n\ttoView( modelElementOrFragment, options = {} ) {\n\t\tconst viewDocument = this.viewDocument;\n\t\tconst viewWriter = this._viewWriter;\n\n\t\t// Clear bindings so the call to this method gives correct results.\n\t\tthis.mapper.clearBindings();\n\n\t\t// First, convert elements.\n\t\tconst modelRange = ModelRange._createIn( modelElementOrFragment );\n\t\tconst viewDocumentFragment = new ViewDocumentFragment( viewDocument );\n\n\t\tthis.mapper.bindElements( modelElementOrFragment, viewDocumentFragment );\n\n\t\t// Make additional options available during conversion process through `conversionApi`.\n\t\tthis.downcastDispatcher.conversionApi.options = options;\n\n\t\t// We have no view controller and rendering to DOM in DataController so view.change() block is not used here.\n\t\tthis.downcastDispatcher.convertInsert( modelRange, viewWriter );\n\n\t\t// Convert markers.\n\t\t// For document fragment, simply take the markers assigned to this document fragment.\n\t\t// For model root, all markers in that root will be taken.\n\t\t// For model element, we need to check which markers are intersecting with this element and relatively modify the markers' ranges.\n\t\tconst markers = modelElementOrFragment.is( 'documentFragment' ) ?\n\t\t\tArray.from( modelElementOrFragment.markers ) :\n\t\t\t_getMarkersRelativeToElement( modelElementOrFragment );\n\n\t\tfor ( const [ name, range ] of markers ) {\n\t\t\tthis.downcastDispatcher.convertMarkerAdd( name, range, viewWriter );\n\t\t}\n\n\t\t// Clean `conversionApi`.\n\t\tdelete this.downcastDispatcher.conversionApi.options;\n\n\t\treturn viewDocumentFragment;\n\t}\n\n\t/**\n\t * Sets initial input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.\n\t *\n\t * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n\t * used by e.g. collaborative editing plugin that syncs remote data on init.\n\t *\n\t * When data is passed as a string it is initialized on a default `main` root:\n\t *\n\t *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root.\n\t *\n\t * To initialize data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on the `main` and `title` roots.\n\t *\n\t * @fires init\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to initialize data on multiple roots at once.\n\t * @returns {Promise} Promise that is resolved after the data is set on the editor.\n\t */\n\tinit( data ) {\n\t\tif ( this.model.document.version ) {\n\t\t\t/**\n\t\t\t * Cannot set initial data to not empty {@link module:engine/model/document~Document}.\n\t\t\t * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,\n\t\t\t * when the {@link module:engine/model/document~Document#version} is equal 0.\n\t\t\t *\n\t\t\t * @error datacontroller-init-document-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-document-not-empty', this );\n\t\t}\n\n\t\tlet initialData = {};\n\t\tif ( typeof data === 'string' ) {\n\t\t\tinitialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n\t\t} else {\n\t\t\tinitialData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( initialData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot init data on a non-existing root. This error is thrown when {@link #init DataController#init() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #init} like:\n\t\t\t *\n\t\t\t * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-init-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-non-existent-root', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\tfor ( const rootName of Object.keys( initialData ) ) {\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\t\t\t\twriter.insert( this.parse( initialData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Sets input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * This method can be used any time to replace existing editor data by the new one without clearing the\n\t * {@link module:engine/model/document~Document#history document history}.\n\t *\n\t * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n\t * the {@link #parse} method.\n\t *\n\t * When data is passed as a string it is set on a default `main` root:\n\t *\n\t *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root.\n\t *\n\t * To set data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots.\n\t *\n\t * @fires set\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to set data on multiple roots at once.\n\t */\n\tset( data ) {\n\t\tlet newData = {};\n\n\t\tif ( typeof data === 'string' ) {\n\t\t\tnewData.main = data; // Default root is 'main'. To set data on a different root, object should be passed.\n\t\t} else {\n\t\t\tnewData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( newData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot set data on a non-existing root. This error is thrown when {@link #set DataController#set() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #set} like:\n\t\t\t *\n\t\t\t * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-set-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-set-non-existent-root', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\twriter.setSelection( null );\n\t\t\twriter.removeSelectionAttribute( this.model.document.selection.getAttributeKeys() );\n\n\t\t\tfor ( const rootName of Object.keys( newData ) ) {\n\t\t\t\t// Save to model.\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\n\t\t\t\twriter.remove( writer.createRangeIn( modelRoot ) );\n\t\t\t\twriter.insert( this.parse( newData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n\t * attached to the {@link #upcastDispatcher}.\n\t *\n\t * @see #set\n\t * @param {String} data Data to parse.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n\t */\n\tparse( data, context = '$root' ) {\n\t\t// data -> view\n\t\tconst viewDocumentFragment = this.processor.toView( data );\n\n\t\t// view -> model\n\t\treturn this.toModel( viewDocumentFragment, context );\n\t}\n\n\t/**\n\t * Returns the result of the given {@link module:engine/view/element~Element view element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n\t * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n\t *\n\t * When marker elements were converted during the conversion process, it will be set as a document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n\t */\n\ttoModel( viewElementOrFragment, context = '$root' ) {\n\t\treturn this.model.change( writer => {\n\t\t\treturn this.upcastDispatcher.convert( viewElementOrFragment, writer, context );\n\t\t} );\n\t}\n\n\t/**\n\t * Adds a style processor normalization rules.\n\t *\n\t * You can implement your own rules as well as use one of the available processor rules:\n\t *\n\t * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n\t * * border: {@link module:engine/view/styles/border~addBorderRules}\n\t * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n\t * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n\t *\n\t * @param {Function} callback\n\t */\n\taddStyleProcessorRules( callback ) {\n\t\tcallback( this.stylesProcessor );\n\t}\n\n\t/**\n\t * Registers a {@link module:engine/view/matcher~MatcherPattern} on {@link #htmlProcessor htmlProcessor}\n\t * and {@link #processor processor} for view elements whose content should be treated as a raw data\n\t * and not processed during conversion from DOM to view elements.\n\t *\n\t * The raw data can be later accessed by {@link module:engine/view/element~Element#getCustomProperty view element custom property}\n\t * `\"$rawContent\"`.\n\t *\n\t * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching all view elements whose content should\n\t * be treated as a raw data.\n\t */\n\tregisterRawContentMatcher( pattern ) {\n\t\t// No need to register the pattern if both `htmlProcessor` and `processor` are the same instances.\n\t\tif ( this.processor && this.processor !== this.htmlProcessor ) {\n\t\t\tthis.processor.registerRawContentMatcher( pattern );\n\t\t}\n\n\t\tthis.htmlProcessor.registerRawContentMatcher( pattern );\n\t}\n\n\t/**\n\t * Removes all event listeners set by the DataController.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Checks if all provided root names are existing editor roots.\n\t *\n\t * @private\n\t * @param {Array.<String>} rootNames Root names to check.\n\t * @returns {Boolean} Whether all provided root names are existing editor roots.\n\t */\n\t_checkIfRootsExists( rootNames ) {\n\t\tfor ( const rootName of rootNames ) {\n\t\t\tif ( !this.model.document.getRootNames().includes( rootName ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Event fired once the data initialization has finished.\n\t *\n\t * @event ready\n\t */\n\n\t/**\n\t * Event fired after the {@link #init `init()` method} was run. It can be {@link #listenTo listened to} in order to adjust or modify\n\t * the initialization flow. However, if the `init` event is stopped or prevented, the {@link #event:ready `ready` event}\n\t * should be fired manually.\n\t *\n\t * The `init` event is fired by the decorated {@link #init} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event init\n\t */\n\n\t/**\n\t * Event fired after {@link #set set() method} has been run.\n\t *\n\t * The `set` event is fired by decorated {@link #set} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event set\n\t */\n}\n\nmix( DataController, ObservableMixin );\n\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it\n// and which markers are containing it. If the marker is intersecting with element, the intersection is returned.\nfunction _getMarkersRelativeToElement( element ) {\n\tconst result = [];\n\tconst doc = element.root.document;\n\n\tif ( !doc ) {\n\t\treturn [];\n\t}\n\n\tconst elementRange = ModelRange._createIn( element );\n\n\tfor ( const marker of doc.model.markers ) {\n\t\tconst intersection = elementRange.getIntersection( marker.getRange() );\n\n\t\tif ( intersection ) {\n\t\t\tresult.push( [ marker.name, intersection ] );\n\t\t}\n\t}\n\n\treturn result;\n}\n"]}]}