{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL29wZXJhdGlvbi91dGlscwogKi8KaW1wb3J0IE5vZGUgZnJvbSAnLi4vbm9kZSc7CmltcG9ydCBUZXh0IGZyb20gJy4uL3RleHQnOwppbXBvcnQgVGV4dFByb3h5IGZyb20gJy4uL3RleHRwcm94eSc7CmltcG9ydCBSYW5nZSBmcm9tICcuLi9yYW5nZSc7CmltcG9ydCBEb2N1bWVudEZyYWdtZW50IGZyb20gJy4uL2RvY3VtZW50ZnJhZ21lbnQnOwppbXBvcnQgTm9kZUxpc3QgZnJvbSAnLi4vbm9kZWxpc3QnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKLyoqCiAqIENvbnRhaW5zIGZ1bmN0aW9ucyB1c2VkIGZvciBjb21wb3NpbmcgbW9kZWwgdHJlZSBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbiBvcGVyYXRpb25zfS4KICogVGhvc2UgZnVuY3Rpb25zIGFyZSBidWlsdCBvbiB0b3Agb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlIG5vZGV9LCBhbmQgaXQncyBjaGlsZCBjbGFzc2VzJywgQVBJcy4KICoKICogQHByb3RlY3RlZAogKiBAbmFtZXNwYWNlIHV0aWxzCiAqLwoKLyoqCiAqIEluc2VydHMgZ2l2ZW4gbm9kZXMgYXQgZ2l2ZW4gcG9zaXRpb24uCiAqCiAqIEBwcm90ZWN0ZWQKICogQGZ1bmN0aW9uIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3V0aWxzfnV0aWxzLmluc2VydAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIGF0IHdoaWNoIG5vZGVzIHNob3VsZCBiZSBpbnNlcnRlZC4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZVNldH0gbm9kZXMgTm9kZXMgdG8gaW5zZXJ0LgogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gUmFuZ2Ugc3Bhbm5pbmcgb3ZlciBpbnNlcnRlZCBlbGVtZW50cy4KICovCgpleHBvcnQgZnVuY3Rpb24gX2luc2VydChwb3NpdGlvbiwgbm9kZXMpIHsKICBub2RlcyA9IF9ub3JtYWxpemVOb2Rlcyhub2Rlcyk7IC8vIFdlIGhhdmUgdG8gY291bnQgb2Zmc2V0IGJlZm9yZSBpbnNlcnRpbmcgbm9kZXMgYmVjYXVzZSB0aGV5IGNhbiBnZXQgbWVyZ2VkIGFuZCB3ZSB3b3VsZCBnZXQgd3Jvbmcgb2Zmc2V0cy4KCiAgdmFyIG9mZnNldCA9IG5vZGVzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBub2RlKSB7CiAgICByZXR1cm4gc3VtICsgbm9kZS5vZmZzZXRTaXplOwogIH0sIDApOwogIHZhciBwYXJlbnQgPSBwb3NpdGlvbi5wYXJlbnQ7IC8vIEluc2VydGlvbiBtaWdodCBiZSBpbiBhIHRleHQgbm9kZSwgd2Ugc2hvdWxkIHNwbGl0IGl0IGlmIHRoYXQncyB0aGUgY2FzZS4KCiAgX3NwbGl0Tm9kZUF0UG9zaXRpb24ocG9zaXRpb24pOwoKICB2YXIgaW5kZXggPSBwb3NpdGlvbi5pbmRleDsgLy8gSW5zZXJ0IG5vZGVzIGF0IGdpdmVuIGluZGV4LiBBZnRlciBzcGxpdHRpbmcgd2UgaGF2ZSBhIHByb3BlciBpbmRleCBhbmQgaW5zZXJ0aW9uIGlzIGJldHdlZW4gbm9kZXMsCiAgLy8gdXNpbmcgYmFzaWMgYEVsZW1lbnRgIEFQSS4KCiAgcGFyZW50Ll9pbnNlcnRDaGlsZChpbmRleCwgbm9kZXMpOyAvLyBNZXJnZSB0ZXh0IG5vZGVzLCBpZiBwb3NzaWJsZS4gTWVyZ2luZyBpcyBuZWVkZWQgb25seSBhdCBwb2ludHMgd2hlcmUgaW5zZXJ0ZWQgbm9kZXMgInRvdWNoIiAib2xkIiBub2Rlcy4KCgogIF9tZXJnZU5vZGVzQXRJbmRleChwYXJlbnQsIGluZGV4ICsgbm9kZXMubGVuZ3RoKTsKCiAgX21lcmdlTm9kZXNBdEluZGV4KHBhcmVudCwgaW5kZXgpOwoKICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uLCBwb3NpdGlvbi5nZXRTaGlmdGVkQnkob2Zmc2V0KSk7Cn0KLyoqCiAqIFJlbW92ZWQgbm9kZXMgaW4gZ2l2ZW4gcmFuZ2UuIE9ubHkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UjaXNGbGF0IGZsYXR9IHJhbmdlcyBhcmUgYWNjZXB0ZWQuCiAqCiAqIEBwcm90ZWN0ZWQKICogQGZ1bmN0aW9uIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3V0aWxzfnV0aWxzLl9yZW1vdmUKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBSYW5nZSBjb250YWluaW5nIG5vZGVzIHRvIHJlbW92ZS4KICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59CiAqLwoKZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmUocmFuZ2UpIHsKICBpZiAoIXJhbmdlLmlzRmxhdCkgewogICAgLyoqCiAgICAgKiBUcnlpbmcgdG8gcmVtb3ZlIGEgcmFuZ2Ugd2hpY2ggc3RhcnRzIGFuZCBlbmRzIGluIGRpZmZlcmVudCBlbGVtZW50LgogICAgICoKICAgICAqIEBlcnJvciBvcGVyYXRpb24tdXRpbHMtcmVtb3ZlLXJhbmdlLW5vdC1mbGF0CiAgICAgKi8KICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdvcGVyYXRpb24tdXRpbHMtcmVtb3ZlLXJhbmdlLW5vdC1mbGF0JywgdGhpcyk7CiAgfQoKICB2YXIgcGFyZW50ID0gcmFuZ2Uuc3RhcnQucGFyZW50OyAvLyBSYW5nZSBtYXkgYmUgaW5zaWRlIHRleHQgbm9kZXMsIHdlIGhhdmUgdG8gc3BsaXQgdGhlbSBpZiB0aGF0J3MgdGhlIGNhc2UuCgogIF9zcGxpdE5vZGVBdFBvc2l0aW9uKHJhbmdlLnN0YXJ0KTsKCiAgX3NwbGl0Tm9kZUF0UG9zaXRpb24ocmFuZ2UuZW5kKTsgLy8gUmVtb3ZlIHRoZSB0ZXh0IG5vZGVzIHVzaW5nIGJhc2ljIGBFbGVtZW50YCBBUEkuCgoKICB2YXIgcmVtb3ZlZCA9IHBhcmVudC5fcmVtb3ZlQ2hpbGRyZW4ocmFuZ2Uuc3RhcnQuaW5kZXgsIHJhbmdlLmVuZC5pbmRleCAtIHJhbmdlLnN0YXJ0LmluZGV4KTsgLy8gTWVyZ2UgdGV4dCBub2RlcywgaWYgcG9zc2libGUuIEFmdGVyIHNvbWUgbm9kZXMgd2VyZSByZW1vdmVkLCBub2RlIGJlZm9yZSBhbmQgYWZ0ZXIgcmVtb3ZlZCByYW5nZSB3aWxsIGJlCiAgLy8gdG91Y2hpbmcgYXQgdGhlIHBvc2l0aW9uIGVxdWFsIHRvIHRoZSByZW1vdmVkIHJhbmdlIGJlZ2lubmluZy4gV2UgY2hlY2sgbWVyZ2luZyBwb3NzaWJpbGl0eSB0aGVyZS4KCgogIF9tZXJnZU5vZGVzQXRJbmRleChwYXJlbnQsIHJhbmdlLnN0YXJ0LmluZGV4KTsKCiAgcmV0dXJuIHJlbW92ZWQ7Cn0KLyoqCiAqIE1vdmVzIG5vZGVzIGluIGdpdmVuIHJhbmdlIHRvIGdpdmVuIHRhcmdldCBwb3NpdGlvbi4gT25seSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNpc0ZsYXQgZmxhdH0gcmFuZ2VzIGFyZSBhY2NlcHRlZC4KICoKICogQHByb3RlY3RlZAogKiBAZnVuY3Rpb24gbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdXRpbHN+dXRpbHMubW92ZQogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHNvdXJjZVJhbmdlIFJhbmdlIGNvbnRhaW5pbmcgbm9kZXMgdG8gbW92ZS4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSB0YXJnZXRQb3NpdGlvbiBQb3NpdGlvbiB0byB3aGljaCBub2RlcyBzaG91bGQgYmUgbW92ZWQuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBSYW5nZSBjb250YWluaW5nIG1vdmVkIG5vZGVzLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBfbW92ZShzb3VyY2VSYW5nZSwgdGFyZ2V0UG9zaXRpb24pIHsKICBpZiAoIXNvdXJjZVJhbmdlLmlzRmxhdCkgewogICAgLyoqCiAgICAgKiBUcnlpbmcgdG8gbW92ZSBhIHJhbmdlIHdoaWNoIHN0YXJ0cyBhbmQgZW5kcyBpbiBkaWZmZXJlbnQgZWxlbWVudC4KICAgICAqCiAgICAgKiBAZXJyb3Igb3BlcmF0aW9uLXV0aWxzLW1vdmUtcmFuZ2Utbm90LWZsYXQKICAgICAqLwogICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ29wZXJhdGlvbi11dGlscy1tb3ZlLXJhbmdlLW5vdC1mbGF0JywgdGhpcyk7CiAgfQoKICB2YXIgbm9kZXMgPSBfcmVtb3ZlKHNvdXJjZVJhbmdlKTsgLy8gV2UgaGF2ZSB0byBmaXggYHRhcmdldFBvc2l0aW9uYCBiZWNhdXNlIG1vZGVsIGNoYW5nZWQgYWZ0ZXIgbm9kZXMgZnJvbSBgc291cmNlUmFuZ2VgIGdvdCByZW1vdmVkIGFuZAogIC8vIHRoYXQgY2hhbmdlIG1pZ2h0IGhhdmUgYW4gaW1wYWN0IG9uIGB0YXJnZXRQb3NpdGlvbmAuCgoKICB0YXJnZXRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oc291cmNlUmFuZ2Uuc3RhcnQsIHNvdXJjZVJhbmdlLmVuZC5vZmZzZXQgLSBzb3VyY2VSYW5nZS5zdGFydC5vZmZzZXQpOwogIHJldHVybiBfaW5zZXJ0KHRhcmdldFBvc2l0aW9uLCBub2Rlcyk7Cn0KLyoqCiAqIFNldHMgZ2l2ZW4gYXR0cmlidXRlIG9uIG5vZGVzIGluIGdpdmVuIHJhbmdlLiBUaGUgYXR0cmlidXRlcyBhcmUgb25seSBzZXQgb24gdG9wLWxldmVsIG5vZGVzIG9mIHRoZSByYW5nZSwgbm90IG9uIGl0cyBjaGlsZHJlbi4KICoKICogQHByb3RlY3RlZAogKiBAZnVuY3Rpb24gbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdXRpbHN+dXRpbHMuX3NldEF0dHJpYnV0ZQogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIGNvbnRhaW5pbmcgbm9kZXMgdGhhdCBzaG91bGQgaGF2ZSB0aGUgYXR0cmlidXRlIHNldC4gTXVzdCBiZSBhIGZsYXQgcmFuZ2UuCiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG9mIGF0dHJpYnV0ZSB0byBzZXQuCiAqIEBwYXJhbSB7Kn0gdmFsdWUgQXR0cmlidXRlIHZhbHVlLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBfc2V0QXR0cmlidXRlKHJhbmdlLCBrZXksIHZhbHVlKSB7CiAgLy8gUmFuZ2UgbWlnaHQgc3RhcnQgb3IgZW5kIGluIHRleHQgbm9kZXMsIHNvIHdlIGhhdmUgdG8gc3BsaXQgdGhlbS4KICBfc3BsaXROb2RlQXRQb3NpdGlvbihyYW5nZS5zdGFydCk7CgogIF9zcGxpdE5vZGVBdFBvc2l0aW9uKHJhbmdlLmVuZCk7IC8vIEl0ZXJhdGUgb3ZlciBhbGwgaXRlbXMgaW4gdGhlIHJhbmdlLgoKCiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJhbmdlLmdldEl0ZW1zKHsKICAgIHNoYWxsb3c6IHRydWUKICB9KSksCiAgICAgIF9zdGVwOwoKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgdmFyIGl0ZW0gPSBfc3RlcC52YWx1ZTsKICAgICAgLy8gSXRlcmF0b3Igd2lsbCByZXR1cm4gYFRleHRQcm94eWAgaW5zdGFuY2VzIGJ1dCB3ZSBrbm93IHRoYXQgdGhvc2UgdGV4dCBwcm94aWVzIHdpbGwKICAgICAgLy8gYWx3YXlzIHJlcHJlc2VudCBmdWxsIHRleHQgbm9kZXMgKHRoaXMgaXMgZ3VhcmFudGVlZCB0aGFua3MgdG8gc3BsaXR0aW5nIHdlIGRpZCBiZWZvcmUpLgogICAgICAvLyBTbywgd2UgY2FuIG9wZXJhdGUgb24gdGhvc2UgdGV4dCBwcm94aWVzJyB0ZXh0IG5vZGVzLgogICAgICB2YXIgbm9kZSA9IGl0ZW0uaXMoJyR0ZXh0UHJveHknKSA/IGl0ZW0udGV4dE5vZGUgOiBpdGVtOwoKICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7CiAgICAgICAgbm9kZS5fc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpOwogICAgICB9IGVsc2UgewogICAgICAgIG5vZGUuX3JlbW92ZUF0dHJpYnV0ZShrZXkpOwogICAgICB9IC8vIEFmdGVyIGF0dHJpYnV0ZXMgY2hhbmdpbmcgaXQgbWF5IGhhcHBlbiB0aGF0IHNvbWUgdGV4dCBub2RlcyBjYW4gYmUgbWVyZ2VkLiBUcnkgdG8gbWVyZ2Ugd2l0aCBwcmV2aW91cyBub2RlLgoKCiAgICAgIF9tZXJnZU5vZGVzQXRJbmRleChub2RlLnBhcmVudCwgbm9kZS5pbmRleCk7CiAgICB9IC8vIFRyeSB0byBtZXJnZSBsYXN0IGNoYW5nZWQgbm9kZSB3aXRoIGl0J3MgcHJldmlvdXMgc2libGluZyAobm90IGNvdmVyZWQgYnkgdGhlIGxvb3AgYWJvdmUpLgoKICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvci5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvci5mKCk7CiAgfQoKICBfbWVyZ2VOb2Rlc0F0SW5kZXgocmFuZ2UuZW5kLnBhcmVudCwgcmFuZ2UuZW5kLmluZGV4KTsKfQovKioKICogTm9ybWFsaXplcyBnaXZlbiBvYmplY3Qgb3IgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBhbiBhcnJheSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUgbm9kZXN9LiBTZWUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlU2V0IE5vZGVTZXR9IGZvciBkZXRhaWxzIG9uIGhvdyBub3JtYWxpemF0aW9uIGlzIHBlcmZvcm1lZC4KICoKICogQHByb3RlY3RlZAogKiBAZnVuY3Rpb24gbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdXRpbHN+dXRpbHMubm9ybWFsaXplTm9kZXMKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZVNldH0gbm9kZXMgT2JqZWN0cyB0byBub3JtYWxpemUuCiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fSBOb3JtYWxpemVkIG5vZGVzLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBfbm9ybWFsaXplTm9kZXMobm9kZXMpIHsKICB2YXIgbm9ybWFsaXplZCA9IFtdOwoKICBpZiAoIShub2RlcyBpbnN0YW5jZW9mIEFycmF5KSkgewogICAgbm9kZXMgPSBbbm9kZXNdOwogIH0gLy8gQ29udmVydCBpbnN0YW5jZXMgb2YgY2xhc3NlcyBvdGhlciB0aGFuIE5vZGUuCgoKICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7CiAgICBpZiAodHlwZW9mIG5vZGVzW2ldID09ICdzdHJpbmcnKSB7CiAgICAgIG5vcm1hbGl6ZWQucHVzaChuZXcgVGV4dChub2Rlc1tpXSkpOwogICAgfSBlbHNlIGlmIChub2Rlc1tpXSBpbnN0YW5jZW9mIFRleHRQcm94eSkgewogICAgICBub3JtYWxpemVkLnB1c2gobmV3IFRleHQobm9kZXNbaV0uZGF0YSwgbm9kZXNbaV0uZ2V0QXR0cmlidXRlcygpKSk7CiAgICB9IGVsc2UgaWYgKG5vZGVzW2ldIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCBub2Rlc1tpXSBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7CiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobm9kZXNbaV0pLAogICAgICAgICAgX3N0ZXAyOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAyLnZhbHVlOwogICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGNoaWxkKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjIuZigpOwogICAgICB9CiAgICB9IGVsc2UgaWYgKG5vZGVzW2ldIGluc3RhbmNlb2YgTm9kZSkgewogICAgICBub3JtYWxpemVkLnB1c2gobm9kZXNbaV0pOwogICAgfSAvLyBTa2lwIHVucmVjb2duaXplZCB0eXBlLgoKICB9IC8vIE1lcmdlIHRleHQgbm9kZXMuCgoKICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgbm9ybWFsaXplZC5sZW5ndGg7IF9pKyspIHsKICAgIHZhciBub2RlID0gbm9ybWFsaXplZFtfaV07CiAgICB2YXIgcHJldiA9IG5vcm1hbGl6ZWRbX2kgLSAxXTsKCiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRleHQgJiYgcHJldiBpbnN0YW5jZW9mIFRleHQgJiYgX2hhdmVTYW1lQXR0cmlidXRlcyhub2RlLCBwcmV2KSkgewogICAgICAvLyBEb2luZyB0aGlzIGluc3RlYWQgY2hhbmdpbmcgYHByZXYuZGF0YWAgYmVjYXVzZSBgZGF0YWAgaXMgcmVhZG9ubHkuCiAgICAgIG5vcm1hbGl6ZWQuc3BsaWNlKF9pIC0gMSwgMiwgbmV3IFRleHQocHJldi5kYXRhICsgbm9kZS5kYXRhLCBwcmV2LmdldEF0dHJpYnV0ZXMoKSkpOwogICAgICBfaS0tOwogICAgfQogIH0KCiAgcmV0dXJuIG5vcm1hbGl6ZWQ7Cn0gLy8gQ2hlY2tzIGlmIG5vZGVzIGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4gaW5kZXggaW4gZ2l2ZW4gZWxlbWVudCBhcmUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0IHRleHQgbm9kZXN9IGFuZAovLyBtZXJnZXMgdGhlbSBpbnRvIG9uZSBub2RlIGlmIHRoZXkgaGF2ZSBzYW1lIGF0dHJpYnV0ZXMuCi8vCi8vIE1lcmdpbmcgaXMgZG9uZSBieSByZW1vdmluZyB0d28gdGV4dCBub2RlcyBhbmQgaW5zZXJ0aW5nIGEgbmV3IHRleHQgbm9kZSBjb250YWluaW5nIGRhdGEgZnJvbSBib3RoIG1lcmdlZCB0ZXh0IG5vZGVzLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IFBhcmVudCBlbGVtZW50IG9mIG5vZGVzIHRvIG1lcmdlLgovLyBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggYmV0d2VlbiBub2RlcyB0byBtZXJnZS4KCmZ1bmN0aW9uIF9tZXJnZU5vZGVzQXRJbmRleChlbGVtZW50LCBpbmRleCkgewogIHZhciBub2RlQmVmb3JlID0gZWxlbWVudC5nZXRDaGlsZChpbmRleCAtIDEpOwogIHZhciBub2RlQWZ0ZXIgPSBlbGVtZW50LmdldENoaWxkKGluZGV4KTsgLy8gQ2hlY2sgaWYgYm90aCBvZiB0aG9zZSBub2RlcyBhcmUgdGV4dCBvYmplY3RzIHdpdGggc2FtZSBhdHRyaWJ1dGVzLgoKICBpZiAobm9kZUJlZm9yZSAmJiBub2RlQWZ0ZXIgJiYgbm9kZUJlZm9yZS5pcygnJHRleHQnKSAmJiBub2RlQWZ0ZXIuaXMoJyR0ZXh0JykgJiYgX2hhdmVTYW1lQXR0cmlidXRlcyhub2RlQmVmb3JlLCBub2RlQWZ0ZXIpKSB7CiAgICAvLyBBcHBlbmQgdGV4dCBvZiB0ZXh0IG5vZGUgYWZ0ZXIgaW5kZXggdG8gdGhlIGJlZm9yZSBvbmUuCiAgICB2YXIgbWVyZ2VkTm9kZSA9IG5ldyBUZXh0KG5vZGVCZWZvcmUuZGF0YSArIG5vZGVBZnRlci5kYXRhLCBub2RlQmVmb3JlLmdldEF0dHJpYnV0ZXMoKSk7IC8vIFJlbW92ZSBzZXBhcmF0ZSB0ZXh0IG5vZGVzLgoKICAgIGVsZW1lbnQuX3JlbW92ZUNoaWxkcmVuKGluZGV4IC0gMSwgMik7IC8vIEluc2VydCBtZXJnZWQgdGV4dCBub2RlLgoKCiAgICBlbGVtZW50Ll9pbnNlcnRDaGlsZChpbmRleCAtIDEsIG1lcmdlZE5vZGUpOwogIH0KfSAvLyBDaGVja3MgaWYgZ2l2ZW4gcG9zaXRpb24gaXMgaW4gYSB0ZXh0IG5vZGUsIGFuZCBpZiBzbywgc3BsaXRzIHRoZSB0ZXh0IG5vZGUgaW4gdHdvIHRleHQgbm9kZXMsIGVhY2ggb2YgdGhlbQovLyBjb250YWluaW5nIGEgcGFydCBvZiBvcmlnaW5hbCB0ZXh0IG5vZGUuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gYXQgd2hpY2ggbm9kZSBzaG91bGQgYmUgc3BsaXQuCgoKZnVuY3Rpb24gX3NwbGl0Tm9kZUF0UG9zaXRpb24ocG9zaXRpb24pIHsKICB2YXIgdGV4dE5vZGUgPSBwb3NpdGlvbi50ZXh0Tm9kZTsKICB2YXIgZWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgaWYgKHRleHROb2RlKSB7CiAgICB2YXIgb2Zmc2V0RGlmZiA9IHBvc2l0aW9uLm9mZnNldCAtIHRleHROb2RlLnN0YXJ0T2Zmc2V0OwogICAgdmFyIGluZGV4ID0gdGV4dE5vZGUuaW5kZXg7CgogICAgZWxlbWVudC5fcmVtb3ZlQ2hpbGRyZW4oaW5kZXgsIDEpOwoKICAgIHZhciBmaXJzdFBhcnQgPSBuZXcgVGV4dCh0ZXh0Tm9kZS5kYXRhLnN1YnN0cigwLCBvZmZzZXREaWZmKSwgdGV4dE5vZGUuZ2V0QXR0cmlidXRlcygpKTsKICAgIHZhciBzZWNvbmRQYXJ0ID0gbmV3IFRleHQodGV4dE5vZGUuZGF0YS5zdWJzdHIob2Zmc2V0RGlmZiksIHRleHROb2RlLmdldEF0dHJpYnV0ZXMoKSk7CgogICAgZWxlbWVudC5faW5zZXJ0Q2hpbGQoaW5kZXgsIFtmaXJzdFBhcnQsIHNlY29uZFBhcnRdKTsKICB9Cn0gLy8gQ2hlY2tzIHdoZXRoZXIgdHdvIGdpdmVuIG5vZGVzIGhhdmUgc2FtZSBhdHRyaWJ1dGVzLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlQSBOb2RlIHRvIGNoZWNrLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlQiBOb2RlIHRvIGNoZWNrLgovLyBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIG5vZGVzIGhhdmUgc2FtZSBhdHRyaWJ1dGVzLCBgZmFsc2VgIG90aGVyd2lzZS4KCgpmdW5jdGlvbiBfaGF2ZVNhbWVBdHRyaWJ1dGVzKG5vZGVBLCBub2RlQikgewogIHZhciBpdGVyYXRvckEgPSBub2RlQS5nZXRBdHRyaWJ1dGVzKCk7CiAgdmFyIGl0ZXJhdG9yQiA9IG5vZGVCLmdldEF0dHJpYnV0ZXMoKTsKCiAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVyYXRvckEpLAogICAgICBfc3RlcDM7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykgewogICAgICB2YXIgYXR0ciA9IF9zdGVwMy52YWx1ZTsKCiAgICAgIGlmIChhdHRyWzFdICE9PSBub2RlQi5nZXRBdHRyaWJ1dGUoYXR0clswXSkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIGl0ZXJhdG9yQi5uZXh0KCk7CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3IzLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yMy5mKCk7CiAgfQoKICByZXR1cm4gaXRlcmF0b3JCLm5leHQoKS5kb25lOwp9Ci8qKgogKiBWYWx1ZSB0aGF0IGNhbiBiZSBub3JtYWxpemVkIHRvIGFuIGFycmF5IG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSBub2Rlc30uCiAqCiAqIE5vbi1hcnJheXMgYXJlIG5vcm1hbGl6ZWQgYXMgZm9sbG93czoKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUgTm9kZX0gaXMgbGVmdCBhcyBpcywKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5IFRleHRQcm94eX0gYW5kIGBTdHJpbmdgIGFyZSBub3JtYWxpemVkIHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCBUZXh0fSwKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2RlbGlzdH5Ob2RlTGlzdCBOb2RlTGlzdH0gaXMgbm9ybWFsaXplZCB0byBhbiBhcnJheSBjb250YWluaW5nIGFsbCBub2RlcyB0aGF0IGFyZSBpbiB0aGF0IG5vZGUgbGlzdCwKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgRG9jdW1lbnRGcmFnbWVudH0gaXMgbm9ybWFsaXplZCB0byBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiBpdCdzCiAqICogY2hpbGRyZW4uCiAqCiAqIEFycmF5cyBhcmUgcHJvY2Vzc2VkIGl0ZW0gYnkgaXRlbSBsaWtlIG5vbi1hcnJheSB2YWx1ZXMgYW5kIGZsYXR0ZW5lZCB0byBvbmUgYXJyYXkuIE5vcm1hbGl6YXRpb24gYWx3YXlzIHJlc3VsdHMgaW4KICogYSBmbGF0IGFycmF5IG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSBub2Rlc30uIENvbnNlY3V0aXZlIHRleHQgbm9kZXMgKG9yIGl0ZW1zIG5vcm1hbGl6ZWQgdG8gdGV4dCBub2Rlcykgd2lsbCBiZQogKiBtZXJnZWQgaWYgdGhleSBoYXZlIHNhbWUgYXR0cmlidXRlcy4KICoKICogQHR5cGVkZWYge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eXxTdHJpbmd8CiAqIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZWxpc3R+Tm9kZUxpc3R8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8SXRlcmFibGV9CiAqIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlU2V0CiAqLw=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js"],"names":["Node","Text","TextProxy","Range","DocumentFragment","NodeList","CKEditorError","_insert","position","nodes","_normalizeNodes","offset","reduce","sum","node","offsetSize","parent","_splitNodeAtPosition","index","_insertChild","_mergeNodesAtIndex","length","getShiftedBy","_remove","range","isFlat","start","end","removed","_removeChildren","_move","sourceRange","targetPosition","_getTransformedByDeletion","_setAttribute","key","value","getItems","shallow","item","is","textNode","_removeAttribute","normalized","Array","i","push","data","getAttributes","child","prev","_haveSameAttributes","splice","element","nodeBefore","getChild","nodeAfter","mergedNode","offsetDiff","startOffset","firstPart","substr","secondPart","nodeA","nodeB","iteratorA","iteratorB","attr","getAttribute","next","done"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/utils\n */\n\nimport Node from '../node';\nimport Text from '../text';\nimport TextProxy from '../textproxy';\nimport Range from '../range';\nimport DocumentFragment from '../documentfragment';\nimport NodeList from '../nodelist';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.\n * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.\n *\n * @protected\n * @namespace utils\n */\n\n/**\n * Inserts given nodes at given position.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.insert\n * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.\n * @param {module:engine/model/node~NodeSet} nodes Nodes to insert.\n * @returns {module:engine/model/range~Range} Range spanning over inserted elements.\n */\nexport function _insert( position, nodes ) {\n\tnodes = _normalizeNodes( nodes );\n\n\t// We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.\n\tconst offset = nodes.reduce( ( sum, node ) => sum + node.offsetSize, 0 );\n\tconst parent = position.parent;\n\n\t// Insertion might be in a text node, we should split it if that's the case.\n\t_splitNodeAtPosition( position );\n\tconst index = position.index;\n\n\t// Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,\n\t// using basic `Element` API.\n\tparent._insertChild( index, nodes );\n\n\t// Merge text nodes, if possible. Merging is needed only at points where inserted nodes \"touch\" \"old\" nodes.\n\t_mergeNodesAtIndex( parent, index + nodes.length );\n\t_mergeNodesAtIndex( parent, index );\n\n\treturn new Range( position, position.getShiftedBy( offset ) );\n}\n\n/**\n * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._remove\n * @param {module:engine/model/range~Range} range Range containing nodes to remove.\n * @returns {Array.<module:engine/model/node~Node>}\n */\nexport function _remove( range ) {\n\tif ( !range.isFlat ) {\n\t\t/**\n\t\t * Trying to remove a range which starts and ends in different element.\n\t\t *\n\t\t * @error operation-utils-remove-range-not-flat\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'operation-utils-remove-range-not-flat',\n\t\t\tthis\n\t\t);\n\t}\n\n\tconst parent = range.start.parent;\n\n\t// Range may be inside text nodes, we have to split them if that's the case.\n\t_splitNodeAtPosition( range.start );\n\t_splitNodeAtPosition( range.end );\n\n\t// Remove the text nodes using basic `Element` API.\n\tconst removed = parent._removeChildren( range.start.index, range.end.index - range.start.index );\n\n\t// Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be\n\t// touching at the position equal to the removed range beginning. We check merging possibility there.\n\t_mergeNodesAtIndex( parent, range.start.index );\n\n\treturn removed;\n}\n\n/**\n * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.move\n * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.\n * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.\n * @returns {module:engine/model/range~Range} Range containing moved nodes.\n */\nexport function _move( sourceRange, targetPosition ) {\n\tif ( !sourceRange.isFlat ) {\n\t\t/**\n\t\t * Trying to move a range which starts and ends in different element.\n\t\t *\n\t\t * @error operation-utils-move-range-not-flat\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'operation-utils-move-range-not-flat',\n\t\t\tthis\n\t\t);\n\t}\n\n\tconst nodes = _remove( sourceRange );\n\n\t// We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and\n\t// that change might have an impact on `targetPosition`.\n\ttargetPosition = targetPosition._getTransformedByDeletion( sourceRange.start, sourceRange.end.offset - sourceRange.start.offset );\n\n\treturn _insert( targetPosition, nodes );\n}\n\n/**\n * Sets given attribute on nodes in given range. The attributes are only set on top-level nodes of the range, not on its children.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._setAttribute\n * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set. Must be a flat range.\n * @param {String} key Key of attribute to set.\n * @param {*} value Attribute value.\n */\nexport function _setAttribute( range, key, value ) {\n\t// Range might start or end in text nodes, so we have to split them.\n\t_splitNodeAtPosition( range.start );\n\t_splitNodeAtPosition( range.end );\n\n\t// Iterate over all items in the range.\n\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t// Iterator will return `TextProxy` instances but we know that those text proxies will\n\t\t// always represent full text nodes (this is guaranteed thanks to splitting we did before).\n\t\t// So, we can operate on those text proxies' text nodes.\n\t\tconst node = item.is( '$textProxy' ) ? item.textNode : item;\n\n\t\tif ( value !== null ) {\n\t\t\tnode._setAttribute( key, value );\n\t\t} else {\n\t\t\tnode._removeAttribute( key );\n\t\t}\n\n\t\t// After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.\n\t\t_mergeNodesAtIndex( node.parent, node.index );\n\t}\n\n\t// Try to merge last changed node with it's previous sibling (not covered by the loop above).\n\t_mergeNodesAtIndex( range.end.parent, range.end.index );\n}\n\n/**\n * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See\n * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.normalizeNodes\n * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.\n * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.\n */\nexport function _normalizeNodes( nodes ) {\n\tconst normalized = [];\n\n\tif ( !( nodes instanceof Array ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Convert instances of classes other than Node.\n\tfor ( let i = 0; i < nodes.length; i++ ) {\n\t\tif ( typeof nodes[ i ] == 'string' ) {\n\t\t\tnormalized.push( new Text( nodes[ i ] ) );\n\t\t} else if ( nodes[ i ] instanceof TextProxy ) {\n\t\t\tnormalized.push( new Text( nodes[ i ].data, nodes[ i ].getAttributes() ) );\n\t\t} else if ( nodes[ i ] instanceof DocumentFragment || nodes[ i ] instanceof NodeList ) {\n\t\t\tfor ( const child of nodes[ i ] ) {\n\t\t\t\tnormalized.push( child );\n\t\t\t}\n\t\t} else if ( nodes[ i ] instanceof Node ) {\n\t\t\tnormalized.push( nodes[ i ] );\n\t\t}\n\t\t// Skip unrecognized type.\n\t}\n\n\t// Merge text nodes.\n\tfor ( let i = 1; i < normalized.length; i++ ) {\n\t\tconst node = normalized[ i ];\n\t\tconst prev = normalized[ i - 1 ];\n\n\t\tif ( node instanceof Text && prev instanceof Text && _haveSameAttributes( node, prev ) ) {\n\t\t\t// Doing this instead changing `prev.data` because `data` is readonly.\n\t\t\tnormalized.splice( i - 1, 2, new Text( prev.data + node.data, prev.getAttributes() ) );\n\t\t\ti--;\n\t\t}\n\t}\n\n\treturn normalized;\n}\n\n// Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and\n// merges them into one node if they have same attributes.\n//\n// Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.\n//\n// @private\n// @param {module:engine/model/element~Element} element Parent element of nodes to merge.\n// @param {Number} index Index between nodes to merge.\nfunction _mergeNodesAtIndex( element, index ) {\n\tconst nodeBefore = element.getChild( index - 1 );\n\tconst nodeAfter = element.getChild( index );\n\n\t// Check if both of those nodes are text objects with same attributes.\n\tif ( nodeBefore && nodeAfter && nodeBefore.is( '$text' ) && nodeAfter.is( '$text' ) && _haveSameAttributes( nodeBefore, nodeAfter ) ) {\n\t\t// Append text of text node after index to the before one.\n\t\tconst mergedNode = new Text( nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes() );\n\n\t\t// Remove separate text nodes.\n\t\telement._removeChildren( index - 1, 2 );\n\n\t\t// Insert merged text node.\n\t\telement._insertChild( index - 1, mergedNode );\n\t}\n}\n\n// Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them\n// containing a part of original text node.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position at which node should be split.\nfunction _splitNodeAtPosition( position ) {\n\tconst textNode = position.textNode;\n\tconst element = position.parent;\n\n\tif ( textNode ) {\n\t\tconst offsetDiff = position.offset - textNode.startOffset;\n\t\tconst index = textNode.index;\n\n\t\telement._removeChildren( index, 1 );\n\n\t\tconst firstPart = new Text( textNode.data.substr( 0, offsetDiff ), textNode.getAttributes() );\n\t\tconst secondPart = new Text( textNode.data.substr( offsetDiff ), textNode.getAttributes() );\n\n\t\telement._insertChild( index, [ firstPart, secondPart ] );\n\t}\n}\n\n// Checks whether two given nodes have same attributes.\n//\n// @private\n// @param {module:engine/model/node~Node} nodeA Node to check.\n// @param {module:engine/model/node~Node} nodeB Node to check.\n// @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.\nfunction _haveSameAttributes( nodeA, nodeB ) {\n\tconst iteratorA = nodeA.getAttributes();\n\tconst iteratorB = nodeB.getAttributes();\n\n\tfor ( const attr of iteratorA ) {\n\t\tif ( attr[ 1 ] !== nodeB.getAttribute( attr[ 0 ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\titeratorB.next();\n\t}\n\n\treturn iteratorB.next().done;\n}\n\n/**\n * Value that can be normalized to an array of {@link module:engine/model/node~Node nodes}.\n *\n * Non-arrays are normalized as follows:\n * * {@link module:engine/model/node~Node Node} is left as is,\n * * {@link module:engine/model/textproxy~TextProxy TextProxy} and `String` are normalized to {@link module:engine/model/text~Text Text},\n * * {@link module:engine/model/nodelist~NodeList NodeList} is normalized to an array containing all nodes that are in that node list,\n * * {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment} is normalized to an array containing all of it's\n * * children.\n *\n * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in\n * a flat array of {@link module:engine/model/node~Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be\n * merged if they have same attributes.\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/textproxy~TextProxy|String|\n * module:engine/model/nodelist~NodeList|module:engine/model/documentfragment~DocumentFragment|Iterable}\n * module:engine/model/node~NodeSet\n */\n"]}]}