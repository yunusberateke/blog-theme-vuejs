{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheSI7CmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZW50cmllcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbmQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS92aWV3L3N0eWxlc21hcAogKi8KaW1wb3J0IHsgZ2V0LCBpc09iamVjdCwgbWVyZ2UsIHNldCwgdW5zZXQgfSBmcm9tICdsb2Rhc2gtZXMnOwovKioKICogU3R5bGVzIG1hcC4gQWxsb3dzIGhhbmRsaW5nIChhZGRpbmcsIHJlbW92aW5nLCByZXRyaWV2aW5nKSBhIHNldCBvZiBzdHlsZSBydWxlcyAodXN1YWxseSwgb2YgYW4gZWxlbWVudCkuCiAqCiAqIFRoZSBzdHlsZXMgbWFwIGlzIGNhcGFibGUgb2Ygbm9ybWFsaXppbmcgc3R5bGUgbmFtZXMgc28gZS5nLiB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlIHBvc3NpYmxlOgogKi8KCnZhciBTdHlsZXNNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgU3R5bGVzIGluc3RhbmNlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzbWFwflN0eWxlc1Byb2Nlc3Nvcn0gc3R5bGVQcm9jZXNzb3IKICAgKi8KICBmdW5jdGlvbiBTdHlsZXNNYXAoc3R5bGVQcm9jZXNzb3IpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZXNNYXApOwoKICAgIC8qKgogICAgICogS2VlcHMgYW4gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2Ygc3R5bGVzIG1hcC4gTm9ybWFsaXplZCBzdHlsZXMgYXJlIGtlcHQgYXMgb2JqZWN0IHRyZWUgdG8gYWxsb3cgdW5pZmllZCBtb2RpZmljYXRpb24gYW5kCiAgICAgKiB2YWx1ZSBhY2Nlc3MgbW9kZWwgdXNpbmcgbG9kYXNoJ3MgZ2V0LCBzZXQsIHVuc2V0LCBldGMgbWV0aG9kcy4KICAgICAqCiAgICAgKiBXaGVuIG5vIHN0eWxlIHByb2Nlc3NvciBydWxlcyBhcmUgZGVmaW5lZCB0aGUgaXQgYWN0cyBhcyBzaW1wbGUga2V5LXZhbHVlIHN0b3JhZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtPYmplY3R9CiAgICAgKi8KICAgIHRoaXMuX3N0eWxlcyA9IHt9OwogICAgLyoqCiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+U3R5bGVzUHJvY2Vzc29yfS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS92aWV3L3N0eWxlc21hcH5TdHlsZXNQcm9jZXNzb3J9CiAgICAgKi8KCiAgICB0aGlzLl9zdHlsZVByb2Nlc3NvciA9IHN0eWxlUHJvY2Vzc29yOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHRydWUgaWYgc3R5bGUgbWFwIGhhcyBubyBzdHlsZXMgc2V0LgogICAqCiAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoU3R5bGVzTWFwLCBbewogICAga2V5OiAiaXNFbXB0eSIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLl9zdHlsZXMpOwogICAgICB2YXIgZnJvbSA9IEFycmF5LmZyb20oZW50cmllcyk7CiAgICAgIHJldHVybiAhZnJvbS5sZW5ndGg7CiAgICB9CiAgICAvKioKICAgICAqIE51bWJlciBvZiBzdHlsZXMgZGVmaW5lZC4KICAgICAqCiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogIH0sIHsKICAgIGtleTogInNpemUiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHsKICAgICAgICByZXR1cm4gMDsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVOYW1lcygpLmxlbmd0aDsKICAgIH0KICAgIC8qKgogICAgICogU2V0IHN0eWxlcyBtYXAgdG8gYSBuZXcgdmFsdWUuCiAgICAgKgogICAgICoJCXN0eWxlcy5zZXRUbyggJ2JvcmRlcjoxcHggc29saWQgYmx1ZTttYXJnaW4tdG9wOjFweDsnICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGlubGluZVN0eWxlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0VG8iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRvKGlubGluZVN0eWxlKSB7CiAgICAgIHRoaXMuY2xlYXIoKTsKICAgICAgdmFyIHBhcnNlZFN0eWxlcyA9IEFycmF5LmZyb20ocGFyc2VJbmxpbmVTdHlsZXMoaW5saW5lU3R5bGUpLmVudHJpZXMoKSk7CgogICAgICBmb3IgKHZhciBfaSA9IDAsIF9wYXJzZWRTdHlsZXMgPSBwYXJzZWRTdHlsZXM7IF9pIDwgX3BhcnNlZFN0eWxlcy5sZW5ndGg7IF9pKyspIHsKICAgICAgICB2YXIgX3BhcnNlZFN0eWxlcyRfaSA9IF9zbGljZWRUb0FycmF5KF9wYXJzZWRTdHlsZXNbX2ldLCAyKSwKICAgICAgICAgICAga2V5ID0gX3BhcnNlZFN0eWxlcyRfaVswXSwKICAgICAgICAgICAgdmFsdWUgPSBfcGFyc2VkU3R5bGVzJF9pWzFdOwoKICAgICAgICB0aGlzLl9zdHlsZVByb2Nlc3Nvci50b05vcm1hbGl6ZWRGb3JtKGtleSwgdmFsdWUsIHRoaXMuX3N0eWxlcyk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gc3R5bGUgaXMgc2V0LgogICAgICoKICAgICAqCQlzdHlsZXMuc2V0VG8oICdtYXJnaW4tbGVmdDoxcHg7JyApOwogICAgICoKICAgICAqCQlzdHlsZXMuaGFzKCAnbWFyZ2luLWxlZnQnICk7ICAgIC8vIC0+IHRydWUKICAgICAqCQlzdHlsZXMuaGFzKCAncGFkZGluZycgKTsgICAgICAgIC8vIC0+IGZhbHNlCiAgICAgKgogICAgICogKipOb3RlKio6IFRoaXMgY2hlY2sgc3VwcG9ydHMgbm9ybWFsaXplZCBzdHlsZSBuYW1lcy4KICAgICAqCiAgICAgKgkJLy8gRW5hYmxlICdtYXJnaW4nIHNob3J0aGFuZCBwcm9jZXNzaW5nOgogICAgICoJCWVkaXRvci5kYXRhLmFkZFN0eWxlUHJvY2Vzc29yUnVsZXMoIGFkZE1hcmdpblJ1bGVzICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5zZXRUbyggJ21hcmdpbjoycHg7JyApOwogICAgICoKICAgICAqCQlzdHlsZXMuaGFzKCAnbWFyZ2luJyApOyAgICAgICAgIC8vIC0+IHRydWUKICAgICAqCQlzdHlsZXMuaGFzKCAnbWFyZ2luLXRvcCcgKTsgICAgIC8vIC0+IHRydWUKICAgICAqCQlzdHlsZXMuaGFzKCAnbWFyZ2luLWxlZnQnICk7ICAgIC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJc3R5bGVzLnJlbW92ZSggJ21hcmdpbi10b3AnICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5oYXMoICdtYXJnaW4nICk7ICAgICAgICAgLy8gLT4gZmFsc2UKICAgICAqCQlzdHlsZXMuaGFzKCAnbWFyZ2luLXRvcCcgKTsgICAgIC8vIC0+IGZhbHNlCiAgICAgKgkJc3R5bGVzLmhhcyggJ21hcmdpbi1sZWZ0JyApOyAgICAvLyAtPiB0cnVlCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgU3R5bGUgbmFtZS4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImhhcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKG5hbWUpIHsKICAgICAgaWYgKHRoaXMuaXNFbXB0eSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuX3N0eWxlUHJvY2Vzc29yLmdldFJlZHVjZWRGb3JtKG5hbWUsIHRoaXMuX3N0eWxlcyk7CgogICAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gc3R5bGVzLmZpbmQoZnVuY3Rpb24gKF9yZWYpIHsKICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAxKSwKICAgICAgICAgICAgcHJvcGVydHkgPSBfcmVmMlswXTsKCiAgICAgICAgcmV0dXJuIHByb3BlcnR5ID09PSBuYW1lOwogICAgICB9KTsgLy8gT25seSByZXR1cm4gYSB2YWx1ZSBpZiBpdCBpcyBzZXQ7CgogICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwcm9wZXJ0eURlc2NyaXB0b3IpOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGEgZ2l2ZW4gc3R5bGUuCiAgICAgKgogICAgICogQ2FuIGluc2VydCBvbmUgYnkgb25lOgogICAgICoKICAgICAqCQlzdHlsZXMuc2V0KCAnY29sb3InLCAnYmx1ZScgKTsKICAgICAqCQlzdHlsZXMuc2V0KCAnbWFyZ2luLXJpZ2h0JywgJzFlbScgKTsKICAgICAqCiAgICAgKiBvciBtYW55IHN0eWxlcyBhdCBvbmNlOgogICAgICoKICAgICAqCQlzdHlsZXMuc2V0KCB7CiAgICAgKgkJCWNvbG9yOiAnYmx1ZScsCiAgICAgKgkJCSdtYXJnaW4tcmlnaHQnOiAnMWVtJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiAqKipOb3RlKio6KiBUaGlzIG1ldGhvZCB1c2VzIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnRyb2xsZXIvZGF0YWNvbnRyb2xsZXJ+RGF0YUNvbnRyb2xsZXIjYWRkU3R5bGVQcm9jZXNzb3JSdWxlcwogICAgICogZW5hYmxlZCBzdHlsZSBwcm9jZXNzb3IgcnVsZXN9IHRvIG5vcm1hbGl6ZSBwYXNzZWQgdmFsdWVzLgogICAgICoKICAgICAqCQkvLyBFbmFibGUgJ21hcmdpbicgc2hvcnRoYW5kIHByb2Nlc3Npbmc6CiAgICAgKgkJZWRpdG9yLmRhdGEuYWRkU3R5bGVQcm9jZXNzb3JSdWxlcyggYWRkTWFyZ2luUnVsZXMgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLnNldCggJ21hcmdpbicsICcycHgnICk7CiAgICAgKgogICAgICogVGhlIGFib3ZlIGNvZGUgd2lsbCBzZXQgbWFyZ2luIHRvOgogICAgICoKICAgICAqCQlzdHlsZXMuZ2V0Tm9ybWFsaXplZCggJ21hcmdpbicgKTsKICAgICAqCQkvLyAtPiB7IHRvcDogJzJweCcsIHJpZ2h0OiAnMnB4JywgYm90dG9tOiAnMnB4JywgbGVmdDogJzJweCcgfQogICAgICoKICAgICAqIFdoaWNoIG1ha2VzIGl0IHBvc3NpYmxlIHRvIHJldHJpZXZlIGEgInN1Yi12YWx1ZSI6CiAgICAgKgogICAgICoJCXN0eWxlcy5nZXQoICdtYXJnaW4tbGVmdCcgKTsgICAgICAgLy8gLT4gJzJweCcKICAgICAqCiAgICAgKiBPciBtb2RpZnkgaXQ6CiAgICAgKgogICAgICoJCXN0eWxlcy5yZW1vdmUoICdtYXJnaW4tbGVmdCcgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLmdldE5vcm1hbGl6ZWQoICdtYXJnaW4nICk7ICAvLyAtPiB7IHRvcDogJzFweCcsIGJvdHRvbTogJzFweCcsIHJpZ2h0OiAnMXB4JyB9CiAgICAgKgkJc3R5bGVzLnRvU3RyaW5nKCk7ICAgICAgICAgICAgICAgICAvLyAtPiAnbWFyZ2luLWJvdHRvbToxcHg7bWFyZ2luLXJpZ2h0OjFweDttYXJnaW4tdG9wOjFweDsnCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgYWxzbyBhbGxvd3MgdG8gc2V0IG5vcm1hbGl6ZWQgdmFsdWVzIGRpcmVjdGx5IChpZiBhIHBhcnRpY3VsYXIgc3R5bGVzIHByb2Nlc3NvciBydWxlIHdhcyBlbmFibGVkKToKICAgICAqCiAgICAgKgkJc3R5bGVzLnNldCggJ2JvcmRlci1jb2xvcicsIHsgdG9wOiAnYmx1ZScgfSApOwogICAgICoJCXN0eWxlcy5zZXQoICdtYXJnaW4nLCB7IHJpZ2h0OiAnMmVtJyB9ICk7CiAgICAgKgogICAgICoJCXN0eWxlcy50b1N0cmluZygpOyAgICAgICAgICAgICAgICAgLy8gLT4gJ2JvcmRlci1jb2xvci10b3A6Ymx1ZTttYXJnaW4tcmlnaHQ6MmVtOycKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5hbWVPck9iamVjdCBTdHlsZSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCB3aXRoIG11bHRpcGxlIHByb3BlcnRpZXMuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHZhbHVlT3JPYmplY3QgVmFsdWUgdG8gc2V0LgogICAgICovCgogIH0sIHsKICAgIGtleTogInNldCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG5hbWVPck9iamVjdCwgdmFsdWVPck9iamVjdCkgewogICAgICBpZiAoaXNPYmplY3QobmFtZU9yT2JqZWN0KSkgewogICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9PYmplY3QkZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG5hbWVPck9iamVjdCk7IF9pMiA8IF9PYmplY3QkZW50cmllcy5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgICB2YXIgX09iamVjdCRlbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoX09iamVjdCRlbnRyaWVzW19pMl0sIDIpLAogICAgICAgICAgICAgIGtleSA9IF9PYmplY3QkZW50cmllcyRfaVswXSwKICAgICAgICAgICAgICB2YWx1ZSA9IF9PYmplY3QkZW50cmllcyRfaVsxXTsKCiAgICAgICAgICB0aGlzLl9zdHlsZVByb2Nlc3Nvci50b05vcm1hbGl6ZWRGb3JtKGtleSwgdmFsdWUsIHRoaXMuX3N0eWxlcyk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuX3N0eWxlUHJvY2Vzc29yLnRvTm9ybWFsaXplZEZvcm0obmFtZU9yT2JqZWN0LCB2YWx1ZU9yT2JqZWN0LCB0aGlzLl9zdHlsZXMpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgZ2l2ZW4gc3R5bGUuCiAgICAgKgogICAgICoJCXN0eWxlcy5zZXRUbyggJ2JhY2tncm91bmQ6I2YwMDttYXJnaW4tcmlnaHQ6MnB4OycgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLnJlbW92ZSggJ2JhY2tncm91bmQnICk7CiAgICAgKgogICAgICoJCXN0eWxlcy50b1N0cmluZygpOyAgIC8vIC0+ICdtYXJnaW4tcmlnaHQ6MnB4OycKICAgICAqCiAgICAgKiAqKipOb3RlKio6KiBUaGlzIG1ldGhvZCB1c2VzIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnRyb2xsZXIvZGF0YWNvbnRyb2xsZXJ+RGF0YUNvbnRyb2xsZXIjYWRkU3R5bGVQcm9jZXNzb3JSdWxlcwogICAgICogZW5hYmxlZCBzdHlsZSBwcm9jZXNzb3IgcnVsZXN9IHRvIG5vcm1hbGl6ZSBwYXNzZWQgdmFsdWVzLgogICAgICoKICAgICAqCQkvLyBFbmFibGUgJ21hcmdpbicgc2hvcnRoYW5kIHByb2Nlc3Npbmc6CiAgICAgKgkJZWRpdG9yLmRhdGEuYWRkU3R5bGVQcm9jZXNzb3JSdWxlcyggYWRkTWFyZ2luUnVsZXMgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLnNldFRvKCAnbWFyZ2luOjFweCcgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLnJlbW92ZSggJ21hcmdpbi10b3AnICk7CiAgICAgKgkJc3R5bGVzLnJlbW92ZSggJ21hcmdpbi1yaWdodCcgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLnRvU3RyaW5nKCk7IC8vIC0+ICdtYXJnaW4tYm90dG9tOjFweDttYXJnaW4tbGVmdDoxcHg7JwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFN0eWxlIG5hbWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkgewogICAgICB2YXIgcGF0aCA9IHRvUGF0aChuYW1lKTsKICAgICAgdW5zZXQodGhpcy5fc3R5bGVzLCBwYXRoKTsKICAgICAgZGVsZXRlIHRoaXMuX3N0eWxlc1tuYW1lXTsKCiAgICAgIHRoaXMuX2NsZWFuRW1wdHlPYmplY3RzT25QYXRoKHBhdGgpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbm9ybWFsaXplZCBzdHlsZSBvYmplY3Qgb3IgYSBzaW5nbGUgdmFsdWUuCiAgICAgKgogICAgICoJCS8vIEVuYWJsZSAnbWFyZ2luJyBzaG9ydGhhbmQgcHJvY2Vzc2luZzoKICAgICAqCQllZGl0b3IuZGF0YS5hZGRTdHlsZVByb2Nlc3NvclJ1bGVzKCBhZGRNYXJnaW5SdWxlcyApOwogICAgICoKICAgICAqCQljb25zdCBzdHlsZXMgPSBuZXcgU3R5bGVzKCk7CiAgICAgKgkJc3R5bGVzLnNldFRvKCAnbWFyZ2luOjFweCAycHggM2VtOycgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLmdldE5vcm1hbGl6ZWQoICdtYXJnaW4nICk7CiAgICAgKgkJLy8gd2lsbCBsb2c6CiAgICAgKgkJLy8gewogICAgICoJCS8vICAgICB0b3A6ICcxcHgnLAogICAgICoJCS8vICAgICByaWdodDogJzJweCcsCiAgICAgKgkJLy8gICAgIGJvdHRvbTogJzNlbScsCiAgICAgKgkJLy8gICAgIGxlZnQ6ICcycHgnICAgICAvLyBub3JtYWxpemVkIHZhbHVlIGZyb20gbWFyZ2luIHNob3J0aGFuZAogICAgICoJCS8vIH0KICAgICAqCiAgICAgKgkJc3R5bGVzLmdldE5vcm1hbGl6ZWQoICdtYXJnaW4tbGVmdCcgKTsgLy8gLT4gJzJweCcKICAgICAqCiAgICAgKiAqKk5vdGUqKjogVGhpcyBtZXRob2Qgd2lsbCBvbmx5IHJldHVybiBub3JtYWxpemVkIHN0eWxlcyBpZiBhIHN0eWxlIHByb2Nlc3NvciB3YXMgZGVmaW5lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBTdHlsZSBuYW1lLgogICAgICogQHJldHVybnMge09iamVjdHxTdHJpbmd8dW5kZWZpbmVkfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldE5vcm1hbGl6ZWQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWQobmFtZSkgewogICAgICByZXR1cm4gdGhpcy5fc3R5bGVQcm9jZXNzb3IuZ2V0Tm9ybWFsaXplZChuYW1lLCB0aGlzLl9zdHlsZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbm9ybWFsaXplZCBzdHlsZSBzdHJpbmcuIFN0eWxlcyBhcmUgc29ydGVkIGJ5IG5hbWUuCiAgICAgKgogICAgICoJCXN0eWxlcy5zZXQoICdtYXJnaW4nICwgJzFweCcgKTsKICAgICAqCQlzdHlsZXMuc2V0KCAnYmFja2dyb3VuZCcsICcjZjAwJyApOwogICAgICoKICAgICAqCQlzdHlsZXMudG9TdHJpbmcoKTsgLy8gLT4gJ2JhY2tncm91bmQ6I2YwMDttYXJnaW46MXB4OycKICAgICAqCiAgICAgKiAqKk5vdGUqKjogVGhpcyBtZXRob2Qgc3VwcG9ydHMgbm9ybWFsaXplZCBzdHlsZXMgaWYgZGVmaW5lZC4KICAgICAqCiAgICAgKgkJLy8gRW5hYmxlICdtYXJnaW4nIHNob3J0aGFuZCBwcm9jZXNzaW5nOgogICAgICoJCWVkaXRvci5kYXRhLmFkZFN0eWxlUHJvY2Vzc29yUnVsZXMoIGFkZE1hcmdpblJ1bGVzICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5zZXQoICdtYXJnaW4nICwgJzFweCcgKTsKICAgICAqCQlzdHlsZXMuc2V0KCAnYmFja2dyb3VuZCcsICcjZjAwJyApOwogICAgICoJCXN0eWxlcy5yZW1vdmUoICdtYXJnaW4tdG9wJyApOwogICAgICoJCXN0eWxlcy5yZW1vdmUoICdtYXJnaW4tcmlnaHQnICk7CiAgICAgKgogICAgICoJCXN0eWxlcy50b1N0cmluZygpOyAvLyAtPiAnYmFja2dyb3VuZDojZjAwO21hcmdpbi1ib3R0b206MXB4O21hcmdpbi1sZWZ0OjFweDsnCiAgICAgKgogICAgICogQHJldHVybnMge1N0cmluZ30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b1N0cmluZyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHsKICAgICAgICByZXR1cm4gJyc7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLl9nZXRTdHlsZXNFbnRyaWVzKCkubWFwKGZ1bmN0aW9uIChhcnIpIHsKICAgICAgICByZXR1cm4gYXJyLmpvaW4oJzonKTsKICAgICAgfSkuc29ydCgpLmpvaW4oJzsnKSArICc7JzsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBwcm9wZXJ0eSBhcyBhIHZhbHVlIHN0cmluZyBvciB1bmRlZmluZWQgaWYgcHJvcGVydHkgaXMgbm90IHNldC4KICAgICAqCiAgICAgKgkJLy8gRW5hYmxlICdtYXJnaW4nIHNob3J0aGFuZCBwcm9jZXNzaW5nOgogICAgICoJCWVkaXRvci5kYXRhLmFkZFN0eWxlUHJvY2Vzc29yUnVsZXMoIGFkZE1hcmdpblJ1bGVzICk7CiAgICAgKgogICAgICoJCWNvbnN0IHN0eWxlcyA9IG5ldyBTdHlsZXMoKTsKICAgICAqCQlzdHlsZXMuc2V0VG8oICdtYXJnaW46MXB4OycgKTsKICAgICAqCQlzdHlsZXMuc2V0KCAnbWFyZ2luLWJvdHRvbScsICczZW0nICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5nZXRBc1N0cmluZyggJ21hcmdpbicgKTsgLy8gLT4gJ21hcmdpbjogMXB4IDFweCAzZW07JwogICAgICoKICAgICAqIE5vdGUsIGhvd2V2ZXIsIHRoYXQgYWxsIHN1Yi12YWx1ZXMgbXVzdCBiZSBzZXQgZm9yIHRoZSBsb25naGFuZCBwcm9wZXJ0eSBuYW1lIHRvIHJldHVybiBhIHZhbHVlOgogICAgICoKICAgICAqCQljb25zdCBzdHlsZXMgPSBuZXcgU3R5bGVzKCk7CiAgICAgKgkJc3R5bGVzLnNldFRvKCAnbWFyZ2luOjFweDsnICk7CiAgICAgKgkJc3R5bGVzLnJlbW92ZSggJ21hcmdpbi1ib3R0b20nICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5nZXRBc1N0cmluZyggJ21hcmdpbicgKTsgLy8gLT4gdW5kZWZpbmVkCiAgICAgKgogICAgICogSW4gdGhlIGFib3ZlIHNjZW5hcmlvLCBpdCBpcyBub3QgcG9zc2libGUgdG8gcmV0dXJuIGEgYG1hcmdpbmAgdmFsdWUsIHNvIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLgogICAgICogSW5zdGVhZCwgeW91IHNob3VsZCB1c2U6CiAgICAgKgogICAgICoJCWNvbnN0IHN0eWxlcyA9IG5ldyBTdHlsZXMoKTsKICAgICAqCQlzdHlsZXMuc2V0VG8oICdtYXJnaW46MXB4OycgKTsKICAgICAqCQlzdHlsZXMucmVtb3ZlKCAnbWFyZ2luLWJvdHRvbScgKTsKICAgICAqCiAgICAgKgkJZm9yICggY29uc3Qgc3R5bGVOYW1lIG9mIHN0eWxlcy5nZXRTdHlsZU5hbWVzKCkgKSB7CiAgICAgKgkJCWNvbnNvbGUubG9nKCBzdHlsZU5hbWUsIHN0eWxlcy5nZXRBc1N0cmluZyggc3R5bGVOYW1lICkgKTsKICAgICAqCQl9CiAgICAgKgkJLy8gJ21hcmdpbi10b3AnLCAnMXB4JwogICAgICoJCS8vICdtYXJnaW4tcmlnaHQnLCAnMXB4JwogICAgICoJCS8vICdtYXJnaW4tbGVmdCcsICcxcHgnCiAgICAgKgogICAgICogSW4gZ2VuZXJhbCwgaXQgaXMgcmVjb21tZW5kIHRvIGl0ZXJhdGUgb3ZlciBzdHlsZSBuYW1lcyBsaWtlIGluIHRoZSBleGFtcGxlIGFib3ZlLiBUaGlzIHdheSwgeW91IHdpbGwgYWx3YXlzIGdldCBhbGwKICAgICAqIHRoZSBjdXJyZW50bHkgc2V0IHN0eWxlIHZhbHVlcy4gU28sIGlmIGFsbCB0aGUgNCBtYXJnaW4gdmFsdWVzIHdvdWxkIGJlIHNldAogICAgICogdGhlIGZvci1vZiBsb29wIGFib3ZlIHdvdWxkIHlpZWxkIG9ubHkgYCdtYXJnaW4nYCwgYCcxcHgnYDoKICAgICAqCiAgICAgKgkJY29uc3Qgc3R5bGVzID0gbmV3IFN0eWxlcygpOwogICAgICoJCXN0eWxlcy5zZXRUbyggJ21hcmdpbjoxcHg7JyApOwogICAgICoKICAgICAqCQlmb3IgKCBjb25zdCBzdHlsZU5hbWUgb2Ygc3R5bGVzLmdldFN0eWxlTmFtZXMoKSApIHsKICAgICAqCQkJY29uc29sZS5sb2coIHN0eWxlTmFtZSwgc3R5bGVzLmdldEFzU3RyaW5nKCBzdHlsZU5hbWUgKSApOwogICAgICoJCX0KICAgICAqCQkvLyAnbWFyZ2luJywgJzFweCcKICAgICAqCiAgICAgKiAqKk5vdGUqKjogVG8gZ2V0IGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIGEgbG9uZ2hhbmQgcHJvcGVydHkgdXNlIHRoZSB7QGxpbmsgI2dldE5vcm1hbGl6ZWQgYCNnZXROb3JtYWxpemVkKClgfSBtZXRob2QuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5TmFtZQogICAgICogQHJldHVybnMge1N0cmluZ3x1bmRlZmluZWR9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0QXNTdHJpbmciLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFzU3RyaW5nKHByb3BlcnR5TmFtZSkgewogICAgICBpZiAodGhpcy5pc0VtcHR5KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAodGhpcy5fc3R5bGVzW3Byb3BlcnR5TmFtZV0gJiYgIWlzT2JqZWN0KHRoaXMuX3N0eWxlc1twcm9wZXJ0eU5hbWVdKSkgewogICAgICAgIC8vIFRyeSByZXR1cm4gc3R5bGVzIHNldCBkaXJlY3RseSAtIHZhbHVlcyB0aGF0IGFyZSBub3QgcGFyc2VkLgogICAgICAgIHJldHVybiB0aGlzLl9zdHlsZXNbcHJvcGVydHlOYW1lXTsKICAgICAgfQoKICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuX3N0eWxlUHJvY2Vzc29yLmdldFJlZHVjZWRGb3JtKHByb3BlcnR5TmFtZSwgdGhpcy5fc3R5bGVzKTsKCiAgICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBzdHlsZXMuZmluZChmdW5jdGlvbiAoX3JlZjMpIHsKICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksCiAgICAgICAgICAgIHByb3BlcnR5ID0gX3JlZjRbMF07CgogICAgICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gcHJvcGVydHlOYW1lOwogICAgICB9KTsgLy8gT25seSByZXR1cm4gYSB2YWx1ZSBpZiBpdCBpcyBzZXQ7CgogICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eURlc2NyaXB0b3IpKSB7CiAgICAgICAgcmV0dXJuIHByb3BlcnR5RGVzY3JpcHRvclsxXTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHN0eWxlIHByb3BlcnR5IG5hbWVzIGFzIHRoZXkgd291bGQgYXBwZWFyIHdoZW4gdXNpbmcge0BsaW5rICN0b1N0cmluZyBgI3RvU3RyaW5nKClgfS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0U3R5bGVOYW1lcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3R5bGVOYW1lcygpIHsKICAgICAgaWYgKHRoaXMuaXNFbXB0eSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQoKICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9nZXRTdHlsZXNFbnRyaWVzKCk7CgogICAgICByZXR1cm4gZW50cmllcy5tYXAoZnVuY3Rpb24gKF9yZWY1KSB7CiAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLAogICAgICAgICAgICBrZXkgPSBfcmVmNlswXTsKCiAgICAgICAgcmV0dXJuIGtleTsKICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIHN0eWxlcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjbGVhciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7CiAgICAgIHRoaXMuX3N0eWxlcyA9IHt9OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIG5vcm1hbGl6ZWQgc3R5bGVzIGVudHJpZXMgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzbWFwflByb3BlcnR5RGVzY3JpcHRvcj59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFN0eWxlc0VudHJpZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHlsZXNFbnRyaWVzKCkgewogICAgICB2YXIgcGFyc2VkID0gW107CiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fc3R5bGVzKTsKCiAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9rZXlzID0ga2V5czsgX2kzIDwgX2tleXMubGVuZ3RoOyBfaTMrKykgewogICAgICAgIHZhciBrZXkgPSBfa2V5c1tfaTNdOwogICAgICAgIHBhcnNlZC5wdXNoLmFwcGx5KHBhcnNlZCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX3N0eWxlUHJvY2Vzc29yLmdldFJlZHVjZWRGb3JtKGtleSwgdGhpcy5fc3R5bGVzKSkpOwogICAgICB9CgogICAgICByZXR1cm4gcGFyc2VkOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGVtcHR5IG9iamVjdHMgdXBvbiByZW1vdmluZyBhbiBlbnRyeSBmcm9tIGludGVybmFsIG9iamVjdC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aAogICAgICogQHByaXZhdGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY2xlYW5FbXB0eU9iamVjdHNPblBhdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbkVtcHR5T2JqZWN0c09uUGF0aChwYXRoKSB7CiAgICAgIHZhciBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7CiAgICAgIHZhciBpc0NoaWxkUGF0aCA9IHBhdGhQYXJ0cy5sZW5ndGggPiAxOwoKICAgICAgaWYgKCFpc0NoaWxkUGF0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIHBhcmVudFBhdGggPSBwYXRoUGFydHMuc3BsaWNlKDAsIHBhdGhQYXJ0cy5sZW5ndGggLSAxKS5qb2luKCcuJyk7CiAgICAgIHZhciBwYXJlbnRPYmplY3QgPSBnZXQodGhpcy5fc3R5bGVzLCBwYXJlbnRQYXRoKTsKCiAgICAgIGlmICghcGFyZW50T2JqZWN0KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgaXNQYXJlbnRFbXB0eSA9ICFBcnJheS5mcm9tKE9iamVjdC5rZXlzKHBhcmVudE9iamVjdCkpLmxlbmd0aDsKCiAgICAgIGlmIChpc1BhcmVudEVtcHR5KSB7CiAgICAgICAgdGhpcy5yZW1vdmUocGFyZW50UGF0aCk7CiAgICAgIH0KICAgIH0KICB9XSk7CgogIHJldHVybiBTdHlsZXNNYXA7Cn0oKTsKLyoqCiAqIFN0eWxlIHByb2Nlc3NvciBpcyByZXNwb25zaWJsZSBmb3Igd3JpdGluZyBhbmQgcmVhZGluZyBhIG5vcm1hbGl6ZWQgc3R5bGVzIG9iamVjdC4KICovCgoKZXhwb3J0IHsgU3R5bGVzTWFwIGFzIGRlZmF1bHQgfTsKZXhwb3J0IHZhciBTdHlsZXNQcm9jZXNzb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgU3R5bGVzUHJvY2Vzc29yIGluc3RhbmNlLgogICAqCiAgICogQHByaXZhdGUKICAgKi8KICBmdW5jdGlvbiBTdHlsZXNQcm9jZXNzb3IoKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVzUHJvY2Vzc29yKTsKCiAgICB0aGlzLl9ub3JtYWxpemVycyA9IG5ldyBNYXAoKTsKICAgIHRoaXMuX2V4dHJhY3RvcnMgPSBuZXcgTWFwKCk7CiAgICB0aGlzLl9yZWR1Y2VycyA9IG5ldyBNYXAoKTsKICAgIHRoaXMuX2NvbnN1bWFibGVzID0gbmV3IE1hcCgpOwogIH0KICAvKioKICAgKiBQYXJzZSBzdHlsZSBzdHJpbmcgdmFsdWUgdG8gYSBub3JtYWxpemVkIG9iamVjdCBhbmQgYXBwZW5kcyBpdCB0byBzdHlsZXMgb2JqZWN0LgogICAqCiAgICoJCWNvbnN0IHN0eWxlcyA9IHt9OwogICAqCiAgICoJCXN0eWxlc1Byb2Nlc3Nvci50b05vcm1hbGl6ZWRGb3JtKCAnbWFyZ2luJywgJzFweCcsIHN0eWxlcyApOwogICAqCiAgICoJCS8vIHN0eWxlcyB3aWxsIGNvbnNpc3Q6IHsgbWFyZ2luOiB7IHRvcDogJzFweCcsIHJpZ2h0OiAnMXB4JywgYm90dG9tOiAnMXB4JywgbGVmdDogJzFweDsgfSB9CiAgICoKICAgKiAqKk5vdGUqKjogVG8gZGVmaW5lIG5vcm1hbGl6ZXIgY2FsbGJhY2tzIHVzZSB7QGxpbmsgI3NldE5vcm1hbGl6ZXJ9LgogICAqCiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiBzdHlsZSBwcm9wZXJ0eS4KICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlWYWx1ZSBWYWx1ZSBvZiBzdHlsZSBwcm9wZXJ0eS4KICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIE9iamVjdCBob2xkaW5nIG5vcm1hbGl6ZWQgc3R5bGVzLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFN0eWxlc1Byb2Nlc3NvciwgW3sKICAgIGtleTogInRvTm9ybWFsaXplZEZvcm0iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvTm9ybWFsaXplZEZvcm0obmFtZSwgcHJvcGVydHlWYWx1ZSwgc3R5bGVzKSB7CiAgICAgIGlmIChpc09iamVjdChwcm9wZXJ0eVZhbHVlKSkgewogICAgICAgIGFwcGVuZFN0eWxlVmFsdWUoc3R5bGVzLCB0b1BhdGgobmFtZSksIHByb3BlcnR5VmFsdWUpOwogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZXJzLmhhcyhuYW1lKSkgewogICAgICAgIHZhciBub3JtYWxpemVyID0gdGhpcy5fbm9ybWFsaXplcnMuZ2V0KG5hbWUpOwoKICAgICAgICB2YXIgX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyKHByb3BlcnR5VmFsdWUpLAogICAgICAgICAgICBwYXRoID0gX25vcm1hbGl6ZXIucGF0aCwKICAgICAgICAgICAgdmFsdWUgPSBfbm9ybWFsaXplci52YWx1ZTsKCiAgICAgICAgYXBwZW5kU3R5bGVWYWx1ZShzdHlsZXMsIHBhdGgsIHZhbHVlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBhcHBlbmRTdHlsZVZhbHVlKHN0eWxlcywgbmFtZSwgcHJvcGVydHlWYWx1ZSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiBhIHN0eWxlIHByb3BlcnR5LgogICAgICoJCWNvbnN0IHN0eWxlcyA9IHsKICAgICAqCQkJbWFyZ2luOiB7IHRvcDogJzFweCcsIHJpZ2h0OiAnMXB4JywgYm90dG9tOiAnMXB4JywgbGVmdDogJzFweDsgfSwKICAgICAqCQkJYmFja2dyb3VuZDogeyBjb2xvcjogJyNmMDAnIH0KICAgICAqCQl9OwogICAgICoKICAgICAqCQlzdHlsZXNQcm9jZXNzb3IuZ2V0Tm9ybWFsaXplZCggJ2JhY2tncm91bmQnICk7CiAgICAgKgkJLy8gd2lsbCByZXR1cm46IHsgY29sb3I6ICcjZjAwJyB9CiAgICAgKgogICAgICoJCXN0eWxlc1Byb2Nlc3Nvci5nZXROb3JtYWxpemVkKCAnbWFyZ2luLXRvcCcgKTsKICAgICAqCQkvLyB3aWxsIHJldHVybjogJzFweCcKICAgICAqCiAgICAgKiAqKk5vdGUqKjogSW4gc29tZSBjYXNlcyBleHRyYWN0aW5nIHNpbmdsZSB2YWx1ZSByZXF1aXJlcyBkZWZpbmluZyBhbiBleHRyYWN0b3IgY2FsbGJhY2sge0BsaW5rICNzZXRFeHRyYWN0b3J9LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2Ygc3R5bGUgcHJvcGVydHkuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIE9iamVjdCBob2xkaW5nIG5vcm1hbGl6ZWQgc3R5bGVzLgogICAgICogQHJldHVybnMgeyp9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Tm9ybWFsaXplZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZChuYW1lLCBzdHlsZXMpIHsKICAgICAgaWYgKCFuYW1lKSB7CiAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCBzdHlsZXMpOwogICAgICB9IC8vIE1pZ2h0IGJlIGVtcHR5IHN0cmluZy4KCgogICAgICBpZiAoc3R5bGVzW25hbWVdICE9PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gc3R5bGVzW25hbWVdOwogICAgICB9CgogICAgICBpZiAodGhpcy5fZXh0cmFjdG9ycy5oYXMobmFtZSkpIHsKICAgICAgICB2YXIgZXh0cmFjdG9yID0gdGhpcy5fZXh0cmFjdG9ycy5nZXQobmFtZSk7CgogICAgICAgIGlmICh0eXBlb2YgZXh0cmFjdG9yID09PSAnc3RyaW5nJykgewogICAgICAgICAgcmV0dXJuIGdldChzdHlsZXMsIGV4dHJhY3Rvcik7CiAgICAgICAgfQoKICAgICAgICB2YXIgdmFsdWUgPSBleHRyYWN0b3IobmFtZSwgc3R5bGVzKTsKCiAgICAgICAgaWYgKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gZ2V0KHN0eWxlcywgdG9QYXRoKG5hbWUpKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHJlZHVjZWQgZm9ybSBvZiBzdHlsZSBwcm9wZXJ0eSBmb3JtIG5vcm1hbGl6ZWQgb2JqZWN0LgogICAgICoKICAgICAqIEZvciBkZWZhdWx0IG1hcmdpbiByZWR1Y2VyLCB0aGUgYmVsb3cgY29kZToKICAgICAqCiAgICAgKgkJc3R5bGVzUHJvY2Vzc29yLmdldFJlZHVjZWRGb3JtKCAnbWFyZ2luJywgewogICAgICoJCQltYXJnaW46IHsgdG9wOiAnMXB4JywgcmlnaHQ6ICcxcHgnLCBib3R0b206ICcycHgnLCBsZWZ0OiAnMXB4OyB9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIHdpbGwgcmV0dXJuOgogICAgICoKICAgICAqCQlbCiAgICAgKgkJCVsgJ21hcmdpbicsICcxcHggMXB4IDJweCcgXQogICAgICoJCV0KICAgICAqCiAgICAgKiBiZWNhdXNlIGl0IG1pZ2h0IGJlIHJlcHJlc2VudGVkIGFzIGEgc2hvcnRoYW5kICdtYXJnaW4nIHZhbHVlLiBIb3dldmVyIGlmIG9uZSBvZiBtYXJnaW4gbG9uZyBoYW5kIHZhbHVlcyBpcyBtaXNzaW5nIGl0IHNob3VsZCByZXR1cm46CiAgICAgKgogICAgICoJCVsKICAgICAqCQkJWyAnbWFyZ2luLXRvcCcsICcxcHgnIF0sCiAgICAgKgkJCVsgJ21hcmdpbi1yaWdodCcsICcxcHgnIF0sCiAgICAgKgkJCVsgJ21hcmdpbi1ib3R0b20nLCAnMnB4JyBdCiAgICAgKgkJCS8vIHRoZSAnbGVmdCcgdmFsdWUgaXMgbWlzc2luZyAtIGNhbm5vdCB1c2UgJ21hcmdpbicgc2hvcnRoYW5kLgogICAgICoJCV0KICAgICAqCiAgICAgKiAqKk5vdGUqKjogVG8gZGVmaW5lIHJlZHVjZXIgY2FsbGJhY2tzIHVzZSB7QGxpbmsgI3NldFJlZHVjZXJ9LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHN0eWxlIHByb3BlcnR5LgogICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBPYmplY3QgaG9sZGluZyBub3JtYWxpemVkIHN0eWxlcy4KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS92aWV3L3N0eWxlc21hcH5Qcm9wZXJ0eURlc2NyaXB0b3I+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFJlZHVjZWRGb3JtIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWR1Y2VkRm9ybShuYW1lLCBzdHlsZXMpIHsKICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IHRoaXMuZ2V0Tm9ybWFsaXplZChuYW1lLCBzdHlsZXMpOyAvLyBNaWdodCBiZSBlbXB0eSBzdHJpbmcuCgogICAgICBpZiAobm9ybWFsaXplZFZhbHVlID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLl9yZWR1Y2Vycy5oYXMobmFtZSkpIHsKICAgICAgICB2YXIgcmVkdWNlciA9IHRoaXMuX3JlZHVjZXJzLmdldChuYW1lKTsKCiAgICAgICAgcmV0dXJuIHJlZHVjZXIobm9ybWFsaXplZFZhbHVlKTsKICAgICAgfQoKICAgICAgcmV0dXJuIFtbbmFtZSwgbm9ybWFsaXplZFZhbHVlXV07CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgcmVsYXRlZCBzdHlsZSBuYW1lcy4KICAgICAqCiAgICAgKgkJc3R5bGVzUHJvY2Vzc29yLmdldFJlbGF0ZWRTdHlsZXMoICdtYXJnaW4nICk7CiAgICAgKgkJLy8gd2lsbCByZXR1cm46IFsgJ21hcmdpbi10b3AnLCAnbWFyZ2luLXJpZ2h0JywgJ21hcmdpbi1ib3R0b20nLCAnbWFyZ2luLWxlZnQnIF07CiAgICAgKgogICAgICoJCXN0eWxlc1Byb2Nlc3Nvci5nZXRSZWxhdGVkU3R5bGVzKCAnbWFyZ2luLXRvcCcgKTsKICAgICAqCQkvLyB3aWxsIHJldHVybjogWyAnbWFyZ2luJyBdOwogICAgICoKICAgICAqICoqTm90ZSoqOiBUbyBkZWZpbmUgbmV3IHN0eWxlIHJlbGF0aW9ucyBsb2FkIGFuIGV4aXN0aW5nIHN0eWxlIHByb2Nlc3NvciBvciB1c2UKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzbWFwflN0eWxlc1Byb2Nlc3NvciNzZXRTdHlsZVJlbGF0aW9uIGBTdHlsZXNQcm9jZXNzb3Iuc2V0U3R5bGVSZWxhdGlvbigpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUKICAgICAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRSZWxhdGVkU3R5bGVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWxhdGVkU3R5bGVzKG5hbWUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NvbnN1bWFibGVzLmdldChuYW1lKSB8fCBbXTsKICAgIH0KICAgIC8qKgogICAgICogQWRkcyBhIG5vcm1hbGl6ZXIgbWV0aG9kIGZvciBhIHN0eWxlIHByb3BlcnR5LgogICAgICoKICAgICAqIEEgbm9ybWFsaXplciByZXR1cm5zIGRlc2NyaWJpbmcgaG93IHRoZSB2YWx1ZSBzaG91bGQgYmUgbm9ybWFsaXplZC4KICAgICAqCiAgICAgKiBGb3IgaW5zdGFuY2UgJ21hcmdpbicgc3R5bGUgaXMgYSBzaG9ydGhhbmQgZm9yIGZvdXIgbWFyZ2luIHZhbHVlczoKICAgICAqCiAgICAgKiAtICdtYXJnaW4tdG9wJwogICAgICogLSAnbWFyZ2luLXJpZ2h0JwogICAgICogLSAnbWFyZ2luLWJvdHRvbScKICAgICAqIC0gJ21hcmdpbi1sZWZ0JwogICAgICoKICAgICAqIGFuZCBjYW4gYmUgd3JpdHRlbiBpbiB2YXJpb3VzIHdheXMgaWYgc29tZSB2YWx1ZXMgYXJlIGVxdWFsIHRvIG90aGVycy4gRm9yIGluc3RhbmNlIGAnbWFyZ2luOiAxcHggMmVtOydgIGlzIGEgc2hvcnRoYW5kIGZvcgogICAgICogYCdtYXJnaW4tdG9wOiAxcHg7bWFyZ2luLXJpZ2h0OiAyZW07bWFyZ2luLWJvdHRvbTogMXB4O21hcmdpbi1sZWZ0OiAyZW0nYC4KICAgICAqCiAgICAgKiBBIG5vcm1hbGl6ZXIgc2hvdWxkIHBhcnNlIHZhcmlvdXMgbWFyZ2luIG5vdGF0aW9ucyBhcyBhIHNpbmdsZSBvYmplY3Q6CiAgICAgKgogICAgICoJCWNvbnN0IHN0eWxlcyA9IHsKICAgICAqCQkJbWFyZ2luOiB7CiAgICAgKgkJCQl0b3A6ICcxcHgnLAogICAgICoJCQkJcmlnaHQ6ICcyZW0nLAogICAgICoJCQkJYm90dG9tOiAnMXB4JywKICAgICAqCQkJCWxlZnQ6ICcyZW0nCiAgICAgKgkJCX0KICAgICAqCQl9OwogICAgICoKICAgICAqIFRodXMgYSBub3JtYWxpemVyIGZvciAnbWFyZ2luJyBzdHlsZSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBkZWZpbmluZyBzdHlsZSBwYXRoIGFuZCB2YWx1ZSB0byBzdG9yZToKICAgICAqCiAgICAgKgkJY29uc3QgcmV0dXJuVmFsdWUgPSB7CiAgICAgKgkJCXBhdGg6ICdtYXJnaW4nLAogICAgICoJCQl2YWx1ZTogewogICAgICoJCQkJdG9wOiAnMXB4JywKICAgICAqCQkJCXJpZ2h0OiAnMmVtJywKICAgICAqCQkJCWJvdHRvbTogJzFweCcsCiAgICAgKgkJCQlsZWZ0OiAnMmVtJwogICAgICoJCQl9CiAgICAgKgkJfTsKICAgICAqCiAgICAgKiBBZGRpdGlvbmFsbHkgdG8gZnVsbHkgc3VwcG9ydCBhbGwgbWFyZ2luIG5vdGF0aW9ucyB0aGVyZSBzaG91bGQgYmUgYWxzbyBkZWZpbmVkIDQgbm9ybWFsaXplcnMgZm9yIGxvbmdoYW5kIG1hcmdpbiBub3RhdGlvbnMuIEJlbG93CiAgICAgKiBpcyBhbiBleGFtcGxlIGZvciAnbWFyZ2luLXRvcCcgc3R5bGUgcHJvcGVydHkgbm9ybWFsaXplcjoKICAgICAqCiAgICAgKgkJc3R5bGVzUHJvY2Vzc29yLnNldE5vcm1hbGl6ZXIoICdtYXJnaW4tdG9wJywgdmFsdWVTdHJpbmcgPT4gewogICAgICoJCQlyZXR1cm4gewogICAgICoJCQkJcGF0aDogJ21hcmdpbi50b3AnLAogICAgICoJCQkJdmFsdWU6IHZhbHVlU3RyaW5nCiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUKICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0Tm9ybWFsaXplciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Tm9ybWFsaXplcihuYW1lLCBjYWxsYmFjaykgewogICAgICB0aGlzLl9ub3JtYWxpemVycy5zZXQobmFtZSwgY2FsbGJhY2spOwogICAgfQogICAgLyoqCiAgICAgKiBBZGRzIGEgZXh0cmFjdG9yIGNhbGxiYWNrIGZvciBhIHN0eWxlIHByb3BlcnR5LgogICAgICoKICAgICAqIE1vc3Qgbm9ybWFsaXplZCBzdHlsZSB2YWx1ZXMgYXJlIHN0b3JlZCBhcyBvbmUgbGV2ZWwgb2JqZWN0cy4gSXQgaXMgYXNzdW1lZCB0aGF0IGAnbWFyZ2luLXRvcCdgIHN0eWxlIHdpbGwgYmUgc3RvcmVkIGFzOgogICAgICoKICAgICAqCQljb25zdCBzdHlsZXMgPSB7CiAgICAgKgkJCW1hcmdpbjogewogICAgICoJCQkJdG9wOiAndmFsdWUnCiAgICAgKgkJCX0KICAgICAqCQl9CiAgICAgKgogICAgICogSG93ZXZlciwgc29tZSBzdHlsZXMgY2FuIGhhdmUgY29uZmxpY3Rpbmcgbm90YXRpb25zIGFuZCB0aHVzIGl0IG1pZ2h0IGJlIGhhcmRlciB0byBleHRyYWN0IGEgc3R5bGUgdmFsdWUgZnJvbSBzaG9ydGhhbmQuIEZvciBpbnN0YW5jZQogICAgICogdGhlICdib3JkZXItdG9wLXN0eWxlJyBjYW4gYmUgZGVmaW5lZCB1c2luZyBgJ2JvcmRlci10b3A6c29saWQnYCwgYCdib3JkZXItc3R5bGU6c29saWQgbm9uZSBub25lIG5vbmUnYCBvciBieSBgJ2JvcmRlcjpzb2xpZCdgCiAgICAgKiBzaG9ydGhhbmRzLiBUaGUgZGVmYXVsdCBib3JkZXIgc3R5bGVzIHByb2Nlc3NvcnMgc3RvcmVzIHN0eWxlcyBhczoKICAgICAqCiAgICAgKgkJY29uc3Qgc3R5bGVzID0gewogICAgICoJCQlib3JkZXI6IHsKICAgICAqCQkJCXN0eWxlOiB7CiAgICAgKgkJCQkJdG9wOiAnc29saWQnCiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9CiAgICAgKgogICAgICogYXMgaXQgaXMgYmV0dGVyIHRvIG1vZGlmeSBib3JkZXIgc3R5bGUgaW5kZXBlbmRlbnRseSBmcm9tIG90aGVyIHZhbHVlcy4gT24gdGhlIG90aGVyIHBhcnQgdGhlIG91dHB1dCBvZiB0aGUgYm9yZGVyIG1pZ2h0IGJlCiAgICAgKiBkZXNpcmVkIGFzIGBib3JkZXItdG9wYCwgYGJvcmRlci1sZWZ0YCwgZXRjIG5vdGF0aW9uLgogICAgICoKICAgICAqIEluIHRoZSBhYm92ZSBleGFtcGxlIGEgcmVkdWNlciBzaG91bGQgcmV0dXJuIGEgc2lkZSBib3JkZXIgdmFsdWUgdGhhdCBjb21iaW5lcyBzdHlsZSwgY29sb3IgYW5kIHdpZHRoOgogICAgICoKICAgICAqCQlzdHlsZVByb2Nlc3Nvci5zZXRFeHRyYWN0b3IoICdib3JkZXItdG9wJywgc3R5bGVzID0+IHsKICAgICAqCQkJcmV0dXJuIHsKICAgICAqCQkJCWNvbG9yOiBzdHlsZXMuYm9yZGVyLmNvbG9yLnRvcCwKICAgICAqCQkJCXN0eWxlOiBzdHlsZXMuYm9yZGVyLnN0eWxlLnRvcCwKICAgICAqCQkJCXdpZHRoOiBzdHlsZXMuYm9yZGVyLndpZHRoLnRvcAogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gY2FsbGJhY2tPclBhdGggQ2FsbGJhY2sgdGhhdCByZXR1cm4gYSByZXF1ZXN0ZWQgdmFsdWUgb3IgcGF0aCBzdHJpbmcgZm9yIHNpbmdsZSB2YWx1ZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0RXh0cmFjdG9yIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFeHRyYWN0b3IobmFtZSwgY2FsbGJhY2tPclBhdGgpIHsKICAgICAgdGhpcy5fZXh0cmFjdG9ycy5zZXQobmFtZSwgY2FsbGJhY2tPclBhdGgpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGRzIGEgcmVkdWNlciBjYWxsYmFjayBmb3IgYSBzdHlsZSBwcm9wZXJ0eS4KICAgICAqCiAgICAgKiBSZWR1Y2VyIHJldHVybnMgYSBtaW5pbWFsIG5vdGF0aW9uIGZvciBnaXZlbiBzdHlsZSBuYW1lLiBGb3IgbG9uZ2hhbmQgcHJvcGVydGllcyBpdCBpcyBub3QgcmVxdWlyZWQgdG8gd3JpdGUgYSByZWR1Y2VyIGFzCiAgICAgKiBieSBkZWZhdWx0IHRoZSBkaXJlY3QgdmFsdWUgZnJvbSBzdHlsZSBwYXRoIGlzIHRha2VuLgogICAgICoKICAgICAqIEZvciBzaG9ydGhhbmQgc3R5bGVzIGEgcmVkdWNlciBzaG91bGQgcmV0dXJuIG1pbmltYWwgc3R5bGUgbm90YXRpb24gZWl0aGVyIGJ5IHJldHVybmluZyBzaW5nbGUgbmFtZS12YWx1ZSB0dXBsZSBvciBtdWx0aXBsZSB0dXBsZXMKICAgICAqIGlmIGEgc2hvcnRoYW5kIGNhbm5vdCBiZSB1c2VkLiBGb3IgaW5zdGFuY2UgZm9yIGEgbWFyZ2luIHNob3J0aGFuZCBhIHJlZHVjZXIgbWlnaHQgcmV0dXJuOgogICAgICoKICAgICAqCQljb25zdCBtYXJnaW5TaG9ydEhhbmRUdXBsZSA9IFsKICAgICAqCQkJWyAnbWFyZ2luJywgJzFweCAxcHggMnB4JyBdCiAgICAgKgkJXTsKICAgICAqCiAgICAgKiBvciBhIGxvbmdoYW5kIHR1cGxlcyBmb3IgZGVmaW5lZCB2YWx1ZXM6CiAgICAgKgogICAgICoJCS8vIENvbnNpZGVyaW5nIG1hcmdpbi5ib3R0b20gYW5kIG1hcmdpbi5sZWZ0IGFyZSB1bmRlZmluZWQuCiAgICAgKgkJY29uc3QgbWFyZ2luTG9uZ2hhbmRzVHVwbGVzID0gWwogICAgICoJCQlbICdtYXJnaW4tdG9wJywgJzFweCcgXSwKICAgICAqCQkJWyAnbWFyZ2luLXJpZ2h0JywgJzFweCcgXQogICAgICoJCV07CiAgICAgKgogICAgICogQSByZWR1Y2VyIG9idGFpbnMgYSBub3JtYWxpemVkIHN0eWxlIHZhbHVlOgogICAgICoKICAgICAqCQkvLyBTaW1wbGlmaWVkIHJlZHVjZXIgdGhhdCBhbHdheXMgb3V0cHV0cyA0IHZhbHVlcyB3aGljaCBhcmUgYWx3YXlzIHByZXNlbnQ6CiAgICAgKgkJc3R5bGVzUHJvY2Vzc29yLnNldFJlZHVjZXIoICdtYXJnaW4nLCBtYXJnaW4gPT4gewogICAgICoJCQlyZXR1cm4gWwogICAgICoJCQkJWyAnbWFyZ2luJywgYCR7IG1hcmdpbi50b3AgfSAkeyBtYXJnaW4ucmlnaHQgfSAkeyBtYXJnaW4uYm90dG9tIH0gJHsgbWFyZ2luLmxlZnQgfWAgXQogICAgICoJCQldCiAgICAgKgkJfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjawogICAgICovCgogIH0sIHsKICAgIGtleTogInNldFJlZHVjZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJlZHVjZXIobmFtZSwgY2FsbGJhY2spIHsKICAgICAgdGhpcy5fcmVkdWNlcnMuc2V0KG5hbWUsIGNhbGxiYWNrKTsKICAgIH0KICAgIC8qKgogICAgICogRGVmaW5lcyBhIHN0eWxlIHNob3J0aGFuZCByZWxhdGlvbiB0byBvdGhlciBzdHlsZSBub3RhdGlvbnMuCiAgICAgKgogICAgICoJCXN0eWxlc1Byb2Nlc3Nvci5zZXRTdHlsZVJlbGF0aW9uKCAnbWFyZ2luJywgWwogICAgICoJCQknbWFyZ2luLXRvcCcsCiAgICAgKgkJCSdtYXJnaW4tcmlnaHQnLAogICAgICoJCQknbWFyZ2luLWJvdHRvbScsCiAgICAgKgkJCSdtYXJnaW4tbGVmdCcKICAgICAqCQldICk7CiAgICAgKgogICAgICogVGhpcyBlbmFibGVzIGV4cGFuZGluZyBvZiBzdHlsZSBuYW1lcyBmb3Igc2hvcnRoYW5kcy4gRm9yIGluc3RhbmNlLCBpZiBkZWZpbmVkLAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZSB2aWV3IGNvbnN1bWFibGV9IGl0ZW1zIGFyZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQKICAgICAqIGZvciBsb25nLWhhbmQgbWFyZ2luIHN0eWxlIG5vdGF0aW9uIGFsb25nc2lkZSB0aGUgYCdtYXJnaW4nYCBpdGVtLgogICAgICoKICAgICAqIFRoaXMgbWVhbnMgdGhhdCB3aGVuIGFuIGVsZW1lbnQgYmVpbmcgY29udmVydGVkIGhhcyBhIHN0eWxlIGBtYXJnaW5gLCBhIGNvbnZlcnRlciBmb3IgYG1hcmdpbi1sZWZ0YCB3aWxsIHdvcmsganVzdAogICAgICogZmluZSBzaW5jZSB0aGUgdmlldyBjb25zdW1hYmxlIHdpbGwgY29udGFpbiBhIGNvbnN1bWFibGUgYG1hcmdpbi1sZWZ0YCBpdGVtICh0aGFua3MgdG8gdGhlIHJlbGF0aW9uKSBhbmQKICAgICAqIGBlbGVtZW50LmdldFN0eWxlKCAnbWFyZ2luLWxlZnQnIClgIHdpbGwgd29yayBhcyB3ZWxsIGFzc3VtaW5nIHRoYXQgdGhlIHN0eWxlIHByb2Nlc3NvciB3YXMgY29ycmVjdGx5IGNvbmZpZ3VyZWQuCiAgICAgKiBIb3dldmVyLCBvbmNlIGBtYXJnaW4tbGVmdGAgaXMgY29uc3VtZWQsIGBtYXJnaW5gIHdpbGwgbm90IGJlIGNvbnN1bWFibGUgYW55bW9yZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2hvcnRoYW5kTmFtZQogICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gc3R5bGVOYW1lcwogICAgICovCgogIH0sIHsKICAgIGtleTogInNldFN0eWxlUmVsYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0eWxlUmVsYXRpb24oc2hvcnRoYW5kTmFtZSwgc3R5bGVOYW1lcykgewogICAgICB0aGlzLl9tYXBTdHlsZU5hbWVzKHNob3J0aGFuZE5hbWUsIHN0eWxlTmFtZXMpOwoKICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0eWxlTmFtZXMpLAogICAgICAgICAgX3N0ZXA7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgYWxzb05hbWUgPSBfc3RlcC52YWx1ZTsKCiAgICAgICAgICB0aGlzLl9tYXBTdHlsZU5hbWVzKGFsc29OYW1lLCBbc2hvcnRoYW5kTmFtZV0pOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0d28td2F5IGJpbmRpbmcgb2Ygc3R5bGUgbmFtZXMuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUKICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHN0eWxlTmFtZXMKICAgICAqIEBwcml2YXRlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21hcFN0eWxlTmFtZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXBTdHlsZU5hbWVzKG5hbWUsIHN0eWxlTmFtZXMpIHsKICAgICAgdmFyIF90aGlzJF9jb25zdW1hYmxlcyRnZTsKCiAgICAgIGlmICghdGhpcy5fY29uc3VtYWJsZXMuaGFzKG5hbWUpKSB7CiAgICAgICAgdGhpcy5fY29uc3VtYWJsZXMuc2V0KG5hbWUsIFtdKTsKICAgICAgfQoKICAgICAgKF90aGlzJF9jb25zdW1hYmxlcyRnZSA9IHRoaXMuX2NvbnN1bWFibGVzLmdldChuYW1lKSkucHVzaC5hcHBseShfdGhpcyRfY29uc3VtYWJsZXMkZ2UsIF90b0NvbnN1bWFibGVBcnJheShzdHlsZU5hbWVzKSk7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gU3R5bGVzUHJvY2Vzc29yOwp9KCk7IC8vIFBhcnNlcyBpbmxpbmUgc3R5bGVzIGFuZCBwdXRzIHByb3BlcnR5IC0gdmFsdWUgcGFpcnMgaW50byBzdHlsZXMgbWFwLgovLwovLyBAcGFyYW0ge1N0cmluZ30gc3R5bGVzU3RyaW5nIFN0eWxlcyB0byBwYXJzZS4KLy8gQHJldHVybnMge01hcC48U3RyaW5nLCBTdHJpbmc+fSBzdHlsZXNNYXAgTWFwIG9mIHBhcnNlZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuCgpmdW5jdGlvbiBwYXJzZUlubGluZVN0eWxlcyhzdHlsZXNTdHJpbmcpIHsKICAvLyBgbnVsbGAgaWYgbm8gcXVvdGUgd2FzIGZvdW5kIGluIGlucHV0IHN0cmluZyBvciBsYXN0IGZvdW5kIHF1b3RlIHdhcyBhIGNsb3NpbmcgcXVvdGUuIFNlZSBiZWxvdy4KICB2YXIgcXVvdGVUeXBlID0gbnVsbDsKICB2YXIgcHJvcGVydHlOYW1lU3RhcnQgPSAwOwogIHZhciBwcm9wZXJ0eVZhbHVlU3RhcnQgPSAwOwogIHZhciBwcm9wZXJ0eU5hbWUgPSBudWxsOwogIHZhciBzdHlsZXNNYXAgPSBuZXcgTWFwKCk7IC8vIERvIG5vdCBzZXQgYW55dGhpbmcgaWYgaW5wdXQgc3RyaW5nIGlzIGVtcHR5LgoKICBpZiAoc3R5bGVzU3RyaW5nID09PSAnJykgewogICAgcmV0dXJuIHN0eWxlc01hcDsKICB9IC8vIEZpeCBpbmxpbmUgc3R5bGVzIHRoYXQgZG8gbm90IGVuZCB3aXRoIGA7YCBzbyB0aGV5IGFyZSBjb21wYXRpYmxlIHdpdGggYWxnb3JpdGhtIGJlbG93LgoKCiAgaWYgKHN0eWxlc1N0cmluZy5jaGFyQXQoc3R5bGVzU3RyaW5nLmxlbmd0aCAtIDEpICE9ICc7JykgewogICAgc3R5bGVzU3RyaW5nID0gc3R5bGVzU3RyaW5nICsgJzsnOwogIH0gLy8gU2VlayB0aGUgd2hvbGUgc3RyaW5nIGZvciAic3BlY2lhbCBjaGFyYWN0ZXJzIi4KCgogIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzU3RyaW5nLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgY2hhciA9IHN0eWxlc1N0cmluZy5jaGFyQXQoaSk7CgogICAgaWYgKHF1b3RlVHlwZSA9PT0gbnVsbCkgewogICAgICAvLyBObyBxdW90ZSBmb3VuZCB5ZXQgb3IgbGFzdCBmb3VuZCBxdW90ZSB3YXMgYSBjbG9zaW5nIHF1b3RlLgogICAgICBzd2l0Y2ggKGNoYXIpIHsKICAgICAgICBjYXNlICc6JzoKICAgICAgICAgIC8vIE1vc3Qgb2YgdGltZSBjb2xvbiBtZWFucyB0aGF0IHByb3BlcnR5IG5hbWUganVzdCBlbmRlZC4KICAgICAgICAgIC8vIFNvbWV0aW1lcyBob3dldmVyIGA6YCBpcyBmb3VuZCBpbnNpZGUgcHJvcGVydHkgdmFsdWUgKGZvciBleGFtcGxlIGluIGJhY2tncm91bmQgaW1hZ2UgdXJsKS4KICAgICAgICAgIGlmICghcHJvcGVydHlOYW1lKSB7CiAgICAgICAgICAgIC8vIFRyZWF0IHRoaXMgYXMgZW5kIG9mIHByb3BlcnR5IG9ubHkgaWYgcHJvcGVydHkgbmFtZSBpcyBub3QgYWxyZWFkeSBzYXZlZC4KICAgICAgICAgICAgLy8gU2F2ZSBwcm9wZXJ0eSBuYW1lLgogICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBzdHlsZXNTdHJpbmcuc3Vic3RyKHByb3BlcnR5TmFtZVN0YXJ0LCBpIC0gcHJvcGVydHlOYW1lU3RhcnQpOyAvLyBTYXZlIHRoaXMgcG9pbnQgYXMgdGhlIHN0YXJ0IG9mIHByb3BlcnR5IHZhbHVlLgoKICAgICAgICAgICAgcHJvcGVydHlWYWx1ZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJyInOgogICAgICAgIGNhc2UgJ1wnJzoKICAgICAgICAgIC8vIE9wZW5pbmcgcXVvdGUgZm91bmQgKHRoaXMgaXMgYW4gb3BlbmluZyBxdW90ZSwgYmVjYXVzZSBgcXVvdGVUeXBlYCBpcyBgbnVsbGApLgogICAgICAgICAgcXVvdGVUeXBlID0gY2hhcjsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICc7JzoKICAgICAgICAgIHsKICAgICAgICAgICAgLy8gUHJvcGVydHkgdmFsdWUganVzdCBlbmRlZC4KICAgICAgICAgICAgLy8gVXNlIHByZXZpb3VzbHkgc3RvcmVkIHByb3BlcnR5IHZhbHVlIHN0YXJ0IHRvIG9idGFpbiBwcm9wZXJ0eSB2YWx1ZS4KICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBzdHlsZXNTdHJpbmcuc3Vic3RyKHByb3BlcnR5VmFsdWVTdGFydCwgaSAtIHByb3BlcnR5VmFsdWVTdGFydCk7CgogICAgICAgICAgICBpZiAocHJvcGVydHlOYW1lKSB7CiAgICAgICAgICAgICAgLy8gU2F2ZSBwYXJzZWQgcGFydC4KICAgICAgICAgICAgICBzdHlsZXNNYXAuc2V0KHByb3BlcnR5TmFtZS50cmltKCksIHByb3BlcnR5VmFsdWUudHJpbSgpKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gbnVsbDsgLy8gU2F2ZSB0aGlzIHBvaW50IGFzIHByb3BlcnR5IG5hbWUgc3RhcnQuIFByb3BlcnR5IG5hbWUgc3RhcnRzIGltbWVkaWF0ZWx5IGFmdGVyIHByZXZpb3VzIHByb3BlcnR5IHZhbHVlIGVuZHMuCgogICAgICAgICAgICBwcm9wZXJ0eU5hbWVTdGFydCA9IGkgKyAxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIGlmIChjaGFyID09PSBxdW90ZVR5cGUpIHsKICAgICAgLy8gSWYgYSBxdW90ZSBjaGFyIGlzIGZvdW5kIGFuZCBpdCBpcyBhIGNsb3NpbmcgcXVvdGUsIG1hcmsgdGhpcyBmYWN0IGJ5IGBudWxsYC1pbmcgYHF1b3RlVHlwZWAuCiAgICAgIHF1b3RlVHlwZSA9IG51bGw7CiAgICB9CiAgfQoKICByZXR1cm4gc3R5bGVzTWFwOwp9IC8vIFJldHVybiBsb2Rhc2ggY29tcGF0aWJsZSBwYXRoIGZyb20gc3R5bGUgbmFtZS4KCgpmdW5jdGlvbiB0b1BhdGgobmFtZSkgewogIHJldHVybiBuYW1lLnJlcGxhY2UoJy0nLCAnLicpOwp9IC8vIEFwcGVuZHMgc3R5bGUgZGVmaW5pdGlvbiB0byB0aGUgc3R5bGVzIG9iamVjdC4KLy8KLy8gQHBhcmFtIHtTdHJpbmd9IG5hbWVPclBhdGgKLy8gQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZU9yT2JqZWN0Ci8vIEBwcml2YXRlCgoKZnVuY3Rpb24gYXBwZW5kU3R5bGVWYWx1ZShzdHlsZXNPYmplY3QsIG5hbWVPclBhdGgsIHZhbHVlT3JPYmplY3QpIHsKICB2YXIgdmFsdWVUb1NldCA9IHZhbHVlT3JPYmplY3Q7CgogIGlmIChpc09iamVjdCh2YWx1ZU9yT2JqZWN0KSkgewogICAgdmFsdWVUb1NldCA9IG1lcmdlKHt9LCBnZXQoc3R5bGVzT2JqZWN0LCBuYW1lT3JQYXRoKSwgdmFsdWVPck9iamVjdCk7CiAgfQoKICBzZXQoc3R5bGVzT2JqZWN0LCBuYW1lT3JQYXRoLCB2YWx1ZVRvU2V0KTsKfQovKioKICogQSBDU1Mgc3R5bGUgcHJvcGVydHkgZGVzY3JpcHRvciB0aGF0IGNvbnRhaW5zIHR1cGxldCBvZiB0d28gc3RyaW5nczoKICoKICogLSBmaXJzdCBzdHJpbmcgZGVzY3JpYmVzIHByb3BlcnR5IG5hbWUKICogLSBzZWNvbmQgc3RyaW5nIGRlc2NyaWJlcyBwcm9wZXJ0eSB2YWx1ZQogKgogKgkJY29uc3QgbWFyZ2luRGVzY3JpcHRvciA9IFsgJ21hcmdpbicsICcycHggM2VtJyBdOwogKgkJY29uc3QgbWFyZ2luVG9wRGVzY3JpcHRvciA9IFsgJ21hcmdpbi10b3AnLCAnMnB4JyBdOwogKgogKiBAdHlwZWRlZiB7QXJyYXkuPFN0cmluZywgU3RyaW5nPn0gbW9kdWxlOmVuZ2luZS92aWV3L3N0eWxlc21hcH5Qcm9wZXJ0eURlc2NyaXB0b3IKICovCgovKioKICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lkZXMgb2YgYSBib3gsIGZvciBpbnN0YW5jZSBtYXJnaW5zLCBwYWRkaW5ncywKICogYm9yZGVyIHdpZHRocywgYm9yZGVyIGNvbG9ycywgZXRjLgogKgogKgkJY29uc3QgbWFyZ2luID0gewogKgkJCXRvcDogJzFweCcsCiAqCQkJcmlnaHQ6ICczcHgnLAogKgkJCWJvdHRvbTogJzNweCcsCiAqCQkJbGVmdDogJzdweCcKICoJCX07CiAqCiAqCQljb25zdCBib3JkZXJDb2xvciA9IHsKICoJCQl0b3A6ICdyZWQnLAogKgkJCXJpZ2h0OiAnYmx1ZScsCiAqCQkJYm90dG9tOiAnYmx1ZScsCiAqCQkJbGVmdDogJ3JlZCcKICoJCX07CiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+Qm94U2lkZXMKICoKICogQHByb3BlcnR5IHtTdHJpbmd9IHRvcCBUb3Agc2lkZSB2YWx1ZS4KICogQHByb3BlcnR5IHtTdHJpbmd9IHJpZ2h0IFJpZ2h0IHNpZGUgdmFsdWUuCiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBib3R0b20gQm90dG9tIHNpZGUgdmFsdWUuCiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsZWZ0IExlZnQgc2lkZSB2YWx1ZS4KICov"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js"],"names":["get","isObject","merge","set","unset","StylesMap","styleProcessor","_styles","_styleProcessor","entries","Object","from","Array","length","isEmpty","getStyleNames","inlineStyle","clear","parsedStyles","parseInlineStyles","key","value","toNormalizedForm","name","styles","getReducedForm","propertyDescriptor","find","property","isArray","nameOrObject","valueOrObject","path","toPath","_cleanEmptyObjectsOnPath","getNormalized","_getStylesEntries","map","arr","join","sort","propertyName","parsed","keys","push","pathParts","split","isChildPath","parentPath","splice","parentObject","isParentEmpty","remove","StylesProcessor","_normalizers","Map","_extractors","_reducers","_consumables","propertyValue","appendStyleValue","has","normalizer","undefined","extractor","normalizedValue","reducer","callback","callbackOrPath","shorthandName","styleNames","_mapStyleNames","alsoName","stylesString","quoteType","propertyNameStart","propertyValueStart","stylesMap","charAt","i","char","substr","trim","replace","stylesObject","nameOrPath","valueToSet"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,GAAT,EAAcC,QAAd,EAAwBC,KAAxB,EAA+BC,GAA/B,EAAoCC,KAApC,QAAiD,WAAjD;AAEA;AACA;AACA;AACA;AACA;;IACqBC,S;AACpB;AACD;AACA;AACA;AACA;AACC,qBAAaC,cAAb,EAA8B;AAAA;;AAC7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,OAAL,GAAe,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,eAAL,GAAuBF,cAAvB;AACA;AAED;AACD;AACA;AACA;AACA;;;;;SACC,eAAc;AACb,UAAMG,OAAO,GAAGC,MAAM,CAACD,OAAP,CAAgB,KAAKF,OAArB,CAAhB;AACA,UAAMI,IAAI,GAAGC,KAAK,CAACD,IAAN,CAAYF,OAAZ,CAAb;AAEA,aAAO,CAACE,IAAI,CAACE,MAAb;AACA;AAED;AACD;AACA;AACA;AACA;;;;SACC,eAAW;AACV,UAAK,KAAKC,OAAV,EAAoB;AACnB,eAAO,CAAP;AACA;;AAED,aAAO,KAAKC,aAAL,GAAqBF,MAA5B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,eAAOG,WAAP,EAAqB;AACpB,WAAKC,KAAL;AAEA,UAAMC,YAAY,GAAGN,KAAK,CAACD,IAAN,CAAYQ,iBAAiB,CAAEH,WAAF,CAAjB,CAAiCP,OAAjC,EAAZ,CAArB;;AAEA,uCAA8BS,YAA9B,mCAA6C;AAAA;AAAA,YAA/BE,GAA+B;AAAA,YAA1BC,KAA0B;;AAC5C,aAAKb,eAAL,CAAqBc,gBAArB,CAAuCF,GAAvC,EAA4CC,KAA5C,EAAmD,KAAKd,OAAxD;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,aAAKgB,IAAL,EAAY;AACX,UAAK,KAAKT,OAAV,EAAoB;AACnB,eAAO,KAAP;AACA;;AAED,UAAMU,MAAM,GAAG,KAAKhB,eAAL,CAAqBiB,cAArB,CAAqCF,IAArC,EAA2C,KAAKhB,OAAhD,CAAf;;AAEA,UAAMmB,kBAAkB,GAAGF,MAAM,CAACG,IAAP,CAAa;AAAA;AAAA,YAAIC,QAAJ;;AAAA,eAAoBA,QAAQ,KAAKL,IAAjC;AAAA,OAAb,CAA3B,CAPW,CASX;;AACA,aAAOX,KAAK,CAACiB,OAAN,CAAeH,kBAAf,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,aAAKI,YAAL,EAAmBC,aAAnB,EAAmC;AAClC,UAAK9B,QAAQ,CAAE6B,YAAF,CAAb,EAAgC;AAC/B,4CAA8BpB,MAAM,CAACD,OAAP,CAAgBqB,YAAhB,CAA9B,uCAA+D;AAAA;AAAA,cAAjDV,GAAiD;AAAA,cAA5CC,KAA4C;;AAC9D,eAAKb,eAAL,CAAqBc,gBAArB,CAAuCF,GAAvC,EAA4CC,KAA5C,EAAmD,KAAKd,OAAxD;AACA;AACD,OAJD,MAIO;AACN,aAAKC,eAAL,CAAqBc,gBAArB,CAAuCQ,YAAvC,EAAqDC,aAArD,EAAoE,KAAKxB,OAAzE;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gBAAQgB,IAAR,EAAe;AACd,UAAMS,IAAI,GAAGC,MAAM,CAAEV,IAAF,CAAnB;AAEAnB,MAAAA,KAAK,CAAE,KAAKG,OAAP,EAAgByB,IAAhB,CAAL;AACA,aAAO,KAAKzB,OAAL,CAAcgB,IAAd,CAAP;;AAEA,WAAKW,wBAAL,CAA+BF,IAA/B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeT,IAAf,EAAsB;AACrB,aAAO,KAAKf,eAAL,CAAqB2B,aAArB,CAAoCZ,IAApC,EAA0C,KAAKhB,OAA/C,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,oBAAW;AACV,UAAK,KAAKO,OAAV,EAAoB;AACnB,eAAO,EAAP;AACA;;AAED,aAAO,KAAKsB,iBAAL,GACLC,GADK,CACA,UAAAC,GAAG;AAAA,eAAIA,GAAG,CAACC,IAAJ,CAAU,GAAV,CAAJ;AAAA,OADH,EAELC,IAFK,GAGLD,IAHK,CAGC,GAHD,IAGS,GAHhB;AAIA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,qBAAaE,YAAb,EAA4B;AAC3B,UAAK,KAAK3B,OAAV,EAAoB;AACnB;AACA;;AAED,UAAK,KAAKP,OAAL,CAAckC,YAAd,KAAgC,CAACxC,QAAQ,CAAE,KAAKM,OAAL,CAAckC,YAAd,CAAF,CAA9C,EAAiF;AAChF;AACA,eAAO,KAAKlC,OAAL,CAAckC,YAAd,CAAP;AACA;;AAED,UAAMjB,MAAM,GAAG,KAAKhB,eAAL,CAAqBiB,cAArB,CAAqCgB,YAArC,EAAmD,KAAKlC,OAAxD,CAAf;;AAEA,UAAMmB,kBAAkB,GAAGF,MAAM,CAACG,IAAP,CAAa;AAAA;AAAA,YAAIC,QAAJ;;AAAA,eAAoBA,QAAQ,KAAKa,YAAjC;AAAA,OAAb,CAA3B,CAZ2B,CAc3B;;AACA,UAAK7B,KAAK,CAACiB,OAAN,CAAeH,kBAAf,CAAL,EAA2C;AAC1C,eAAOA,kBAAkB,CAAE,CAAF,CAAzB;AACA;AACD;AAED;AACD;AACA;AACA;AACA;;;;WACC,yBAAgB;AACf,UAAK,KAAKZ,OAAV,EAAoB;AACnB,eAAO,EAAP;AACA;;AAED,UAAML,OAAO,GAAG,KAAK2B,iBAAL,EAAhB;;AAEA,aAAO3B,OAAO,CAAC4B,GAAR,CAAa;AAAA;AAAA,YAAIjB,GAAJ;;AAAA,eAAeA,GAAf;AAAA,OAAb,CAAP;AACA;AAED;AACD;AACA;;;;WACC,iBAAQ;AACP,WAAKb,OAAL,GAAe,EAAf;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,6BAAoB;AACnB,UAAMmC,MAAM,GAAG,EAAf;AAEA,UAAMC,IAAI,GAAGjC,MAAM,CAACiC,IAAP,CAAa,KAAKpC,OAAlB,CAAb;;AAEA,gCAAmBoC,IAAnB,6BAA0B;AAApB,YAAMvB,GAAG,aAAT;AACLsB,QAAAA,MAAM,CAACE,IAAP,OAAAF,MAAM,qBAAU,KAAKlC,eAAL,CAAqBiB,cAArB,CAAqCL,GAArC,EAA0C,KAAKb,OAA/C,CAAV,EAAN;AACA;;AAED,aAAOmC,MAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,kCAA0BV,IAA1B,EAAiC;AAChC,UAAMa,SAAS,GAAGb,IAAI,CAACc,KAAL,CAAY,GAAZ,CAAlB;AACA,UAAMC,WAAW,GAAGF,SAAS,CAAChC,MAAV,GAAmB,CAAvC;;AAEA,UAAK,CAACkC,WAAN,EAAoB;AACnB;AACA;;AAED,UAAMC,UAAU,GAAGH,SAAS,CAACI,MAAV,CAAkB,CAAlB,EAAqBJ,SAAS,CAAChC,MAAV,GAAmB,CAAxC,EAA4C0B,IAA5C,CAAkD,GAAlD,CAAnB;AAEA,UAAMW,YAAY,GAAGlD,GAAG,CAAE,KAAKO,OAAP,EAAgByC,UAAhB,CAAxB;;AAEA,UAAK,CAACE,YAAN,EAAqB;AACpB;AACA;;AAED,UAAMC,aAAa,GAAG,CAACvC,KAAK,CAACD,IAAN,CAAYD,MAAM,CAACiC,IAAP,CAAaO,YAAb,CAAZ,EAA0CrC,MAAjE;;AAEA,UAAKsC,aAAL,EAAqB;AACpB,aAAKC,MAAL,CAAaJ,UAAb;AACA;AACD;;;;;AAGF;AACA;AACA;;;SAvZqB3C,S;AAwZrB,WAAagD,eAAb;AACC;AACD;AACA;AACA;AACA;AACC,6BAAc;AAAA;;AACb,SAAKC,YAAL,GAAoB,IAAIC,GAAJ,EAApB;AACA,SAAKC,WAAL,GAAmB,IAAID,GAAJ,EAAnB;AACA,SAAKE,SAAL,GAAiB,IAAIF,GAAJ,EAAjB;AACA,SAAKG,YAAL,GAAoB,IAAIH,GAAJ,EAApB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA3BA;AAAA;AAAA,WA4BC,0BAAkBhC,IAAlB,EAAwBoC,aAAxB,EAAuCnC,MAAvC,EAAgD;AAC/C,UAAKvB,QAAQ,CAAE0D,aAAF,CAAb,EAAiC;AAChCC,QAAAA,gBAAgB,CAAEpC,MAAF,EAAUS,MAAM,CAAEV,IAAF,CAAhB,EAA0BoC,aAA1B,CAAhB;AAEA;AACA;;AAED,UAAK,KAAKL,YAAL,CAAkBO,GAAlB,CAAuBtC,IAAvB,CAAL,EAAqC;AACpC,YAAMuC,UAAU,GAAG,KAAKR,YAAL,CAAkBtD,GAAlB,CAAuBuB,IAAvB,CAAnB;;AADoC,0BAGZuC,UAAU,CAAEH,aAAF,CAHE;AAAA,YAG5B3B,IAH4B,eAG5BA,IAH4B;AAAA,YAGtBX,KAHsB,eAGtBA,KAHsB;;AAKpCuC,QAAAA,gBAAgB,CAAEpC,MAAF,EAAUQ,IAAV,EAAgBX,KAAhB,CAAhB;AACA,OAND,MAMO;AACNuC,QAAAA,gBAAgB,CAAEpC,MAAF,EAAUD,IAAV,EAAgBoC,aAAhB,CAAhB;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhEA;AAAA;AAAA,WAiEC,uBAAepC,IAAf,EAAqBC,MAArB,EAA8B;AAC7B,UAAK,CAACD,IAAN,EAAa;AACZ,eAAOrB,KAAK,CAAE,EAAF,EAAMsB,MAAN,CAAZ;AACA,OAH4B,CAK7B;;;AACA,UAAKA,MAAM,CAAED,IAAF,CAAN,KAAmBwC,SAAxB,EAAoC;AACnC,eAAOvC,MAAM,CAAED,IAAF,CAAb;AACA;;AAED,UAAK,KAAKiC,WAAL,CAAiBK,GAAjB,CAAsBtC,IAAtB,CAAL,EAAoC;AACnC,YAAMyC,SAAS,GAAG,KAAKR,WAAL,CAAiBxD,GAAjB,CAAsBuB,IAAtB,CAAlB;;AAEA,YAAK,OAAOyC,SAAP,KAAqB,QAA1B,EAAqC;AACpC,iBAAOhE,GAAG,CAAEwB,MAAF,EAAUwC,SAAV,CAAV;AACA;;AAED,YAAM3C,KAAK,GAAG2C,SAAS,CAAEzC,IAAF,EAAQC,MAAR,CAAvB;;AAEA,YAAKH,KAAL,EAAa;AACZ,iBAAOA,KAAP;AACA;AACD;;AAED,aAAOrB,GAAG,CAAEwB,MAAF,EAAUS,MAAM,CAAEV,IAAF,CAAhB,CAAV;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1HA;AAAA;AAAA,WA2HC,wBAAgBA,IAAhB,EAAsBC,MAAtB,EAA+B;AAC9B,UAAMyC,eAAe,GAAG,KAAK9B,aAAL,CAAoBZ,IAApB,EAA0BC,MAA1B,CAAxB,CAD8B,CAG9B;;AACA,UAAKyC,eAAe,KAAKF,SAAzB,EAAqC;AACpC,eAAO,EAAP;AACA;;AAED,UAAK,KAAKN,SAAL,CAAeI,GAAf,CAAoBtC,IAApB,CAAL,EAAkC;AACjC,YAAM2C,OAAO,GAAG,KAAKT,SAAL,CAAezD,GAAf,CAAoBuB,IAApB,CAAhB;;AAEA,eAAO2C,OAAO,CAAED,eAAF,CAAd;AACA;;AAED,aAAO,CAAE,CAAE1C,IAAF,EAAQ0C,eAAR,CAAF,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1JA;AAAA;AAAA,WA2JC,0BAAkB1C,IAAlB,EAAyB;AACxB,aAAO,KAAKmC,YAAL,CAAkB1D,GAAlB,CAAuBuB,IAAvB,KAAiC,EAAxC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjNA;AAAA;AAAA,WAkNC,uBAAeA,IAAf,EAAqB4C,QAArB,EAAgC;AAC/B,WAAKb,YAAL,CAAkBnD,GAAlB,CAAuBoB,IAAvB,EAA6B4C,QAA7B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5PA;AAAA;AAAA,WA6PC,sBAAc5C,IAAd,EAAoB6C,cAApB,EAAqC;AACpC,WAAKZ,WAAL,CAAiBrD,GAAjB,CAAsBoB,IAAtB,EAA4B6C,cAA5B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjSA;AAAA;AAAA,WAkSC,oBAAY7C,IAAZ,EAAkB4C,QAAlB,EAA6B;AAC5B,WAAKV,SAAL,CAAetD,GAAf,CAAoBoB,IAApB,EAA0B4C,QAA1B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/stylesmap\n */\n\nimport { get, isObject, merge, set, unset } from 'lodash-es';\n\n/**\n * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).\n *\n * The styles map is capable of normalizing style names so e.g. the following operations are possible:\n */\nexport default class StylesMap {\n\t/**\n\t * Creates Styles instance.\n\t *\n\t * @param {module:engine/view/stylesmap~StylesProcessor} styleProcessor\n\t */\n\tconstructor( styleProcessor ) {\n\t\t/**\n\t\t * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and\n\t\t * value access model using lodash's get, set, unset, etc methods.\n\t\t *\n\t\t * When no style processor rules are defined the it acts as simple key-value storage.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._styles = {};\n\n\t\t/**\n\t\t * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis._styleProcessor = styleProcessor;\n\t}\n\n\t/**\n\t * Returns true if style map has no styles set.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget isEmpty() {\n\t\tconst entries = Object.entries( this._styles );\n\t\tconst from = Array.from( entries );\n\n\t\treturn !from.length;\n\t}\n\n\t/**\n\t * Number of styles defined.\n\t *\n\t * @type {Number}\n\t */\n\tget size() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.getStyleNames().length;\n\t}\n\n\t/**\n\t * Set styles map to a new value.\n\t *\n\t *\t\tstyles.setTo( 'border:1px solid blue;margin-top:1px;' );\n\t *\n\t * @param {String} inlineStyle\n\t */\n\tsetTo( inlineStyle ) {\n\t\tthis.clear();\n\n\t\tconst parsedStyles = Array.from( parseInlineStyles( inlineStyle ).entries() );\n\n\t\tfor ( const [ key, value ] of parsedStyles ) {\n\t\t\tthis._styleProcessor.toNormalizedForm( key, value, this._styles );\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a given style is set.\n\t *\n\t *\t\tstyles.setTo( 'margin-left:1px;' );\n\t *\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\t\tstyles.has( 'padding' );        // -> false\n\t *\n\t * **Note**: This check supports normalized style names.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.setTo( 'margin:2px;' );\n\t *\n\t *\t\tstyles.has( 'margin' );         // -> true\n\t *\t\tstyles.has( 'margin-top' );     // -> true\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\n\t *\t\tstyles.has( 'margin' );         // -> false\n\t *\t\tstyles.has( 'margin-top' );     // -> false\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\n\t * @param {String} name Style name.\n\t * @returns {Boolean}\n\t */\n\thas( name ) {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst styles = this._styleProcessor.getReducedForm( name, this._styles );\n\n\t\tconst propertyDescriptor = styles.find( ( [ property ] ) => property === name );\n\n\t\t// Only return a value if it is set;\n\t\treturn Array.isArray( propertyDescriptor );\n\t}\n\n\t/**\n\t * Sets a given style.\n\t *\n\t * Can insert one by one:\n\t *\n\t *\t\tstyles.set( 'color', 'blue' );\n\t *\t\tstyles.set( 'margin-right', '1em' );\n\t *\n\t * or many styles at once:\n\t *\n\t *\t\tstyles.set( {\n\t *\t\t\tcolor: 'blue',\n\t *\t\t\t'margin-right': '1em'\n\t *\t\t} );\n\t *\n\t * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n\t * enabled style processor rules} to normalize passed values.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.set( 'margin', '2px' );\n\t *\n\t * The above code will set margin to:\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );\n\t *\t\t// -> { top: '2px', right: '2px', bottom: '2px', left: '2px' }\n\t *\n\t * Which makes it possible to retrieve a \"sub-value\":\n\t *\n\t *\t\tstyles.get( 'margin-left' );       // -> '2px'\n\t *\n\t * Or modify it:\n\t *\n\t *\t\tstyles.remove( 'margin-left' );\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );  // -> { top: '1px', bottom: '1px', right: '1px' }\n\t *\t\tstyles.toString();                 // -> 'margin-bottom:1px;margin-right:1px;margin-top:1px;'\n\t *\n\t * This method also allows to set normalized values directly (if a particular styles processor rule was enabled):\n\t *\n\t *\t\tstyles.set( 'border-color', { top: 'blue' } );\n\t *\t\tstyles.set( 'margin', { right: '2em' } );\n\t *\n\t *\t\tstyles.toString();                 // -> 'border-color-top:blue;margin-right:2em;'\n\t *\n\t * @param {String|Object} nameOrObject Style property name or object with multiple properties.\n\t * @param {String|Object} valueOrObject Value to set.\n\t */\n\tset( nameOrObject, valueOrObject ) {\n\t\tif ( isObject( nameOrObject ) ) {\n\t\t\tfor ( const [ key, value ] of Object.entries( nameOrObject ) ) {\n\t\t\t\tthis._styleProcessor.toNormalizedForm( key, value, this._styles );\n\t\t\t}\n\t\t} else {\n\t\t\tthis._styleProcessor.toNormalizedForm( nameOrObject, valueOrObject, this._styles );\n\t\t}\n\t}\n\n\t/**\n\t * Removes given style.\n\t *\n\t *\t\tstyles.setTo( 'background:#f00;margin-right:2px;' );\n\t *\n\t *\t\tstyles.remove( 'background' );\n\t *\n\t *\t\tstyles.toString();   // -> 'margin-right:2px;'\n\t *\n\t * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n\t * enabled style processor rules} to normalize passed values.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.setTo( 'margin:1px' );\n\t *\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\t\tstyles.remove( 'margin-right' );\n\t *\n\t *\t\tstyles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'\n\t *\n\t * @param {String} name Style name.\n\t */\n\tremove( name ) {\n\t\tconst path = toPath( name );\n\n\t\tunset( this._styles, path );\n\t\tdelete this._styles[ name ];\n\n\t\tthis._cleanEmptyObjectsOnPath( path );\n\t}\n\n\t/**\n\t * Returns a normalized style object or a single value.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px 2px 3em;' );\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );\n\t *\t\t// will log:\n\t *\t\t// {\n\t *\t\t//     top: '1px',\n\t *\t\t//     right: '2px',\n\t *\t\t//     bottom: '3em',\n\t *\t\t//     left: '2px'     // normalized value from margin shorthand\n\t *\t\t// }\n\t *\n\t *\t\tstyles.getNormalized( 'margin-left' ); // -> '2px'\n\t *\n\t * **Note**: This method will only return normalized styles if a style processor was defined.\n\t *\n\t * @param {String} name Style name.\n\t * @returns {Object|String|undefined}\n\t */\n\tgetNormalized( name ) {\n\t\treturn this._styleProcessor.getNormalized( name, this._styles );\n\t}\n\n\t/**\n\t * Returns a normalized style string. Styles are sorted by name.\n\t *\n\t *\t\tstyles.set( 'margin' , '1px' );\n\t *\t\tstyles.set( 'background', '#f00' );\n\t *\n\t *\t\tstyles.toString(); // -> 'background:#f00;margin:1px;'\n\t *\n\t * **Note**: This method supports normalized styles if defined.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.set( 'margin' , '1px' );\n\t *\t\tstyles.set( 'background', '#f00' );\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\t\tstyles.remove( 'margin-right' );\n\t *\n\t *\t\tstyles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'\n\t *\n\t * @returns {String}\n\t */\n\ttoString() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this._getStylesEntries()\n\t\t\t.map( arr => arr.join( ':' ) )\n\t\t\t.sort()\n\t\t\t.join( ';' ) + ';';\n\t}\n\n\t/**\n\t * Returns property as a value string or undefined if property is not set.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.set( 'margin-bottom', '3em' );\n\t *\n\t *\t\tstyles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'\n\t *\n\t * Note, however, that all sub-values must be set for the longhand property name to return a value:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.remove( 'margin-bottom' );\n\t *\n\t *\t\tstyles.getAsString( 'margin' ); // -> undefined\n\t *\n\t * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.\n\t * Instead, you should use:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.remove( 'margin-bottom' );\n\t *\n\t *\t\tfor ( const styleName of styles.getStyleNames() ) {\n\t *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n\t *\t\t}\n\t *\t\t// 'margin-top', '1px'\n\t *\t\t// 'margin-right', '1px'\n\t *\t\t// 'margin-left', '1px'\n\t *\n\t * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all\n\t * the currently set style values. So, if all the 4 margin values would be set\n\t * the for-of loop above would yield only `'margin'`, `'1px'`:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\n\t *\t\tfor ( const styleName of styles.getStyleNames() ) {\n\t *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n\t *\t\t}\n\t *\t\t// 'margin', '1px'\n\t *\n\t * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.\n\t *\n\t * @param {String} propertyName\n\t * @returns {String|undefined}\n\t */\n\tgetAsString( propertyName ) {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._styles[ propertyName ] && !isObject( this._styles[ propertyName ] ) ) {\n\t\t\t// Try return styles set directly - values that are not parsed.\n\t\t\treturn this._styles[ propertyName ];\n\t\t}\n\n\t\tconst styles = this._styleProcessor.getReducedForm( propertyName, this._styles );\n\n\t\tconst propertyDescriptor = styles.find( ( [ property ] ) => property === propertyName );\n\n\t\t// Only return a value if it is set;\n\t\tif ( Array.isArray( propertyDescriptor ) ) {\n\t\t\treturn propertyDescriptor[ 1 ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns style property names as they would appear when using {@link #toString `#toString()`}.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tgetStyleNames() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst entries = this._getStylesEntries();\n\n\t\treturn entries.map( ( [ key ] ) => key );\n\t}\n\n\t/**\n\t * Removes all styles.\n\t */\n\tclear() {\n\t\tthis._styles = {};\n\t}\n\n\t/**\n\t * Returns normalized styles entries for further processing.\n\t *\n\t * @private\n\t * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n\t */\n\t_getStylesEntries() {\n\t\tconst parsed = [];\n\n\t\tconst keys = Object.keys( this._styles );\n\n\t\tfor ( const key of keys ) {\n\t\t\tparsed.push( ...this._styleProcessor.getReducedForm( key, this._styles ) );\n\t\t}\n\n\t\treturn parsed;\n\t}\n\n\t/**\n\t * Removes empty objects upon removing an entry from internal object.\n\t *\n\t * @param {String} path\n\t * @private\n\t */\n\t_cleanEmptyObjectsOnPath( path ) {\n\t\tconst pathParts = path.split( '.' );\n\t\tconst isChildPath = pathParts.length > 1;\n\n\t\tif ( !isChildPath ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst parentPath = pathParts.splice( 0, pathParts.length - 1 ).join( '.' );\n\n\t\tconst parentObject = get( this._styles, parentPath );\n\n\t\tif ( !parentObject ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isParentEmpty = !Array.from( Object.keys( parentObject ) ).length;\n\n\t\tif ( isParentEmpty ) {\n\t\t\tthis.remove( parentPath );\n\t\t}\n\t}\n}\n\n/**\n * Style processor is responsible for writing and reading a normalized styles object.\n */\nexport class StylesProcessor {\n\t/**\n\t * Creates StylesProcessor instance.\n\t *\n\t * @private\n\t */\n\tconstructor() {\n\t\tthis._normalizers = new Map();\n\t\tthis._extractors = new Map();\n\t\tthis._reducers = new Map();\n\t\tthis._consumables = new Map();\n\t}\n\n\t/**\n\t * Parse style string value to a normalized object and appends it to styles object.\n\t *\n\t *\t\tconst styles = {};\n\t *\n\t *\t\tstylesProcessor.toNormalizedForm( 'margin', '1px', styles );\n\t *\n\t *\t\t// styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }\n\t *\n\t * **Note**: To define normalizer callbacks use {@link #setNormalizer}.\n\t *\n\t * @param {String} name Name of style property.\n\t * @param {String} propertyValue Value of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t */\n\ttoNormalizedForm( name, propertyValue, styles ) {\n\t\tif ( isObject( propertyValue ) ) {\n\t\t\tappendStyleValue( styles, toPath( name ), propertyValue );\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._normalizers.has( name ) ) {\n\t\t\tconst normalizer = this._normalizers.get( name );\n\n\t\t\tconst { path, value } = normalizer( propertyValue );\n\n\t\t\tappendStyleValue( styles, path, value );\n\t\t} else {\n\t\t\tappendStyleValue( styles, name, propertyValue );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a normalized version of a style property.\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },\n\t *\t\t\tbackground: { color: '#f00' }\n\t *\t\t};\n\t *\n\t *\t\tstylesProcessor.getNormalized( 'background' );\n\t *\t\t// will return: { color: '#f00' }\n\t *\n\t *\t\tstylesProcessor.getNormalized( 'margin-top' );\n\t *\t\t// will return: '1px'\n\t *\n\t * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.\n\t *\n\t * @param {String} name Name of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t * @returns {*}\n\t */\n\tgetNormalized( name, styles ) {\n\t\tif ( !name ) {\n\t\t\treturn merge( {}, styles );\n\t\t}\n\n\t\t// Might be empty string.\n\t\tif ( styles[ name ] !== undefined ) {\n\t\t\treturn styles[ name ];\n\t\t}\n\n\t\tif ( this._extractors.has( name ) ) {\n\t\t\tconst extractor = this._extractors.get( name );\n\n\t\t\tif ( typeof extractor === 'string' ) {\n\t\t\t\treturn get( styles, extractor );\n\t\t\t}\n\n\t\t\tconst value = extractor( name, styles );\n\n\t\t\tif ( value ) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\treturn get( styles, toPath( name ) );\n\t}\n\n\t/**\n\t * Returns a reduced form of style property form normalized object.\n\t *\n\t * For default margin reducer, the below code:\n\t *\n\t *\t\tstylesProcessor.getReducedForm( 'margin', {\n\t *\t\t\tmargin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }\n\t *\t\t} );\n\t *\n\t * will return:\n\t *\n\t *\t\t[\n\t *\t\t\t[ 'margin', '1px 1px 2px' ]\n\t *\t\t]\n\t *\n\t * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:\n\t *\n\t *\t\t[\n\t *\t\t\t[ 'margin-top', '1px' ],\n\t *\t\t\t[ 'margin-right', '1px' ],\n\t *\t\t\t[ 'margin-bottom', '2px' ]\n\t *\t\t\t// the 'left' value is missing - cannot use 'margin' shorthand.\n\t *\t\t]\n\t *\n\t * **Note**: To define reducer callbacks use {@link #setReducer}.\n\t *\n\t * @param {String} name\n\t * @param {String} name Name of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n\t */\n\tgetReducedForm( name, styles ) {\n\t\tconst normalizedValue = this.getNormalized( name, styles );\n\n\t\t// Might be empty string.\n\t\tif ( normalizedValue === undefined ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( this._reducers.has( name ) ) {\n\t\t\tconst reducer = this._reducers.get( name );\n\n\t\t\treturn reducer( normalizedValue );\n\t\t}\n\n\t\treturn [ [ name, normalizedValue ] ];\n\t}\n\n\t/**\n\t * Returns related style names.\n\t *\n\t *\t\tstylesProcessor.getRelatedStyles( 'margin' );\n\t *\t\t// will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];\n\t *\n\t *\t\tstylesProcessor.getRelatedStyles( 'margin-top' );\n\t *\t\t// will return: [ 'margin' ];\n\t *\n\t * **Note**: To define new style relations load an existing style processor or use\n\t * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.\n\t *\n\t * @param {String} name\n\t * @returns {Array.<String>}\n\t */\n\tgetRelatedStyles( name ) {\n\t\treturn this._consumables.get( name ) || [];\n\t}\n\n\t/**\n\t * Adds a normalizer method for a style property.\n\t *\n\t * A normalizer returns describing how the value should be normalized.\n\t *\n\t * For instance 'margin' style is a shorthand for four margin values:\n\t *\n\t * - 'margin-top'\n\t * - 'margin-right'\n\t * - 'margin-bottom'\n\t * - 'margin-left'\n\t *\n\t * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for\n\t * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.\n\t *\n\t * A normalizer should parse various margin notations as a single object:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: {\n\t *\t\t\t\ttop: '1px',\n\t *\t\t\t\tright: '2em',\n\t *\t\t\t\tbottom: '1px',\n\t *\t\t\t\tleft: '2em'\n\t *\t\t\t}\n\t *\t\t};\n\t *\n\t * Thus a normalizer for 'margin' style should return an object defining style path and value to store:\n\t *\n\t *\t\tconst returnValue = {\n\t *\t\t\tpath: 'margin',\n\t *\t\t\tvalue: {\n\t *\t\t\t\ttop: '1px',\n\t *\t\t\t\tright: '2em',\n\t *\t\t\t\tbottom: '1px',\n\t *\t\t\t\tleft: '2em'\n\t *\t\t\t}\n\t *\t\t};\n\t *\n\t * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below\n\t * is an example for 'margin-top' style property normalizer:\n\t *\n\t *\t\tstylesProcessor.setNormalizer( 'margin-top', valueString => {\n\t *\t\t\treturn {\n\t *\t\t\t\tpath: 'margin.top',\n\t *\t\t\t\tvalue: valueString\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function} callback\n\t */\n\tsetNormalizer( name, callback ) {\n\t\tthis._normalizers.set( name, callback );\n\t}\n\n\t/**\n\t * Adds a extractor callback for a style property.\n\t *\n\t * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: {\n\t *\t\t\t\ttop: 'value'\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance\n\t * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`\n\t * shorthands. The default border styles processors stores styles as:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tborder: {\n\t *\t\t\t\tstyle: {\n\t *\t\t\t\t\ttop: 'solid'\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * as it is better to modify border style independently from other values. On the other part the output of the border might be\n\t * desired as `border-top`, `border-left`, etc notation.\n\t *\n\t * In the above example a reducer should return a side border value that combines style, color and width:\n\t *\n\t *\t\tstyleProcessor.setExtractor( 'border-top', styles => {\n\t *\t\t\treturn {\n\t *\t\t\t\tcolor: styles.border.color.top,\n\t *\t\t\t\tstyle: styles.border.style.top,\n\t *\t\t\t\twidth: styles.border.width.top\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function|String} callbackOrPath Callback that return a requested value or path string for single values.\n\t */\n\tsetExtractor( name, callbackOrPath ) {\n\t\tthis._extractors.set( name, callbackOrPath );\n\t}\n\n\t/**\n\t * Adds a reducer callback for a style property.\n\t *\n\t * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as\n\t * by default the direct value from style path is taken.\n\t *\n\t * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples\n\t * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:\n\t *\n\t *\t\tconst marginShortHandTuple = [\n\t *\t\t\t[ 'margin', '1px 1px 2px' ]\n\t *\t\t];\n\t *\n\t * or a longhand tuples for defined values:\n\t *\n\t *\t\t// Considering margin.bottom and margin.left are undefined.\n\t *\t\tconst marginLonghandsTuples = [\n\t *\t\t\t[ 'margin-top', '1px' ],\n\t *\t\t\t[ 'margin-right', '1px' ]\n\t *\t\t];\n\t *\n\t * A reducer obtains a normalized style value:\n\t *\n\t *\t\t// Simplified reducer that always outputs 4 values which are always present:\n\t *\t\tstylesProcessor.setReducer( 'margin', margin => {\n\t *\t\t\treturn [\n\t *\t\t\t\t[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function} callback\n\t */\n\tsetReducer( name, callback ) {\n\t\tthis._reducers.set( name, callback );\n\t}\n\n\t/**\n\t * Defines a style shorthand relation to other style notations.\n\t *\n\t *\t\tstylesProcessor.setStyleRelation( 'margin', [\n\t *\t\t\t'margin-top',\n\t *\t\t\t'margin-right',\n\t *\t\t\t'margin-bottom',\n\t *\t\t\t'margin-left'\n\t *\t\t] );\n\t *\n\t * This enables expanding of style names for shorthands. For instance, if defined,\n\t * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created\n\t * for long-hand margin style notation alongside the `'margin'` item.\n\t *\n\t * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just\n\t * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and\n\t * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.\n\t * However, once `margin-left` is consumed, `margin` will not be consumable anymore.\n\t *\n\t * @param {String} shorthandName\n\t * @param {Array.<String>} styleNames\n\t */\n\tsetStyleRelation( shorthandName, styleNames ) {\n\t\tthis._mapStyleNames( shorthandName, styleNames );\n\n\t\tfor ( const alsoName of styleNames ) {\n\t\t\tthis._mapStyleNames( alsoName, [ shorthandName ] );\n\t\t}\n\t}\n\n\t/**\n\t * Set two-way binding of style names.\n\t *\n\t * @param {String} name\n\t * @param {Array.<String>} styleNames\n\t * @private\n\t */\n\t_mapStyleNames( name, styleNames ) {\n\t\tif ( !this._consumables.has( name ) ) {\n\t\t\tthis._consumables.set( name, [] );\n\t\t}\n\n\t\tthis._consumables.get( name ).push( ...styleNames );\n\t}\n}\n\n// Parses inline styles and puts property - value pairs into styles map.\n//\n// @param {String} stylesString Styles to parse.\n// @returns {Map.<String, String>} stylesMap Map of parsed properties and values.\nfunction parseInlineStyles( stylesString ) {\n\t// `null` if no quote was found in input string or last found quote was a closing quote. See below.\n\tlet quoteType = null;\n\tlet propertyNameStart = 0;\n\tlet propertyValueStart = 0;\n\tlet propertyName = null;\n\n\tconst stylesMap = new Map();\n\n\t// Do not set anything if input string is empty.\n\tif ( stylesString === '' ) {\n\t\treturn stylesMap;\n\t}\n\n\t// Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n\tif ( stylesString.charAt( stylesString.length - 1 ) != ';' ) {\n\t\tstylesString = stylesString + ';';\n\t}\n\n\t// Seek the whole string for \"special characters\".\n\tfor ( let i = 0; i < stylesString.length; i++ ) {\n\t\tconst char = stylesString.charAt( i );\n\n\t\tif ( quoteType === null ) {\n\t\t\t// No quote found yet or last found quote was a closing quote.\n\t\t\tswitch ( char ) {\n\t\t\t\tcase ':':\n\t\t\t\t\t// Most of time colon means that property name just ended.\n\t\t\t\t\t// Sometimes however `:` is found inside property value (for example in background image url).\n\t\t\t\t\tif ( !propertyName ) {\n\t\t\t\t\t\t// Treat this as end of property only if property name is not already saved.\n\t\t\t\t\t\t// Save property name.\n\t\t\t\t\t\tpropertyName = stylesString.substr( propertyNameStart, i - propertyNameStart );\n\t\t\t\t\t\t// Save this point as the start of property value.\n\t\t\t\t\t\tpropertyValueStart = i + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\t// Opening quote found (this is an opening quote, because `quoteType` is `null`).\n\t\t\t\t\tquoteType = char;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ';': {\n\t\t\t\t\t// Property value just ended.\n\t\t\t\t\t// Use previously stored property value start to obtain property value.\n\t\t\t\t\tconst propertyValue = stylesString.substr( propertyValueStart, i - propertyValueStart );\n\n\t\t\t\t\tif ( propertyName ) {\n\t\t\t\t\t\t// Save parsed part.\n\t\t\t\t\t\tstylesMap.set( propertyName.trim(), propertyValue.trim() );\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyName = null;\n\n\t\t\t\t\t// Save this point as property name start. Property name starts immediately after previous property value ends.\n\t\t\t\t\tpropertyNameStart = i + 1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( char === quoteType ) {\n\t\t\t// If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n\t\t\tquoteType = null;\n\t\t}\n\t}\n\n\treturn stylesMap;\n}\n\n// Return lodash compatible path from style name.\nfunction toPath( name ) {\n\treturn name.replace( '-', '.' );\n}\n\n// Appends style definition to the styles object.\n//\n// @param {String} nameOrPath\n// @param {String|Object} valueOrObject\n// @private\nfunction appendStyleValue( stylesObject, nameOrPath, valueOrObject ) {\n\tlet valueToSet = valueOrObject;\n\n\tif ( isObject( valueOrObject ) ) {\n\t\tvalueToSet = merge( {}, get( stylesObject, nameOrPath ), valueOrObject );\n\t}\n\n\tset( stylesObject, nameOrPath, valueToSet );\n}\n\n/**\n * A CSS style property descriptor that contains tuplet of two strings:\n *\n * - first string describes property name\n * - second string describes property value\n *\n *\t\tconst marginDescriptor = [ 'margin', '2px 3em' ];\n *\t\tconst marginTopDescriptor = [ 'margin-top', '2px' ];\n *\n * @typedef {Array.<String, String>} module:engine/view/stylesmap~PropertyDescriptor\n */\n\n/**\n * An object describing values associated with the sides of a box, for instance margins, paddings,\n * border widths, border colors, etc.\n *\n *\t\tconst margin = {\n *\t\t\ttop: '1px',\n *\t\t\tright: '3px',\n *\t\t\tbottom: '3px',\n *\t\t\tleft: '7px'\n *\t\t};\n *\n *\t\tconst borderColor = {\n *\t\t\ttop: 'red',\n *\t\t\tright: 'blue',\n *\t\t\tbottom: 'blue',\n *\t\t\tleft: 'red'\n *\t\t};\n *\n * @typedef {Object} module:engine/view/stylesmap~BoxSides\n *\n * @property {String} top Top side value.\n * @property {String} right Right side value.\n * @property {String} bottom Bottom side value.\n * @property {String} left Left side value.\n */\n"]}]}