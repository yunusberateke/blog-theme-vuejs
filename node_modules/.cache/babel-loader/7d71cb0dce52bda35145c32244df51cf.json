{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC90cmVld2Fsa2VyCiAqLwppbXBvcnQgVGV4dCBmcm9tICcuL3RleHQnOwppbXBvcnQgVGV4dFByb3h5IGZyb20gJy4vdGV4dHByb3h5JzsKaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50JzsKaW1wb3J0IHsgZGVmYXVsdCBhcyBQb3NpdGlvbiwgZ2V0VGV4dE5vZGVBdFBvc2l0aW9uLCBnZXROb2RlQWZ0ZXJQb3NpdGlvbiwgZ2V0Tm9kZUJlZm9yZVBvc2l0aW9uIH0gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwovKioKICogUG9zaXRpb24gaXRlcmF0b3IgY2xhc3MuIEl0IGFsbG93cyB0byBpdGVyYXRlIGZvcndhcmQgYW5kIGJhY2t3YXJkIG92ZXIgdGhlIGRvY3VtZW50LgogKi8KCnZhciBUcmVlV2Fsa2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGEgcmFuZ2UgaXRlcmF0b3IuIEFsbCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbCwgYnV0IHlvdSBoYXZlIHRvIHNwZWNpZnkgZWl0aGVyIGBib3VuZGFyaWVzYCBvciBgc3RhcnRQb3NpdGlvbmAuCiAgICoKICAgKiBAY29uc3RydWN0b3IKICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24uCiAgICogQHBhcmFtIHsnZm9yd2FyZCd8J2JhY2t3YXJkJ30gW29wdGlvbnMuZGlyZWN0aW9uPSdmb3J3YXJkJ10gV2Fsa2luZyBkaXJlY3Rpb24uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBbb3B0aW9ucy5ib3VuZGFyaWVzPW51bGxdIFJhbmdlIHRvIGRlZmluZSBib3VuZGFyaWVzIG9mIHRoZSBpdGVyYXRvci4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFtvcHRpb25zLnN0YXJ0UG9zaXRpb25dIFN0YXJ0aW5nIHBvc2l0aW9uLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2luZ2xlQ2hhcmFjdGVycz1mYWxzZV0gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgYWxsIGNvbnNlY3V0aXZlIGNoYXJhY3RlcnMgd2l0aCB0aGUgc2FtZSBhdHRyaWJ1dGVzCiAgICogc2hvdWxkIGJlIHJldHVybmVkIG9uZSBieSBvbmUgYXMgbXVsdGlwbGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eX0gKGB0cnVlYCkgb2JqZWN0cyBvciBhcyBvbmUKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5fSAoYGZhbHNlYCkuCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaGFsbG93PWZhbHNlXSBGbGFnIGluZGljYXRpbmcgd2hldGhlciBpdGVyYXRvciBzaG91bGQgZW50ZXIgZWxlbWVudHMgb3Igbm90LiBJZiB0aGUKICAgKiBpdGVyYXRvciBpcyBzaGFsbG93IGNoaWxkIG5vZGVzIG9mIGFueSBpdGVyYXRlZCBub2RlIHdpbGwgbm90IGJlIHJldHVybmVkIGFsb25nIHdpdGggYGVsZW1lbnRFbmRgIHRhZy4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQ9ZmFsc2VdIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGl0ZXJhdG9yIHNob3VsZCBpZ25vcmUgYGVsZW1lbnRFbmRgCiAgICogdGFncy4gSWYgdGhlIG9wdGlvbiBpcyB0cnVlIHdhbGtlciB3aWxsIG5vdCByZXR1cm4gYSBwYXJlbnQgbm9kZSBvZiBzdGFydCBwb3NpdGlvbi4gSWYgdGhpcyBvcHRpb24gaXMgYHRydWVgCiAgICogZWFjaCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHdpbGwgYmUgcmV0dXJuZWQgb25jZSwgd2hpbGUgaWYgdGhlIG9wdGlvbiBpcyBgZmFsc2VgIHRoZXkgbWlnaHQgYmUgcmV0dXJuZWQKICAgKiB0d2ljZTogZm9yIGAnZWxlbWVudFN0YXJ0J2AgYW5kIGAnZWxlbWVudEVuZCdgLgogICAqLwogIGZ1bmN0aW9uIFRyZWVXYWxrZXIoKSB7CiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307CgogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyZWVXYWxrZXIpOwoKICAgIGlmICghb3B0aW9ucy5ib3VuZGFyaWVzICYmICFvcHRpb25zLnN0YXJ0UG9zaXRpb24pIHsKICAgICAgLyoqCiAgICAgICAqIE5laXRoZXIgYm91bmRhcmllcyBub3Igc3RhcnRpbmcgcG9zaXRpb24gb2YgYSBgVHJlZVdhbGtlcmAgaGF2ZSBiZWVuIGRlZmluZWQuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciBtb2RlbC10cmVlLXdhbGtlci1uby1zdGFydC1wb3NpdGlvbgogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXRyZWUtd2Fsa2VyLW5vLXN0YXJ0LXBvc2l0aW9uJywgbnVsbCk7CiAgICB9CgogICAgdmFyIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8ICdmb3J3YXJkJzsKCiAgICBpZiAoZGlyZWN0aW9uICE9ICdmb3J3YXJkJyAmJiBkaXJlY3Rpb24gIT0gJ2JhY2t3YXJkJykgewogICAgICAvKioKICAgICAgICogT25seSBgYmFja3dhcmRgIGFuZCBgZm9yd2FyZGAgZGlyZWN0aW9uIGFsbG93ZWQuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciBtb2RlbC10cmVlLXdhbGtlci11bmtub3duLWRpcmVjdGlvbgogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXRyZWUtd2Fsa2VyLXVua25vd24tZGlyZWN0aW9uJywgb3B0aW9ucywgewogICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uCiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBXYWxraW5nIGRpcmVjdGlvbi4gRGVmYXVsdHMgYCdmb3J3YXJkJ2AuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHsnYmFja3dhcmQnfCdmb3J3YXJkJ30gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjZGlyZWN0aW9uCiAgICAgKi8KCgogICAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247CiAgICAvKioKICAgICAqIEl0ZXJhdG9yIGJvdW5kYXJpZXMuCiAgICAgKgogICAgICogV2hlbiB0aGUgaXRlcmF0b3IgaXMgd2Fsa2luZyBgJ2ZvcndhcmQnYCBvbiB0aGUgZW5kIG9mIGJvdW5kYXJ5IG9yIGlzIHdhbGtpbmcgYCdiYWNrd2FyZCdgCiAgICAgKiBvbiB0aGUgc3RhcnQgb2YgYm91bmRhcnksIHRoZW4gYHsgZG9uZTogdHJ1ZSB9YCBpcyByZXR1cm5lZC4KICAgICAqCiAgICAgKiBJZiBib3VuZGFyaWVzIGFyZSBub3QgZGVmaW5lZCB0aGV5IGFyZSBzZXQgYmVmb3JlIGZpcnN0IGFuZCBhZnRlciBsYXN0IGNoaWxkIG9mIHRoZSByb290IG5vZGUuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNib3VuZGFyaWVzCiAgICAgKi8KCiAgICB0aGlzLmJvdW5kYXJpZXMgPSBvcHRpb25zLmJvdW5kYXJpZXMgfHwgbnVsbDsKICAgIC8qKgogICAgICogSXRlcmF0b3IgcG9zaXRpb24uIFRoaXMgaXMgYWx3YXlzIHN0YXRpYyBwb3NpdGlvbiwgZXZlbiBpZiB0aGUgaW5pdGlhbCBwb3NpdGlvbiB3YXMgYQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXBvc2l0aW9ufkxpdmVQb3NpdGlvbiBsaXZlIHBvc2l0aW9ufS4gSWYgc3RhcnQgcG9zaXRpb24gaXMgbm90IGRlZmluZWQgdGhlbiBwb3NpdGlvbiBkZXBlbmRzCiAgICAgKiBvbiB7QGxpbmsgI2RpcmVjdGlvbn0uIElmIGRpcmVjdGlvbiBpcyBgJ2ZvcndhcmQnYCBwb3NpdGlvbiBzdGFydHMgZm9ybSB0aGUgYmVnaW5uaW5nLCB3aGVuIGRpcmVjdGlvbgogICAgICogaXMgYCdiYWNrd2FyZCdgIHBvc2l0aW9uIHN0YXJ0cyBmcm9tIHRoZSBlbmQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNwb3NpdGlvbgogICAgICovCgogICAgaWYgKG9wdGlvbnMuc3RhcnRQb3NpdGlvbikgewogICAgICB0aGlzLnBvc2l0aW9uID0gb3B0aW9ucy5zdGFydFBvc2l0aW9uLmNsb25lKCk7CiAgICB9IGVsc2UgewogICAgICB0aGlzLnBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUF0KHRoaXMuYm91bmRhcmllc1t0aGlzLmRpcmVjdGlvbiA9PSAnYmFja3dhcmQnID8gJ2VuZCcgOiAnc3RhcnQnXSk7CiAgICB9IC8vIFJlc2V0IHBvc2l0aW9uIHN0aWNraW5lc3MgaW4gY2FzZSBpdCB3YXMgc2V0IHRvIG90aGVyIHZhbHVlLCBhcyB0aGUgc3RpY2tpbmVzcyBpcyBrZXB0IGFmdGVyIGNsb25pbmcuCgoKICAgIHRoaXMucG9zaXRpb24uc3RpY2tpbmVzcyA9ICd0b05vbmUnOwogICAgLyoqCiAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciBhbGwgY29uc2VjdXRpdmUgY2hhcmFjdGVycyB3aXRoIHRoZSBzYW1lIGF0dHJpYnV0ZXMgc2hvdWxkIGJlCiAgICAgKiByZXR1cm5lZCBhcyBvbmUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eX0gKGB0cnVlYCkgb3Igb25lIGJ5IG9uZSAoYGZhbHNlYCkuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNzaW5nbGVDaGFyYWN0ZXJzCiAgICAgKi8KCiAgICB0aGlzLnNpbmdsZUNoYXJhY3RlcnMgPSAhIW9wdGlvbnMuc2luZ2xlQ2hhcmFjdGVyczsKICAgIC8qKgogICAgICogRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgaXRlcmF0b3Igc2hvdWxkIGVudGVyIGVsZW1lbnRzIG9yIG5vdC4gSWYgdGhlIGl0ZXJhdG9yIGlzIHNoYWxsb3cgY2hpbGQgbm9kZXMgb2YgYW55CiAgICAgKiBpdGVyYXRlZCBub2RlIHdpbGwgbm90IGJlIHJldHVybmVkIGFsb25nIHdpdGggYGVsZW1lbnRFbmRgIHRhZy4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyI3NoYWxsb3cKICAgICAqLwoKICAgIHRoaXMuc2hhbGxvdyA9ICEhb3B0aW9ucy5zaGFsbG93OwogICAgLyoqCiAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciBpdGVyYXRvciBzaG91bGQgaWdub3JlIGBlbGVtZW50RW5kYCB0YWdzLiBJZiB0aGUgb3B0aW9uIGlzIHRydWUgd2Fsa2VyIHdpbGwgbm90CiAgICAgKiByZXR1cm4gYSBwYXJlbnQgbm9kZSBvZiB0aGUgc3RhcnQgcG9zaXRpb24uIElmIHRoaXMgb3B0aW9uIGlzIGB0cnVlYCBlYWNoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gd2lsbAogICAgICogYmUgcmV0dXJuZWQgb25jZSwgd2hpbGUgaWYgdGhlIG9wdGlvbiBpcyBgZmFsc2VgIHRoZXkgbWlnaHQgYmUgcmV0dXJuZWQgdHdpY2U6CiAgICAgKiBmb3IgYCdlbGVtZW50U3RhcnQnYCBhbmQgYCdlbGVtZW50RW5kJ2AuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNpZ25vcmVFbGVtZW50RW5kCiAgICAgKi8KCiAgICB0aGlzLmlnbm9yZUVsZW1lbnRFbmQgPSAhIW9wdGlvbnMuaWdub3JlRWxlbWVudEVuZDsKICAgIC8qKgogICAgICogU3RhcnQgYm91bmRhcnkgY2FjaGVkIGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNfYm91bmRhcnlTdGFydFBhcmVudAogICAgICovCgogICAgdGhpcy5fYm91bmRhcnlTdGFydFBhcmVudCA9IHRoaXMuYm91bmRhcmllcyA/IHRoaXMuYm91bmRhcmllcy5zdGFydC5wYXJlbnQgOiBudWxsOwogICAgLyoqCiAgICAgKiBFbmQgYm91bmRhcnkgY2FjaGVkIGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNfYm91bmRhcnlFbmRQYXJlbnQKICAgICAqLwoKICAgIHRoaXMuX2JvdW5kYXJ5RW5kUGFyZW50ID0gdGhpcy5ib3VuZGFyaWVzID8gdGhpcy5ib3VuZGFyaWVzLmVuZC5wYXJlbnQgOiBudWxsOwogICAgLyoqCiAgICAgKiBQYXJlbnQgb2YgdGhlIG1vc3QgcmVjZW50bHkgdmlzaXRlZCBub2RlLiBDYWNoZWQgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICAgKiBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNfdmlzaXRlZFBhcmVudAogICAgICovCgogICAgdGhpcy5fdmlzaXRlZFBhcmVudCA9IHRoaXMucG9zaXRpb24ucGFyZW50OwogIH0KICAvKioKICAgKiBJdGVyYWJsZSBpbnRlcmZhY2UuCiAgICoKICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWU+fQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFRyZWVXYWxrZXIsIFt7CiAgICBrZXk6IFN5bWJvbC5pdGVyYXRvciwKICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIE1vdmVzIHtAbGluayAjcG9zaXRpb259IGluIHRoZSB7QGxpbmsgI2RpcmVjdGlvbn0gc2tpcHBpbmcgdmFsdWVzIGFzIGxvbmcgYXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgLgogICAgICoKICAgICAqIEZvciBleGFtcGxlOgogICAgICoKICAgICAqIAkJd2Fsa2VyLnNraXAoIHZhbHVlID0+IHZhbHVlLnR5cGUgPT0gJ3RleHQnICk7IC8vIDxwYXJhZ3JhcGg+W11mb288L3BhcmFncmFwaD4gLT4gPHBhcmFncmFwaD5mb29bXTwvcGFyYWdyYXBoPgogICAgICogCQl3YWxrZXIuc2tpcCggKCkgPT4gdHJ1ZSApOyAvLyBNb3ZlIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kOiA8cGFyYWdyYXBoPltdZm9vPC9wYXJhZ3JhcGg+IC0+IDxwYXJhZ3JhcGg+Zm9vPC9wYXJhZ3JhcGg+W10KICAgICAqIAkJd2Fsa2VyLnNraXAoICgpID0+IGZhbHNlICk7IC8vIERvIG5vdCBtb3ZlIHRoZSBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBza2lwIENhbGxiYWNrIGZ1bmN0aW9uLiBHZXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfSBhbmQgc2hvdWxkCiAgICAgKiByZXR1cm4gYHRydWVgIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgc2tpcHBlZCBvciBgZmFsc2VgIGlmIG5vdC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJza2lwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwKF9za2lwKSB7CiAgICAgIHZhciBkb25lLCB2YWx1ZSwgcHJldlBvc2l0aW9uLCBwcmV2VmlzaXRlZFBhcmVudDsKCiAgICAgIGRvIHsKICAgICAgICBwcmV2UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uOwogICAgICAgIHByZXZWaXNpdGVkUGFyZW50ID0gdGhpcy5fdmlzaXRlZFBhcmVudDsKCiAgICAgICAgdmFyIF90aGlzJG5leHQgPSB0aGlzLm5leHQoKTsKCiAgICAgICAgZG9uZSA9IF90aGlzJG5leHQuZG9uZTsKICAgICAgICB2YWx1ZSA9IF90aGlzJG5leHQudmFsdWU7CiAgICAgIH0gd2hpbGUgKCFkb25lICYmIF9za2lwKHZhbHVlKSk7CgogICAgICBpZiAoIWRvbmUpIHsKICAgICAgICB0aGlzLnBvc2l0aW9uID0gcHJldlBvc2l0aW9uOwogICAgICAgIHRoaXMuX3Zpc2l0ZWRQYXJlbnQgPSBwcmV2VmlzaXRlZFBhcmVudDsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBuZXh0IHRyZWUgd2Fsa2VyJ3MgdmFsdWUuCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9IE5leHQgdHJlZSB3YWxrZXIncyB2YWx1ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJuZXh0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkgewogICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT0gJ2ZvcndhcmQnKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX25leHQoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXMoKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBNYWtlcyBhIHN0ZXAgZm9yd2FyZCBpbiBtb2RlbC4gTW92ZXMgdGhlIHtAbGluayAjcG9zaXRpb259IHRvIHRoZSBuZXh0IHBvc2l0aW9uIGFuZCByZXR1cm5zIHRoZSBlbmNvdW50ZXJlZCB2YWx1ZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHJldHVybnMge09iamVjdH0KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZXR1cm4uZG9uZSBUcnVlIGlmIGl0ZXJhdG9yIGlzIGRvbmUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0gcmV0dXJuLnZhbHVlIEluZm9ybWF0aW9uIGFib3V0IHRha2VuIHN0ZXAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX25leHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXh0KCkgewogICAgICB2YXIgcHJldmlvdXNQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247CiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uY2xvbmUoKTsKICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3Zpc2l0ZWRQYXJlbnQ7IC8vIFdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSByb290LgoKICAgICAgaWYgKHBhcmVudC5wYXJlbnQgPT09IG51bGwgJiYgcG9zaXRpb24ub2Zmc2V0ID09PSBwYXJlbnQubWF4T2Zmc2V0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRvbmU6IHRydWUKICAgICAgICB9OwogICAgICB9IC8vIFdlIHJlYWNoZWQgdGhlIHdhbGtlciBib3VuZGFyeS4KCgogICAgICBpZiAocGFyZW50ID09PSB0aGlzLl9ib3VuZGFyeUVuZFBhcmVudCAmJiBwb3NpdGlvbi5vZmZzZXQgPT0gdGhpcy5ib3VuZGFyaWVzLmVuZC5vZmZzZXQpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZG9uZTogdHJ1ZQogICAgICAgIH07CiAgICAgIH0gLy8gR2V0IG5vZGUganVzdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbi4KICAgICAgLy8gVXNlIGEgaGlnaGx5IG9wdGltaXplZCB2ZXJzaW9uIGluc3RlYWQgb2YgY2hlY2tpbmcgdGhlIHRleHQgbm9kZSBmaXJzdCBhbmQgdGhlbiBnZXR0aW5nIHRoZSBub2RlIGFmdGVyLiBTZWUgIzY1ODIuCgoKICAgICAgdmFyIHBvc2l0aW9uUGFyZW50ID0gcG9zaXRpb24ucGFyZW50OwogICAgICB2YXIgdGV4dE5vZGVBdFBvc2l0aW9uID0gZ2V0VGV4dE5vZGVBdFBvc2l0aW9uKHBvc2l0aW9uLCBwb3NpdGlvblBhcmVudCk7CiAgICAgIHZhciBub2RlID0gdGV4dE5vZGVBdFBvc2l0aW9uID8gdGV4dE5vZGVBdFBvc2l0aW9uIDogZ2V0Tm9kZUFmdGVyUG9zaXRpb24ocG9zaXRpb24sIHBvc2l0aW9uUGFyZW50LCB0ZXh0Tm9kZUF0UG9zaXRpb24pOwoKICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7CiAgICAgICAgaWYgKCF0aGlzLnNoYWxsb3cpIHsKICAgICAgICAgIC8vIE1hbnVhbCBvcGVyYXRpb25zIG9uIHBhdGggaW50ZXJuYWxzIGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuIEhlcmUgYW5kIGluIHRoZSByZXN0IG9mIHRoZSBtZXRob2QuCiAgICAgICAgICBwb3NpdGlvbi5wYXRoLnB1c2goMCk7CiAgICAgICAgICB0aGlzLl92aXNpdGVkUGFyZW50ID0gbm9kZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcG9zaXRpb24ub2Zmc2V0Kys7CiAgICAgICAgfQoKICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKCdlbGVtZW50U3RhcnQnLCBub2RlLCBwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbiwgMSk7CiAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRleHQpIHsKICAgICAgICB2YXIgY2hhcmFjdGVyc0NvdW50OwoKICAgICAgICBpZiAodGhpcy5zaW5nbGVDaGFyYWN0ZXJzKSB7CiAgICAgICAgICBjaGFyYWN0ZXJzQ291bnQgPSAxOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgb2Zmc2V0ID0gbm9kZS5lbmRPZmZzZXQ7CgogICAgICAgICAgaWYgKHRoaXMuX2JvdW5kYXJ5RW5kUGFyZW50ID09IHBhcmVudCAmJiB0aGlzLmJvdW5kYXJpZXMuZW5kLm9mZnNldCA8IG9mZnNldCkgewogICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmJvdW5kYXJpZXMuZW5kLm9mZnNldDsKICAgICAgICAgIH0KCiAgICAgICAgICBjaGFyYWN0ZXJzQ291bnQgPSBvZmZzZXQgLSBwb3NpdGlvbi5vZmZzZXQ7CiAgICAgICAgfQoKICAgICAgICB2YXIgb2Zmc2V0SW5UZXh0Tm9kZSA9IHBvc2l0aW9uLm9mZnNldCAtIG5vZGUuc3RhcnRPZmZzZXQ7CiAgICAgICAgdmFyIGl0ZW0gPSBuZXcgVGV4dFByb3h5KG5vZGUsIG9mZnNldEluVGV4dE5vZGUsIGNoYXJhY3RlcnNDb3VudCk7CiAgICAgICAgcG9zaXRpb24ub2Zmc2V0ICs9IGNoYXJhY3RlcnNDb3VudDsKICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKCd0ZXh0JywgaXRlbSwgcHJldmlvdXNQb3NpdGlvbiwgcG9zaXRpb24sIGNoYXJhY3RlcnNDb3VudCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gYG5vZGVgIGlzIG5vdCBzZXQsIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiBjdXJyZW50IGBwYXJlbnRgLgogICAgICAgIHBvc2l0aW9uLnBhdGgucG9wKCk7CiAgICAgICAgcG9zaXRpb24ub2Zmc2V0Kys7CiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOwogICAgICAgIHRoaXMuX3Zpc2l0ZWRQYXJlbnQgPSBwYXJlbnQucGFyZW50OwoKICAgICAgICBpZiAodGhpcy5pZ25vcmVFbGVtZW50RW5kKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fbmV4dCgpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoJ2VsZW1lbnRFbmQnLCBwYXJlbnQsIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogTWFrZXMgYSBzdGVwIGJhY2t3YXJkIGluIG1vZGVsLiBNb3ZlcyB0aGUge0BsaW5rICNwb3NpdGlvbn0gdG8gdGhlIHByZXZpb3VzIHBvc2l0aW9uIGFuZCByZXR1cm5zIHRoZSBlbmNvdW50ZXJlZCB2YWx1ZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHJldHVybnMge09iamVjdH0KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZXR1cm4uZG9uZSBUcnVlIGlmIGl0ZXJhdG9yIGlzIGRvbmUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0gcmV0dXJuLnZhbHVlIEluZm9ybWF0aW9uIGFib3V0IHRha2VuIHN0ZXAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3ByZXZpb3VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJldmlvdXMoKSB7CiAgICAgIHZhciBwcmV2aW91c1Bvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjsKICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpOwogICAgICB2YXIgcGFyZW50ID0gdGhpcy5fdmlzaXRlZFBhcmVudDsgLy8gV2UgYXJlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJvb3QuCgogICAgICBpZiAocGFyZW50LnBhcmVudCA9PT0gbnVsbCAmJiBwb3NpdGlvbi5vZmZzZXQgPT09IDApIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZG9uZTogdHJ1ZQogICAgICAgIH07CiAgICAgIH0gLy8gV2UgcmVhY2hlZCB0aGUgd2Fsa2VyIGJvdW5kYXJ5LgoKCiAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy5fYm91bmRhcnlTdGFydFBhcmVudCAmJiBwb3NpdGlvbi5vZmZzZXQgPT0gdGhpcy5ib3VuZGFyaWVzLnN0YXJ0Lm9mZnNldCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkb25lOiB0cnVlCiAgICAgICAgfTsKICAgICAgfSAvLyBHZXQgbm9kZSBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBwb3NpdGlvbi4KICAgICAgLy8gVXNlIGEgaGlnaGx5IG9wdGltaXplZCB2ZXJzaW9uIGluc3RlYWQgb2YgY2hlY2tpbmcgdGhlIHRleHQgbm9kZSBmaXJzdCBhbmQgdGhlbiBnZXR0aW5nIHRoZSBub2RlIGJlZm9yZS4gU2VlICM2NTgyLgoKCiAgICAgIHZhciBwb3NpdGlvblBhcmVudCA9IHBvc2l0aW9uLnBhcmVudDsKICAgICAgdmFyIHRleHROb2RlQXRQb3NpdGlvbiA9IGdldFRleHROb2RlQXRQb3NpdGlvbihwb3NpdGlvbiwgcG9zaXRpb25QYXJlbnQpOwogICAgICB2YXIgbm9kZSA9IHRleHROb2RlQXRQb3NpdGlvbiA/IHRleHROb2RlQXRQb3NpdGlvbiA6IGdldE5vZGVCZWZvcmVQb3NpdGlvbihwb3NpdGlvbiwgcG9zaXRpb25QYXJlbnQsIHRleHROb2RlQXRQb3NpdGlvbik7CgogICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHsKICAgICAgICBwb3NpdGlvbi5vZmZzZXQtLTsKCiAgICAgICAgaWYgKCF0aGlzLnNoYWxsb3cpIHsKICAgICAgICAgIHBvc2l0aW9uLnBhdGgucHVzaChub2RlLm1heE9mZnNldCk7CiAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgICB0aGlzLl92aXNpdGVkUGFyZW50ID0gbm9kZTsKCiAgICAgICAgICBpZiAodGhpcy5pZ25vcmVFbGVtZW50RW5kKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91cygpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKCdlbGVtZW50RW5kJywgbm9kZSwgcHJldmlvdXNQb3NpdGlvbiwgcG9zaXRpb24pOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoJ2VsZW1lbnRTdGFydCcsIG5vZGUsIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uLCAxKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRleHQpIHsKICAgICAgICB2YXIgY2hhcmFjdGVyc0NvdW50OwoKICAgICAgICBpZiAodGhpcy5zaW5nbGVDaGFyYWN0ZXJzKSB7CiAgICAgICAgICBjaGFyYWN0ZXJzQ291bnQgPSAxOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgb2Zmc2V0ID0gbm9kZS5zdGFydE9mZnNldDsKCiAgICAgICAgICBpZiAodGhpcy5fYm91bmRhcnlTdGFydFBhcmVudCA9PSBwYXJlbnQgJiYgdGhpcy5ib3VuZGFyaWVzLnN0YXJ0Lm9mZnNldCA+IG9mZnNldCkgewogICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmJvdW5kYXJpZXMuc3RhcnQub2Zmc2V0OwogICAgICAgICAgfQoKICAgICAgICAgIGNoYXJhY3RlcnNDb3VudCA9IHBvc2l0aW9uLm9mZnNldCAtIG9mZnNldDsKICAgICAgICB9CgogICAgICAgIHZhciBvZmZzZXRJblRleHROb2RlID0gcG9zaXRpb24ub2Zmc2V0IC0gbm9kZS5zdGFydE9mZnNldDsKICAgICAgICB2YXIgaXRlbSA9IG5ldyBUZXh0UHJveHkobm9kZSwgb2Zmc2V0SW5UZXh0Tm9kZSAtIGNoYXJhY3RlcnNDb3VudCwgY2hhcmFjdGVyc0NvdW50KTsKICAgICAgICBwb3NpdGlvbi5vZmZzZXQgLT0gY2hhcmFjdGVyc0NvdW50OwogICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsKICAgICAgICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoJ3RleHQnLCBpdGVtLCBwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbiwgY2hhcmFjdGVyc0NvdW50KTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBgbm9kZWAgaXMgbm90IHNldCwgd2UgcmVhY2hlZCB0aGUgYmVnaW5uaW5nIG9mIGN1cnJlbnQgYHBhcmVudGAuCiAgICAgICAgcG9zaXRpb24ucGF0aC5wb3AoKTsKICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgdGhpcy5fdmlzaXRlZFBhcmVudCA9IHBhcmVudC5wYXJlbnQ7CiAgICAgICAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKCdlbGVtZW50U3RhcnQnLCBwYXJlbnQsIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uLCAxKTsKICAgICAgfQogICAgfQogIH1dKTsKCiAgcmV0dXJuIFRyZWVXYWxrZXI7Cn0oKTsKCmV4cG9ydCB7IFRyZWVXYWxrZXIgYXMgZGVmYXVsdCB9OwoKZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUodHlwZSwgaXRlbSwgcHJldmlvdXNQb3NpdGlvbiwgbmV4dFBvc2l0aW9uLCBsZW5ndGgpIHsKICByZXR1cm4gewogICAgZG9uZTogZmFsc2UsCiAgICB2YWx1ZTogewogICAgICB0eXBlOiB0eXBlLAogICAgICBpdGVtOiBpdGVtLAogICAgICBwcmV2aW91c1Bvc2l0aW9uOiBwcmV2aW91c1Bvc2l0aW9uLAogICAgICBuZXh0UG9zaXRpb246IG5leHRQb3NpdGlvbiwKICAgICAgbGVuZ3RoOiBsZW5ndGgKICAgIH0KICB9Owp9Ci8qKgogKiBUeXBlIG9mIHRoZSBzdGVwIG1hZGUgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfS4KICogUG9zc2libGUgdmFsdWVzOiBgJ2VsZW1lbnRTdGFydCdgIGlmIHdhbGtlciBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbm9kZSwgYCdlbGVtZW50RW5kJ2AgaWYgd2Fsa2VyIGlzIGF0IHRoZSBlbmQgb2Ygbm9kZSwKICogYCdjaGFyYWN0ZXInYCBpZiB3YWxrZXIgdHJhdmVyc2VkIG92ZXIgYSBjaGFyYWN0ZXIsIG9yIGAndGV4dCdgIGlmIHdhbGtlciB0cmF2ZXJzZWQgb3ZlciBtdWx0aXBsZSBjaGFyYWN0ZXJzIChhdmFpbGFibGUgaW4KICogY2hhcmFjdGVyIG1lcmdpbmcgbW9kZSwgc2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNjb25zdHJ1Y3Rvcn0pLgogKgogKiBAdHlwZWRlZiB7J2VsZW1lbnRTdGFydCd8J2VsZW1lbnRFbmQnfCdjaGFyYWN0ZXInfCd0ZXh0J30gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZVR5cGUKICovCgovKioKICogT2JqZWN0IHJldHVybmVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gd2hlbiB0cmF2ZXJzaW5nIHRyZWUgbW9kZWwuCiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWUKICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlVHlwZX0gdHlwZQogKiBAcHJvcGVydHkge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtIEl0ZW0gYmV0d2VlbiBvbGQgYW5kIG5ldyBwb3NpdGlvbnMgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfS4KICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwcmV2aW91c1Bvc2l0aW9uIFByZXZpb3VzIHBvc2l0aW9uIG9mIHRoZSBpdGVyYXRvci4KICogKiBGb3J3YXJkIGl0ZXJhdGlvbjogRm9yIGAnZWxlbWVudEVuZCdgIGl0IGlzIHRoZSBsYXN0IHBvc2l0aW9uIGluc2lkZSB0aGUgZWxlbWVudC4gRm9yIGFsbCBvdGhlciB0eXBlcyBpdCBpcyB0aGUKICogcG9zaXRpb24gYmVmb3JlIHRoZSBpdGVtLgogKiAqIEJhY2t3YXJkIGl0ZXJhdGlvbjogRm9yIGAnZWxlbWVudFN0YXJ0J2AgaXQgaXMgdGhlIGZpcnN0IHBvc2l0aW9uIGluc2lkZSB0aGUgZWxlbWVudC4gRm9yIGFsbCBvdGhlciB0eXBlcyBpdCBpcwogKiB0aGUgcG9zaXRpb24gYWZ0ZXIgaXRlbS4KICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBuZXh0UG9zaXRpb24gTmV4dCBwb3NpdGlvbiBvZiB0aGUgaXRlcmF0b3IuCiAqICogRm9yd2FyZCBpdGVyYXRpb246IEZvciBgJ2VsZW1lbnRTdGFydCdgIGl0IGlzIHRoZSBmaXJzdCBwb3NpdGlvbiBpbnNpZGUgdGhlIGVsZW1lbnQuIEZvciBhbGwgb3RoZXIgdHlwZXMgaXQgaXMKICogdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBpdGVtLgogKiAqIEJhY2t3YXJkIGl0ZXJhdGlvbjogRm9yIGAnZWxlbWVudEVuZCdgIGl0IGlzIGxhc3QgcG9zaXRpb24gaW5zaWRlIGVsZW1lbnQuIEZvciBhbGwgb3RoZXIgdHlwZXMgaXQgaXMgdGhlIHBvc2l0aW9uCiAqIGJlZm9yZSB0aGUgaXRlbS4KICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBvZiB0aGUgaXRlbS4gRm9yIGAnZWxlbWVudFN0YXJ0J2AgYW5kIGAnY2hhcmFjdGVyJ2AgaXQgaXMgMS4gRm9yIGAndGV4dCdgIGl0IGlzCiAqIHRoZSBsZW5ndGggb2YgdGhlIHRleHQuIEZvciBgJ2VsZW1lbnRFbmQnYCBpdCBpcyBgdW5kZWZpbmVkYC4KICovCgovKioKICogVHJlZSB3YWxraW5nIGRpcmVjdGlvbnMuCiAqCiAqIEB0eXBlZGVmIHsnZm9yd2FyZCd8J2JhY2t3YXJkJ30gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJEaXJlY3Rpb24KICov"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js"],"names":["Text","TextProxy","Element","default","Position","getTextNodeAtPosition","getNodeAfterPosition","getNodeBeforePosition","CKEditorError","TreeWalker","options","boundaries","startPosition","direction","position","clone","_createAt","stickiness","singleCharacters","shallow","ignoreElementEnd","_boundaryStartParent","start","parent","_boundaryEndParent","end","_visitedParent","Symbol","iterator","skip","done","value","prevPosition","prevVisitedParent","next","_next","_previous","previousPosition","offset","maxOffset","positionParent","textNodeAtPosition","node","path","push","formatReturnValue","charactersCount","endOffset","offsetInTextNode","startOffset","item","pop","type","nextPosition","length"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/treewalker\n */\n\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Element from './element';\nimport {\n\tdefault as Position,\n\tgetTextNodeAtPosition,\n\tgetNodeAfterPosition,\n\tgetNodeBeforePosition\n} from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n\t/**\n\t * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n\t *\n\t * @constructor\n\t * @param {Object} [options={}] Object with configuration.\n\t * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n\t * @param {module:engine/model/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n\t * @param {module:engine/model/position~Position} [options.startPosition] Starting position.\n\t * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes\n\t * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one\n\t * {@link module:engine/model/textproxy~TextProxy} (`false`).\n\t * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n\t * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n\t * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n\t * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n\t * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned\n\t * twice: for `'elementStart'` and `'elementEnd'`.\n\t */\n\tconstructor( options = {} ) {\n\t\tif ( !options.boundaries && !options.startPosition ) {\n\t\t\t/**\n\t\t\t * Neither boundaries nor starting position of a `TreeWalker` have been defined.\n\t\t\t *\n\t\t\t * @error model-tree-walker-no-start-position\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-tree-walker-no-start-position',\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\tconst direction = options.direction || 'forward';\n\n\t\tif ( direction != 'forward' && direction != 'backward' ) {\n\t\t\t/**\n\t\t\t * Only `backward` and `forward` direction allowed.\n\t\t\t *\n\t\t\t * @error model-tree-walker-unknown-direction\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-tree-walker-unknown-direction', options, { direction } );\n\t\t}\n\n\t\t/**\n\t\t * Walking direction. Defaults `'forward'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction\n\t\t */\n\t\tthis.direction = direction;\n\n\t\t/**\n\t\t * Iterator boundaries.\n\t\t *\n\t\t * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n\t\t * on the start of boundary, then `{ done: true }` is returned.\n\t\t *\n\t\t * If boundaries are not defined they are set before first and after last child of the root node.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/range~Range} module:engine/model/treewalker~TreeWalker#boundaries\n\t\t */\n\t\tthis.boundaries = options.boundaries || null;\n\n\t\t/**\n\t\t * Iterator position. This is always static position, even if the initial position was a\n\t\t * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends\n\t\t * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction\n\t\t * is `'backward'` position starts from the end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position\n\t\t */\n\t\tif ( options.startPosition ) {\n\t\t\tthis.position = options.startPosition.clone();\n\t\t} else {\n\t\t\tthis.position = Position._createAt( this.boundaries[ this.direction == 'backward' ? 'end' : 'start' ] );\n\t\t}\n\n\t\t// Reset position stickiness in case it was set to other value, as the stickiness is kept after cloning.\n\t\tthis.position.stickiness = 'toNone';\n\n\t\t/**\n\t\t * Flag indicating whether all consecutive characters with the same attributes should be\n\t\t * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters\n\t\t */\n\t\tthis.singleCharacters = !!options.singleCharacters;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n\t\t * iterated node will not be returned along with `elementEnd` tag.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow\n\t\t */\n\t\tthis.shallow = !!options.shallow;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not\n\t\t * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will\n\t\t * be returned once, while if the option is `false` they might be returned twice:\n\t\t * for `'elementStart'` and `'elementEnd'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd\n\t\t */\n\t\tthis.ignoreElementEnd = !!options.ignoreElementEnd;\n\n\t\t/**\n\t\t * Start boundary cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent\n\t\t */\n\t\tthis._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n\n\t\t/**\n\t\t * End boundary cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent\n\t\t */\n\t\tthis._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n\n\t\t/**\n\t\t * Parent of the most recently visited node. Cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/treewalker~TreeWalker#_visitedParent\n\t\t */\n\t\tthis._visitedParent = this.position.parent;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n\t *\n\t * For example:\n\t *\n\t * \t\twalker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t * \t\twalker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]\n\t * \t\twalker.skip( () => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t */\n\tskip( skip ) {\n\t\tlet done, value, prevPosition, prevVisitedParent;\n\n\t\tdo {\n\t\t\tprevPosition = this.position;\n\t\t\tprevVisitedParent = this._visitedParent;\n\n\t\t\t( { done, value } = this.next() );\n\t\t} while ( !done && skip( value ) );\n\n\t\tif ( !done ) {\n\t\t\tthis.position = prevPosition;\n\t\t\tthis._visitedParent = prevVisitedParent;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the next tree walker's value.\n\t *\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} Next tree walker's value.\n\t */\n\tnext() {\n\t\tif ( this.direction == 'forward' ) {\n\t\t\treturn this._next();\n\t\t} else {\n\t\t\treturn this._previous();\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_next() {\n\t\tconst previousPosition = this.position;\n\t\tconst position = this.position.clone();\n\t\tconst parent = this._visitedParent;\n\n\t\t// We are at the end of the root.\n\t\tif ( parent.parent === null && position.offset === parent.maxOffset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just after the current position.\n\t\t// Use a highly optimized version instead of checking the text node first and then getting the node after. See #6582.\n\t\tconst positionParent = position.parent;\n\t\tconst textNodeAtPosition = getTextNodeAtPosition( position, positionParent );\n\t\tconst node = textNodeAtPosition ? textNodeAtPosition : getNodeAfterPosition( position, positionParent, textNodeAtPosition );\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\t// Manual operations on path internals for optimization purposes. Here and in the rest of the method.\n\t\t\t\tposition.path.push( 0 );\n\t\t\t\tthis._visitedParent = node;\n\t\t\t} else {\n\t\t\t\tposition.offset++;\n\t\t\t}\n\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t} else if ( node instanceof Text ) {\n\t\t\tlet charactersCount;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tcharactersCount = 1;\n\t\t\t} else {\n\t\t\t\tlet offset = node.endOffset;\n\n\t\t\t\tif ( this._boundaryEndParent == parent && this.boundaries.end.offset < offset ) {\n\t\t\t\t\toffset = this.boundaries.end.offset;\n\t\t\t\t}\n\n\t\t\t\tcharactersCount = offset - position.offset;\n\t\t\t}\n\n\t\t\tconst offsetInTextNode = position.offset - node.startOffset;\n\t\t\tconst item = new TextProxy( node, offsetInTextNode, charactersCount );\n\n\t\t\tposition.offset += charactersCount;\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the end of current `parent`.\n\t\t\tposition.path.pop();\n\t\t\tposition.offset++;\n\t\t\tthis.position = position;\n\t\t\tthis._visitedParent = parent.parent;\n\n\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\treturn formatReturnValue( 'elementEnd', parent, previousPosition, position );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_previous() {\n\t\tconst previousPosition = this.position;\n\t\tconst position = this.position.clone();\n\t\tconst parent = this._visitedParent;\n\n\t\t// We are at the beginning of the root.\n\t\tif ( parent.parent === null && position.offset === 0 ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just before the current position.\n\t\t// Use a highly optimized version instead of checking the text node first and then getting the node before. See #6582.\n\t\tconst positionParent = position.parent;\n\t\tconst textNodeAtPosition = getTextNodeAtPosition( position, positionParent );\n\t\tconst node = textNodeAtPosition ? textNodeAtPosition : getNodeBeforePosition( position, positionParent, textNodeAtPosition );\n\n\t\tif ( node instanceof Element ) {\n\t\t\tposition.offset--;\n\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition.path.push( node.maxOffset );\n\t\t\t\tthis.position = position;\n\t\t\t\tthis._visitedParent = node;\n\n\t\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\t\treturn this._previous();\n\t\t\t\t} else {\n\t\t\t\t\treturn formatReturnValue( 'elementEnd', node, previousPosition, position );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t\t}\n\t\t} else if ( node instanceof Text ) {\n\t\t\tlet charactersCount;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tcharactersCount = 1;\n\t\t\t} else {\n\t\t\t\tlet offset = node.startOffset;\n\n\t\t\t\tif ( this._boundaryStartParent == parent && this.boundaries.start.offset > offset ) {\n\t\t\t\t\toffset = this.boundaries.start.offset;\n\t\t\t\t}\n\n\t\t\t\tcharactersCount = position.offset - offset;\n\t\t\t}\n\n\t\t\tconst offsetInTextNode = position.offset - node.startOffset;\n\t\t\tconst item = new TextProxy( node, offsetInTextNode - charactersCount, charactersCount );\n\n\t\t\tposition.offset -= charactersCount;\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the beginning of current `parent`.\n\t\t\tposition.path.pop();\n\t\t\tthis.position = position;\n\t\t\tthis._visitedParent = parent.parent;\n\n\t\t\treturn formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );\n\t\t}\n\t}\n}\n\nfunction formatReturnValue( type, item, previousPosition, nextPosition, length ) {\n\treturn {\n\t\tdone: false,\n\t\tvalue: {\n\t\t\ttype,\n\t\t\titem,\n\t\t\tpreviousPosition,\n\t\t\tnextPosition,\n\t\t\tlength\n\t\t}\n\t};\n}\n\n/**\n * Type of the step made by {@link module:engine/model/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,\n * `'character'` if walker traversed over a character, or `'text'` if walker traversed over multiple characters (available in\n * character merging mode, see {@link module:engine/model/treewalker~TreeWalker#constructor}).\n *\n * @typedef {'elementStart'|'elementEnd'|'character'|'text'} module:engine/model/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/model/treewalker~TreeWalker} when traversing tree model.\n *\n * @typedef {Object} module:engine/model/treewalker~TreeWalkerValue\n * @property {module:engine/model/treewalker~TreeWalkerValueType} type\n * @property {module:engine/model/item~Item} item Item between old and new positions of {@link module:engine/model/treewalker~TreeWalker}.\n * @property {module:engine/model/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * @property {module:engine/model/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * @property {Number} [length] Length of the item. For `'elementStart'` and `'character'` it is 1. For `'text'` it is\n * the length of the text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/model/treewalker~TreeWalkerDirection\n */\n"]}]}