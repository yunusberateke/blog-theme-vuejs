{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS92aWV3L3JhbmdlCiAqLwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBUcmVlV2Fsa2VyIGZyb20gJy4vdHJlZXdhbGtlcic7Ci8qKgogKiBSYW5nZSBpbiB0aGUgdmlldyB0cmVlLiBBIHJhbmdlIGlzIHJlcHJlc2VudGVkIGJ5IGl0cyBzdGFydCBhbmQgZW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb25zfS4KICoKICogSW4gb3JkZXIgdG8gY3JlYXRlIGEgbmV3IHBvc2l0aW9uIGluc3RhbmNlIHVzZSB0aGUgYGNyZWF0ZVBvc2l0aW9uKigpYCBmYWN0b3J5IG1ldGhvZHMgYXZhaWxhYmxlIGluOgogKgogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlld35WaWV3fQogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXJ9CiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91cGNhc3R3cml0ZXJ+VXBjYXN0V3JpdGVyfQogKi8KCnZhciBSYW5nZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIHJhbmdlIHNwYW5uaW5nIGZyb20gYHN0YXJ0YCBwb3NpdGlvbiB0byBgZW5kYCBwb3NpdGlvbi4KICAgKgogICAqICoqTm90ZToqKiBDb25zdHJ1Y3RvciBjcmVhdGVzIGl0J3Mgb3duIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IGluc3RhbmNlcyBiYXNpbmcgb24gcGFzc2VkIHZhbHVlcy4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBzdGFydCBTdGFydCBwb3NpdGlvbi4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gW2VuZF0gRW5kIHBvc2l0aW9uLiBJZiBub3Qgc2V0LCByYW5nZSB3aWxsIGJlIGNvbGxhcHNlZCBhdCB0aGUgYHN0YXJ0YCBwb3NpdGlvbi4KICAgKi8KICBmdW5jdGlvbiBSYW5nZShzdGFydCkgewogICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2UpOwoKICAgIC8qKgogICAgICogU3RhcnQgcG9zaXRpb24uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KICAgIHRoaXMuc3RhcnQgPSBzdGFydC5jbG9uZSgpOwogICAgLyoqCiAgICAgKiBFbmQgcG9zaXRpb24uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgICB0aGlzLmVuZCA9IGVuZCA/IGVuZC5jbG9uZSgpIDogc3RhcnQuY2xvbmUoKTsKICB9CiAgLyoqCiAgICogSXRlcmFibGUgaW50ZXJmYWNlLgogICAqCiAgICogSXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gdmlldyBpdGVtc30gdGhhdCBhcmUgaW4gdGhpcyByYW5nZSBhbmQgcmV0dXJucwogICAqIHRoZW0gdG9nZXRoZXIgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGxpa2UgbGVuZ3RoIG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb25zfSwKICAgKiBncm91cGVkIGFzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9LgogICAqCiAgICogVGhpcyBpdGVyYXRvciB1c2VzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyIFRyZWVXYWxrZXJ9IHdpdGggYGJvdW5kYXJpZXNgIHNldCB0byB0aGlzIHJhbmdlIGFuZAogICAqIGBpZ25vcmVFbGVtZW50RW5kYCBvcHRpb24KICAgKiBzZXQgdG8gYHRydWVgLgogICAqCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWU+fQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFJhbmdlLCBbewogICAga2V5OiBTeW1ib2wuaXRlcmF0b3IsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkgewogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0KSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKG5ldyBUcmVlV2Fsa2VyKHsKICAgICAgICAgICAgICAgIGJvdW5kYXJpZXM6IHRoaXMsCiAgICAgICAgICAgICAgICBpZ25vcmVFbGVtZW50RW5kOiB0cnVlCiAgICAgICAgICAgICAgfSksICJ0MCIsIDEpOwoKICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCB2YWx1ZSwgdGhpcyk7CiAgICB9KQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgdGhhdCBpcyBpdCBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBhcmUgZXF1YWwuCiAgICAgKgogICAgICogQHR5cGUge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNDb2xsYXBzZWQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmlzRXF1YWwodGhpcy5lbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByYW5nZSBpcyBmbGF0LCB0aGF0IGlzIGlmIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9IHBvc2l0aW9uIGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbiBhcmUgaW4gdGhlIHNhbWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcGFyZW50fS4KICAgICAqCiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0ZsYXQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnBhcmVudCA9PT0gdGhpcy5lbmQucGFyZW50OwogICAgfQogICAgLyoqCiAgICAgKiBSYW5nZSByb290IGVsZW1lbnQuCiAgICAgKgogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyb290IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5zdGFydC5yb290OwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbWF4aW1hbCByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSBjb250ZW50IGFzIHRoaXMgcmFuZ2UgYnV0IGlzIGV4cGFuZGVkIGluIGJvdGggd2F5cyAoYXQgdGhlIGJlZ2lubmluZwogICAgICogYW5kIGF0IHRoZSBlbmQpLgogICAgICoKICAgICAqIEZvciBleGFtcGxlOgogICAgICoKICAgICAqCQk8cD5Gb288L3A+PHA+PGI+e0Jhcn08L2I+PC9wPiAtPiA8cD5Gb288L3A+WzxwPjxiPkJhcjwvYj5dPC9wPgogICAgICoJCTxwPjxiPmZvbzwvYj57YmFyfTxzcGFuPjwvc3Bhbj48L3A+IC0+IDxwPjxiPmZvb1s8L2I+YmFyPHNwYW4+PC9zcGFuPl08L3A+CiAgICAgKgogICAgICogTm90ZSB0aGF0IGluIHRoZSBzYW1wbGUgYWJvdmU6CiAgICAgKgogICAgICogLSBgPHA+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR9LAogICAgICogLSBgPGI+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9LAogICAgICogLSBgPHNwYW4+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBFbmxhcmdlZCByYW5nZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRFbmxhcmdlZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RW5sYXJnZWQoKSB7CiAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQuZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oZW5sYXJnZVRyaW1Ta2lwLCB7CiAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnCiAgICAgIH0pOwogICAgICB2YXIgZW5kID0gdGhpcy5lbmQuZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oZW5sYXJnZVRyaW1Ta2lwKTsgLy8gRml4IHBvc2l0aW9ucywgaW4gY2FzZSBpZiB0aGV5IGFyZSBpbiBUZXh0IG5vZGUuCgogICAgICBpZiAoc3RhcnQucGFyZW50LmlzKCckdGV4dCcpICYmIHN0YXJ0LmlzQXRTdGFydCkgewogICAgICAgIHN0YXJ0ID0gUG9zaXRpb24uX2NyZWF0ZUJlZm9yZShzdGFydC5wYXJlbnQpOwogICAgICB9CgogICAgICBpZiAoZW5kLnBhcmVudC5pcygnJHRleHQnKSAmJiBlbmQuaXNBdEVuZCkgewogICAgICAgIGVuZCA9IFBvc2l0aW9uLl9jcmVhdGVBZnRlcihlbmQucGFyZW50KTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG1pbmltdW0gcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgY29udGVudCBhcyB0aGlzIHJhbmdlIGJ1dCBpcyB0cmltbWVkIGluIGJvdGggd2F5cyAoYXQgdGhlIGJlZ2lubmluZwogICAgICogYW5kIGF0IHRoZSBlbmQpLgogICAgICoKICAgICAqIEZvciBleGFtcGxlOgogICAgICoKICAgICAqCQk8cD5Gb288L3A+WzxwPjxiPkJhcjwvYj5dPC9wPiAtPiA8cD5Gb288L3A+PHA+PGI+e0Jhcn08L2I+PC9wPgogICAgICoJCTxwPjxiPmZvb1s8L2I+YmFyPHNwYW4+PC9zcGFuPl08L3A+IC0+IDxwPjxiPmZvbzwvYj57YmFyfTxzcGFuPjwvc3Bhbj48L3A+CiAgICAgKgogICAgICogTm90ZSB0aGF0IGluIHRoZSBzYW1wbGUgYWJvdmU6CiAgICAgKgogICAgICogLSBgPHA+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR9LAogICAgICogLSBgPGI+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9LAogICAgICogLSBgPHNwYW4+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBTaHJpbmsgcmFuZ2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0VHJpbW1lZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJpbW1lZCgpIHsKICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydC5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihlbmxhcmdlVHJpbVNraXApOwoKICAgICAgaWYgKHN0YXJ0LmlzQWZ0ZXIodGhpcy5lbmQpIHx8IHN0YXJ0LmlzRXF1YWwodGhpcy5lbmQpKSB7CiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgc3RhcnQpOwogICAgICB9CgogICAgICB2YXIgZW5kID0gdGhpcy5lbmQuZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oZW5sYXJnZVRyaW1Ta2lwLCB7CiAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnCiAgICAgIH0pOwogICAgICB2YXIgbm9kZUFmdGVyU3RhcnQgPSBzdGFydC5ub2RlQWZ0ZXI7CiAgICAgIHZhciBub2RlQmVmb3JlRW5kID0gZW5kLm5vZGVCZWZvcmU7IC8vIEJlY2F1c2UgVHJlZVdhbGtlciBwcmVmZXJzIHBvc2l0aW9ucyBuZXh0IHRvIHRleHQgbm9kZSwgd2UgbmVlZCB0byBtb3ZlIHRoZW0gbWFudWFsbHkgaW50byB0aGVzZSB0ZXh0IG5vZGVzLgoKICAgICAgaWYgKG5vZGVBZnRlclN0YXJ0ICYmIG5vZGVBZnRlclN0YXJ0LmlzKCckdGV4dCcpKSB7CiAgICAgICAgc3RhcnQgPSBuZXcgUG9zaXRpb24obm9kZUFmdGVyU3RhcnQsIDApOwogICAgICB9CgogICAgICBpZiAobm9kZUJlZm9yZUVuZCAmJiBub2RlQmVmb3JlRW5kLmlzKCckdGV4dCcpKSB7CiAgICAgICAgZW5kID0gbmV3IFBvc2l0aW9uKG5vZGVCZWZvcmVFbmQsIG5vZGVCZWZvcmVFbmQuZGF0YS5sZW5ndGgpOwogICAgICB9CgogICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBUd28gcmFuZ2VzIGFyZSBlcXVhbCBpZiB0aGVpciBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBhcmUgZXF1YWwuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gY29tcGFyZSB3aXRoLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiByYW5nZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzRXF1YWwiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzRXF1YWwob3RoZXJSYW5nZSkgewogICAgICByZXR1cm4gdGhpcyA9PSBvdGhlclJhbmdlIHx8IHRoaXMuc3RhcnQuaXNFcXVhbChvdGhlclJhbmdlLnN0YXJ0KSAmJiB0aGlzLmVuZC5pc0VxdWFsKG90aGVyUmFuZ2UuZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyByYW5nZSBjb250YWlucyBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259IGlzIGNvbnRhaW5lZCBpbiB0aGlzIHJhbmdlLAogICAgICogYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29udGFpbnNQb3NpdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb3NpdGlvbihwb3NpdGlvbikgewogICAgICByZXR1cm4gcG9zaXRpb24uaXNBZnRlcih0aGlzLnN0YXJ0KSAmJiBwb3NpdGlvbi5pc0JlZm9yZSh0aGlzLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcmFuZ2UgY29udGFpbnMgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gY2hlY2suCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29zZT1mYWxzZV0gV2hldGhlciB0aGUgY2hlY2sgaXMgbG9vc2Ugb3Igc3RyaWN0LiBJZiB0aGUgY2hlY2sgaXMgc3RyaWN0IChgZmFsc2VgKSwgY29tcGFyZWQgcmFuZ2UgY2Fubm90CiAgICAgKiBzdGFydCBvciBlbmQgYXQgdGhlIHNhbWUgcG9zaXRpb24gYXMgdGhpcyByYW5nZSBib3VuZGFyaWVzLiBJZiB0aGUgY2hlY2sgaXMgbG9vc2UgKGB0cnVlYCksIGNvbXBhcmVkIHJhbmdlIGNhbiBzdGFydCwgZW5kIG9yCiAgICAgKiBldmVuIGJlIGVxdWFsIHRvIHRoaXMgcmFuZ2UuIE5vdGUgdGhhdCBjb2xsYXBzZWQgcmFuZ2VzIGFyZSBhbHdheXMgY29tcGFyZWQgaW4gc3RyaWN0IG1vZGUuCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UgcmFuZ2V9IGJvdW5kYXJpZXMgYXJlIGNvbnRhaW5lZCBieSB0aGlzIHJhbmdlLCBgZmFsc2VgCiAgICAgKiBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29udGFpbnNSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNSYW5nZShvdGhlclJhbmdlKSB7CiAgICAgIHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7CgogICAgICBpZiAob3RoZXJSYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICAgIGxvb3NlID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciBjb250YWluc1N0YXJ0ID0gdGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2Uuc3RhcnQpIHx8IGxvb3NlICYmIHRoaXMuc3RhcnQuaXNFcXVhbChvdGhlclJhbmdlLnN0YXJ0KTsKICAgICAgdmFyIGNvbnRhaW5zRW5kID0gdGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2UuZW5kKSB8fCBsb29zZSAmJiB0aGlzLmVuZC5pc0VxdWFsKG90aGVyUmFuZ2UuZW5kKTsKICAgICAgcmV0dXJuIGNvbnRhaW5zU3RhcnQgJiYgY29udGFpbnNFbmQ7CiAgICB9CiAgICAvKioKICAgICAqIENvbXB1dGVzIHdoaWNoIHBhcnQocykgb2YgdGhpcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlIHJhbmdlfSBpcyBub3QgYSBwYXJ0IG9mIGdpdmVuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlIHJhbmdlfS4KICAgICAqIFJldHVybmVkIGFycmF5IGNvbnRhaW5zIHplcm8sIG9uZSBvciB0d28ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSByYW5nZXN9LgogICAgICoKICAgICAqIEV4YW1wbGVzOgogICAgICoKICAgICAqCQlsZXQgZm9vID0gZG93bmNhc3RXcml0ZXIuY3JlYXRlVGV4dCggJ2ZvbycgKTsKICAgICAqCQlsZXQgaW1nID0gZG93bmNhc3RXcml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ2ltZycgKTsKICAgICAqCQlsZXQgYmFyID0gZG93bmNhc3RXcml0ZXIuY3JlYXRlVGV4dCggJ2JhcicgKTsKICAgICAqCQlsZXQgcCA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJywgbnVsbCwgWyBmb28sIGltZywgYmFyIF0gKTsKICAgICAqCiAgICAgKgkJbGV0IHJhbmdlID0gdmlldy5jcmVhdGVSYW5nZSggdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBmb28sIDIgKSwgdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBiYXIsIDEgKTsgLy8gIm8iLCBpbWcsICJiIiBhcmUgaW4gcmFuZ2UuCiAgICAgKgkJbGV0IG90aGVyUmFuZ2UgPSB2aWV3LmNyZWF0ZVJhbmdlKCAvLyAib28iLCBpbWcsICJiYSIgYXJlIGluIHJhbmdlLgogICAgICoJCQl2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGZvbywgMSApLAogICAgICoJCQl2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGJhciwgMiApCiAgICAgKgkJKTsKICAgICAqCQlsZXQgdHJhbnNmb3JtZWQgPSByYW5nZS5nZXREaWZmZXJlbmNlKCBvdGhlclJhbmdlICk7CiAgICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIG5vIHJhbmdlcyBiZWNhdXNlIGBvdGhlclJhbmdlYCBjb250YWlucyBgcmFuZ2VgCiAgICAgKgogICAgICoJCW90aGVyUmFuZ2UgPSB2aWV3LmNyZWF0ZVJhbmdlKCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGZvbywgMSApLCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIHAsIDIgKTsgLy8gIm9vIiwgaW1nIGFyZSBpbiByYW5nZS4KICAgICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldERpZmZlcmVuY2UoIG90aGVyUmFuZ2UgKTsKICAgICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgb25lIHJhbmdlOiBmcm9tICggcCwgMiApIHRvICggYmFyLCAxICkKICAgICAqCiAgICAgKgkJb3RoZXJSYW5nZSA9IHZpZXcuY3JlYXRlUmFuZ2UoIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggcCwgMSApLCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIHAsIDIgKSApOyAvLyBpbWcgaXMgaW4gcmFuZ2UuCiAgICAgKgkJdHJhbnNmb3JtZWQgPSByYW5nZS5nZXREaWZmZXJlbmNlKCBvdGhlclJhbmdlICk7CiAgICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIHR3byByYW5nZXM6IGZyb20gKCBmb28sIDEgKSB0byAoIHAsIDEgKSBhbmQgZnJvbSAoIHAsIDIgKSB0byAoIGJhciwgMSApCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gZGlmZmVyZW50aWF0ZSBhZ2FpbnN0LgogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2U+fSBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHJhbmdlcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXREaWZmZXJlbmNlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaWZmZXJlbmNlKG90aGVyUmFuZ2UpIHsKICAgICAgdmFyIHJhbmdlcyA9IFtdOwoKICAgICAgaWYgKHRoaXMuaXNJbnRlcnNlY3Rpbmcob3RoZXJSYW5nZSkpIHsKICAgICAgICAvLyBSYW5nZXMgaW50ZXJzZWN0LgogICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5zdGFydCkpIHsKICAgICAgICAgIC8vIEdpdmVuIHJhbmdlIHN0YXJ0IGlzIGluc2lkZSB0aGlzIHJhbmdlLiBUaGlzIG1lYW5zIHRoYXQgd2UgaGF2ZSB0bwogICAgICAgICAgLy8gYWRkIHNocnVua2VuIHJhbmdlIC0gZnJvbSB0aGUgc3RhcnQgdG8gdGhlIG1pZGRsZSBvZiB0aGlzIHJhbmdlLgogICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHRoaXMuc3RhcnQsIG90aGVyUmFuZ2Uuc3RhcnQpKTsKICAgICAgICB9CgogICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5lbmQpKSB7CiAgICAgICAgICAvLyBHaXZlbiByYW5nZSBlbmQgaXMgaW5zaWRlIHRoaXMgcmFuZ2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvCiAgICAgICAgICAvLyBhZGQgc2hydW5rZW4gcmFuZ2UgLSBmcm9tIHRoZSBtaWRkbGUgb2YgdGhpcyByYW5nZSB0byB0aGUgZW5kLgogICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKG90aGVyUmFuZ2UuZW5kLCB0aGlzLmVuZCkpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBSYW5nZXMgZG8gbm90IGludGVyc2VjdCwgcmV0dXJuIHRoZSBvcmlnaW5hbCByYW5nZS4KICAgICAgICByYW5nZXMucHVzaCh0aGlzLmNsb25lKCkpOwogICAgICB9CgogICAgICByZXR1cm4gcmFuZ2VzOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGludGVyc2VjdGlvbiBvZiB0aGlzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UgcmFuZ2V9IGFuZCBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlIHJhbmdlfS4KICAgICAqIEludGVyc2VjdGlvbiBpcyBhIGNvbW1vbiBwYXJ0IG9mIGJvdGggb2YgdGhvc2UgcmFuZ2VzLiBJZiByYW5nZXMgaGFzIG5vIGNvbW1vbiBwYXJ0LCByZXR1cm5zIGBudWxsYC4KICAgICAqCiAgICAgKiBFeGFtcGxlczoKICAgICAqCiAgICAgKgkJbGV0IGZvbyA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZVRleHQoICdmb28nICk7CiAgICAgKgkJbGV0IGltZyA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdpbWcnICk7CiAgICAgKgkJbGV0IGJhciA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZVRleHQoICdiYXInICk7CiAgICAgKgkJbGV0IHAgPSBkb3duY2FzdFdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAncCcsIG51bGwsIFsgZm9vLCBpbWcsIGJhciBdICk7CiAgICAgKgogICAgICoJCWxldCByYW5nZSA9IHZpZXcuY3JlYXRlUmFuZ2UoIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggZm9vLCAyICksIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggYmFyLCAxICk7IC8vICJvIiwgaW1nLCAiYiIgYXJlIGluIHJhbmdlLgogICAgICoJCWxldCBvdGhlclJhbmdlID0gdmlldy5jcmVhdGVSYW5nZSggdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBmb28sIDEgKSwgdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBwLCAyICk7IC8vICJvbyIsIGltZyBhcmUgaW4gcmFuZ2UuCiAgICAgKgkJbGV0IHRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0SW50ZXJzZWN0aW9uKCBvdGhlclJhbmdlICk7IC8vIHJhbmdlIGZyb20gKCBmb28sIDEgKSB0byAoIHAsIDIgKS4KICAgICAqCiAgICAgKgkJb3RoZXJSYW5nZSA9IHZpZXcuY3JlYXRlUmFuZ2UoIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggYmFyLCAxICksIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggYmFyLCAzICk7ICJhciIgaXMgaW4gcmFuZ2UuCiAgICAgKgkJdHJhbnNmb3JtZWQgPSByYW5nZS5nZXRJbnRlcnNlY3Rpb24oIG90aGVyUmFuZ2UgKTsgLy8gbnVsbCAtIG5vIGNvbW1vbiBwYXJ0LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfG51bGx9IEEgY29tbW9uIHBhcnQgb2YgZ2l2ZW4gcmFuZ2VzIG9yIGBudWxsYCBpZiByYW5nZXMgaGF2ZSBubyBjb21tb24gcGFydC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRJbnRlcnNlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihvdGhlclJhbmdlKSB7CiAgICAgIGlmICh0aGlzLmlzSW50ZXJzZWN0aW5nKG90aGVyUmFuZ2UpKSB7CiAgICAgICAgLy8gUmFuZ2VzIGludGVyc2VjdCwgc28gYSBjb21tb24gcmFuZ2Ugd2lsbCBiZSByZXR1cm5lZC4KICAgICAgICAvLyBBdCBtb3N0LCBpdCB3aWxsIGJlIHNhbWUgYXMgdGhpcyByYW5nZS4KICAgICAgICB2YXIgY29tbW9uUmFuZ2VTdGFydCA9IHRoaXMuc3RhcnQ7CiAgICAgICAgdmFyIGNvbW1vblJhbmdlRW5kID0gdGhpcy5lbmQ7CgogICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5zdGFydCkpIHsKICAgICAgICAgIC8vIEdpdmVuIHJhbmdlIHN0YXJ0IGlzIGluc2lkZSB0aGlzIHJhbmdlLiBUaGlzIG1lYW5zIHRoYU50IHdlIGhhdmUgdG8KICAgICAgICAgIC8vIHNocmluayBjb21tb24gcmFuZ2UgdG8gdGhlIGdpdmVuIHJhbmdlIHN0YXJ0LgogICAgICAgICAgY29tbW9uUmFuZ2VTdGFydCA9IG90aGVyUmFuZ2Uuc3RhcnQ7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2UuZW5kKSkgewogICAgICAgICAgLy8gR2l2ZW4gcmFuZ2UgZW5kIGlzIGluc2lkZSB0aGlzIHJhbmdlLiBUaGlzIG1lYW5zIHRoYXQgd2UgaGF2ZSB0bwogICAgICAgICAgLy8gc2hyaW5rIGNvbW1vbiByYW5nZSB0byB0aGUgZ2l2ZW4gcmFuZ2UgZW5kLgogICAgICAgICAgY29tbW9uUmFuZ2VFbmQgPSBvdGhlclJhbmdlLmVuZDsKICAgICAgICB9CgogICAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tbW9uUmFuZ2VTdGFydCwgY29tbW9uUmFuZ2VFbmQpOwogICAgICB9IC8vIFJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCBzbyB0aGV5IGRvIG5vdCBoYXZlIGNvbW1vbiBwYXJ0LgoKCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXIgVHJlZVdhbGtlcn0gaW5zdGFuY2Ugd2l0aCB0aGlzIHJhbmdlIGFzIGEgYm91bmRhcnkuCiAgICAgKgogICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IFtvcHRpb25zLnN0YXJ0UG9zaXRpb25dCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNpbmdsZUNoYXJhY3RlcnM9ZmFsc2VdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNoYWxsb3c9ZmFsc2VdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQ9ZmFsc2VdCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRXYWxrZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdhbGtlcigpIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9OwogICAgICBvcHRpb25zLmJvdW5kYXJpZXMgPSB0aGlzOwogICAgICByZXR1cm4gbmV3IFRyZWVXYWxrZXIob3B0aW9ucyk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZX0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICAgKiB3aGljaCBpcyBhIGNvbW1vbiBhbmNlc3RvciBvZiByYW5nZSdzIGJvdGggZW5kcyAoaW4gd2hpY2ggdGhlIGVudGlyZSByYW5nZSBpcyBjb250YWluZWQpLgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDb21tb25BbmNlc3RvciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29tbW9uQW5jZXN0b3IoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmdldENvbW1vbkFuY2VzdG9yKHRoaXMuZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBFbGVtZW50fSBjb250YWluZWQgYnkgdGhlIHJhbmdlLgogICAgICogVGhlIGVsZW1lbnQgd2lsbCBiZSByZXR1cm5lZCB3aGVuIGl0IGlzIHRoZSAqKm9ubHkqKiBub2RlIHdpdGhpbiB0aGUgcmFuZ2UgYW5kICoqZnVsbHnigJNjb250YWluZWQqKgogICAgICogYXQgdGhlIHNhbWUgdGltZS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENvbnRhaW5lZEVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRhaW5lZEVsZW1lbnQoKSB7CiAgICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIHZhciBub2RlQWZ0ZXJTdGFydCA9IHRoaXMuc3RhcnQubm9kZUFmdGVyOwogICAgICB2YXIgbm9kZUJlZm9yZUVuZCA9IHRoaXMuZW5kLm5vZGVCZWZvcmU7IC8vIEhhbmRsZSB0aGUgc2l0dWF0aW9uIHdoZW4gdGhlIHJhbmdlIHBvc2l0aW9uIGlzIGF0IHRoZSBiZWdpbm5pbmcgLyBhdCB0aGUgZW5kIG9mIGEgdGV4dCBub2RlLgogICAgICAvLyBJbiBzdWNoIHNpdHVhdGlvbiBgLm5vZGVBZnRlcmAgYW5kIGAubm9kZUJlZm9yZWAgYXJlIGBudWxsYCBidXQgdGhlIHJhbmdlIHN0aWxsIG1pZ2h0IGJlIHNwYW5uaW5nCiAgICAgIC8vIG92ZXIgb25lIGVsZW1lbnQuCiAgICAgIC8vCiAgICAgIC8vIDxwPkZvb3s8c3BhbiBjbGFzcz0id2lkZ2V0Ij48L3NwYW4+fWJhcjwvcD4gdnMgPHA+Rm9vWzxzcGFuIGNsYXNzPSJ3aWRnZXQiPjwvc3Bhbj5dYmFyPC9wPgogICAgICAvLwogICAgICAvLyBUaGVzZSBhcmUgYmFzaWNhbGx5IHRoZSBzYW1lIHJhbmdlLCBvbmx5IHRoZSBkaWZmZXJlbmNlIGlzIGlmIHRoZSByYW5nZSBwb3NpdGlvbiBpcyBhdAogICAgICAvLyBhdCB0aGUgZW5kL2F0IHRoZSBiZWdpbm5pbmcgb2YgYSB0ZXh0IG5vZGUgb3IganVzdCBiZWZvcmUvanVzdCBhZnRlciB0aGUgdGV4dCBub2RlLgogICAgICAvLwoKICAgICAgaWYgKHRoaXMuc3RhcnQucGFyZW50LmlzKCckdGV4dCcpICYmIHRoaXMuc3RhcnQuaXNBdEVuZCAmJiB0aGlzLnN0YXJ0LnBhcmVudC5uZXh0U2libGluZykgewogICAgICAgIG5vZGVBZnRlclN0YXJ0ID0gdGhpcy5zdGFydC5wYXJlbnQubmV4dFNpYmxpbmc7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmVuZC5wYXJlbnQuaXMoJyR0ZXh0JykgJiYgdGhpcy5lbmQuaXNBdFN0YXJ0ICYmIHRoaXMuZW5kLnBhcmVudC5wcmV2aW91c1NpYmxpbmcpIHsKICAgICAgICBub2RlQmVmb3JlRW5kID0gdGhpcy5lbmQucGFyZW50LnByZXZpb3VzU2libGluZzsKICAgICAgfQoKICAgICAgaWYgKG5vZGVBZnRlclN0YXJ0ICYmIG5vZGVBZnRlclN0YXJ0LmlzKCdlbGVtZW50JykgJiYgbm9kZUFmdGVyU3RhcnQgPT09IG5vZGVCZWZvcmVFbmQpIHsKICAgICAgICByZXR1cm4gbm9kZUFmdGVyU3RhcnQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBDbG9uZXMgdGhpcyByYW5nZS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImNsb25lIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHsKICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCBpdGVyYXRlcyBvdmVyIGFsbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSB2aWV3IGl0ZW1zfSB0aGF0IGFyZSBpbiB0aGlzIHJhbmdlIGFuZCByZXR1cm5zCiAgICAgKiB0aGVtLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IHdpdGggYGJvdW5kYXJpZXNgIHNldCB0byB0aGlzIHJhbmdlIGFuZCBgaWdub3JlRWxlbWVudEVuZGAgb3B0aW9uCiAgICAgKiBzZXQgdG8gYHRydWVgLiBIb3dldmVyIGl0IHJldHVybnMgb25seSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSBpdGVtc30sCiAgICAgKiBub3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICAgKgogICAgICogWW91IG1heSBzcGVjaWZ5IGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRyZWUgd2Fsa2VyLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IGZvcgogICAgICogYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMuCiAgICAgKgogICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9LgogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRJdGVtcyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldEl0ZW1zKCkgewogICAgICB2YXIgb3B0aW9ucywKICAgICAgICAgIHRyZWVXYWxrZXIsCiAgICAgICAgICBfaXRlcmF0b3IsCiAgICAgICAgICBfc3RlcCwKICAgICAgICAgIF92YWx1ZSwKICAgICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50czsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRJdGVtcyQoX2NvbnRleHQyKSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzMi5sZW5ndGggPiAwICYmIF9hcmdzMlswXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzBdIDoge307CiAgICAgICAgICAgICAgb3B0aW9ucy5ib3VuZGFyaWVzID0gdGhpczsKICAgICAgICAgICAgICBvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQgPSB0cnVlOwogICAgICAgICAgICAgIHRyZWVXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0cmVlV2Fsa2VyKTsKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDU7CgogICAgICAgICAgICAgIF9pdGVyYXRvci5zKCk7CgogICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmUpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF92YWx1ZSA9IF9zdGVwLnZhbHVlOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7CiAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZS5pdGVtOwoKICAgICAgICAgICAgY2FzZSAxMToKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDEzOgogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTU7CiAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWyJjYXRjaCJdKDUpOwoKICAgICAgICAgICAgICBfaXRlcmF0b3IuZShfY29udGV4dDIudDApOwoKICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE4OwoKICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpOwoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgxOCk7CgogICAgICAgICAgICBjYXNlIDIxOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZ2V0SXRlbXMsIHRoaXMsIFtbNSwgMTUsIDE4LCAyMV1dKTsKICAgIH0pCiAgICAvKioKICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCBpdGVyYXRlcyBvdmVyIGFsbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30gdGhhdCBhcmUgYm91bmRhcmllcyBvcgogICAgICogY29udGFpbmVkIGluIHRoaXMgcmFuZ2UuCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gd2l0aCBgYm91bmRhcmllc2Agc2V0IHRvIHRoaXMgcmFuZ2UuIEhvd2V2ZXIgaXQgcmV0dXJucyBvbmx5CiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30sIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfS4KICAgICAqCiAgICAgKiBZb3UgbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdHJlZSB3YWxrZXIuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gZm9yCiAgICAgKiBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9ucy4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbj59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0UG9zaXRpb25zIiwKICAgIHZhbHVlOgogICAgLyojX19QVVJFX18qLwogICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gZ2V0UG9zaXRpb25zKCkgewogICAgICB2YXIgb3B0aW9ucywKICAgICAgICAgIHRyZWVXYWxrZXIsCiAgICAgICAgICBfaXRlcmF0b3IyLAogICAgICAgICAgX3N0ZXAyLAogICAgICAgICAgX3ZhbHVlMiwKICAgICAgICAgIF9hcmdzMyA9IGFyZ3VtZW50czsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRQb3NpdGlvbnMkKF9jb250ZXh0MykgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnczMubGVuZ3RoID4gMCAmJiBfYXJnczNbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzM1swXSA6IHt9OwogICAgICAgICAgICAgIG9wdGlvbnMuYm91bmRhcmllcyA9IHRoaXM7CiAgICAgICAgICAgICAgdHJlZVdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKG9wdGlvbnMpOwogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTsKICAgICAgICAgICAgICByZXR1cm4gdHJlZVdhbGtlci5wb3NpdGlvbjsKCiAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodHJlZVdhbGtlcik7CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA2OwoKICAgICAgICAgICAgICBfaXRlcmF0b3IyLnMoKTsKCiAgICAgICAgICAgIGNhc2UgODoKICAgICAgICAgICAgICBpZiAoKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE0OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfdmFsdWUyID0gX3N0ZXAyLnZhbHVlOwogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTIubmV4dFBvc2l0aW9uOwoKICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDg7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE2OgogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTY7CiAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzWyJjYXRjaCJdKDYpOwoKICAgICAgICAgICAgICBfaXRlcmF0b3IyLmUoX2NvbnRleHQzLnQwKTsKCiAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxOTsKCiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7CgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuZmluaXNoKDE5KTsKCiAgICAgICAgICAgIGNhc2UgMjI6CiAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCBnZXRQb3NpdGlvbnMsIHRoaXMsIFtbNiwgMTYsIDE5LCAyMl1dKTsKICAgIH0pCiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLgogICAgICoKICAgICAqCQlyYW5nZS5pcyggJ3JhbmdlJyApOyAvLyAtPiB0cnVlCiAgICAgKgkJcmFuZ2UuaXMoICd2aWV3OnJhbmdlJyApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICoJCXJhbmdlLmlzKCAnbW9kZWw6cmFuZ2UnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJcmFuZ2UuaXMoICdlbGVtZW50JyApOyAvLyAtPiBmYWxzZQogICAgICoJCXJhbmdlLmlzKCAnc2VsZWN0aW9uJyApOyAvLyAtPiBmYWxzZQogICAgICoKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlI2lzIENoZWNrIHRoZSBlbnRpcmUgbGlzdCBvZiB2aWV3IG9iamVjdHN9IHdoaWNoIGltcGxlbWVudCB0aGUgYGlzKClgIG1ldGhvZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZQogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzKHR5cGUpIHsKICAgICAgcmV0dXJuIHR5cGUgPT09ICdyYW5nZScgfHwgdHlwZSA9PT0gJ3ZpZXc6cmFuZ2UnOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgYW5kIHJldHVybnMgd2hldGhlciB0aGlzIHJhbmdlIGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2UuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gY29tcGFyZSB3aXRoLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgcmFuZ2VzIGludGVyc2VjdC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0ludGVyc2VjdGluZyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnRlcnNlY3Rpbmcob3RoZXJSYW5nZSkgewogICAgICByZXR1cm4gdGhpcy5zdGFydC5pc0JlZm9yZShvdGhlclJhbmdlLmVuZCkgJiYgdGhpcy5lbmQuaXNBZnRlcihvdGhlclJhbmdlLnN0YXJ0KTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIGZyb20gdGhlIGdpdmVuIHBhcmVudHMgYW5kIG9mZnNldHMuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHN0YXJ0RWxlbWVudCBTdGFydCBwb3NpdGlvbgogICAgICogcGFyZW50IGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRPZmZzZXQgU3RhcnQgcG9zaXRpb24gb2Zmc2V0LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGVuZEVsZW1lbnQgRW5kIHBvc2l0aW9uCiAgICAgKiBwYXJlbnQgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRPZmZzZXQgRW5kIHBvc2l0aW9uIG9mZnNldC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IENyZWF0ZWQgcmFuZ2UuCiAgICAgKi8KCiAgfV0sIFt7CiAgICBrZXk6ICJfY3JlYXRlRnJvbVBhcmVudHNBbmRPZmZzZXRzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRnJvbVBhcmVudHNBbmRPZmZzZXRzKHN0YXJ0RWxlbWVudCwgc3RhcnRPZmZzZXQsIGVuZEVsZW1lbnQsIGVuZE9mZnNldCkgewogICAgICByZXR1cm4gbmV3IHRoaXMobmV3IFBvc2l0aW9uKHN0YXJ0RWxlbWVudCwgc3RhcnRPZmZzZXQpLCBuZXcgUG9zaXRpb24oZW5kRWxlbWVudCwgZW5kT2Zmc2V0KSk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcgcmFuZ2UsIHNwcmVhZGluZyBmcm9tIHNwZWNpZmllZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSB0byBhIHBvc2l0aW9uIG1vdmVkIGJ5CiAgICAgKiBnaXZlbiBgc2hpZnRgLiBJZiBgc2hpZnRgIGlzIGEgbmVnYXRpdmUgdmFsdWUsIHNoaWZ0ZWQgcG9zaXRpb24gaXMgdHJlYXRlZCBhcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSByYW5nZS4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gQmVnaW5uaW5nIG9mIHRoZSByYW5nZS4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaGlmdCBIb3cgbG9uZyB0aGUgcmFuZ2Ugc2hvdWxkIGJlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChwb3NpdGlvbiwgc2hpZnQpIHsKICAgICAgdmFyIHN0YXJ0ID0gcG9zaXRpb247CiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbi5nZXRTaGlmdGVkQnkoc2hpZnQpOwogICAgICByZXR1cm4gc2hpZnQgPiAwID8gbmV3IHRoaXMoc3RhcnQsIGVuZCkgOiBuZXcgdGhpcyhlbmQsIHN0YXJ0KTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZgogICAgICogdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB3aGljaCBpcyBhIHBhcmVudCBmb3IgdGhlIHJhbmdlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlSW4iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVJbihlbGVtZW50KSB7CiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVGcm9tUGFyZW50c0FuZE9mZnNldHMoZWxlbWVudCwgMCwgZWxlbWVudCwgZWxlbWVudC5jaGlsZENvdW50KTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIHRoYXQgc3RhcnRzIGJlZm9yZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSB2aWV3IGl0ZW19IGFuZCBlbmRzIGFmdGVyIGl0LgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gaXRlbQogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlT24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVPbihpdGVtKSB7CiAgICAgIHZhciBzaXplID0gaXRlbS5pcygnJHRleHRQcm94eScpID8gaXRlbS5vZmZzZXRTaXplIDogMTsKICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSksIHNpemUpOwogICAgfQogIH1dKTsKCiAgcmV0dXJuIFJhbmdlOwp9KCk7IC8vIEZ1bmN0aW9uIHVzZWQgYnkgZ2V0RW5sYXJnZWQgYW5kIGdldFRyaW1tZWQgbWV0aG9kcy4KCgpleHBvcnQgeyBSYW5nZSBhcyBkZWZhdWx0IH07CgpmdW5jdGlvbiBlbmxhcmdlVHJpbVNraXAodmFsdWUpIHsKICBpZiAodmFsdWUuaXRlbS5pcygnYXR0cmlidXRlRWxlbWVudCcpIHx8IHZhbHVlLml0ZW0uaXMoJ3VpRWxlbWVudCcpKSB7CiAgICByZXR1cm4gdHJ1ZTsKICB9CgogIHJldHVybiBmYWxzZTsKfQ=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js"],"names":["Position","TreeWalker","Range","start","end","clone","Symbol","iterator","boundaries","ignoreElementEnd","isEqual","parent","root","getLastMatchingPosition","enlargeTrimSkip","direction","is","isAtStart","_createBefore","isAtEnd","_createAfter","isAfter","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","data","length","otherRange","position","isBefore","loose","isCollapsed","containsStart","containsPosition","containsEnd","ranges","isIntersecting","push","commonRangeStart","commonRangeEnd","options","getCommonAncestor","nextSibling","previousSibling","treeWalker","value","item","nextPosition","type","startElement","startOffset","endElement","endOffset","shift","getShiftedBy","element","_createFromParentsAndOffsets","childCount","size","offsetSize","_createFromPositionAndShift"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\n\n/**\n * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.start = start.clone();\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.end = end ? end.clone() : start.clone();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/view/position~Position positions},\n\t * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n\t * `ignoreElementEnd` option\n\t * set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is it start and end positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n\t * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\treturn this.start.parent === this.end.parent;\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t *\t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n\t *\t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n\t *\n\t * Note that in the sample above:\n\t *\n\t * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Enlarged range.\n\t */\n\tgetEnlarged() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\t// Fix positions, in case if they are in Text node.\n\t\tif ( start.parent.is( '$text' ) && start.isAtStart ) {\n\t\t\tstart = Position._createBefore( start.parent );\n\t\t}\n\n\t\tif ( end.parent.is( '$text' ) && end.isAtEnd ) {\n\t\t\tend = Position._createAfter( end.parent );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t *\t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n\t *\t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n\t *\n\t * Note that in the sample above:\n\t *\n\t * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Shrink range.\n\t */\n\tgetTrimmed() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\tif ( start.isAfter( this.end ) || start.isEqual( this.end ) ) {\n\t\t\treturn new Range( start, start );\n\t\t}\n\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tconst nodeAfterStart = start.nodeAfter;\n\t\tconst nodeBeforeEnd = end.nodeBefore;\n\n\t\t// Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n\t\tif ( nodeAfterStart && nodeAfterStart.is( '$text' ) ) {\n\t\t\tstart = new Position( nodeAfterStart, 0 );\n\t\t}\n\n\t\tif ( nodeBeforeEnd && nodeBeforeEnd.is( '$text' ) ) {\n\t\t\tend = new Position( nodeBeforeEnd, nodeBeforeEnd.data.length );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Two ranges are equal if their start and end positions are equal.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this == otherRange || ( this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end ) );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n\t *\n\t * @param {module:engine/view/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n\t * `false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n\t * otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n\t * {@link module:engine/view/range~Range range}.\n\t * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = downcastWriter.createText( 'foo' );\n\t *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n\t *\t\tlet bar = downcastWriter.createText( 'bar' );\n\t *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = view.createRange( // \"oo\", img, \"ba\" are in range.\n\t *\t\t\tview.createPositionAt( foo, 1 ),\n\t *\t\t\tview.createPositionAt( bar, 2 )\n\t *\t\t);\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( this.clone() );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = downcastWriter.createText( 'foo' );\n\t *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n\t *\t\tlet bar = downcastWriter.createText( 'bar' );\n\t *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); \"ar\" is in range.\n\t *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @param {module:engine/view/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t * @returns {module:engine/view/treewalker~TreeWalker}\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n\t * which is a common ancestor of range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/view/element~Element Element} contained by the range.\n\t * The element will be returned when it is the **only** node within the range and **fully–contained**\n\t * at the same time.\n\t *\n\t * @returns {module:engine/view/element~Element|null}\n\t */\n\tgetContainedElement() {\n\t\tif ( this.isCollapsed ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet nodeAfterStart = this.start.nodeAfter;\n\t\tlet nodeBeforeEnd = this.end.nodeBefore;\n\n\t\t// Handle the situation when the range position is at the beginning / at the end of a text node.\n\t\t// In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning\n\t\t// over one element.\n\t\t//\n\t\t// <p>Foo{<span class=\"widget\"></span>}bar</p> vs <p>Foo[<span class=\"widget\"></span>]bar</p>\n\t\t//\n\t\t// These are basically the same range, only the difference is if the range position is at\n\t\t// at the end/at the beginning of a text node or just before/just after the text node.\n\t\t//\n\t\tif ( this.start.parent.is( '$text' ) && this.start.isAtEnd && this.start.parent.nextSibling ) {\n\t\t\tnodeAfterStart = this.start.parent.nextSibling;\n\t\t}\n\n\t\tif ( this.end.parent.is( '$text' ) && this.end.isAtStart && this.end.parent.previousSibling ) {\n\t\t\tnodeBeforeEnd = this.end.parent.previousSibling;\n\t\t}\n\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'element' ) && nodeAfterStart === nodeBeforeEnd ) {\n\t\t\treturn nodeAfterStart;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clones this range.\n\t *\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tclone() {\n\t\treturn new Range( this.start, this.end );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n\t * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\trange.is( 'range' ); // -> true\n\t *\t\trange.is( 'view:range' ); // -> true\n\t *\n\t *\t\trange.is( 'model:range' ); // -> false\n\t *\t\trange.is( 'element' ); // -> false\n\t *\t\trange.is( 'selection' ); // -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'range' || type === 'view:range';\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with the given range.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} True if ranges intersect.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Creates a range from the given parents and offsets.\n\t *\n\t * @protected\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n\t * parent element.\n\t * @param {Number} startOffset Start position offset.\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n\t * parent element.\n\t * @param {Number} endOffset End position offset.\n\t * @returns {module:engine/view/range~Range} Created range.\n\t */\n\tstatic _createFromParentsAndOffsets( startElement, startOffset, endElement, endOffset ) {\n\t\treturn new this(\n\t\t\tnew Position( startElement, startOffset ),\n\t\t\tnew Position( endElement, endOffset )\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @protected\n\t * @param {module:engine/view/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @protected\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createIn( element ) {\n\t\treturn this._createFromParentsAndOffsets( element, 0, element, element.childCount );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @protected\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createOn( item ) {\n\t\tconst size = item.is( '$textProxy' ) ? item.offsetSize : 1;\n\n\t\treturn this._createFromPositionAndShift( Position._createBefore( item ), size );\n\t}\n}\n\n// Function used by getEnlarged and getTrimmed methods.\nfunction enlargeTrimSkip( value ) {\n\tif ( value.item.is( 'attributeElement' ) || value.item.is( 'uiElement' ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"]}]}