{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS92aWV3L3RyZWV3YWxrZXIKICovCmltcG9ydCBFbGVtZW50IGZyb20gJy4vZWxlbWVudCc7CmltcG9ydCBUZXh0IGZyb20gJy4vdGV4dCc7CmltcG9ydCBUZXh0UHJveHkgZnJvbSAnLi90ZXh0cHJveHknOwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwovKioKICogUG9zaXRpb24gaXRlcmF0b3IgY2xhc3MuIEl0IGFsbG93cyB0byBpdGVyYXRlIGZvcndhcmQgYW5kIGJhY2t3YXJkIG92ZXIgdGhlIGRvY3VtZW50LgogKi8KCnZhciBUcmVlV2Fsa2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGEgcmFuZ2UgaXRlcmF0b3IuIEFsbCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbCwgYnV0IHlvdSBoYXZlIHRvIHNwZWNpZnkgZWl0aGVyIGBib3VuZGFyaWVzYCBvciBgc3RhcnRQb3NpdGlvbmAuCiAgICoKICAgKiBAY29uc3RydWN0b3IKICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBbb3B0aW9ucy5ib3VuZGFyaWVzPW51bGxdIFJhbmdlIHRvIGRlZmluZSBib3VuZGFyaWVzIG9mIHRoZSBpdGVyYXRvci4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gW29wdGlvbnMuc3RhcnRQb3NpdGlvbl0gU3RhcnRpbmcgcG9zaXRpb24uCiAgICogQHBhcmFtIHsnZm9yd2FyZCd8J2JhY2t3YXJkJ30gW29wdGlvbnMuZGlyZWN0aW9uPSdmb3J3YXJkJ10gV2Fsa2luZyBkaXJlY3Rpb24uCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaW5nbGVDaGFyYWN0ZXJzPWZhbHNlXSBGbGFnIGluZGljYXRpbmcgd2hldGhlciBhbGwgY2hhcmFjdGVycyBmcm9tCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IHNob3VsZCBiZSByZXR1cm5lZCBhcyBvbmUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IChgZmFsc2VgKSBvcmUgb25lIGJ5IG9uZSBhcwogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dHByb3h5flRleHRQcm94eX0gKGB0cnVlYCkuCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaGFsbG93PWZhbHNlXSBGbGFnIGluZGljYXRpbmcgd2hldGhlciBpdGVyYXRvciBzaG91bGQgZW50ZXIgZWxlbWVudHMgb3Igbm90LiBJZiB0aGUKICAgKiBpdGVyYXRvciBpcyBzaGFsbG93IGNoaWxkIG5vZGVzIG9mIGFueSBpdGVyYXRlZCBub2RlIHdpbGwgbm90IGJlIHJldHVybmVkIGFsb25nIHdpdGggYGVsZW1lbnRFbmRgIHRhZy4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQ9ZmFsc2VdIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGl0ZXJhdG9yIHNob3VsZCBpZ25vcmUgYGVsZW1lbnRFbmRgCiAgICogdGFncy4gSWYgdGhlIG9wdGlvbiBpcyB0cnVlIHdhbGtlciB3aWxsIG5vdCByZXR1cm4gYSBwYXJlbnQgbm9kZSBvZiBzdGFydCBwb3NpdGlvbi4gSWYgdGhpcyBvcHRpb24gaXMgYHRydWVgCiAgICogZWFjaCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gd2lsbCBiZSByZXR1cm5lZCBvbmNlLCB3aGlsZSBpZiB0aGUgb3B0aW9uIGlzIGBmYWxzZWAgdGhleSBtaWdodCBiZSByZXR1cm5lZAogICAqIHR3aWNlOiBmb3IgYCdlbGVtZW50U3RhcnQnYCBhbmQgYCdlbGVtZW50RW5kJ2AuCiAgICovCiAgZnVuY3Rpb24gVHJlZVdhbGtlcigpIHsKICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZVdhbGtlcik7CgogICAgaWYgKCFvcHRpb25zLmJvdW5kYXJpZXMgJiYgIW9wdGlvbnMuc3RhcnRQb3NpdGlvbikgewogICAgICAvKioKICAgICAgICogTmVpdGhlciBib3VuZGFyaWVzIG5vciBzdGFydGluZyBwb3NpdGlvbiBoYXZlIGJlZW4gZGVmaW5lZC4KICAgICAgICoKICAgICAgICogQGVycm9yIHZpZXctdHJlZS13YWxrZXItbm8tc3RhcnQtcG9zaXRpb24KICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXRyZWUtd2Fsa2VyLW5vLXN0YXJ0LXBvc2l0aW9uJywgbnVsbCk7CiAgICB9CgogICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYmIG9wdGlvbnMuZGlyZWN0aW9uICE9ICdmb3J3YXJkJyAmJiBvcHRpb25zLmRpcmVjdGlvbiAhPSAnYmFja3dhcmQnKSB7CiAgICAgIC8qKgogICAgICAgKiBPbmx5IGBiYWNrd2FyZGAgYW5kIGBmb3J3YXJkYCBkaXJlY3Rpb24gYWxsb3dlZC4KICAgICAgICoKICAgICAgICogQGVycm9yIHZpZXctdHJlZS13YWxrZXItdW5rbm93bi1kaXJlY3Rpb24KICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXRyZWUtd2Fsa2VyLXVua25vd24tZGlyZWN0aW9uJywgb3B0aW9ucy5zdGFydFBvc2l0aW9uLCB7CiAgICAgICAgZGlyZWN0aW9uOiBvcHRpb25zLmRpcmVjdGlvbgogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogSXRlcmF0b3IgYm91bmRhcmllcy4KICAgICAqCiAgICAgKiBXaGVuIHRoZSBpdGVyYXRvciBpcyB3YWxraW5nIGAnZm9yd2FyZCdgIG9uIHRoZSBlbmQgb2YgYm91bmRhcnkgb3IgaXMgd2Fsa2luZyBgJ2JhY2t3YXJkJ2AKICAgICAqIG9uIHRoZSBzdGFydCBvZiBib3VuZGFyeSwgdGhlbiBgeyBkb25lOiB0cnVlIH1gIGlzIHJldHVybmVkLgogICAgICoKICAgICAqIElmIGJvdW5kYXJpZXMgYXJlIG5vdCBkZWZpbmVkIHRoZXkgYXJlIHNldCBiZWZvcmUgZmlyc3QgYW5kIGFmdGVyIGxhc3QgY2hpbGQgb2YgdGhlIHJvb3Qgbm9kZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNib3VuZGFyaWVzCiAgICAgKi8KCgogICAgdGhpcy5ib3VuZGFyaWVzID0gb3B0aW9ucy5ib3VuZGFyaWVzIHx8IG51bGw7CiAgICAvKioKICAgICAqIEl0ZXJhdG9yIHBvc2l0aW9uLiBJZiBzdGFydCBwb3NpdGlvbiBpcyBub3QgZGVmaW5lZCB0aGVuIHBvc2l0aW9uIGRlcGVuZHMgb24ge0BsaW5rICNkaXJlY3Rpb259LiBJZiBkaXJlY3Rpb24gaXMKICAgICAqIGAnZm9yd2FyZCdgIHBvc2l0aW9uIHN0YXJ0cyBmb3JtIHRoZSBiZWdpbm5pbmcsIHdoZW4gZGlyZWN0aW9uIGlzIGAnYmFja3dhcmQnYCBwb3NpdGlvbiBzdGFydHMgZnJvbSB0aGUgZW5kLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyI3Bvc2l0aW9uCiAgICAgKi8KCiAgICBpZiAob3B0aW9ucy5zdGFydFBvc2l0aW9uKSB7CiAgICAgIHRoaXMucG9zaXRpb24gPSBQb3NpdGlvbi5fY3JlYXRlQXQob3B0aW9ucy5zdGFydFBvc2l0aW9uKTsKICAgIH0gZWxzZSB7CiAgICAgIHRoaXMucG9zaXRpb24gPSBQb3NpdGlvbi5fY3JlYXRlQXQob3B0aW9ucy5ib3VuZGFyaWVzW29wdGlvbnMuZGlyZWN0aW9uID09ICdiYWNrd2FyZCcgPyAnZW5kJyA6ICdzdGFydCddKTsKICAgIH0KICAgIC8qKgogICAgICogV2Fsa2luZyBkaXJlY3Rpb24uIERlZmF1bHRzIGAnZm9yd2FyZCdgLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7J2JhY2t3YXJkJ3wnZm9yd2FyZCd9IG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXIjZGlyZWN0aW9uCiAgICAgKi8KCgogICAgdGhpcy5kaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCAnZm9yd2FyZCc7CiAgICAvKioKICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGFsbCBjaGFyYWN0ZXJzIGZyb20ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IHNob3VsZCBiZSByZXR1cm5lZCBhcyBvbmUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSBvciBvbmUgYnkgb25lIGFzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dHByb3h5flRleHRQcm94eX0uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyI3NpbmdsZUNoYXJhY3RlcnMKICAgICAqLwoKICAgIHRoaXMuc2luZ2xlQ2hhcmFjdGVycyA9ICEhb3B0aW9ucy5zaW5nbGVDaGFyYWN0ZXJzOwogICAgLyoqCiAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciBpdGVyYXRvciBzaG91bGQgZW50ZXIgZWxlbWVudHMgb3Igbm90LiBJZiB0aGUgaXRlcmF0b3IgaXMgc2hhbGxvdyBjaGlsZCBub2RlcyBvZiBhbnkKICAgICAqIGl0ZXJhdGVkIG5vZGUgd2lsbCBub3QgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCBgZWxlbWVudEVuZGAgdGFnLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNzaGFsbG93CiAgICAgKi8KCiAgICB0aGlzLnNoYWxsb3cgPSAhIW9wdGlvbnMuc2hhbGxvdzsKICAgIC8qKgogICAgICogRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgaXRlcmF0b3Igc2hvdWxkIGlnbm9yZSBgZWxlbWVudEVuZGAgdGFncy4gSWYgc2V0IHRvIGB0cnVlYCwgd2Fsa2VyIHdpbGwgbm90CiAgICAgKiByZXR1cm4gYSBwYXJlbnQgbm9kZSBvZiB0aGUgc3RhcnQgcG9zaXRpb24uIEVhY2gge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IHdpbGwgYmUgcmV0dXJuZWQgb25jZS4KICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAgZWFjaCBlbGVtZW50IG1pZ2h0IGJlIHJldHVybmVkIHR3aWNlOiBmb3IgYCdlbGVtZW50U3RhcnQnYCBhbmQgYCdlbGVtZW50RW5kJ2AuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyI2lnbm9yZUVsZW1lbnRFbmQKICAgICAqLwoKICAgIHRoaXMuaWdub3JlRWxlbWVudEVuZCA9ICEhb3B0aW9ucy5pZ25vcmVFbGVtZW50RW5kOwogICAgLyoqCiAgICAgKiBTdGFydCBib3VuZGFyeSBwYXJlbnQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV9IG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXIjX2JvdW5kYXJ5U3RhcnRQYXJlbnQKICAgICAqLwoKICAgIHRoaXMuX2JvdW5kYXJ5U3RhcnRQYXJlbnQgPSB0aGlzLmJvdW5kYXJpZXMgPyB0aGlzLmJvdW5kYXJpZXMuc3RhcnQucGFyZW50IDogbnVsbDsKICAgIC8qKgogICAgICogRW5kIGJvdW5kYXJ5IHBhcmVudC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZX0gbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNfYm91bmRhcnlFbmRQYXJlbnQKICAgICAqLwoKICAgIHRoaXMuX2JvdW5kYXJ5RW5kUGFyZW50ID0gdGhpcy5ib3VuZGFyaWVzID8gdGhpcy5ib3VuZGFyaWVzLmVuZC5wYXJlbnQgOiBudWxsOwogIH0KICAvKioKICAgKiBJdGVyYWJsZSBpbnRlcmZhY2UuCiAgICoKICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZT59CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoVHJlZVdhbGtlciwgW3sKICAgIGtleTogU3ltYm9sLml0ZXJhdG9yLAogICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkgewogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogTW92ZXMge0BsaW5rICNwb3NpdGlvbn0gaW4gdGhlIHtAbGluayAjZGlyZWN0aW9ufSBza2lwcGluZyB2YWx1ZXMgYXMgbG9uZyBhcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAuCiAgICAgKgogICAgICogRm9yIGV4YW1wbGU6CiAgICAgKgogICAgICogCQl3YWxrZXIuc2tpcCggdmFsdWUgPT4gdmFsdWUudHlwZSA9PSAndGV4dCcgKTsgLy8gPHA+e31mb288L3A+IC0+IDxwPmZvb1tdPC9wPgogICAgICogCQl3YWxrZXIuc2tpcCggdmFsdWUgPT4gdHJ1ZSApOyAvLyBNb3ZlIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kOiA8cD57fWZvbzwvcD4gLT4gPHA+Zm9vPC9wPltdCiAgICAgKiAJCXdhbGtlci5za2lwKCB2YWx1ZSA9PiBmYWxzZSApOyAvLyBEbyBub3QgbW92ZSB0aGUgcG9zaXRpb24uCiAgICAgKgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2tpcCBDYWxsYmFjayBmdW5jdGlvbi4gR2V0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfSBhbmQgc2hvdWxkCiAgICAgKiByZXR1cm4gYHRydWVgIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgc2tpcHBlZCBvciBgZmFsc2VgIGlmIG5vdC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJza2lwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwKF9za2lwKSB7CiAgICAgIHZhciBkb25lLCB2YWx1ZSwgcHJldlBvc2l0aW9uOwoKICAgICAgZG8gewogICAgICAgIHByZXZQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247CgogICAgICAgIHZhciBfdGhpcyRuZXh0ID0gdGhpcy5uZXh0KCk7CgogICAgICAgIGRvbmUgPSBfdGhpcyRuZXh0LmRvbmU7CiAgICAgICAgdmFsdWUgPSBfdGhpcyRuZXh0LnZhbHVlOwogICAgICB9IHdoaWxlICghZG9uZSAmJiBfc2tpcCh2YWx1ZSkpOwoKICAgICAgaWYgKCFkb25lKSB7CiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHByZXZQb3NpdGlvbjsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBuZXh0IHRyZWUgd2Fsa2VyJ3MgdmFsdWUuCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0gT2JqZWN0IGltcGxlbWVudGluZyBpdGVyYXRvciBpbnRlcmZhY2UsIHJldHVybmluZwogICAgICogaW5mb3JtYXRpb24gYWJvdXQgdGFrZW4gc3RlcC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJuZXh0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkgewogICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT0gJ2ZvcndhcmQnKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX25leHQoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXMoKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBNYWtlcyBhIHN0ZXAgZm9yd2FyZCBpbiB2aWV3LiBNb3ZlcyB0aGUge0BsaW5rICNwb3NpdGlvbn0gdG8gdGhlIG5leHQgcG9zaXRpb24gYW5kIHJldHVybnMgdGhlIGVuY291bnRlcmVkIHZhbHVlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fQogICAgICogQHJldHVybnMge0Jvb2xlYW59IHJldHVybi5kb25lIGB0cnVlYCBpZiBpdGVyYXRvciBpcyBkb25lLCBgZmFsc2VgIG90aGVyd2lzZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9IHJldHVybi52YWx1ZSBJbmZvcm1hdGlvbiBhYm91dCB0YWtlbiBzdGVwLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9uZXh0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV4dCgpIHsKICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpOwogICAgICB2YXIgcHJldmlvdXNQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247CiAgICAgIHZhciBwYXJlbnQgPSBwb3NpdGlvbi5wYXJlbnQ7IC8vIFdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSByb290LgoKICAgICAgaWYgKHBhcmVudC5wYXJlbnQgPT09IG51bGwgJiYgcG9zaXRpb24ub2Zmc2V0ID09PSBwYXJlbnQuY2hpbGRDb3VudCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkb25lOiB0cnVlCiAgICAgICAgfTsKICAgICAgfSAvLyBXZSByZWFjaGVkIHRoZSB3YWxrZXIgYm91bmRhcnkuCgoKICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcy5fYm91bmRhcnlFbmRQYXJlbnQgJiYgcG9zaXRpb24ub2Zmc2V0ID09IHRoaXMuYm91bmRhcmllcy5lbmQub2Zmc2V0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRvbmU6IHRydWUKICAgICAgICB9OwogICAgICB9IC8vIEdldCBub2RlIGp1c3QgYWZ0ZXIgY3VycmVudCBwb3NpdGlvbi4KCgogICAgICB2YXIgbm9kZTsgLy8gVGV4dCBpcyBhIHNwZWNpZmljIHBhcmVudCBiZWNhdXNlIGl0IGNvbnRhaW5zIHN0cmluZyBpbnN0ZWFkIG9mIGNoaWxkIG5vZGVzLgoKICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFRleHQpIHsKICAgICAgICBpZiAocG9zaXRpb24uaXNBdEVuZCkgewogICAgICAgICAgLy8gUHJldmVudCByZXR1cm5pbmcgImVsZW1lbnRFbmQiIGZvciBUZXh0IG5vZGUuIFNraXAgdGhhdCB2YWx1ZSBhbmQgcmV0dXJuIHRoZSBuZXh0IHdhbGtlciBzdGVwLgogICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFBvc2l0aW9uLl9jcmVhdGVBZnRlcihwYXJlbnQpOwogICAgICAgICAgcmV0dXJuIHRoaXMuX25leHQoKTsKICAgICAgICB9CgogICAgICAgIG5vZGUgPSBwYXJlbnQuZGF0YVtwb3NpdGlvbi5vZmZzZXRdOwogICAgICB9IGVsc2UgewogICAgICAgIG5vZGUgPSBwYXJlbnQuZ2V0Q2hpbGQocG9zaXRpb24ub2Zmc2V0KTsKICAgICAgfQoKICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7CiAgICAgICAgaWYgKCF0aGlzLnNoYWxsb3cpIHsKICAgICAgICAgIHBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKG5vZGUsIDApOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwb3NpdGlvbi5vZmZzZXQrKzsKICAgICAgICB9CgogICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsKICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0UmV0dXJuVmFsdWUoJ2VsZW1lbnRTdGFydCcsIG5vZGUsIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uLCAxKTsKICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVGV4dCkgewogICAgICAgIGlmICh0aGlzLnNpbmdsZUNoYXJhY3RlcnMpIHsKICAgICAgICAgIHBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKG5vZGUsIDApOwogICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOwogICAgICAgICAgcmV0dXJuIHRoaXMuX25leHQoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIGNoYXJhY3RlcnNDb3VudCA9IG5vZGUuZGF0YS5sZW5ndGg7CiAgICAgICAgICB2YXIgaXRlbTsgLy8gSWYgdGV4dCBzdGljayBvdXQgb2Ygd2Fsa2VyIHJhbmdlLCB3ZSBuZWVkIHRvIGN1dCBpdCBhbmQgd3JhcCBpbiBUZXh0UHJveHkuCgogICAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5fYm91bmRhcnlFbmRQYXJlbnQpIHsKICAgICAgICAgICAgY2hhcmFjdGVyc0NvdW50ID0gdGhpcy5ib3VuZGFyaWVzLmVuZC5vZmZzZXQ7CiAgICAgICAgICAgIGl0ZW0gPSBuZXcgVGV4dFByb3h5KG5vZGUsIDAsIGNoYXJhY3RlcnNDb3VudCk7CiAgICAgICAgICAgIHBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGl0ZW0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaXRlbSA9IG5ldyBUZXh0UHJveHkobm9kZSwgMCwgbm9kZS5kYXRhLmxlbmd0aCk7IC8vIElmIG5vdCBqdXN0IGtlZXAgbW92aW5nIGZvcndhcmQuCgogICAgICAgICAgICBwb3NpdGlvbi5vZmZzZXQrKzsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0UmV0dXJuVmFsdWUoJ3RleHQnLCBpdGVtLCBwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbiwgY2hhcmFjdGVyc0NvdW50KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT0gJ3N0cmluZycpIHsKICAgICAgICB2YXIgdGV4dExlbmd0aDsKCiAgICAgICAgaWYgKHRoaXMuc2luZ2xlQ2hhcmFjdGVycykgewogICAgICAgICAgdGV4dExlbmd0aCA9IDE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIENoZWNrIGlmIHRleHQgc3RpY2sgb3V0IG9mIHdhbGtlciByYW5nZS4KICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSBwYXJlbnQgPT09IHRoaXMuX2JvdW5kYXJ5RW5kUGFyZW50ID8gdGhpcy5ib3VuZGFyaWVzLmVuZC5vZmZzZXQgOiBwYXJlbnQuZGF0YS5sZW5ndGg7CiAgICAgICAgICB0ZXh0TGVuZ3RoID0gZW5kT2Zmc2V0IC0gcG9zaXRpb24ub2Zmc2V0OwogICAgICAgIH0KCiAgICAgICAgdmFyIHRleHRQcm94eSA9IG5ldyBUZXh0UHJveHkocGFyZW50LCBwb3NpdGlvbi5vZmZzZXQsIHRleHRMZW5ndGgpOwogICAgICAgIHBvc2l0aW9uLm9mZnNldCArPSB0ZXh0TGVuZ3RoOwogICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsKICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0UmV0dXJuVmFsdWUoJ3RleHQnLCB0ZXh0UHJveHksIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uLCB0ZXh0TGVuZ3RoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBgbm9kZWAgaXMgbm90IHNldCwgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIGN1cnJlbnQgYHBhcmVudGAuCiAgICAgICAgcG9zaXRpb24gPSBQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIocGFyZW50KTsKICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CgogICAgICAgIGlmICh0aGlzLmlnbm9yZUVsZW1lbnRFbmQpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9uZXh0KCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRSZXR1cm5WYWx1ZSgnZWxlbWVudEVuZCcsIHBhcmVudCwgcHJldmlvdXNQb3NpdGlvbiwgcG9zaXRpb24pOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBNYWtlcyBhIHN0ZXAgYmFja3dhcmQgaW4gdmlldy4gTW92ZXMgdGhlIHtAbGluayAjcG9zaXRpb259IHRvIHRoZSBwcmV2aW91cyBwb3NpdGlvbiBhbmQgcmV0dXJucyB0aGUgZW5jb3VudGVyZWQgdmFsdWUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEByZXR1cm5zIHtPYmplY3R9CiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmV0dXJuLmRvbmUgVHJ1ZSBpZiBpdGVyYXRvciBpcyBkb25lLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0gcmV0dXJuLnZhbHVlIEluZm9ybWF0aW9uIGFib3V0IHRha2VuIHN0ZXAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3ByZXZpb3VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJldmlvdXMoKSB7CiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uY2xvbmUoKTsKICAgICAgdmFyIHByZXZpb3VzUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uOwogICAgICB2YXIgcGFyZW50ID0gcG9zaXRpb24ucGFyZW50OyAvLyBXZSBhcmUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcm9vdC4KCiAgICAgIGlmIChwYXJlbnQucGFyZW50ID09PSBudWxsICYmIHBvc2l0aW9uLm9mZnNldCA9PT0gMCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkb25lOiB0cnVlCiAgICAgICAgfTsKICAgICAgfSAvLyBXZSByZWFjaGVkIHRoZSB3YWxrZXIgYm91bmRhcnkuCgoKICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLl9ib3VuZGFyeVN0YXJ0UGFyZW50ICYmIHBvc2l0aW9uLm9mZnNldCA9PSB0aGlzLmJvdW5kYXJpZXMuc3RhcnQub2Zmc2V0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRvbmU6IHRydWUKICAgICAgICB9OwogICAgICB9IC8vIEdldCBub2RlIGp1c3QgYmVmb3JlIGN1cnJlbnQgcG9zaXRpb24uCgoKICAgICAgdmFyIG5vZGU7IC8vIFRleHQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IGVsZW1lbnQgaXMgYSBzcGVjaWZpYyBwYXJlbnQgYmVjYXVzZSBjb250YWlucyBzdHJpbmcgaW5zdGVhZCBvZiBjaGlsZCBub2Rlcy4KCiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBUZXh0KSB7CiAgICAgICAgaWYgKHBvc2l0aW9uLmlzQXRTdGFydCkgewogICAgICAgICAgLy8gUHJldmVudCByZXR1cm5pbmcgImVsZW1lbnRTdGFydCIgZm9yIFRleHQgbm9kZS4gU2tpcCB0aGF0IHZhbHVlIGFuZCByZXR1cm4gdGhlIG5leHQgd2Fsa2VyIHN0ZXAuCiAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUJlZm9yZShwYXJlbnQpOwogICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzKCk7CiAgICAgICAgfQoKICAgICAgICBub2RlID0gcGFyZW50LmRhdGFbcG9zaXRpb24ub2Zmc2V0IC0gMV07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbm9kZSA9IHBhcmVudC5nZXRDaGlsZChwb3NpdGlvbi5vZmZzZXQgLSAxKTsKICAgICAgfQoKICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7CiAgICAgICAgaWYgKCF0aGlzLnNoYWxsb3cpIHsKICAgICAgICAgIHBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKG5vZGUsIG5vZGUuY2hpbGRDb3VudCk7CiAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CgogICAgICAgICAgaWYgKHRoaXMuaWdub3JlRWxlbWVudEVuZCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXMoKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRSZXR1cm5WYWx1ZSgnZWxlbWVudEVuZCcsIG5vZGUsIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgcG9zaXRpb24ub2Zmc2V0LS07CiAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0UmV0dXJuVmFsdWUoJ2VsZW1lbnRTdGFydCcsIG5vZGUsIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uLCAxKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRleHQpIHsKICAgICAgICBpZiAodGhpcy5zaW5nbGVDaGFyYWN0ZXJzKSB7CiAgICAgICAgICBwb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihub2RlLCBub2RlLmRhdGEubGVuZ3RoKTsKICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsKICAgICAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91cygpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgY2hhcmFjdGVyc0NvdW50ID0gbm9kZS5kYXRhLmxlbmd0aDsKICAgICAgICAgIHZhciBpdGVtOyAvLyBJZiB0ZXh0IHN0aWNrIG91dCBvZiB3YWxrZXIgcmFuZ2UsIHdlIG5lZWQgdG8gY3V0IGl0IGFuZCB3cmFwIGluIFRleHRQcm94eS4KCiAgICAgICAgICBpZiAobm9kZSA9PSB0aGlzLl9ib3VuZGFyeVN0YXJ0UGFyZW50KSB7CiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kYXJpZXMuc3RhcnQub2Zmc2V0OwogICAgICAgICAgICBpdGVtID0gbmV3IFRleHRQcm94eShub2RlLCBvZmZzZXQsIG5vZGUuZGF0YS5sZW5ndGggLSBvZmZzZXQpOwogICAgICAgICAgICBjaGFyYWN0ZXJzQ291bnQgPSBpdGVtLmRhdGEubGVuZ3RoOwogICAgICAgICAgICBwb3NpdGlvbiA9IFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBpdGVtID0gbmV3IFRleHRQcm94eShub2RlLCAwLCBub2RlLmRhdGEubGVuZ3RoKTsgLy8gSWYgbm90IGp1c3Qga2VlcCBtb3ZpbmcgYmFja3dhcmQuCgogICAgICAgICAgICBwb3NpdGlvbi5vZmZzZXQtLTsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0UmV0dXJuVmFsdWUoJ3RleHQnLCBpdGVtLCBwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbiwgY2hhcmFjdGVyc0NvdW50KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT0gJ3N0cmluZycpIHsKICAgICAgICB2YXIgdGV4dExlbmd0aDsKCiAgICAgICAgaWYgKCF0aGlzLnNpbmdsZUNoYXJhY3RlcnMpIHsKICAgICAgICAgIC8vIENoZWNrIGlmIHRleHQgc3RpY2sgb3V0IG9mIHdhbGtlciByYW5nZS4KICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IHBhcmVudCA9PT0gdGhpcy5fYm91bmRhcnlTdGFydFBhcmVudCA/IHRoaXMuYm91bmRhcmllcy5zdGFydC5vZmZzZXQgOiAwOwogICAgICAgICAgdGV4dExlbmd0aCA9IHBvc2l0aW9uLm9mZnNldCAtIHN0YXJ0T2Zmc2V0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0ZXh0TGVuZ3RoID0gMTsKICAgICAgICB9CgogICAgICAgIHBvc2l0aW9uLm9mZnNldCAtPSB0ZXh0TGVuZ3RoOwogICAgICAgIHZhciB0ZXh0UHJveHkgPSBuZXcgVGV4dFByb3h5KHBhcmVudCwgcG9zaXRpb24ub2Zmc2V0LCB0ZXh0TGVuZ3RoKTsKICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdFJldHVyblZhbHVlKCd0ZXh0JywgdGV4dFByb3h5LCBwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbiwgdGV4dExlbmd0aCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gYG5vZGVgIGlzIG5vdCBzZXQsIHdlIHJlYWNoZWQgdGhlIGJlZ2lubmluZyBvZiBjdXJyZW50IGBwYXJlbnRgLgogICAgICAgIHBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUJlZm9yZShwYXJlbnQpOwogICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsKICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0UmV0dXJuVmFsdWUoJ2VsZW1lbnRTdGFydCcsIHBhcmVudCwgcHJldmlvdXNQb3NpdGlvbiwgcG9zaXRpb24sIDEpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEZvcm1hdCByZXR1cm5lZCBkYXRhIGFuZCBhZGp1c3QgYHByZXZpb3VzUG9zaXRpb25gIGFuZCBgbmV4dFBvc2l0aW9uYCBpZiByZWFjaCB0aGUgYm91bmQgb2YgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWVUeXBlfSB0eXBlIFR5cGUgb2Ygc3RlcC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGJldHdlZW4gb2xkIGFuZCBuZXcgcG9zaXRpb24uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcHJldmlvdXNQb3NpdGlvbiBQcmV2aW91cyBwb3NpdGlvbiBvZiBpdGVyYXRvci4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBuZXh0UG9zaXRpb24gTmV4dCBwb3NpdGlvbiBvZiBpdGVyYXRvci4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggb2YgdGhlIGl0ZW0uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9mb3JtYXRSZXR1cm5WYWx1ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2Zvcm1hdFJldHVyblZhbHVlKHR5cGUsIGl0ZW0sIHByZXZpb3VzUG9zaXRpb24sIG5leHRQb3NpdGlvbiwgbGVuZ3RoKSB7CiAgICAgIC8vIFRleHQgaXMgYSBzcGVjaWZpYyBwYXJlbnQsIGJlY2F1c2UgY29udGFpbnMgc3RyaW5nIGluc3RlYWQgb2YgY2hpbGRyZW4uCiAgICAgIC8vIFdhbGtlciBkb2Vzbid0IGVudGVyIHRvIHRoZSBUZXh0IGV4Y2VwdCBzaXR1YXRpb25zIHdoZW4gd2Fsa2VyIGlzIGl0ZXJhdGluZyBvdmVyIGV2ZXJ5IHNpbmdsZSBjaGFyYWN0ZXIsCiAgICAgIC8vIG9yIHRoZSBib3VuZCBzdGFydHMvZW5kcyBpbnNpZGUgdGhlIFRleHQuIFNvIHdoZW4gdGhlIHBvc2l0aW9uIGlzIGF0IHRoZSBiZWdpbm5pbmcgb3IgYXQgdGhlIGVuZCBvZiB0aGUgVGV4dAogICAgICAvLyB3ZSBtb3ZlIGl0IGp1c3QgYmVmb3JlIG9yIGp1c3QgYWZ0ZXIgVGV4dC4KICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0UHJveHkpIHsKICAgICAgICAvLyBQb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mIFRleHQuCiAgICAgICAgaWYgKGl0ZW0ub2Zmc2V0SW5UZXh0ICsgaXRlbS5kYXRhLmxlbmd0aCA9PSBpdGVtLnRleHROb2RlLmRhdGEubGVuZ3RoKSB7CiAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT0gJ2ZvcndhcmQnICYmICEodGhpcy5ib3VuZGFyaWVzICYmIHRoaXMuYm91bmRhcmllcy5lbmQuaXNFcXVhbCh0aGlzLnBvc2l0aW9uKSkpIHsKICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGl0ZW0udGV4dE5vZGUpOyAvLyBXaGVuIHdlIGNoYW5nZSBuZXh0UG9zaXRpb24gb2YgcmV0dXJuZWQgdmFsdWUgd2UgbmVlZCBhbHNvIHVwZGF0ZSB3YWxrZXIgY3VycmVudCBwb3NpdGlvbi4KCiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXh0UG9zaXRpb247CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwcmV2aW91c1Bvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGl0ZW0udGV4dE5vZGUpOwogICAgICAgICAgfQogICAgICAgIH0gLy8gUG9zaXRpb24gaXMgYXQgdGhlIGJlZ2luaW5nIG90IHRoZSB0ZXh0LgoKCiAgICAgICAgaWYgKGl0ZW0ub2Zmc2V0SW5UZXh0ID09PSAwKSB7CiAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT0gJ2JhY2t3YXJkJyAmJiAhKHRoaXMuYm91bmRhcmllcyAmJiB0aGlzLmJvdW5kYXJpZXMuc3RhcnQuaXNFcXVhbCh0aGlzLnBvc2l0aW9uKSkpIHsKICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUJlZm9yZShpdGVtLnRleHROb2RlKTsgLy8gV2hlbiB3ZSBjaGFuZ2UgbmV4dFBvc2l0aW9uIG9mIHJldHVybmVkIHZhbHVlIHdlIG5lZWQgYWxzbyB1cGRhdGUgd2Fsa2VyIGN1cnJlbnQgcG9zaXRpb24uCgogICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV4dFBvc2l0aW9uOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbS50ZXh0Tm9kZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gewogICAgICAgIGRvbmU6IGZhbHNlLAogICAgICAgIHZhbHVlOiB7CiAgICAgICAgICB0eXBlOiB0eXBlLAogICAgICAgICAgaXRlbTogaXRlbSwKICAgICAgICAgIHByZXZpb3VzUG9zaXRpb246IHByZXZpb3VzUG9zaXRpb24sCiAgICAgICAgICBuZXh0UG9zaXRpb246IG5leHRQb3NpdGlvbiwKICAgICAgICAgIGxlbmd0aDogbGVuZ3RoCiAgICAgICAgfQogICAgICB9OwogICAgfQogIH1dKTsKCiAgcmV0dXJuIFRyZWVXYWxrZXI7Cn0oKTsKLyoqCiAqIFR5cGUgb2YgdGhlIHN0ZXAgbWFkZSBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAqIFBvc3NpYmxlIHZhbHVlczogYCdlbGVtZW50U3RhcnQnYCBpZiB3YWxrZXIgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiBhIG5vZGUsIGAnZWxlbWVudEVuZCdgIGlmIHdhbGtlciBpcyBhdCB0aGUgZW5kCiAqIG9mIG5vZGUsIG9yIGAndGV4dCdgIGlmIHdhbGtlciB0cmF2ZXJzZWQgb3ZlciBzaW5nbGUgYW5kIG11bHRpcGxlIGNoYXJhY3RlcnMuCiAqIEZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gYGVsZW1lbnRTdGFydGAgYW5kIGBlbGVtZW50RW5kYCBpcyBub3QgcmV0dXJuZWQuCiAqCiAqIEB0eXBlZGVmIHtTdHJpbmd9IG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZVR5cGUKICovCgovKioKICogT2JqZWN0IHJldHVybmVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSB3aGVuIHRyYXZlcnNpbmcgdHJlZSB2aWV3LgogKgogKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWUKICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWVUeXBlfSB0eXBlCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGJldHdlZW4gdGhlIG9sZCBhbmQgdGhlIG5ldyBwb3NpdGlvbnMKICogb2YgdGhlIHRyZWUgd2Fsa2VyLgogKiBAcHJvcGVydHkge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcHJldmlvdXNQb3NpdGlvbiBQcmV2aW91cyBwb3NpdGlvbiBvZiB0aGUgaXRlcmF0b3IuCiAqICogRm9yd2FyZCBpdGVyYXRpb246IEZvciBgJ2VsZW1lbnRFbmQnYCBpdCBpcyB0aGUgbGFzdCBwb3NpdGlvbiBpbnNpZGUgdGhlIGVsZW1lbnQuIEZvciBhbGwgb3RoZXIgdHlwZXMgaXQgaXMgdGhlCiAqIHBvc2l0aW9uIGJlZm9yZSB0aGUgaXRlbS4KICogKiBCYWNrd2FyZCBpdGVyYXRpb246IEZvciBgJ2VsZW1lbnRTdGFydCdgIGl0IGlzIHRoZSBmaXJzdCBwb3NpdGlvbiBpbnNpZGUgdGhlIGVsZW1lbnQuIEZvciBhbGwgb3RoZXIgdHlwZXMgaXQgaXMKICogdGhlIHBvc2l0aW9uIGFmdGVyIGl0ZW0uCiAqICogSWYgdGhlIHBvc2l0aW9uIGlzIGF0IHRoZSBiZWdpbm5pbmcgb3IgYXQgdGhlIGVuZCBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IGl0IGlzIGFsd2F5cyBtb3ZlZCBmcm9tIHRoZQogKiBpbnNpZGUgb2YgdGhlIHRleHQgdG8gaXRzIHBhcmVudCBqdXN0IGJlZm9yZSBvciBqdXN0IGFmdGVyIHRoYXQgdGV4dC4KICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IG5leHRQb3NpdGlvbiBOZXh0IHBvc2l0aW9uIG9mIHRoZSBpdGVyYXRvci4KICogKiBGb3J3YXJkIGl0ZXJhdGlvbjogRm9yIGAnZWxlbWVudFN0YXJ0J2AgaXQgaXMgdGhlIGZpcnN0IHBvc2l0aW9uIGluc2lkZSB0aGUgZWxlbWVudC4gRm9yIGFsbCBvdGhlciB0eXBlcyBpdCBpcwogKiB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGl0ZW0uCiAqICogQmFja3dhcmQgaXRlcmF0aW9uOiBGb3IgYCdlbGVtZW50RW5kJ2AgaXQgaXMgbGFzdCBwb3NpdGlvbiBpbnNpZGUgZWxlbWVudC4gRm9yIGFsbCBvdGhlciB0eXBlcyBpdCBpcyB0aGUgcG9zaXRpb24KICogYmVmb3JlIHRoZSBpdGVtLgogKiAqIElmIHRoZSBwb3NpdGlvbiBpcyBhdCB0aGUgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmQgb2YgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSBpdCBpcyBhbHdheXMgbW92ZWQgZnJvbSB0aGUKICogaW5zaWRlIG9mIHRoZSB0ZXh0IHRvIGl0cyBwYXJlbnQganVzdCBiZWZvcmUgb3IganVzdCBhZnRlciB0aGF0IHRleHQuCiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggb2YgdGhlIGl0ZW0uIEZvciBgJ2VsZW1lbnRTdGFydCdgIGl0IGlzIGAxYC4gRm9yIGAndGV4dCdgIGl0IGlzCiAqIHRoZSBsZW5ndGggb2YgdGhhdCB0ZXh0LiBGb3IgYCdlbGVtZW50RW5kJ2AgaXQgaXMgYHVuZGVmaW5lZGAuCiAqLwoKLyoqCiAqIFRyZWUgd2Fsa2luZyBkaXJlY3Rpb25zLgogKgogKiBAdHlwZWRlZiB7J2ZvcndhcmQnfCdiYWNrd2FyZCd9IG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJEaXJlY3Rpb24KICovCgoKZXhwb3J0IHsgVHJlZVdhbGtlciBhcyBkZWZhdWx0IH07"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js"],"names":["Element","Text","TextProxy","Position","CKEditorError","TreeWalker","options","boundaries","startPosition","direction","position","_createAt","singleCharacters","shallow","ignoreElementEnd","_boundaryStartParent","start","parent","_boundaryEndParent","end","Symbol","iterator","skip","done","value","prevPosition","next","_next","_previous","clone","previousPosition","offset","childCount","node","isAtEnd","_createAfter","data","getChild","_formatReturnValue","charactersCount","length","item","textLength","endOffset","textProxy","isAtStart","_createBefore","startOffset","type","nextPosition","offsetInText","textNode","isEqual"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/treewalker\n */\n\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n\t/**\n\t * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n\t *\n\t * @constructor\n\t * @param {Object} options Object with configuration.\n\t * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n\t * @param {module:engine/view/position~Position} [options.startPosition] Starting position.\n\t * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n\t * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all characters from\n\t * {@link module:engine/view/text~Text} should be returned as one {@link module:engine/view/text~Text} (`false`) ore one by one as\n\t * {@link module:engine/view/textproxy~TextProxy} (`true`).\n\t * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n\t * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n\t * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n\t * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n\t * each {@link module:engine/view/element~Element} will be returned once, while if the option is `false` they might be returned\n\t * twice: for `'elementStart'` and `'elementEnd'`.\n\t */\n\tconstructor( options = {} ) {\n\t\tif ( !options.boundaries && !options.startPosition ) {\n\t\t\t/**\n\t\t\t * Neither boundaries nor starting position have been defined.\n\t\t\t *\n\t\t\t * @error view-tree-walker-no-start-position\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-tree-walker-no-start-position',\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\tif ( options.direction && options.direction != 'forward' && options.direction != 'backward' ) {\n\t\t\t/**\n\t\t\t * Only `backward` and `forward` direction allowed.\n\t\t\t *\n\t\t\t * @error view-tree-walker-unknown-direction\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-tree-walker-unknown-direction', options.startPosition, { direction: options.direction } );\n\t\t}\n\n\t\t/**\n\t\t * Iterator boundaries.\n\t\t *\n\t\t * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n\t\t * on the start of boundary, then `{ done: true }` is returned.\n\t\t *\n\t\t * If boundaries are not defined they are set before first and after last child of the root node.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries\n\t\t */\n\t\tthis.boundaries = options.boundaries || null;\n\n\t\t/**\n\t\t * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is\n\t\t * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position\n\t\t */\n\t\tif ( options.startPosition ) {\n\t\t\tthis.position = Position._createAt( options.startPosition );\n\t\t} else {\n\t\t\tthis.position = Position._createAt( options.boundaries[ options.direction == 'backward' ? 'end' : 'start' ] );\n\t\t}\n\n\t\t/**\n\t\t * Walking direction. Defaults `'forward'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction\n\t\t */\n\t\tthis.direction = options.direction || 'forward';\n\n\t\t/**\n\t\t * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one\n\t\t * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters\n\t\t */\n\t\tthis.singleCharacters = !!options.singleCharacters;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n\t\t * iterated node will not be returned along with `elementEnd` tag.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow\n\t\t */\n\t\tthis.shallow = !!options.shallow;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not\n\t\t * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.\n\t\t * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd\n\t\t */\n\t\tthis.ignoreElementEnd = !!options.ignoreElementEnd;\n\n\t\t/**\n\t\t * Start boundary parent.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent\n\t\t */\n\t\tthis._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n\n\t\t/**\n\t\t * End boundary parent.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent\n\t\t */\n\t\tthis._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n\t *\n\t * For example:\n\t *\n\t * \t\twalker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n\t * \t\twalker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]\n\t * \t\twalker.skip( value => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t */\n\tskip( skip ) {\n\t\tlet done, value, prevPosition;\n\n\t\tdo {\n\t\t\tprevPosition = this.position;\n\n\t\t\t( { done, value } = this.next() );\n\t\t} while ( !done && skip( value ) );\n\n\t\tif ( !done ) {\n\t\t\tthis.position = prevPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the next tree walker's value.\n\t *\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} Object implementing iterator interface, returning\n\t * information about taken step.\n\t */\n\tnext() {\n\t\tif ( this.direction == 'forward' ) {\n\t\t\treturn this._next();\n\t\t} else {\n\t\t\treturn this._previous();\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_next() {\n\t\tlet position = this.position.clone();\n\t\tconst previousPosition = this.position;\n\t\tconst parent = position.parent;\n\n\t\t// We are at the end of the root.\n\t\tif ( parent.parent === null && position.offset === parent.childCount ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just after current position.\n\t\tlet node;\n\n\t\t// Text is a specific parent because it contains string instead of child nodes.\n\t\tif ( parent instanceof Text ) {\n\t\t\tif ( position.isAtEnd ) {\n\t\t\t\t// Prevent returning \"elementEnd\" for Text node. Skip that value and return the next walker step.\n\t\t\t\tthis.position = Position._createAfter( parent );\n\n\t\t\t\treturn this._next();\n\t\t\t}\n\n\t\t\tnode = parent.data[ position.offset ];\n\t\t} else {\n\t\t\tnode = parent.getChild( position.offset );\n\t\t}\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition = new Position( node, 0 );\n\t\t\t} else {\n\t\t\t\tposition.offset++;\n\t\t\t}\n\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t} else if ( node instanceof Text ) {\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tposition = new Position( node, 0 );\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\tlet charactersCount = node.data.length;\n\t\t\t\tlet item;\n\n\t\t\t\t// If text stick out of walker range, we need to cut it and wrap in TextProxy.\n\t\t\t\tif ( node == this._boundaryEndParent ) {\n\t\t\t\t\tcharactersCount = this.boundaries.end.offset;\n\t\t\t\t\titem = new TextProxy( node, 0, charactersCount );\n\t\t\t\t\tposition = Position._createAfter( item );\n\t\t\t\t} else {\n\t\t\t\t\titem = new TextProxy( node, 0, node.data.length );\n\t\t\t\t\t// If not just keep moving forward.\n\t\t\t\t\tposition.offset++;\n\t\t\t\t}\n\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t\t}\n\t\t} else if ( typeof node == 'string' ) {\n\t\t\tlet textLength;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\ttextLength = 1;\n\t\t\t} else {\n\t\t\t\t// Check if text stick out of walker range.\n\t\t\t\tconst endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;\n\n\t\t\t\ttextLength = endOffset - position.offset;\n\t\t\t}\n\n\t\t\tconst textProxy = new TextProxy( parent, position.offset, textLength );\n\n\t\t\tposition.offset += textLength;\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'text', textProxy, previousPosition, position, textLength );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the end of current `parent`.\n\t\t\tposition = Position._createAfter( parent );\n\t\t\tthis.position = position;\n\n\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\treturn this._formatReturnValue( 'elementEnd', parent, previousPosition, position );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_previous() {\n\t\tlet position = this.position.clone();\n\t\tconst previousPosition = this.position;\n\t\tconst parent = position.parent;\n\n\t\t// We are at the beginning of the root.\n\t\tif ( parent.parent === null && position.offset === 0 ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just before current position.\n\t\tlet node;\n\n\t\t// Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.\n\t\tif ( parent instanceof Text ) {\n\t\t\tif ( position.isAtStart ) {\n\t\t\t\t// Prevent returning \"elementStart\" for Text node. Skip that value and return the next walker step.\n\t\t\t\tthis.position = Position._createBefore( parent );\n\n\t\t\t\treturn this._previous();\n\t\t\t}\n\n\t\t\tnode = parent.data[ position.offset - 1 ];\n\t\t} else {\n\t\t\tnode = parent.getChild( position.offset - 1 );\n\t\t}\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition = new Position( node, node.childCount );\n\t\t\t\tthis.position = position;\n\n\t\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\t\treturn this._previous();\n\t\t\t\t} else {\n\t\t\t\t\treturn this._formatReturnValue( 'elementEnd', node, previousPosition, position );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tposition.offset--;\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t\t}\n\t\t} else if ( node instanceof Text ) {\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tposition = new Position( node, node.data.length );\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._previous();\n\t\t\t} else {\n\t\t\t\tlet charactersCount = node.data.length;\n\t\t\t\tlet item;\n\n\t\t\t\t// If text stick out of walker range, we need to cut it and wrap in TextProxy.\n\t\t\t\tif ( node == this._boundaryStartParent ) {\n\t\t\t\t\tconst offset = this.boundaries.start.offset;\n\n\t\t\t\t\titem = new TextProxy( node, offset, node.data.length - offset );\n\t\t\t\t\tcharactersCount = item.data.length;\n\t\t\t\t\tposition = Position._createBefore( item );\n\t\t\t\t} else {\n\t\t\t\t\titem = new TextProxy( node, 0, node.data.length );\n\t\t\t\t\t// If not just keep moving backward.\n\t\t\t\t\tposition.offset--;\n\t\t\t\t}\n\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn this._formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t\t}\n\t\t} else if ( typeof node == 'string' ) {\n\t\t\tlet textLength;\n\n\t\t\tif ( !this.singleCharacters ) {\n\t\t\t\t// Check if text stick out of walker range.\n\t\t\t\tconst startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;\n\n\t\t\t\ttextLength = position.offset - startOffset;\n\t\t\t} else {\n\t\t\t\ttextLength = 1;\n\t\t\t}\n\n\t\t\tposition.offset -= textLength;\n\n\t\t\tconst textProxy = new TextProxy( parent, position.offset, textLength );\n\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'text', textProxy, previousPosition, position, textLength );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the beginning of current `parent`.\n\t\t\tposition = Position._createBefore( parent );\n\t\t\tthis.position = position;\n\n\t\t\treturn this._formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );\n\t\t}\n\t}\n\n\t/**\n\t * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.\n\t *\n\t * @private\n\t * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.\n\t * @param {module:engine/view/item~Item} item Item between old and new position.\n\t * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.\n\t * @param {module:engine/view/position~Position} nextPosition Next position of iterator.\n\t * @param {Number} [length] Length of the item.\n\t * @returns {module:engine/view/treewalker~TreeWalkerValue}\n\t */\n\t_formatReturnValue( type, item, previousPosition, nextPosition, length ) {\n\t\t// Text is a specific parent, because contains string instead of children.\n\t\t// Walker doesn't enter to the Text except situations when walker is iterating over every single character,\n\t\t// or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text\n\t\t// we move it just before or just after Text.\n\t\tif ( item instanceof TextProxy ) {\n\t\t\t// Position is at the end of Text.\n\t\t\tif ( item.offsetInText + item.data.length == item.textNode.data.length ) {\n\t\t\t\tif ( this.direction == 'forward' && !( this.boundaries && this.boundaries.end.isEqual( this.position ) ) ) {\n\t\t\t\t\tnextPosition = Position._createAfter( item.textNode );\n\t\t\t\t\t// When we change nextPosition of returned value we need also update walker current position.\n\t\t\t\t\tthis.position = nextPosition;\n\t\t\t\t} else {\n\t\t\t\t\tpreviousPosition = Position._createAfter( item.textNode );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Position is at the begining ot the text.\n\t\t\tif ( item.offsetInText === 0 ) {\n\t\t\t\tif ( this.direction == 'backward' && !( this.boundaries && this.boundaries.start.isEqual( this.position ) ) ) {\n\t\t\t\t\tnextPosition = Position._createBefore( item.textNode );\n\t\t\t\t\t// When we change nextPosition of returned value we need also update walker current position.\n\t\t\t\t\tthis.position = nextPosition;\n\t\t\t\t} else {\n\t\t\t\t\tpreviousPosition = Position._createBefore( item.textNode );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdone: false,\n\t\t\tvalue: {\n\t\t\t\ttype,\n\t\t\t\titem,\n\t\t\t\tpreviousPosition,\n\t\t\t\tnextPosition,\n\t\t\t\tlength\n\t\t\t}\n\t\t};\n\t}\n}\n\n/**\n * Type of the step made by {@link module:engine/view/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end\n * of node, or `'text'` if walker traversed over single and multiple characters.\n * For {@link module:engine/view/text~Text} `elementStart` and `elementEnd` is not returned.\n *\n * @typedef {String} module:engine/view/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/view/treewalker~TreeWalker} when traversing tree view.\n *\n * @typedef {Object} module:engine/view/treewalker~TreeWalkerValue\n * @property {module:engine/view/treewalker~TreeWalkerValueType} type\n * @property {module:engine/view/item~Item} item Item between the old and the new positions\n * of the tree walker.\n * @property {module:engine/view/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the text to its parent just before or just after that text.\n * @property {module:engine/view/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the text to its parent just before or just after that text.\n * @property {Number} [length] Length of the item. For `'elementStart'` it is `1`. For `'text'` it is\n * the length of that text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection\n */\n"]}]}