{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheSI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcgogKi8KaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgUmFuZ2UgZnJvbSAnLi9yYW5nZSc7CmltcG9ydCBTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nOwppbXBvcnQgQ29udGFpbmVyRWxlbWVudCBmcm9tICcuL2NvbnRhaW5lcmVsZW1lbnQnOwppbXBvcnQgQXR0cmlidXRlRWxlbWVudCBmcm9tICcuL2F0dHJpYnV0ZWVsZW1lbnQnOwppbXBvcnQgRW1wdHlFbGVtZW50IGZyb20gJy4vZW1wdHllbGVtZW50JzsKaW1wb3J0IFVJRWxlbWVudCBmcm9tICcuL3VpZWxlbWVudCc7CmltcG9ydCBSYXdFbGVtZW50IGZyb20gJy4vcmF3ZWxlbWVudCc7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgRG9jdW1lbnRGcmFnbWVudCBmcm9tICcuL2RvY3VtZW50ZnJhZ21lbnQnOwppbXBvcnQgaXNJdGVyYWJsZSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9pc2l0ZXJhYmxlJzsKaW1wb3J0IFRleHQgZnJvbSAnLi90ZXh0JzsKaW1wb3J0IEVkaXRhYmxlRWxlbWVudCBmcm9tICcuL2VkaXRhYmxlZWxlbWVudCc7CmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnOwovKioKICogVmlldyBkb3duY2FzdCB3cml0ZXIuCiAqCiAqIEl0IHByb3ZpZGVzIGEgc2V0IG9mIG1ldGhvZHMgdXNlZCB0byBtYW5pcHVsYXRlIHZpZXcgbm9kZXMuCiAqCiAqIERvIG5vdCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyB3cml0ZXIgbWFudWFsbHkuIFRvIG1vZGlmeSBhIHZpZXcgc3RydWN0dXJlLCB1c2UKICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlld35WaWV3I2NoYW5nZSBgVmlldyNjaGFuZ2UoKWB9IGJsb2NrLgogKgogKiBUaGUgYERvd25jYXN0V3JpdGVyYCBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGggc2VtYW50aWMgdmlld3Mgd2hpY2ggYXJlIHRoZSB2aWV3cyB0aGF0IHdlcmUvYXJlIGJlaW5nIGRvd25jYXN0ZWQgZnJvbSB0aGUgbW9kZWwuCiAqIFRvIHdvcmsgd2l0aCBvcmRpbmFyeSB2aWV3cyAoZS5nLiBwYXJzZWQgZnJvbSBhIHBhc3RlZCBjb250ZW50KSB1c2UgdGhlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdXBjYXN0d3JpdGVyflVwY2FzdFdyaXRlciB1cGNhc3Qgd3JpdGVyfS4KICoKICogUmVhZCBtb3JlIGFib3V0IGNoYW5naW5nIHRoZSB2aWV3IGluIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI2NoYW5naW5nLXRoZS12aWV3IENoYW5naW5nIHRoZSB2aWV3fQogKiBzZWN0aW9uIG9mIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lIEVkaXRpbmcgZW5naW5lIGFyY2hpdGVjdHVyZX0gZ3VpZGUuCiAqLwoKdmFyIERvd25jYXN0V3JpdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudH0gZG9jdW1lbnQgVGhlIHZpZXcgZG9jdW1lbnQgaW5zdGFuY2UuCiAgICovCiAgZnVuY3Rpb24gRG93bmNhc3RXcml0ZXIoZG9jdW1lbnQpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb3duY2FzdFdyaXRlcik7CgogICAgLyoqCiAgICAgKiBUaGUgdmlldyBkb2N1bWVudCBpbnN0YW5jZSBpbiB3aGljaCB0aGlzIHdyaXRlciBvcGVyYXRlcy4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnR+RG9jdW1lbnR9CiAgICAgKi8KICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDsKICAgIC8qKgogICAgICogSG9sZHMgcmVmZXJlbmNlcyB0byB0aGUgYXR0cmlidXRlIGdyb3VwcyB0aGF0IHNoYXJlIHRoZSBzYW1lIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I2lkIGlkfS4KICAgICAqIFRoZSBrZXlzIGFyZSBgaWRgcywgdGhlIHZhbHVlcyBhcmUgYFNldGBzIGhvbGRpbmcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9cy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge01hcC48U3RyaW5nLFNldD59CiAgICAgKi8KCiAgICB0aGlzLl9jbG9uZUdyb3VwcyA9IG5ldyBNYXAoKTsKICB9CiAgLyoqCiAgICogU2V0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9uIHNlbGVjdGlvbidzfSByYW5nZXMgYW5kIGRpcmVjdGlvbiB0byB0aGUKICAgKiBzcGVjaWZpZWQgbG9jYXRpb24gYmFzZWQgb24gdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGFibGUgc2VsZWN0YWJsZX0uCiAgICoKICAgKiBVc2FnZToKICAgKgogICAqCQkvLyBTZXRzIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4gcmFuZ2UuCiAgICoJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydCwgZW5kICk7CiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHJhbmdlICk7CiAgICoKICAgKgkJLy8gU2V0cyBiYWNrd2FyZCBzZWxlY3Rpb24gdG8gdGhlIGdpdmVuIHJhbmdlLgogICAqCQljb25zdCByYW5nZSA9IHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQsIGVuZCApOwogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCByYW5nZSApOwogICAqCiAgICoJCS8vIFNldHMgc2VsZWN0aW9uIHRvIGdpdmVuIHJhbmdlcy4KICAgKiAJCWNvbnN0IHJhbmdlcyA9IFsgd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydDEsIGVuZDIgKSwgd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydDIsIGVuZDIgKSBdOwogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCByYW5nZSApOwogICAqCiAgICoJCS8vIFNldHMgc2VsZWN0aW9uIHRvIHRoZSBvdGhlciBzZWxlY3Rpb24uCiAgICoJCWNvbnN0IG90aGVyU2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbigpOwogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBvdGhlclNlbGVjdGlvbiApOwogICAqCiAgICogCQkvLyBTZXRzIGNvbGxhcHNlZCBzZWxlY3Rpb24gYXQgdGhlIGdpdmVuIHBvc2l0aW9uLgogICAqCQljb25zdCBwb3NpdGlvbiA9IHdyaXRlci5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBwYXRoICk7CiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHBvc2l0aW9uICk7CiAgICoKICAgKiAJCS8vIFNldHMgY29sbGFwc2VkIHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gb2YgZ2l2ZW4gaXRlbSBhbmQgb2Zmc2V0LgogICAqCQljb25zdCBwYXJhZ3JhcGggPSB3cml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ3AnICk7CiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHBhcmFncmFwaCwgb2Zmc2V0ICk7CiAgICoKICAgKiBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mCiAgCSAqIHRoYXQgZWxlbWVudCBhbmQgZW5kcyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQuCiAgICoKICAgKiAJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHBhcmFncmFwaCwgJ2luJyApOwogICAqCiAgICogQ3JlYXRlcyBhIHJhbmdlIG9uIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSBpdGVtfSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBpdGVtIGFuZCBlbmRzIGp1c3QgYWZ0ZXIgdGhlIGl0ZW0uCiAgICoKICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcGFyYWdyYXBoLCAnb24nICk7CiAgICoKICAgKiAJCS8vIFJlbW92ZXMgYWxsIHJhbmdlcy4KICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggbnVsbCApOwogICAqCiAgICogYERvd25jYXN0V3JpdGVyI3NldFNlbGVjdGlvbigpYCBhbGxvdyBwYXNzaW5nIGFkZGl0aW9uYWwgb3B0aW9ucyAoYGJhY2t3YXJkYCwgYGZha2VgIGFuZCBgbGFiZWxgKSBhcyB0aGUgbGFzdCBhcmd1bWVudC4KICAgKgogICAqCQkvLyBTZXRzIHNlbGVjdGlvbiBhcyBiYWNrd2FyZC4KICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2UsIHsgYmFja3dhcmQ6IHRydWUgfSApOwogICAqCiAgICoJCS8vIFNldHMgc2VsZWN0aW9uIGFzIGZha2UuCiAgICoJCS8vIEZha2Ugc2VsZWN0aW9uIGRvZXMgbm90IHJlbmRlciBhcyBicm93c2VyIG5hdGl2ZSBzZWxlY3Rpb24gb3ZlciBzZWxlY3RlZCBlbGVtZW50cyBhbmQgaXMgaGlkZGVuIHRvIHRoZSB1c2VyLgogICAqIAkJLy8gVGhpcyB3YXksIG5vIG5hdGl2ZSBzZWxlY3Rpb24gVUkgYXJ0aWZhY3RzIGFyZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgYW5kIHNlbGVjdGlvbiBvdmVyIGVsZW1lbnRzIGNhbiBiZQogICAqIAkJLy8gcmVwcmVzZW50ZWQgaW4gb3RoZXIgd2F5LCBmb3IgZXhhbXBsZSBieSBhcHBseWluZyBwcm9wZXIgQ1NTIGNsYXNzLgogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCByYW5nZSwgeyBmYWtlOiB0cnVlIH0gKTsKICAgKgogICAqIAkJLy8gQWRkaXRpb25hbGx5IGZha2UncyBzZWxlY3Rpb24gbGFiZWwgY2FuIGJlIHByb3ZpZGVkLiBJdCB3aWxsIGJlIHVzZWQgdG8gZGVzY3JpYmUgZmFrZSBzZWxlY3Rpb24gaW4gRE9NCiAgICogCQkvLyAoYW5kIGJlICBwcm9wZXJseSBoYW5kbGVkIGJ5IHNjcmVlbiByZWFkZXJzKS4KICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2UsIHsgZmFrZTogdHJ1ZSwgbGFiZWw6ICdmb28nIH0gKTsKICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3NlbGVjdGlvbn5TZWxlY3RhYmxlfSBzZWxlY3RhYmxlCiAgICogQHBhcmFtIHtOdW1iZXJ8J2JlZm9yZSd8J2VuZCd8J2FmdGVyJ3wnb24nfCdpbid9IFtwbGFjZU9yT2Zmc2V0XSBTZXRzIHBsYWNlIG9yIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uLgogICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJhY2t3YXJkXSBTZXRzIHRoaXMgc2VsZWN0aW9uIGluc3RhbmNlIHRvIGJlIGJhY2t3YXJkLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmFrZV0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBtYXJrZWQgYXMgYGZha2VgLgogICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sYWJlbF0gTGFiZWwgZm9yIHRoZSBmYWtlIHNlbGVjdGlvbi4KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhEb3duY2FzdFdyaXRlciwgW3sKICAgIGtleTogInNldFNlbGVjdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQsIG9wdGlvbnMpIHsKICAgICAgdGhpcy5kb2N1bWVudC5zZWxlY3Rpb24uX3NldFRvKHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBNb3ZlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9uI2ZvY3VzIHNlbGVjdGlvbidzIGZvY3VzfSB0byB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uLgogICAgICoKICAgICAqIFRoZSBsb2NhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBzYW1lIGZvcm0gYXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy92aWV3flZpZXcjY3JlYXRlUG9zaXRpb25BdCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoKX0KICAgICAqIHBhcmFtZXRlcnMuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gaXRlbU9yUG9zaXRpb24KICAgICAqIEBwYXJhbSB7TnVtYmVyfCdlbmQnfCdiZWZvcmUnfCdhZnRlcid9IFtvZmZzZXRdIE9mZnNldCBvciBvbmUgb2YgdGhlIGZsYWdzLiBVc2VkIG9ubHkgd2hlbgogICAgICogZmlyc3QgcGFyYW1ldGVyIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gdmlldyBpdGVtfS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRTZWxlY3Rpb25Gb2N1cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uRm9jdXMoaXRlbU9yUG9zaXRpb24sIG9mZnNldCkgewogICAgICB0aGlzLmRvY3VtZW50LnNlbGVjdGlvbi5fc2V0Rm9jdXMoaXRlbU9yUG9zaXRpb24sIG9mZnNldCk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGluc3RhbmNlLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZXxJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZT59IFtjaGlsZHJlbl0KICAgICAqIEEgbGlzdCBvZiBub2RlcyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBjcmVhdGVkIGRvY3VtZW50IGZyYWdtZW50LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IFRoZSBjcmVhdGVkIGRvY3VtZW50IGZyYWdtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pIHsKICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEZyYWdtZW50KHRoaXMuZG9jdW1lbnQsIGNoaWxkcmVuKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGV9LgogICAgICoKICAgICAqCQl3cml0ZXIuY3JlYXRlVGV4dCggJ2ZvbycgKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgdGV4dCdzIGRhdGEuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gVGhlIGNyZWF0ZWQgdGV4dCBub2RlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRleHQoZGF0YSkgewogICAgICByZXR1cm4gbmV3IFRleHQodGhpcy5kb2N1bWVudCwgZGF0YSk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9LgogICAgICoKICAgICAqCQl3cml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCggJ3N0cm9uZycgKTsKICAgICAqCQl3cml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCggJ2EnLCB7IGhyZWY6ICdmb28uYmFyJyB9ICk7CiAgICAgKgogICAgICoJCS8vIE1ha2UgYDxhPmAgZWxlbWVudCBjb250YWluIG90aGVyIGF0dHJpYnV0ZXMgZWxlbWVudCBzbyB0aGUgYDxhPmAgZWxlbWVudCBpcyBub3QgYnJva2VuLgogICAgICoJCXdyaXRlci5jcmVhdGVBdHRyaWJ1dGVFbGVtZW50KCAnYScsIHsgaHJlZjogJ2Zvby5iYXInIH0sIHsgcHJpb3JpdHk6IDUgfSApOwogICAgICoKICAgICAqCQkvLyBTZXQgYGlkYCBvZiBhIG1hcmtlciBlbGVtZW50IHNvIGl0IGlzIG5vdCBqb2luZWQgb3IgbWVyZ2VkIHdpdGggIm5vcm1hbCIgZWxlbWVudHMuCiAgICAgKgkJd3JpdGVyLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoICdzcGFuJywgeyBjbGFzczogJ215LW1hcmtlcicgfSwgeyBpZDogJ21hcmtlcjpteScgfSApOwogICAgICoKICAgICAqICoqTm90ZToqKiBCeSBkZWZhdWx0IGFuIGBBdHRyaWJ1dGVFbGVtZW50YCBpcyBzcGxpdCBieSBhCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBgQ29udGFpbmVyRWxlbWVudGB9IGJ1dCB0aGlzIGJlaGF2aW9yIGNhbiBiZSBtb2RpZmllZAogICAgICogd2l0aCBgaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudGAgb3B0aW9uIHNldCB3aGlsZSB7QGxpbmsgI2NyZWF0ZUNvbnRhaW5lckVsZW1lbnQgY3JlYXRpbmcgdGhlIGVsZW1lbnR9LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnQncyBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBFbGVtZW50J3Mgb3B0aW9ucy4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmlvcml0eV0gRWxlbWVudCdzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I3ByaW9yaXR5IHByaW9yaXR5fS4KICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMuaWRdIEVsZW1lbnQncyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNpZCBpZH0uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcykgewogICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307CiAgICAgIHZhciBhdHRyaWJ1dGVFbGVtZW50ID0gbmV3IEF0dHJpYnV0ZUVsZW1lbnQodGhpcy5kb2N1bWVudCwgbmFtZSwgYXR0cmlidXRlcyk7CgogICAgICBpZiAob3B0aW9ucy5wcmlvcml0eSkgewogICAgICAgIGF0dHJpYnV0ZUVsZW1lbnQuX3ByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eTsKICAgICAgfQoKICAgICAgaWYgKG9wdGlvbnMuaWQpIHsKICAgICAgICBhdHRyaWJ1dGVFbGVtZW50Ll9pZCA9IG9wdGlvbnMuaWQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBhdHRyaWJ1dGVFbGVtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50fS4KICAgICAqCiAgICAgKgkJd3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJyApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGUgZWxlbWVudCB3aXRoIGN1c3RvbSBhdHRyaWJ1dGVzLgogICAgICoJCXdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAnZGl2JywgeyBpZDogJ2Zvby1iYXInLCAnZGF0YS1iYXonOiAnMTIzJyB9ICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZSBlbGVtZW50IHdpdGggY3VzdG9tIHN0eWxlcy4KICAgICAqCQl3cml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ3AnLCB7IHN0eWxlOiAnZm9udC13ZWlnaHQ6IGJvbGQ7IHBhZGRpbmctYm90dG9tOiAxMHB4JyB9ICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZSBlbGVtZW50IHdpdGggY3VzdG9tIGNsYXNzZXMuCiAgICAgKgkJd3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJywgeyBjbGFzczogJ2ZvbyBiYXIgYmF6JyB9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudHMgYXR0cmlidXRlcy4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gRWxlbWVudCdzIG9wdGlvbnMuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzQWxsb3dlZEluc2lkZUF0dHJpYnV0ZUVsZW1lbnQ9ZmFsc2VdIFdoZXRoZXIgYW4gZWxlbWVudCBpcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQjaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudCBhbGxvd2VkIGluc2lkZSBhbiBBdHRyaWJ1dGVFbGVtZW50fSBhbmQgY2FuIGJlIHdyYXBwZWQKICAgICAqIHdpdGgge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXJ9LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR9IENyZWF0ZWQgZWxlbWVudC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVDb250YWluZXJFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9OwogICAgICB2YXIgY29udGFpbmVyRWxlbWVudCA9IG5ldyBDb250YWluZXJFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG5hbWUsIGF0dHJpYnV0ZXMpOwoKICAgICAgaWYgKG9wdGlvbnMuaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgY29udGFpbmVyRWxlbWVudC5faXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudCA9IG9wdGlvbnMuaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudDsKICAgICAgfQoKICAgICAgcmV0dXJuIGNvbnRhaW5lckVsZW1lbnQ7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lZGl0YWJsZWVsZW1lbnR+RWRpdGFibGVFbGVtZW50fS4KICAgICAqCiAgICAgKgkJd3JpdGVyLmNyZWF0ZUVkaXRhYmxlRWxlbWVudCggJ2RpdicgKTsKICAgICAqCQl3cml0ZXIuY3JlYXRlRWRpdGFibGVFbGVtZW50KCAnZGl2JywgeyBpZDogJ2Zvby0xMjM0JyB9ICk7CiAgICAgKgogICAgICogTm90ZTogVGhlIGVkaXRhYmxlIGVsZW1lbnQgaXMgdG8gYmUgdXNlZCBpbiB0aGUgZWRpdGluZyBwaXBlbGluZS4gVXN1YWxseSwgdG9nZXRoZXIgd2l0aAogICAgICoge0BsaW5rIG1vZHVsZTp3aWRnZXQvdXRpbHN+dG9XaWRnZXRFZGl0YWJsZSBgdG9XaWRnZXRFZGl0YWJsZSgpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudHMgYXR0cmlidXRlcy4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWRpdGFibGVlbGVtZW50fkVkaXRhYmxlRWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZUVkaXRhYmxlRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRWRpdGFibGVFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpIHsKICAgICAgdmFyIGVkaXRhYmxlRWxlbWVudCA9IG5ldyBFZGl0YWJsZUVsZW1lbnQodGhpcy5kb2N1bWVudCwgbmFtZSwgYXR0cmlidXRlcyk7CiAgICAgIGVkaXRhYmxlRWxlbWVudC5fZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50OwogICAgICByZXR1cm4gZWRpdGFibGVFbGVtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudH0uCiAgICAgKgogICAgICoJCXdyaXRlci5jcmVhdGVFbXB0eUVsZW1lbnQoICdpbWcnICk7CiAgICAgKgkJd3JpdGVyLmNyZWF0ZUVtcHR5RWxlbWVudCggJ2ltZycsIHsgaWQ6ICdmb28tMTIzNCcgfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnRzIGF0dHJpYnV0ZXMuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEVsZW1lbnQncyBvcHRpb25zLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc0FsbG93ZWRJbnNpZGVBdHRyaWJ1dGVFbGVtZW50PXRydWVdIFdoZXRoZXIgYW4gZWxlbWVudCBpcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQjaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudCBhbGxvd2VkIGluc2lkZSBhbiBBdHRyaWJ1dGVFbGVtZW50fSBhbmQgY2FuIGJlIHdyYXBwZWQKICAgICAqIHdpdGgge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXJ9LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9lbXB0eWVsZW1lbnR+RW1wdHlFbGVtZW50fSBDcmVhdGVkIGVsZW1lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlRW1wdHlFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVFbXB0eUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcykgewogICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307CiAgICAgIHZhciBlbXB0eUVsZW1lbnQgPSBuZXcgRW1wdHlFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG5hbWUsIGF0dHJpYnV0ZXMpOwoKICAgICAgaWYgKG9wdGlvbnMuaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgZW1wdHlFbGVtZW50Ll9pc0FsbG93ZWRJbnNpZGVBdHRyaWJ1dGVFbGVtZW50ID0gb3B0aW9ucy5pc0FsbG93ZWRJbnNpZGVBdHRyaWJ1dGVFbGVtZW50OwogICAgICB9CgogICAgICByZXR1cm4gZW1wdHlFbGVtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0uCiAgICAgKgogICAgICoJCXdyaXRlci5jcmVhdGVVSUVsZW1lbnQoICdzcGFuJyApOwogICAgICoJCXdyaXRlci5jcmVhdGVVSUVsZW1lbnQoICdzcGFuJywgeyBpZDogJ2Zvby0xMjM0JyB9ICk7CiAgICAgKgogICAgICogQSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyOgogICAgICoKICAgICAqCQl3cml0ZXIuY3JlYXRlVUlFbGVtZW50KCAnc3BhbicsIG51bGwsIGZ1bmN0aW9uKCBkb21Eb2N1bWVudCApIHsKICAgICAqCQkJY29uc3QgZG9tRWxlbWVudCA9IHRoaXMudG9Eb21FbGVtZW50KCBkb21Eb2N1bWVudCApOwogICAgICoJCQlkb21FbGVtZW50LmlubmVySFRNTCA9ICc8Yj50aGlzIGlzIHVpIGVsZW1lbnQ8L2I+JzsKICAgICAqCiAgICAgKgkJCXJldHVybiBkb21FbGVtZW50OwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBVbmxpa2Uge0BsaW5rICNjcmVhdGVSYXdFbGVtZW50IHJhdyBlbGVtZW50c30sIFVJIGVsZW1lbnRzIGFyZSBieSBubyBtZWFucyBlZGl0b3IgY29udGVudCwgZm9yIGluc3RhbmNlLAogICAgICogdGhleSBhcmUgaWdub3JlZCBieSB0aGUgZWRpdG9yIHNlbGVjdGlvbiBzeXN0ZW0uCiAgICAgKgogICAgICogWW91IHNob3VsZCBub3QgdXNlIFVJIGVsZW1lbnRzIGFzIGRhdGEgY29udGFpbmVycy4gQ2hlY2sgb3V0IHtAbGluayAjY3JlYXRlUmF3RWxlbWVudH0gaW5zdGVhZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudCBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlbmRlckZ1bmN0aW9uXSBBIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24uCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEVsZW1lbnQncyBvcHRpb25zLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc0FsbG93ZWRJbnNpZGVBdHRyaWJ1dGVFbGVtZW50PXRydWVdIFdoZXRoZXIgYW4gZWxlbWVudCBpcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQjaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudCBhbGxvd2VkIGluc2lkZSBhbiBBdHRyaWJ1dGVFbGVtZW50fSBhbmQgY2FuIGJlIHdyYXBwZWQKICAgICAqIHdpdGgge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXJ9LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fSBUaGUgY3JlYXRlZCBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVVJRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVUlFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHJlbmRlckZ1bmN0aW9uKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTsKICAgICAgdmFyIHVpRWxlbWVudCA9IG5ldyBVSUVsZW1lbnQodGhpcy5kb2N1bWVudCwgbmFtZSwgYXR0cmlidXRlcyk7CgogICAgICBpZiAocmVuZGVyRnVuY3Rpb24pIHsKICAgICAgICB1aUVsZW1lbnQucmVuZGVyID0gcmVuZGVyRnVuY3Rpb247CiAgICAgIH0KCiAgICAgIGlmIChvcHRpb25zLmlzQWxsb3dlZEluc2lkZUF0dHJpYnV0ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkgewogICAgICAgIHVpRWxlbWVudC5faXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudCA9IG9wdGlvbnMuaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudDsKICAgICAgfQoKICAgICAgcmV0dXJuIHVpRWxlbWVudDsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Jhd2VsZW1lbnR+UmF3RWxlbWVudH0uCiAgICAgKgogICAgICoJCXdyaXRlci5jcmVhdGVSYXdFbGVtZW50KCAnc3BhbicsIHsgaWQ6ICdmb28tMTIzNCcgfSwgZnVuY3Rpb24oIGRvbUVsZW1lbnQgKSB7CiAgICAgKgkJCWRvbUVsZW1lbnQuaW5uZXJIVE1MID0gJzxiPlRoaXMgaXMgdGhlIHJhdyBjb250ZW50IG9mIHRoZSByYXcgZWxlbWVudC48L2I+JzsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogUmF3IGVsZW1lbnRzIHdvcmsgYXMgZGF0YSBjb250YWluZXJzICgid3JhcHBlcnMiLCAic2FuZGJveGVzIikgYnV0IHRoZWlyIGNoaWxkcmVuIGFyZSBub3QgbWFuYWdlZCBvcgogICAgICogZXZlbiByZWNvZ25pemVkIGJ5IHRoZSBlZGl0b3IuIFRoaXMgZW5jYXBzdWxhdGlvbiBhbGxvd3MgaW50ZWdyYXRpb25zIHRvIG1haW50YWluIGN1c3RvbSBET00gc3RydWN0dXJlcwogICAgICogaW4gdGhlIGVkaXRvciBjb250ZW50IHdpdGhvdXQsIGZvciBpbnN0YW5jZSwgd29ycnlpbmcgYWJvdXQgY29tcGF0aWJpbGl0eSB3aXRoIG90aGVyIGVkaXRvciBmZWF0dXJlcy4KICAgICAqIFJhdyBlbGVtZW50cyBhcmUgYSBwZXJmZWN0IHRvb2wgZm9yIGludGVncmF0aW9uIHdpdGggZXh0ZXJuYWwgZnJhbWV3b3JrcyBhbmQgZGF0YSBzb3VyY2VzLgogICAgICoKICAgICAqIFVubGlrZSB7QGxpbmsgI2NyZWF0ZVVJRWxlbWVudCBVSSBlbGVtZW50c30sIHJhdyBlbGVtZW50cyBhY3QgbGlrZSAicmVhbCIgZWRpdG9yIGNvbnRlbnQgKHNpbWlsYXIgdG8KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50fSBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnR9KSwKICAgICAqIGFuZCB0aGV5IGFyZSBjb25zaWRlcmVkIGJ5IHRoZSBlZGl0b3Igc2VsZWN0aW9uLgogICAgICoKICAgICAqIFlvdSBzaG91bGQgbm90IHVzZSByYXcgZWxlbWVudHMgdG8gcmVuZGVyIHRoZSBVSSBpbiB0aGUgZWRpdG9yIGNvbnRlbnQuIENoZWNrIG91dCB7QGxpbmsgI2NyZWF0ZVVJRWxlbWVudCBgI2NyZWF0ZVVJRWxlbWVudCgpYH0KICAgICAqIGluc3RlYWQuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnQgYXR0cmlidXRlcy4KICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZW5kZXJGdW5jdGlvbl0gQSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBFbGVtZW50J3Mgb3B0aW9ucy4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudD10cnVlXSBXaGV0aGVyIGFuIGVsZW1lbnQgaXMKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50I2lzQWxsb3dlZEluc2lkZUF0dHJpYnV0ZUVsZW1lbnQgYWxsb3dlZCBpbnNpZGUgYW4gQXR0cmlidXRlRWxlbWVudH0gYW5kIGNhbiBiZSB3cmFwcGVkCiAgICAgKiB3aXRoIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyfS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmF3ZWxlbWVudH5SYXdFbGVtZW50fSBUaGUgY3JlYXRlZCBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVJhd0VsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhd0VsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgcmVuZGVyRnVuY3Rpb24pIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9OwogICAgICB2YXIgcmF3RWxlbWVudCA9IG5ldyBSYXdFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG5hbWUsIGF0dHJpYnV0ZXMpOwoKICAgICAgcmF3RWxlbWVudC5yZW5kZXIgPSByZW5kZXJGdW5jdGlvbiB8fCBmdW5jdGlvbiAoKSB7fTsKCiAgICAgIGlmIChvcHRpb25zLmlzQWxsb3dlZEluc2lkZUF0dHJpYnV0ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkgewogICAgICAgIHJhd0VsZW1lbnQuX2lzQWxsb3dlZEluc2lkZUF0dHJpYnV0ZUVsZW1lbnQgPSBvcHRpb25zLmlzQWxsb3dlZEluc2lkZUF0dHJpYnV0ZUVsZW1lbnQ7CiAgICAgIH0KCiAgICAgIHJldHVybiByYXdFbGVtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBBZGRzIG9yIG92ZXJ3cml0ZXMgdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGUgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIHZhbHVlLgogICAgICoKICAgICAqCQl3cml0ZXIuc2V0QXR0cmlidXRlKCAnaHJlZicsICdodHRwOi8vY2tlZGl0b3IuY29tJywgbGlua0VsZW1lbnQgKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBhdHRyaWJ1dGUga2V5LgogICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRBdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShrZXksIHZhbHVlLCBlbGVtZW50KSB7CiAgICAgIGVsZW1lbnQuX3NldEF0dHJpYnV0ZShrZXksIHZhbHVlKTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhdHRyaWJ1dGUgZnJvbSB0aGUgZWxlbWVudC4KICAgICAqCiAgICAgKgkJd3JpdGVyLnJlbW92ZUF0dHJpYnV0ZSggJ2hyZWYnLCBsaW5rRWxlbWVudCApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgQXR0cmlidXRlIGtleS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAgICovCgogIH0sIHsKICAgIGtleTogInJlbW92ZUF0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGtleSwgZWxlbWVudCkgewogICAgICBlbGVtZW50Ll9yZW1vdmVBdHRyaWJ1dGUoa2V5KTsKICAgIH0KICAgIC8qKgogICAgICogQWRkcyBzcGVjaWZpZWQgY2xhc3MgdG8gdGhlIGVsZW1lbnQuCiAgICAgKgogICAgICoJCXdyaXRlci5hZGRDbGFzcyggJ2ZvbycsIGxpbmtFbGVtZW50ICk7CiAgICAgKgkJd3JpdGVyLmFkZENsYXNzKCBbICdmb28nLCAnYmFyJyBdLCBsaW5rRWxlbWVudCApOwogICAgICoKICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz58U3RyaW5nfSBjbGFzc05hbWUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAgICovCgogIH0sIHsKICAgIGtleTogImFkZENsYXNzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDbGFzcyhjbGFzc05hbWUsIGVsZW1lbnQpIHsKICAgICAgZWxlbWVudC5fYWRkQ2xhc3MoY2xhc3NOYW1lKTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBzcGVjaWZpZWQgY2xhc3MgZnJvbSB0aGUgZWxlbWVudC4KICAgICAqCiAgICAgKgkJd3JpdGVyLnJlbW92ZUNsYXNzKCAnZm9vJywgbGlua0VsZW1lbnQgKTsKICAgICAqCQl3cml0ZXIucmVtb3ZlQ2xhc3MoIFsgJ2ZvbycsICdiYXInIF0sIGxpbmtFbGVtZW50ICk7CiAgICAgKgogICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPnxTdHJpbmd9IGNsYXNzTmFtZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlQ2xhc3MiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSwgZWxlbWVudCkgewogICAgICBlbGVtZW50Ll9yZW1vdmVDbGFzcyhjbGFzc05hbWUpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGRzIHN0eWxlIHRvIHRoZSBlbGVtZW50LgogICAgICoKICAgICAqCQl3cml0ZXIuc2V0U3R5bGUoICdjb2xvcicsICdyZWQnLCBlbGVtZW50ICk7CiAgICAgKgkJd3JpdGVyLnNldFN0eWxlKCB7CiAgICAgKgkJCWNvbG9yOiAncmVkJywKICAgICAqCQkJcG9zaXRpb246ICdmaXhlZCcKICAgICAqCQl9LCBlbGVtZW50ICk7CiAgICAgKgogICAgICogKipOb3RlKio6IFRoZSBwYXNzZWQgc3R5bGUgY2FuIGJlIG5vcm1hbGl6ZWQgaWYKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnRyb2xsZXIvZGF0YWNvbnRyb2xsZXJ+RGF0YUNvbnRyb2xsZXIjYWRkU3R5bGVQcm9jZXNzb3JSdWxlcyBhIHBhcnRpY3VsYXIgc3R5bGUgcHJvY2Vzc29yIHJ1bGUgaXMgZW5hYmxlZH0uCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+U3R5bGVzTWFwI3NldCBgU3R5bGVzTWFwI3NldCgpYH0gZm9yIGRldGFpbHMuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCB3aXRoIGtleSAtIHZhbHVlIHBhaXJzLgogICAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gVmFsdWUgdG8gc2V0LiBUaGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkIGlmIG9iamVjdCBpcyBwcm92aWRlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gc2V0IHN0eWxlcyBvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRTdHlsZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3R5bGUocHJvcGVydHksIHZhbHVlLCBlbGVtZW50KSB7CiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHByb3BlcnR5KSAmJiBlbGVtZW50ID09PSB1bmRlZmluZWQpIHsKICAgICAgICBlbGVtZW50ID0gdmFsdWU7CiAgICAgIH0KCiAgICAgIGVsZW1lbnQuX3NldFN0eWxlKHByb3BlcnR5LCB2YWx1ZSk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgc3BlY2lmaWVkIHN0eWxlIGZyb20gdGhlIGVsZW1lbnQuCiAgICAgKgogICAgICoJCXdyaXRlci5yZW1vdmVTdHlsZSggJ2NvbG9yJywgZWxlbWVudCApOyAvLyBSZW1vdmVzICdjb2xvcicgc3R5bGUuCiAgICAgKgkJd3JpdGVyLnJlbW92ZVN0eWxlKCBbICdjb2xvcicsICdib3JkZXItdG9wJyBdLCBlbGVtZW50ICk7IC8vIFJlbW92ZXMgYm90aCAnY29sb3InIGFuZCAnYm9yZGVyLXRvcCcgc3R5bGVzLgogICAgICoKICAgICAqICoqTm90ZSoqOiBUaGlzIG1ldGhvZCBjYW4gd29yayB3aXRoIG5vcm1hbGl6ZWQgc3R5bGUgbmFtZXMgaWYKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnRyb2xsZXIvZGF0YWNvbnRyb2xsZXJ+RGF0YUNvbnRyb2xsZXIjYWRkU3R5bGVQcm9jZXNzb3JSdWxlcyBhIHBhcnRpY3VsYXIgc3R5bGUgcHJvY2Vzc29yIHJ1bGUgaXMgZW5hYmxlZH0uCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+U3R5bGVzTWFwI3JlbW92ZSBgU3R5bGVzTWFwI3JlbW92ZSgpYH0gZm9yIGRldGFpbHMuCiAgICAgKgogICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPnxTdHJpbmd9IHByb3BlcnR5CiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZW1vdmVTdHlsZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlU3R5bGUocHJvcGVydHksIGVsZW1lbnQpIHsKICAgICAgZWxlbWVudC5fcmVtb3ZlU3R5bGUocHJvcGVydHkpOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGEgY3VzdG9tIHByb3BlcnR5IG9uIGVsZW1lbnQuIFVubGlrZSBhdHRyaWJ1dGVzLCBjdXN0b20gcHJvcGVydGllcyBhcmUgbm90IHJlbmRlcmVkIHRvIHRoZSBET00sCiAgICAgKiBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvIGFkZCBzcGVjaWFsIGRhdGEgdG8gZWxlbWVudHMuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBrZXkKICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAgICovCgogIH0sIHsKICAgIGtleTogInNldEN1c3RvbVByb3BlcnR5IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXN0b21Qcm9wZXJ0eShrZXksIHZhbHVlLCBlbGVtZW50KSB7CiAgICAgIGVsZW1lbnQuX3NldEN1c3RvbVByb3BlcnR5KGtleSwgdmFsdWUpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGEgY3VzdG9tIHByb3BlcnR5IHN0b3JlZCB1bmRlciB0aGUgZ2l2ZW4ga2V5LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0ga2V5CiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgcHJvcGVydHkgd2FzIHJlbW92ZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlQ3VzdG9tUHJvcGVydHkiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BlcnR5KGtleSwgZWxlbWVudCkgewogICAgICByZXR1cm4gZWxlbWVudC5fcmVtb3ZlQ3VzdG9tUHJvcGVydHkoa2V5KTsKICAgIH0KICAgIC8qKgogICAgICogQnJlYWtzIGF0dHJpYnV0ZSBlbGVtZW50cyBhdCB0aGUgcHJvdmlkZWQgcG9zaXRpb24gb3IgYXQgdGhlIGJvdW5kYXJpZXMgb2YgYSBwcm92aWRlZCByYW5nZS4gSXQgYnJlYWtzIGF0dHJpYnV0ZSBlbGVtZW50cwogICAgICogdXAgdG8gdGhlaXIgZmlyc3QgYW5jZXN0b3IgdGhhdCBpcyBhIGNvbnRhaW5lciBlbGVtZW50LgogICAgICoKICAgICAqIEluIGZvbGxvd2luZyBleGFtcGxlcyBgPHA+YCBpcyBhIGNvbnRhaW5lciwgYDxiPmAgYW5kIGA8dT5gIGFyZSBhdHRyaWJ1dGUgZWxlbWVudHM6CiAgICAgKgogICAgICoJCTxwPmZvbzxiPjx1PmJhcnt9PC91PjwvYj48L3A+IC0+IDxwPmZvbzxiPjx1PmJhcjwvdT48L2I+W108L3A+CiAgICAgKgkJPHA+Zm9vPGI+PHU+e31iYXI8L3U+PC9iPjwvcD4gLT4gPHA+Zm9ve308Yj48dT5iYXI8L3U+PC9iPjwvcD4KICAgICAqCQk8cD5mb288Yj48dT5ie31hcjwvdT48L2I+PC9wPiAtPiA8cD5mb288Yj48dT5iPC91PjwvYj5bXTxiPjx1PmFyPC91PjwvYj48L3A+CiAgICAgKgkJPHA+PGI+Zm97bzwvYj48dT5iYX1yPC91PjwvcD4gLT4gPHA+PGI+Zm88L2I+PGI+bzwvYj48dT5iYTwvdT48dT5yPC91PjwvYj48L3A+CiAgICAgKgogICAgICogKipOb3RlOioqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IERvY3VtZW50RnJhZ21lbnR9IGlzIHRyZWF0ZWQgbGlrZSBhIGNvbnRhaW5lci4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQXR0cmlidXRlcyBicmVha0F0dHJpYnV0ZXMoKX0gYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQ29udGFpbmVyIGJyZWFrQ29udGFpbmVyKCl9IGlzIHRoYXQgYGJyZWFrQXR0cmlidXRlcygpYCBicmVha3MgYWxsCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudHN9IHRoYXQgYXJlIGFuY2VzdG9ycyBvZiBhIGdpdmVuIGBwb3NpdGlvbmAsCiAgICAgKiB1cCB0byB0aGUgZmlyc3QgZW5jb3VudGVyZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgY29udGFpbmVyIGVsZW1lbnR9LgogICAgICogYGJyZWFrQ29udGFpbmVyKClgIGFzc3VtZXMgdGhhdCBhIGdpdmVuIGBwb3NpdGlvbmAgaXMgZGlyZWN0bHkgaW4gdGhlIGNvbnRhaW5lciBlbGVtZW50IGFuZCBicmVha3MgdGhhdCBjb250YWluZXIgZWxlbWVudC4KICAgICAqCiAgICAgKiBUaHJvd3MgdGhlIGB2aWV3LXdyaXRlci1pbnZhbGlkLXJhbmdlLWNvbnRhaW5lcmAge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0KICAgICAqIHdoZW4gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9CiAgICAgKiBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbnMgb2YgYSBwYXNzZWQgcmFuZ2UgYXJlIG5vdCBwbGFjZWQgaW5zaWRlIHNhbWUgcGFyZW50IGNvbnRhaW5lci4KICAgICAqCiAgICAgKiBUaHJvd3MgdGhlIGB2aWV3LXdyaXRlci1jYW5ub3QtYnJlYWstZW1wdHktZWxlbWVudGAge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0KICAgICAqIHdoZW4gdHJ5aW5nIHRvIGJyZWFrIGF0dHJpYnV0ZXMgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudCBFbXB0eUVsZW1lbnR9LgogICAgICoKICAgICAqIFRocm93cyB0aGUgYHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay11aS1lbGVtZW50YCB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfQogICAgICogd2hlbiB0cnlpbmcgdG8gYnJlYWsgYXR0cmlidXRlcyBpbnNpZGUgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgVUlFbGVtZW50fS4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudAogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjYnJlYWtDb250YWluZXIKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gcG9zaXRpb25PclJhbmdlIFRoZSBwb3NpdGlvbiB3aGVyZQogICAgICogdG8gYnJlYWsgYXR0cmlidXRlIGVsZW1lbnRzLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbnxtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IFRoZSBuZXcgcG9zaXRpb24gb3IgcmFuZ2UsIGFmdGVyIGJyZWFraW5nIHRoZQogICAgICogYXR0cmlidXRlIGVsZW1lbnRzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImJyZWFrQXR0cmlidXRlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYnJlYWtBdHRyaWJ1dGVzKHBvc2l0aW9uT3JSYW5nZSkgewogICAgICBpZiAocG9zaXRpb25PclJhbmdlIGluc3RhbmNlb2YgUG9zaXRpb24pIHsKICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKHBvc2l0aW9uT3JSYW5nZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2JyZWFrQXR0cmlidXRlc1JhbmdlKHBvc2l0aW9uT3JSYW5nZSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQnJlYWtzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgY29udGFpbmVyIHZpZXcgZWxlbWVudH0gaW50byB0d28sIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4KICAgICAqIFRoZSBwb3NpdGlvbiBoYXMgdG8gYmUgZGlyZWN0bHkgaW5zaWRlIHRoZSBjb250YWluZXIgZWxlbWVudCBhbmQgY2Fubm90IGJlIGluIHRoZSByb290LiBJdCBkb2VzIG5vdCBicmVhayB0aGUgY29ucmFpbmVyIHZpZXcgZWxlbWVudAogICAgICogaWYgdGhlIHBvc2l0aW9uIGlzIGF0IHRoZSBiZWdpbm5pbmcgb3IgYXQgdGhlIGVuZCBvZiBpdHMgcGFyZW50IGVsZW1lbnQuCiAgICAgKgogICAgICoJCTxwPmZvb15iYXI8L3A+IC0+IDxwPmZvbzwvcD48cD5iYXI8L3A+CiAgICAgKgkJPGRpdj48cD5mb288L3A+XjxwPmJhcjwvcD48L2Rpdj4gLT4gPGRpdj48cD5mb288L3A+PC9kaXY+PGRpdj48cD5iYXI8L3A+PC9kaXY+CiAgICAgKgkJPHA+XmZvb2JhcjwvcD4gLT4gXjxwPmZvb2JhcjwvcD4KICAgICAqCQk8cD5mb29iYXJePC9wPiAtPiA8cD5mb29iYXI8L3A+XgogICAgICoKICAgICAqICoqTm90ZToqKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjYnJlYWtBdHRyaWJ1dGVzIGJyZWFrQXR0cmlidXRlcygpfSBhbmQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjYnJlYWtDb250YWluZXIgYnJlYWtDb250YWluZXIoKX0gaXMgdGhhdCBgYnJlYWtBdHRyaWJ1dGVzKClgIGJyZWFrcyBhbGwKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50c30gdGhhdCBhcmUgYW5jZXN0b3JzIG9mIGEgZ2l2ZW4gYHBvc2l0aW9uYCwKICAgICAqIHVwIHRvIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudH0uCiAgICAgKiBgYnJlYWtDb250YWluZXIoKWAgYXNzdW1lcyB0aGF0IHRoZSBnaXZlbiBgcG9zaXRpb25gIGlzIGRpcmVjdGx5IGluIHRoZSBjb250YWluZXIgZWxlbWVudCBhbmQgYnJlYWtzIHRoYXQgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50CiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQXR0cmlidXRlcwogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB3aGVyZSB0byBicmVhayB0aGUgZWxlbWVudC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IFRoZSBwb3NpdGlvbiBiZXR3ZWVuIGJyb2tlbiBlbGVtZW50cy4gSWYgYW4gZWxlbWVudCBoYXMgbm90IGJlZW4gYnJva2VuLAogICAgICogdGhlIHJldHVybmVkIHBvc2l0aW9uIGlzIHBsYWNlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIGl0LgogICAgICovCgogIH0sIHsKICAgIGtleTogImJyZWFrQ29udGFpbmVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBicmVha0NvbnRhaW5lcihwb3NpdGlvbikgewogICAgICB2YXIgZWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgICAgIGlmICghZWxlbWVudC5pcygnY29udGFpbmVyRWxlbWVudCcpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogVHJ5aW5nIHRvIGJyZWFrIGFuIGVsZW1lbnQgd2hpY2ggaXMgbm90IGEgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItYnJlYWstbm9uLWNvbnRhaW5lci1lbGVtZW50CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLWJyZWFrLW5vbi1jb250YWluZXItZWxlbWVudCcsIHRoaXMuZG9jdW1lbnQpOwogICAgICB9CgogICAgICBpZiAoIWVsZW1lbnQucGFyZW50KSB7CiAgICAgICAgLyoqCiAgICAgICAgICogVHJ5aW5nIHRvIGJyZWFrIHJvb3QgZWxlbWVudC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB2aWV3LXdyaXRlci1icmVhay1yb290CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLWJyZWFrLXJvb3QnLCB0aGlzLmRvY3VtZW50KTsKICAgICAgfQoKICAgICAgaWYgKHBvc2l0aW9uLmlzQXRTdGFydCkgewogICAgICAgIHJldHVybiBQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGVsZW1lbnQpOwogICAgICB9IGVsc2UgaWYgKCFwb3NpdGlvbi5pc0F0RW5kKSB7CiAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBlbGVtZW50Ll9jbG9uZShmYWxzZSk7CgogICAgICAgIHRoaXMuaW5zZXJ0KFBvc2l0aW9uLl9jcmVhdGVBZnRlcihlbGVtZW50KSwgbmV3RWxlbWVudCk7CiAgICAgICAgdmFyIHNvdXJjZVJhbmdlID0gbmV3IFJhbmdlKHBvc2l0aW9uLCBQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudCwgJ2VuZCcpKTsKICAgICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBuZXcgUG9zaXRpb24obmV3RWxlbWVudCwgMCk7CiAgICAgICAgdGhpcy5tb3ZlKHNvdXJjZVJhbmdlLCB0YXJnZXRQb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHJldHVybiBQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIoZWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIE1lcmdlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudHN9LiBJdCBhbHNvIG1lcmdlcyB0ZXh0IG5vZGVzIGlmIG5lZWRlZC4KICAgICAqIE9ubHkge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjaXNTaW1pbGFyIHNpbWlsYXJ9IGF0dHJpYnV0ZSBlbGVtZW50cyBjYW4gYmUgbWVyZ2VkLgogICAgICoKICAgICAqIEluIGZvbGxvd2luZyBleGFtcGxlcyBgPHA+YCBpcyBhIGNvbnRhaW5lciBhbmQgYDxiPmAgaXMgYW4gYXR0cmlidXRlIGVsZW1lbnQ6CiAgICAgKgogICAgICoJCTxwPmZvb1tdYmFyPC9wPiAtPiA8cD5mb297fWJhcjwvcD4KICAgICAqCQk8cD48Yj5mb288L2I+W108Yj5iYXI8L2I+PC9wPiAtPiA8cD48Yj5mb297fWJhcjwvYj48L3A+CiAgICAgKgkJPHA+PGIgZm9vPSJiYXIiPmE8L2I+W108YiBmb289ImJheiI+YjwvYj48L3A+IC0+IDxwPjxiIGZvbz0iYmFyIj5hPC9iPltdPGIgZm9vPSJiYXoiPmI8L2I+PC9wPgogICAgICoKICAgICAqIEl0IHdpbGwgYWxzbyB0YWtlIGNhcmUgYWJvdXQgZW1wdHkgYXR0cmlidXRlcyB3aGVuIG1lcmdpbmc6CiAgICAgKgogICAgICoJCTxwPjxiPltdPC9iPjwvcD4gLT4gPHA+W108L3A+CiAgICAgKgkJPHA+PGI+Zm9vPC9iPjxpPltdPC9pPjxiPmJhcjwvYj48L3A+IC0+IDxwPjxiPmZvb3t9YmFyPC9iPjwvcD4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogRGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjbWVyZ2VBdHRyaWJ1dGVzIG1lcmdlQXR0cmlidXRlc30gYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI21lcmdlQ29udGFpbmVycyBtZXJnZUNvbnRhaW5lcnN9IGlzIHRoYXQgYG1lcmdlQXR0cmlidXRlc2AgbWVyZ2VzIHR3bwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnRzfSBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGVzfQogICAgICogd2hpbGUgYG1lcmdlQ29udGFpbmVyYCBtZXJnZXMgdHdvIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IGNvbnRhaW5lciBlbGVtZW50c30uCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50CiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI21lcmdlQ29udGFpbmVycwogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIE1lcmdlIHBvc2l0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gYWZ0ZXIgbWVyZ2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibWVyZ2VBdHRyaWJ1dGVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZXMocG9zaXRpb24pIHsKICAgICAgdmFyIHBvc2l0aW9uT2Zmc2V0ID0gcG9zaXRpb24ub2Zmc2V0OwogICAgICB2YXIgcG9zaXRpb25QYXJlbnQgPSBwb3NpdGlvbi5wYXJlbnQ7IC8vIFdoZW4gaW5zaWRlIHRleHQgbm9kZSAtIG5vdGhpbmcgdG8gbWVyZ2UuCgogICAgICBpZiAocG9zaXRpb25QYXJlbnQuaXMoJyR0ZXh0JykpIHsKICAgICAgICByZXR1cm4gcG9zaXRpb247CiAgICAgIH0gLy8gV2hlbiBpbnNpZGUgZW1wdHkgYXR0cmlidXRlIC0gcmVtb3ZlIGl0LgoKCiAgICAgIGlmIChwb3NpdGlvblBhcmVudC5pcygnYXR0cmlidXRlRWxlbWVudCcpICYmIHBvc2l0aW9uUGFyZW50LmNoaWxkQ291bnQgPT09IDApIHsKICAgICAgICB2YXIgcGFyZW50ID0gcG9zaXRpb25QYXJlbnQucGFyZW50OwogICAgICAgIHZhciBvZmZzZXQgPSBwb3NpdGlvblBhcmVudC5pbmRleDsKCiAgICAgICAgcG9zaXRpb25QYXJlbnQuX3JlbW92ZSgpOwoKICAgICAgICB0aGlzLl9yZW1vdmVGcm9tQ2xvbmVkRWxlbWVudHNHcm91cChwb3NpdGlvblBhcmVudCk7CgogICAgICAgIHJldHVybiB0aGlzLm1lcmdlQXR0cmlidXRlcyhuZXcgUG9zaXRpb24ocGFyZW50LCBvZmZzZXQpKTsKICAgICAgfQoKICAgICAgdmFyIG5vZGVCZWZvcmUgPSBwb3NpdGlvblBhcmVudC5nZXRDaGlsZChwb3NpdGlvbk9mZnNldCAtIDEpOwogICAgICB2YXIgbm9kZUFmdGVyID0gcG9zaXRpb25QYXJlbnQuZ2V0Q2hpbGQocG9zaXRpb25PZmZzZXQpOyAvLyBQb3NpdGlvbiBzaG91bGQgYmUgcGxhY2VkIGJldHdlZW4gdHdvIG5vZGVzLgoKICAgICAgaWYgKCFub2RlQmVmb3JlIHx8ICFub2RlQWZ0ZXIpIHsKICAgICAgICByZXR1cm4gcG9zaXRpb247CiAgICAgIH0gLy8gV2hlbiBwb3NpdGlvbiBpcyBiZXR3ZWVuIHR3byB0ZXh0IG5vZGVzLgoKCiAgICAgIGlmIChub2RlQmVmb3JlLmlzKCckdGV4dCcpICYmIG5vZGVBZnRlci5pcygnJHRleHQnKSkgewogICAgICAgIHJldHVybiBtZXJnZVRleHROb2Rlcyhub2RlQmVmb3JlLCBub2RlQWZ0ZXIpOwogICAgICB9IC8vIFdoZW4gcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gc2FtZSBhdHRyaWJ1dGUgZWxlbWVudHMuCiAgICAgIGVsc2UgaWYgKG5vZGVCZWZvcmUuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSAmJiBub2RlQWZ0ZXIuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSAmJiBub2RlQmVmb3JlLmlzU2ltaWxhcihub2RlQWZ0ZXIpKSB7CiAgICAgICAgICAvLyBNb3ZlIGFsbCBjaGlsZHJlbiBub2RlcyBmcm9tIG5vZGUgcGxhY2VkIGFmdGVyIHNlbGVjdGlvbiBhbmQgcmVtb3ZlIHRoYXQgbm9kZS4KICAgICAgICAgIHZhciBjb3VudCA9IG5vZGVCZWZvcmUuY2hpbGRDb3VudDsKCiAgICAgICAgICBub2RlQmVmb3JlLl9hcHBlbmRDaGlsZChub2RlQWZ0ZXIuZ2V0Q2hpbGRyZW4oKSk7CgogICAgICAgICAgbm9kZUFmdGVyLl9yZW1vdmUoKTsKCiAgICAgICAgICB0aGlzLl9yZW1vdmVGcm9tQ2xvbmVkRWxlbWVudHNHcm91cChub2RlQWZ0ZXIpOyAvLyBOZXcgcG9zaXRpb24gaXMgbG9jYXRlZCBpbnNpZGUgdGhlIGZpcnN0IG5vZGUsIGJlZm9yZSBuZXcgbm9kZXMuCiAgICAgICAgICAvLyBDYWxsIHRoaXMgbWV0aG9kIHJlY3Vyc2l2ZWx5IHRvIG1lcmdlIGFnYWluIGlmIG5lZWRlZC4KCgogICAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VBdHRyaWJ1dGVzKG5ldyBQb3NpdGlvbihub2RlQmVmb3JlLCBjb3VudCkpOwogICAgICAgIH0KCiAgICAgIHJldHVybiBwb3NpdGlvbjsKICAgIH0KICAgIC8qKgogICAgICogTWVyZ2VzIHR3byB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudHN9IHRoYXQgYXJlIGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKiBQcmVjaXNlbHksIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBwb3NpdGlvbiBpcyByZW1vdmVkIGFuZCBpdCdzIGNvbnRlbnRzIGFyZSBtb3ZlZCB0byBlbGVtZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uCiAgICAgKgogICAgICoJCTxwPmZvbzwvcD5ePHA+YmFyPC9wPiAtPiA8cD5mb29eYmFyPC9wPgogICAgICoJCTxkaXY+Zm9vPC9kaXY+XjxwPmJhcjwvcD4gLT4gPGRpdj5mb29eYmFyPC9kaXY+CiAgICAgKgogICAgICogKipOb3RlOioqIERpZmZlcmVuY2UgYmV0d2VlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI21lcmdlQXR0cmlidXRlcyBtZXJnZUF0dHJpYnV0ZXN9IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNtZXJnZUNvbnRhaW5lcnMgbWVyZ2VDb250YWluZXJzfSBpcyB0aGF0IGBtZXJnZUF0dHJpYnV0ZXNgIG1lcmdlcyB0d28KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50c30gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgdGV4dCBub2Rlc30KICAgICAqIHdoaWxlIGBtZXJnZUNvbnRhaW5lcmAgbWVyZ2VzIHR3byB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudHN9LgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudAogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50CiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNtZXJnZUF0dHJpYnV0ZXMKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBNZXJnZSBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IFBvc2l0aW9uIGFmdGVyIG1lcmdlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIm1lcmdlQ29udGFpbmVycyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2VDb250YWluZXJzKHBvc2l0aW9uKSB7CiAgICAgIHZhciBwcmV2ID0gcG9zaXRpb24ubm9kZUJlZm9yZTsKICAgICAgdmFyIG5leHQgPSBwb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgICBpZiAoIXByZXYgfHwgIW5leHQgfHwgIXByZXYuaXMoJ2NvbnRhaW5lckVsZW1lbnQnKSB8fCAhbmV4dC5pcygnY29udGFpbmVyRWxlbWVudCcpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogRWxlbWVudCBiZWZvcmUgYW5kIGFmdGVyIGdpdmVuIHBvc2l0aW9uIGNhbm5vdCBiZSBtZXJnZWQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItbWVyZ2UtY29udGFpbmVycy1pbnZhbGlkLXBvc2l0aW9uCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLW1lcmdlLWNvbnRhaW5lcnMtaW52YWxpZC1wb3NpdGlvbicsIHRoaXMuZG9jdW1lbnQpOwogICAgICB9CgogICAgICB2YXIgbGFzdENoaWxkID0gcHJldi5nZXRDaGlsZChwcmV2LmNoaWxkQ291bnQgLSAxKTsKICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbGFzdENoaWxkIGluc3RhbmNlb2YgVGV4dCA/IFBvc2l0aW9uLl9jcmVhdGVBdChsYXN0Q2hpbGQsICdlbmQnKSA6IFBvc2l0aW9uLl9jcmVhdGVBdChwcmV2LCAnZW5kJyk7CiAgICAgIHRoaXMubW92ZShSYW5nZS5fY3JlYXRlSW4obmV4dCksIFBvc2l0aW9uLl9jcmVhdGVBdChwcmV2LCAnZW5kJykpOwogICAgICB0aGlzLnJlbW92ZShSYW5nZS5fY3JlYXRlT24obmV4dCkpOwogICAgICByZXR1cm4gbmV3UG9zaXRpb247CiAgICB9CiAgICAvKioKICAgICAqIEluc2VydHMgYSBub2RlIG9yIG5vZGVzIGF0IHNwZWNpZmllZCBwb3NpdGlvbi4gVGFrZXMgY2FyZSBhYm91dCBicmVha2luZyBhdHRyaWJ1dGVzIGJlZm9yZSBpbnNlcnRpb24KICAgICAqIGFuZCBtZXJnaW5nIHRoZW0gYWZ0ZXJ3YXJkcy4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWluc2VydC1pbnZhbGlkLW5vZGVgIHdoZW4gbm9kZXMgdG8gaW5zZXJ0CiAgICAgKiBjb250YWlucyBpbnN0YW5jZXMgdGhhdCBhcmUgbm90IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IFRleHRzfSwKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IEF0dHJpYnV0ZUVsZW1lbnRzfSwKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IENvbnRhaW5lckVsZW1lbnRzfSwKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudCBFbXB0eUVsZW1lbnRzfSwKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmF3ZWxlbWVudH5SYXdFbGVtZW50IFJhd0VsZW1lbnRzfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50IFVJRWxlbWVudHN9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBJbnNlcnRpb24gcG9zaXRpb24uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR8bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudHwKICAgICAqIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnR8CiAgICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvcmF3ZWxlbWVudH5SYXdFbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fAogICAgICogSXRlcmFibGUuPG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR8CiAgICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR8CiAgICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvcmF3ZWxlbWVudH5SYXdFbGVtZW50fAogICAgICogbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQ+fSBub2RlcyBOb2RlIG9yIG5vZGVzIHRvIGluc2VydC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IFJhbmdlIGFyb3VuZCBpbnNlcnRlZCBub2Rlcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpbnNlcnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbm9kZXMpIHsKICAgICAgbm9kZXMgPSBpc0l0ZXJhYmxlKG5vZGVzKSA/IF90b0NvbnN1bWFibGVBcnJheShub2RlcykgOiBbbm9kZXNdOyAvLyBDaGVjayBpZiBub2RlcyB0byBpbnNlcnQgYXJlIGluc3RhbmNlcyBvZiBBdHRyaWJ1dGVFbGVtZW50cywgQ29udGFpbmVyRWxlbWVudHMsIEVtcHR5RWxlbWVudHMsIFVJRWxlbWVudHMgb3IgVGV4dC4KCiAgICAgIHZhbGlkYXRlTm9kZXNUb0luc2VydChub2RlcywgdGhpcy5kb2N1bWVudCk7IC8vIEdyb3VwIG5vZGVzIGluIGJhdGNoZXMgb2Ygbm9kZXMgdGhhdCByZXF1aXJlIG9yIGRvIG5vdCByZXF1aXJlIGJyZWFraW5nIGFuIEF0dHJpYnV0ZUVsZW1lbnRzLgoKICAgICAgdmFyIG5vZGVHcm91cHMgPSBub2Rlcy5yZWR1Y2UoZnVuY3Rpb24gKGdyb3Vwcywgbm9kZSkgewogICAgICAgIHZhciBsYXN0R3JvdXAgPSBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdOyAvLyBCcmVhayBhdHRyaWJ1dGVzIG9uIG5vZGVzIHRoYXQgZG8gZXhpc3QgaW4gdGhlIG1vZGVsIHRyZWUgc28gdGhleSBjYW4gaGF2ZSBhdHRyaWJ1dGVzLCBvdGhlciBlbGVtZW50cwogICAgICAgIC8vIGNhbid0IGhhdmUgYW4gYXR0cmlidXRlIGluIG1vZGVsIGFuZCB3b24ndCBnZXQgd3JhcHBlZCB3aXRoIGFuIEF0dHJpYnV0ZUVsZW1lbnQgd2hpbGUgZG93bi1jYXN0ZWQuCgogICAgICAgIHZhciBicmVha0F0dHJpYnV0ZXMgPSAhKG5vZGUuaXMoJ3VpRWxlbWVudCcpICYmIG5vZGUuaXNBbGxvd2VkSW5zaWRlQXR0cmlidXRlRWxlbWVudCk7CgogICAgICAgIGlmICghbGFzdEdyb3VwIHx8IGxhc3RHcm91cC5icmVha0F0dHJpYnV0ZXMgIT0gYnJlYWtBdHRyaWJ1dGVzKSB7CiAgICAgICAgICBncm91cHMucHVzaCh7CiAgICAgICAgICAgIGJyZWFrQXR0cmlidXRlczogYnJlYWtBdHRyaWJ1dGVzLAogICAgICAgICAgICBub2RlczogW25vZGVdCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGFzdEdyb3VwLm5vZGVzLnB1c2gobm9kZSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gZ3JvdXBzOwogICAgICB9LCBbXSk7IC8vIEluc2VydCBub2RlcyBpbiBiYXRjaGVzLgoKICAgICAgdmFyIHN0YXJ0ID0gbnVsbDsKICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uOwoKICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5vZGVHcm91cHMpLAogICAgICAgICAgX3N0ZXA7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSwKICAgICAgICAgICAgICBfbm9kZXMgPSBfc3RlcCR2YWx1ZS5ub2RlcywKICAgICAgICAgICAgICBicmVha0F0dHJpYnV0ZXMgPSBfc3RlcCR2YWx1ZS5icmVha0F0dHJpYnV0ZXM7CgogICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5faW5zZXJ0Tm9kZXMoZW5kLCBfbm9kZXMsIGJyZWFrQXR0cmlidXRlcyk7CgogICAgICAgICAgaWYgKCFzdGFydCkgewogICAgICAgICAgICBzdGFydCA9IHJhbmdlLnN0YXJ0OwogICAgICAgICAgfQoKICAgICAgICAgIGVuZCA9IHJhbmdlLmVuZDsKICAgICAgICB9IC8vIFdoZW4gbm8gbm9kZXMgd2VyZSBpbnNlcnRlZCAtIHJldHVybiBjb2xsYXBzZWQgcmFuZ2UuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvci5mKCk7CiAgICAgIH0KCiAgICAgIGlmICghc3RhcnQpIHsKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBwcm92aWRlZCByYW5nZSBmcm9tIHRoZSBjb250YWluZXIuCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1pbnZhbGlkLXJhbmdlLWNvbnRhaW5lcmAgd2hlbgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydCBzdGFydH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UjZW5kIGVuZH0gcG9zaXRpb25zIGFyZSBub3QgcGxhY2VkIGluc2lkZQogICAgICogc2FtZSBwYXJlbnQgY29udGFpbmVyLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IHJhbmdlT3JJdGVtIFJhbmdlIHRvIHJlbW92ZSBmcm9tIGNvbnRhaW5lcgogICAgICogb3IgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gaXRlbX0gdG8gcmVtb3ZlLiBJZiByYW5nZSBpcyBwcm92aWRlZCwgYWZ0ZXIgcmVtb3ZpbmcsIGl0IHdpbGwgYmUgdXBkYXRlZAogICAgICogdG8gYSBjb2xsYXBzZWQgcmFuZ2Ugc2hvd2luZyB0aGUgbmV3IHBvc2l0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IERvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgcmVtb3ZlZCBub2Rlcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZW1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShyYW5nZU9ySXRlbSkgewogICAgICB2YXIgcmFuZ2UgPSByYW5nZU9ySXRlbSBpbnN0YW5jZW9mIFJhbmdlID8gcmFuZ2VPckl0ZW0gOiBSYW5nZS5fY3JlYXRlT24ocmFuZ2VPckl0ZW0pOwogICAgICB2YWxpZGF0ZVJhbmdlQ29udGFpbmVyKHJhbmdlLCB0aGlzLmRvY3VtZW50KTsgLy8gSWYgcmFuZ2UgaXMgY29sbGFwc2VkIC0gbm90aGluZyB0byByZW1vdmUuCgogICAgICBpZiAocmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQodGhpcy5kb2N1bWVudCk7CiAgICAgIH0gLy8gQnJlYWsgYXR0cmlidXRlcyBhdCByYW5nZSBzdGFydCBhbmQgZW5kLgoKCiAgICAgIHZhciBfdGhpcyRfYnJlYWtBdHRyaWJ1dGUgPSB0aGlzLl9icmVha0F0dHJpYnV0ZXNSYW5nZShyYW5nZSwgdHJ1ZSksCiAgICAgICAgICBicmVha1N0YXJ0ID0gX3RoaXMkX2JyZWFrQXR0cmlidXRlLnN0YXJ0LAogICAgICAgICAgYnJlYWtFbmQgPSBfdGhpcyRfYnJlYWtBdHRyaWJ1dGUuZW5kOwoKICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IGJyZWFrU3RhcnQucGFyZW50OwogICAgICB2YXIgY291bnQgPSBicmVha0VuZC5vZmZzZXQgLSBicmVha1N0YXJ0Lm9mZnNldDsgLy8gUmVtb3ZlIG5vZGVzIGluIHJhbmdlLgoKICAgICAgdmFyIHJlbW92ZWQgPSBwYXJlbnRDb250YWluZXIuX3JlbW92ZUNoaWxkcmVuKGJyZWFrU3RhcnQub2Zmc2V0LCBjb3VudCk7CgogICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJlbW92ZWQpLAogICAgICAgICAgX3N0ZXAyOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykgewogICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDIudmFsdWU7CgogICAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbUNsb25lZEVsZW1lbnRzR3JvdXAobm9kZSk7CiAgICAgICAgfSAvLyBNZXJnZSBhZnRlciByZW1vdmluZy4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjIuZigpOwogICAgICB9CgogICAgICB2YXIgbWVyZ2VQb3NpdGlvbiA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKGJyZWFrU3RhcnQpOwogICAgICByYW5nZS5zdGFydCA9IG1lcmdlUG9zaXRpb247CiAgICAgIHJhbmdlLmVuZCA9IG1lcmdlUG9zaXRpb24uY2xvbmUoKTsgLy8gUmV0dXJuIHJlbW92ZWQgbm9kZXMuCgogICAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQodGhpcy5kb2N1bWVudCwgcmVtb3ZlZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgbWF0Y2hpbmcgZWxlbWVudHMgZnJvbSBnaXZlbiByYW5nZS4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYCB3aGVuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI3N0YXJ0IHN0YXJ0fSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbnMgYXJlIG5vdCBwbGFjZWQgaW5zaWRlCiAgICAgKiBzYW1lIHBhcmVudCBjb250YWluZXIuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIHRvIGNsZWFyLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcmVtb3ZlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNsZWFyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcihyYW5nZSwgZWxlbWVudCkgewogICAgICB2YWxpZGF0ZVJhbmdlQ29udGFpbmVyKHJhbmdlLCB0aGlzLmRvY3VtZW50KTsgLy8gQ3JlYXRlIHdhbGtlciBvbiBnaXZlbiByYW5nZS4KICAgICAgLy8gV2Ugd2FsayBiYWNrd2FyZCBiZWNhdXNlIHdoZW4gd2UgcmVtb3ZlIGVsZW1lbnQgZHVyaW5nIHdhbGsgaXQgbW9kaWZpZXMgcmFuZ2UgZW5kIHBvc2l0aW9uLgoKICAgICAgdmFyIHdhbGtlciA9IHJhbmdlLmdldFdhbGtlcih7CiAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnLAogICAgICAgIGlnbm9yZUVsZW1lbnRFbmQ6IHRydWUKICAgICAgfSk7IC8vIExldCdzIHdhbGsuCgogICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHdhbGtlciksCiAgICAgICAgICBfc3RlcDM7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgY3VycmVudCA9IF9zdGVwMy52YWx1ZTsKICAgICAgICAgIHZhciBpdGVtID0gY3VycmVudC5pdGVtOwogICAgICAgICAgdmFyIHJhbmdlVG9SZW1vdmUgPSB2b2lkIDA7IC8vIFdoZW4gY3VycmVudCBpdGVtIG1hdGNoZXMgdG8gdGhlIGdpdmVuIGVsZW1lbnQuCgogICAgICAgICAgaWYgKGl0ZW0uaXMoJ2VsZW1lbnQnKSAmJiBlbGVtZW50LmlzU2ltaWxhcihpdGVtKSkgewogICAgICAgICAgICAvLyBDcmVhdGUgcmFuZ2Ugb24gdGhpcyBlbGVtZW50LgogICAgICAgICAgICByYW5nZVRvUmVtb3ZlID0gUmFuZ2UuX2NyZWF0ZU9uKGl0ZW0pOyAvLyBXaGVuIHJhbmdlIHN0YXJ0cyBpbnNpZGUgVGV4dCBvciBUZXh0UHJveHkgZWxlbWVudC4KICAgICAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnQubmV4dFBvc2l0aW9uLmlzQWZ0ZXIocmFuZ2Uuc3RhcnQpICYmIGl0ZW0uaXMoJyR0ZXh0UHJveHknKSkgewogICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHBhcmVudCBvZiB0aGlzIHRleHQgbWF0Y2hlcyB0byBnaXZlbiBlbGVtZW50LgogICAgICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IGl0ZW0uZ2V0QW5jZXN0b3JzKCkuZmluZChmdW5jdGlvbiAoYW5jZXN0b3IpIHsKICAgICAgICAgICAgICByZXR1cm4gYW5jZXN0b3IuaXMoJ2VsZW1lbnQnKSAmJiBlbGVtZW50LmlzU2ltaWxhcihhbmNlc3Rvcik7CiAgICAgICAgICAgIH0pOyAvLyBJZiBpdCBpcyB0aGVuIGNyZWF0ZSByYW5nZSBpbnNpZGUgdGhpcyBlbGVtZW50LgoKICAgICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQpIHsKICAgICAgICAgICAgICByYW5nZVRvUmVtb3ZlID0gUmFuZ2UuX2NyZWF0ZUluKHBhcmVudEVsZW1lbnQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vIElmIHdlIGhhdmUgZm91bmQgZWxlbWVudCB0byByZW1vdmUuCgoKICAgICAgICAgIGlmIChyYW5nZVRvUmVtb3ZlKSB7CiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgZWxlbWVudCByYW5nZSBzdGljayBvdXQgb2YgdGhlIGdpdmVuIHJhbmdlIGFuZCB0cnVuY2F0ZSBpZiBpdCBpcy4KICAgICAgICAgICAgaWYgKHJhbmdlVG9SZW1vdmUuZW5kLmlzQWZ0ZXIocmFuZ2UuZW5kKSkgewogICAgICAgICAgICAgIHJhbmdlVG9SZW1vdmUuZW5kID0gcmFuZ2UuZW5kOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAocmFuZ2VUb1JlbW92ZS5zdGFydC5pc0JlZm9yZShyYW5nZS5zdGFydCkpIHsKICAgICAgICAgICAgICByYW5nZVRvUmVtb3ZlLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7CiAgICAgICAgICAgIH0gLy8gQXQgdGhlIGVuZCB3ZSByZW1vdmUgcmFuZ2Ugd2l0aCBmb3VuZCBlbGVtZW50LgoKCiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHJhbmdlVG9SZW1vdmUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogTW92ZXMgbm9kZXMgZnJvbSBwcm92aWRlZCByYW5nZSB0byB0YXJnZXQgcG9zaXRpb24uCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1pbnZhbGlkLXJhbmdlLWNvbnRhaW5lcmAgd2hlbgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydCBzdGFydH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UjZW5kIGVuZH0gcG9zaXRpb25zIGFyZSBub3QgcGxhY2VkIGluc2lkZQogICAgICogc2FtZSBwYXJlbnQgY29udGFpbmVyLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBzb3VyY2VSYW5nZSBSYW5nZSBjb250YWluaW5nIG5vZGVzIHRvIG1vdmUuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdGFyZ2V0UG9zaXRpb24gUG9zaXRpb24gdG8gaW5zZXJ0LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gUmFuZ2UgaW4gdGFyZ2V0IGNvbnRhaW5lci4gSW5zZXJ0ZWQgbm9kZXMgYXJlIHBsYWNlZCBiZXR3ZWVuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI3N0YXJ0IHN0YXJ0fSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbnMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibW92ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShzb3VyY2VSYW5nZSwgdGFyZ2V0UG9zaXRpb24pIHsKICAgICAgdmFyIG5vZGVzOwoKICAgICAgaWYgKHRhcmdldFBvc2l0aW9uLmlzQWZ0ZXIoc291cmNlUmFuZ2UuZW5kKSkgewogICAgICAgIHRhcmdldFBvc2l0aW9uID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKHRhcmdldFBvc2l0aW9uLCB0cnVlKTsKICAgICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0UG9zaXRpb24ucGFyZW50OwogICAgICAgIHZhciBjb3VudEJlZm9yZSA9IHBhcmVudC5jaGlsZENvdW50OwogICAgICAgIHNvdXJjZVJhbmdlID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzUmFuZ2Uoc291cmNlUmFuZ2UsIHRydWUpOwogICAgICAgIG5vZGVzID0gdGhpcy5yZW1vdmUoc291cmNlUmFuZ2UpOwogICAgICAgIHRhcmdldFBvc2l0aW9uLm9mZnNldCArPSBwYXJlbnQuY2hpbGRDb3VudCAtIGNvdW50QmVmb3JlOwogICAgICB9IGVsc2UgewogICAgICAgIG5vZGVzID0gdGhpcy5yZW1vdmUoc291cmNlUmFuZ2UpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5pbnNlcnQodGFyZ2V0UG9zaXRpb24sIG5vZGVzKTsKICAgIH0KICAgIC8qKgogICAgICogV3JhcHMgZWxlbWVudHMgd2l0aGluIHJhbmdlIHdpdGggcHJvdmlkZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0uCiAgICAgKiBJZiBhIGNvbGxhcHNlZCByYW5nZSBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB3cmFwcGVkIG9ubHkgaWYgaXQgaXMgZXF1YWwgdG8gdmlldyBzZWxlY3Rpb24uCiAgICAgKgogICAgICogSWYgYSBjb2xsYXBzZWQgcmFuZ2Ugd2FzIHBhc3NlZCBhbmQgaXMgc2FtZSBhcyBzZWxlY3Rpb24sIHRoZSBzZWxlY3Rpb24KICAgICAqIHdpbGwgYmUgbW92ZWQgdG8gdGhlIGluc2lkZSBvZiB0aGUgd3JhcHBlZCBhdHRyaWJ1dGUgZWxlbWVudC4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1pbnZhbGlkLXJhbmdlLWNvbnRhaW5lcmAKICAgICAqIHdoZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydH0KICAgICAqIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI2VuZH0gcG9zaXRpb25zIGFyZSBub3QgcGxhY2VkIGluc2lkZSBzYW1lIHBhcmVudCBjb250YWluZXIuCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItd3JhcC1pbnZhbGlkLWF0dHJpYnV0ZWAgd2hlbiBwYXNzZWQgYXR0cmlidXRlIGVsZW1lbnQgaXMgbm90CiAgICAgKiBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fS4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci13cmFwLW5vbnNlbGVjdGlvbi1jb2xsYXBzZWQtcmFuZ2VgIHdoZW4gcGFzc2VkIHJhbmdlCiAgICAgKiBpcyBjb2xsYXBzZWQgYW5kIGRpZmZlcmVudCB0aGFuIHZpZXcgc2VsZWN0aW9uLgogICAgICoKICAgICAqICoqTm90ZToqKiBBdHRyaWJ1dGUgZWxlbWVudHMgYnkgZGVmYXVsdCBjYW4gd3JhcCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnR9LCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR9LAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYXdlbGVtZW50flJhd0VsZW1lbnR9IGFuZCBvdGhlciBhdHRyaWJ1dGUgZWxlbWVudHMgd2l0aCBoaWdoZXIgcHJpb3JpdHkuIE90aGVyIGVsZW1lbnRzIHdoaWxlIHBsYWNlZAogICAgICogaW5zaWRlIGFuIGF0dHJpYnV0ZSBlbGVtZW50IHdpbGwgc3BsaXQgaXQgKG9yIG5lc3QgaXQgaW4gY2FzZSBvZiBhbiBgQXR0cmlidXRlRWxlbWVudGApLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBtb2RpZmllZCBieSBjaGFuZ2luZwogICAgICogdGhlIGBpc0FsbG93ZWRJbnNpZGVBdHRyaWJ1dGVFbGVtZW50YCBvcHRpb24gd2hpbGUgdXNpbmcKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjY3JlYXRlQ29udGFpbmVyRWxlbWVudH0sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2NyZWF0ZUVtcHR5RWxlbWVudH0sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2NyZWF0ZVVJRWxlbWVudH0gb3IKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjY3JlYXRlUmF3RWxlbWVudH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIHRvIHdyYXAuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgZWxlbWVudCB0byB1c2UgYXMgd3JhcHBlci4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIGFmdGVyIHdyYXBwaW5nLCBzcGFubmluZyBvdmVyIHdyYXBwaW5nIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogIndyYXAiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHdyYXAocmFuZ2UsIGF0dHJpYnV0ZSkgewogICAgICBpZiAoIShhdHRyaWJ1dGUgaW5zdGFuY2VvZiBBdHRyaWJ1dGVFbGVtZW50KSkgewogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci13cmFwLWludmFsaWQtYXR0cmlidXRlJywgdGhpcy5kb2N1bWVudCk7CiAgICAgIH0KCiAgICAgIHZhbGlkYXRlUmFuZ2VDb250YWluZXIocmFuZ2UsIHRoaXMuZG9jdW1lbnQpOwoKICAgICAgaWYgKCFyYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICAgIC8vIE5vbi1jb2xsYXBzZWQgcmFuZ2UuIFdyYXAgaXQgd2l0aCB0aGUgYXR0cmlidXRlIGVsZW1lbnQuCiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBSYW5nZShyYW5nZSwgYXR0cmlidXRlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBDb2xsYXBzZWQgcmFuZ2UuIFdyYXAgcG9zaXRpb24uCiAgICAgICAgdmFyIHBvc2l0aW9uID0gcmFuZ2Uuc3RhcnQ7CgogICAgICAgIGlmIChwb3NpdGlvbi5wYXJlbnQuaXMoJ2VsZW1lbnQnKSAmJiAhX2hhc05vblVpQ2hpbGRyZW4ocG9zaXRpb24ucGFyZW50KSkgewogICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlLml0ZW0uaXMoJ3VpRWxlbWVudCcpOwogICAgICAgICAgfSk7CiAgICAgICAgfQoKICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX3dyYXBQb3NpdGlvbihwb3NpdGlvbiwgYXR0cmlidXRlKTsKICAgICAgICB2YXIgdmlld1NlbGVjdGlvbiA9IHRoaXMuZG9jdW1lbnQuc2VsZWN0aW9uOyAvLyBJZiB3cmFwcGluZyBwb3NpdGlvbiBpcyBlcXVhbCB0byB2aWV3IHNlbGVjdGlvbiwgbW92ZSB2aWV3IHNlbGVjdGlvbiBpbnNpZGUgd3JhcHBpbmcgYXR0cmlidXRlIGVsZW1lbnQuCgogICAgICAgIGlmICh2aWV3U2VsZWN0aW9uLmlzQ29sbGFwc2VkICYmIHZpZXdTZWxlY3Rpb24uZ2V0Rmlyc3RQb3NpdGlvbigpLmlzRXF1YWwocmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihwb3NpdGlvbik7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBVbndyYXBzIG5vZGVzIHdpdGhpbiBwcm92aWRlZCByYW5nZSBmcm9tIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICoKICAgICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXJgIHdoZW4KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI2VuZCBlbmR9IHBvc2l0aW9ucyBhcmUgbm90IHBsYWNlZCBpbnNpZGUKICAgICAqIHNhbWUgcGFyZW50IGNvbnRhaW5lci4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gcmFuZ2UKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gYXR0cmlidXRlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidW53cmFwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAocmFuZ2UsIGF0dHJpYnV0ZSkgewogICAgICBpZiAoIShhdHRyaWJ1dGUgaW5zdGFuY2VvZiBBdHRyaWJ1dGVFbGVtZW50KSkgewogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBgYXR0cmlidXRlYCBwYXNzZWQgdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciN1bndyYXAgYERvd25jYXN0V3JpdGVyI3Vud3JhcCgpYH0KICAgICAgICAgKiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGBBdHRyaWJ1dGVFbGVtZW50YH0uCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItdW53cmFwLWludmFsaWQtYXR0cmlidXRlCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLXVud3JhcC1pbnZhbGlkLWF0dHJpYnV0ZScsIHRoaXMuZG9jdW1lbnQpOwogICAgICB9CgogICAgICB2YWxpZGF0ZVJhbmdlQ29udGFpbmVyKHJhbmdlLCB0aGlzLmRvY3VtZW50KTsgLy8gSWYgcmFuZ2UgaXMgY29sbGFwc2VkIC0gbm90aGluZyB0byB1bndyYXAuCgogICAgICBpZiAocmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgICByZXR1cm4gcmFuZ2U7CiAgICAgIH0gLy8gQnJlYWsgYXR0cmlidXRlcyBhdCByYW5nZSBzdGFydCBhbmQgZW5kLgoKCiAgICAgIHZhciBfdGhpcyRfYnJlYWtBdHRyaWJ1dGUyID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UsIHRydWUpLAogICAgICAgICAgYnJlYWtTdGFydCA9IF90aGlzJF9icmVha0F0dHJpYnV0ZTIuc3RhcnQsCiAgICAgICAgICBicmVha0VuZCA9IF90aGlzJF9icmVha0F0dHJpYnV0ZTIuZW5kOwoKICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IGJyZWFrU3RhcnQucGFyZW50OyAvLyBVbndyYXAgY2hpbGRyZW4gbG9jYXRlZCBiZXR3ZWVuIGJyZWFrIHBvaW50cy4KCiAgICAgIHZhciBuZXdSYW5nZSA9IHRoaXMuX3Vud3JhcENoaWxkcmVuKHBhcmVudENvbnRhaW5lciwgYnJlYWtTdGFydC5vZmZzZXQsIGJyZWFrRW5kLm9mZnNldCwgYXR0cmlidXRlKTsgLy8gTWVyZ2UgYXR0cmlidXRlcyBhdCB0aGUgYm90aCBlbmRzIGFuZCByZXR1cm4gYSBuZXcgcmFuZ2UuCgoKICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5tZXJnZUF0dHJpYnV0ZXMobmV3UmFuZ2Uuc3RhcnQpOyAvLyBJZiBzdGFydCBwb3NpdGlvbiB3YXMgbWVyZ2VkIC0gbW92ZSBlbmQgcG9zaXRpb24gYmFjay4KCiAgICAgIGlmICghc3RhcnQuaXNFcXVhbChuZXdSYW5nZS5zdGFydCkpIHsKICAgICAgICBuZXdSYW5nZS5lbmQub2Zmc2V0LS07CiAgICAgIH0KCiAgICAgIHZhciBlbmQgPSB0aGlzLm1lcmdlQXR0cmlidXRlcyhuZXdSYW5nZS5lbmQpOwogICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW5hbWVzIGVsZW1lbnQgYnkgY3JlYXRpbmcgYSBjb3B5IG9mIHJlbmFtZWQgZWxlbWVudCBidXQgd2l0aCBjaGFuZ2VkIG5hbWUgYW5kIHRoZW4gbW92aW5nIGNvbnRlbnRzIG9mIHRoZQogICAgICogb2xkIGVsZW1lbnQgdG8gdGhlIG5ldyBvbmUuIEtlZXAgaW4gbWluZCB0aGF0IHRoaXMgd2lsbCBpbnZhbGlkYXRlIGFsbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30gd2hpY2gKICAgICAqIGhhcyByZW5hbWVkIGVsZW1lbnQgYXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgYSBwYXJlbnR9LgogICAgICoKICAgICAqIE5ldyBlbGVtZW50IGhhcyB0byBiZSBjcmVhdGVkIGJlY2F1c2UgYEVsZW1lbnQjdGFnTmFtZWAgcHJvcGVydHkgaW4gRE9NIGlzIHJlYWRvbmx5LgogICAgICoKICAgICAqIFNpbmNlIHRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBlbGVtZW50IGFuZCByZW1vdmVzIHRoZSBnaXZlbiBvbmUsIHRoZSBuZXcgZWxlbWVudCBpcyByZXR1cm5lZCB0byBrZWVwIHJlZmVyZW5jZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3TmFtZSBOZXcgbmFtZSBmb3IgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudH0gdmlld0VsZW1lbnQgRWxlbWVudCB0byBiZSByZW5hbWVkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR9IEVsZW1lbnQgY3JlYXRlZCBkdWUgdG8gcmVuYW1lLgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlbmFtZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuYW1lKG5ld05hbWUsIHZpZXdFbGVtZW50KSB7CiAgICAgIHZhciBuZXdFbGVtZW50ID0gbmV3IENvbnRhaW5lckVsZW1lbnQodGhpcy5kb2N1bWVudCwgbmV3TmFtZSwgdmlld0VsZW1lbnQuZ2V0QXR0cmlidXRlcygpKTsKICAgICAgdGhpcy5pbnNlcnQoUG9zaXRpb24uX2NyZWF0ZUFmdGVyKHZpZXdFbGVtZW50KSwgbmV3RWxlbWVudCk7CiAgICAgIHRoaXMubW92ZShSYW5nZS5fY3JlYXRlSW4odmlld0VsZW1lbnQpLCBQb3NpdGlvbi5fY3JlYXRlQXQobmV3RWxlbWVudCwgMCkpOwogICAgICB0aGlzLnJlbW92ZShSYW5nZS5fY3JlYXRlT24odmlld0VsZW1lbnQpKTsKICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7CiAgICB9CiAgICAvKioKICAgICAqIENsZWFucyB1cCBtZW1vcnkgYnkgcmVtb3Zpbmcgb2Jzb2xldGUgY2xvbmVkIGVsZW1lbnRzIGdyb3VwIGZyb20gdGhlIHdyaXRlci4KICAgICAqCiAgICAgKiBTaG91bGQgYmUgdXNlZCB3aGVuZXZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnRzfQogICAgICogd2l0aCB0aGUgc2FtZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNpZCBpZH0gYXJlIGdvaW5nIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgdmlldyBhbmQKICAgICAqIHRoZSBncm91cCB3aWxsIG5vIGxvbmdlciBiZSBuZWVkZWQuCiAgICAgKgogICAgICogQ2xvbmVkIGVsZW1lbnRzIGdyb3VwIGFyZSBub3QgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IGluIGNhc2UgaWYgdGhlIGdyb3VwIGlzIHN0aWxsIG5lZWRlZCBhZnRlciBhbGwgaXRzIGVsZW1lbnRzCiAgICAgKiB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgdmlldy4KICAgICAqCiAgICAgKiBLZWVwIGluIG1pbmQgdGhhdCBncm91cCBuYW1lcyBhcmUgZXF1YWwgdG8gdGhlIGBpZGAgcHJvcGVydHkgb2YgdGhlIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgTmFtZSBvZiB0aGUgZ3JvdXAgdG8gY2xlYXIuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2xlYXJDbG9uZWRFbGVtZW50c0dyb3VwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNsb25lZEVsZW1lbnRzR3JvdXAoZ3JvdXBOYW1lKSB7CiAgICAgIHRoaXMuX2Nsb25lR3JvdXBzLmRlbGV0ZShncm91cE5hbWUpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBsb2NhdGlvbi4gVGhlIGxvY2F0aW9uIGNhbiBiZSBzcGVjaWZpZWQgYXM6CiAgICAgKgogICAgICogKiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259LAogICAgICogKiBwYXJlbnQgZWxlbWVudCBhbmQgb2Zmc2V0IChvZmZzZXQgZGVmYXVsdHMgdG8gYDBgKSwKICAgICAqICogcGFyZW50IGVsZW1lbnQgYW5kIGAnZW5kJ2AgKHNldHMgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGF0IGVsZW1lbnQpLAogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSB2aWV3IGl0ZW19IGFuZCBgJ2JlZm9yZSdgIG9yIGAnYWZ0ZXInYCAoc2V0cyBwb3NpdGlvbiBiZWZvcmUgb3IgYWZ0ZXIgZ2l2ZW4gdmlldyBpdGVtKS4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0Y3V0IHRvIG90aGVyIGNvbnN0cnVjdG9ycyBzdWNoIGFzOgogICAgICoKICAgICAqICoge0BsaW5rICNjcmVhdGVQb3NpdGlvbkJlZm9yZX0sCiAgICAgKiAqIHtAbGluayAjY3JlYXRlUG9zaXRpb25BZnRlcn0sCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgICAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIHZpZXcgaXRlbX0uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25BdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25BdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIHJldHVybiBQb3NpdGlvbi5fY3JlYXRlQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcgcG9zaXRpb24gYWZ0ZXIgZ2l2ZW4gdmlldyBpdGVtLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gaXRlbSBWaWV3IGl0ZW0gYWZ0ZXIgd2hpY2ggdGhlIHBvc2l0aW9uIHNob3VsZCBiZSBsb2NhdGVkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVQb3NpdGlvbkFmdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkFmdGVyKGl0ZW0pIHsKICAgICAgcmV0dXJuIFBvc2l0aW9uLl9jcmVhdGVBZnRlcihpdGVtKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyBwb3NpdGlvbiBiZWZvcmUgZ2l2ZW4gdmlldyBpdGVtLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gaXRlbSBWaWV3IGl0ZW0gYmVmb3JlIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgbG9jYXRlZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25CZWZvcmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uQmVmb3JlKGl0ZW0pIHsKICAgICAgcmV0dXJuIFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSByYW5nZSBzcGFubmluZyBmcm9tIGBzdGFydGAgcG9zaXRpb24gdG8gYGVuZGAgcG9zaXRpb24uCiAgICAgKgogICAgICogKipOb3RlOioqIFRoaXMgZmFjdG9yeSBtZXRob2QgY3JlYXRlcyBpdHMgb3duIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IGluc3RhbmNlcyBiYXNpbmcgb24gcGFzc2VkIHZhbHVlcy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gc3RhcnQgU3RhcnQgcG9zaXRpb24uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gW2VuZF0gRW5kIHBvc2l0aW9uLiBJZiBub3Qgc2V0LCByYW5nZSB3aWxsIGJlIGNvbGxhcHNlZCBhdCBgc3RhcnRgIHBvc2l0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmFuZ2Uoc3RhcnQsIGVuZCkgewogICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgdGhhdCBzdGFydHMgYmVmb3JlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIHZpZXcgaXRlbX0gYW5kIGVuZHMgYWZ0ZXIgaXQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtfSBpdGVtCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVJhbmdlT24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlT24oaXRlbSkgewogICAgICByZXR1cm4gUmFuZ2UuX2NyZWF0ZU9uKGl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mCiAgICAgKiB0aGF0IGVsZW1lbnQgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHdoaWNoIGlzIGEgcGFyZW50IGZvciB0aGUgcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVJhbmdlSW4iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlSW4oZWxlbWVudCkgewogICAgICByZXR1cm4gUmFuZ2UuX2NyZWF0ZUluKGVsZW1lbnQpOwogICAgfQogICAgLyoqCiAgICAgQ3JlYXRlcyBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufSBpbnN0YW5jZS4KICAgICAqCiAgICAgKiAJCS8vIENyZWF0ZXMgZW1wdHkgc2VsZWN0aW9uIHdpdGhvdXQgcmFuZ2VzLgogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gYXQgdGhlIGdpdmVuIHJhbmdlLgogICAgICoJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydCwgZW5kICk7CiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcmFuZ2UgKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gYXQgdGhlIGdpdmVuIHJhbmdlcwogICAgICogCQljb25zdCByYW5nZXMgPSBbIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQxLCBlbmQyICksIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcjIsIGVuZDIgKSBdOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlcyApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHRoZSBvdGhlciBzZWxlY3Rpb24uCiAgICAgKgkJY29uc3Qgb3RoZXJTZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCk7CiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggb3RoZXJTZWxlY3Rpb24gKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uLgogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIGVkaXRvci5lZGl0aW5nLnZpZXcuZG9jdW1lbnQuc2VsZWN0aW9uICk7CiAgICAgKgogICAgICogCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKgkJY29uc3QgcG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgcGF0aCApOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHBvc2l0aW9uICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgY29sbGFwc2VkIHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gb2YgZ2l2ZW4gaXRlbSBhbmQgb2Zmc2V0LgogICAgICoJCWNvbnN0IHBhcmFncmFwaCA9IHdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAncCcgKTsKICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBwYXJhZ3JhcGgsIG9mZnNldCApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlCiAgICAgKgkJLy8gZmlyc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBwYXJhZ3JhcGgsICdpbicgKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBhIHJhbmdlIG9uIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIGl0ZW19IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGl0ZW0gYW5kIGVuZHMKICAgICAqCQkvLyBqdXN0IGFmdGVyIHRoZSBpdGVtLgogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHBhcmFncmFwaCwgJ29uJyApOwogICAgICoKICAgICAqIGBTZWxlY3Rpb25gJ3MgY29uc3RydWN0b3IgYWxsb3cgcGFzc2luZyBhZGRpdGlvbmFsIG9wdGlvbnMgKGBiYWNrd2FyZGAsIGBmYWtlYCBhbmQgYGxhYmVsYCkgYXMgdGhlIGxhc3QgYXJndW1lbnQuCiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgYmFja3dhcmQgc2VsZWN0aW9uLgogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlLCB7IGJhY2t3YXJkOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBGYWtlIHNlbGVjdGlvbiBkb2VzIG5vdCByZW5kZXIgYXMgYnJvd3NlciBuYXRpdmUgc2VsZWN0aW9uIG92ZXIgc2VsZWN0ZWQgZWxlbWVudHMgYW5kIGlzIGhpZGRlbiB0byB0aGUgdXNlci4KICAgICAqIFRoaXMgd2F5LCBubyBuYXRpdmUgc2VsZWN0aW9uIFVJIGFydGlmYWN0cyBhcmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIGFuZCBzZWxlY3Rpb24gb3ZlciBlbGVtZW50cyBjYW4gYmUKICAgICAqIHJlcHJlc2VudGVkIGluIG90aGVyIHdheSwgZm9yIGV4YW1wbGUgYnkgYXBwbHlpbmcgcHJvcGVyIENTUyBjbGFzcy4KICAgICAqCiAgICAgKiBBZGRpdGlvbmFsbHkgZmFrZSdzIHNlbGVjdGlvbiBsYWJlbCBjYW4gYmUgcHJvdmlkZWQuIEl0IHdpbGwgYmUgdXNlZCB0byBkZXNjcmliZSBmYWtlIHNlbGVjdGlvbiBpbiBET00KICAgICAqIChhbmQgYmUgIHByb3Blcmx5IGhhbmRsZWQgYnkgc2NyZWVuIHJlYWRlcnMpLgogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIGZha2Ugc2VsZWN0aW9uIHdpdGggbGFiZWwuCiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcmFuZ2UsIHsgZmFrZTogdHJ1ZSwgbGFiZWw6ICdmb28nIH0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gW3NlbGVjdGFibGU9bnVsbF0KICAgICAqIEBwYXJhbSB7TnVtYmVyfCdiZWZvcmUnfCdlbmQnfCdhZnRlcid8J29uJ3wnaW4nfSBbcGxhY2VPck9mZnNldF0gT2Zmc2V0IG9yIHBsYWNlIHdoZW4gc2VsZWN0YWJsZSBpcyBhbiBgSXRlbWAuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJhY2t3YXJkXSBTZXRzIHRoaXMgc2VsZWN0aW9uIGluc3RhbmNlIHRvIGJlIGJhY2t3YXJkLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mYWtlXSBTZXRzIHRoaXMgc2VsZWN0aW9uIGluc3RhbmNlIHRvIGJlIG1hcmtlZCBhcyBgZmFrZWAuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGFiZWxdIExhYmVsIGZvciB0aGUgZmFrZSBzZWxlY3Rpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3NlbGVjdGlvbn5TZWxlY3Rpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlU2VsZWN0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24oc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCwgb3B0aW9ucykgewogICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogSW5zZXJ0cyBhIG5vZGUgb3Igbm9kZXMgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gVGFrZXMgY2FyZSBvZiBicmVha2luZyBhdHRyaWJ1dGVzIGJlZm9yZSBpbnNlcnRpb24KICAgICAqIGFuZCBtZXJnaW5nIHRoZW0gYWZ0ZXJ3YXJkcyBpZiByZXF1ZXN0ZWQgYnkgdGhlIGJyZWFrQXR0cmlidXRlcyBwYXJhbS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIEluc2VydGlvbiBwb3NpdGlvbi4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHxtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fAogICAgICogbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudHwKICAgICAqIG1vZHVsZTplbmdpbmUvdmlldy9yYXdlbGVtZW50flJhd0VsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR8CiAgICAgKiBJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHwKICAgICAqIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudHwKICAgICAqIG1vZHVsZTplbmdpbmUvdmlldy9lbXB0eWVsZW1lbnR+RW1wdHlFbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9yYXdlbGVtZW50flJhd0VsZW1lbnR8CiAgICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudD59IG5vZGVzIE5vZGUgb3Igbm9kZXMgdG8gaW5zZXJ0LgogICAgICogQHBhcmFtIHtCb29sZWFufSBicmVha0F0dHJpYnV0ZXMgV2hldGhlciBhdHRyaWJ1dGVzIHNob3VsZCBiZSBicm9rZW4uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBSYW5nZSBhcm91bmQgaW5zZXJ0ZWQgbm9kZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2luc2VydE5vZGVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0Tm9kZXMocG9zaXRpb24sIG5vZGVzLCBicmVha0F0dHJpYnV0ZXMpIHsKICAgICAgdmFyIHBhcmVudEVsZW1lbnQ7IC8vIEJyZWFrIGF0dHJpYnV0ZXMgb24gbm9kZXMgdGhhdCBkbyBleGlzdCBpbiB0aGUgbW9kZWwgdHJlZSBzbyB0aGV5IGNhbiBoYXZlIGF0dHJpYnV0ZXMsIG90aGVyIGVsZW1lbnRzCiAgICAgIC8vIGNhbid0IGhhdmUgYW4gYXR0cmlidXRlIGluIG1vZGVsIGFuZCB3b24ndCBnZXQgd3JhcHBlZCB3aXRoIGFuIEF0dHJpYnV0ZUVsZW1lbnQgd2hpbGUgZG93bi1jYXN0ZWQuCgogICAgICBpZiAoYnJlYWtBdHRyaWJ1dGVzKSB7CiAgICAgICAgcGFyZW50RWxlbWVudCA9IGdldFBhcmVudENvbnRhaW5lcihwb3NpdGlvbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcGFyZW50RWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudC5pcygnJHRleHQnKSA/IHBvc2l0aW9uLnBhcmVudC5wYXJlbnQgOiBwb3NpdGlvbi5wYXJlbnQ7CiAgICAgIH0KCiAgICAgIGlmICghcGFyZW50RWxlbWVudCkgewogICAgICAgIC8qKgogICAgICAgICAqIFBvc2l0aW9uJ3MgcGFyZW50IGNvbnRhaW5lciBjYW5ub3QgYmUgZm91bmQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItaW52YWxpZC1wb3NpdGlvbi1jb250YWluZXIKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItaW52YWxpZC1wb3NpdGlvbi1jb250YWluZXInLCB0aGlzLmRvY3VtZW50KTsKICAgICAgfQoKICAgICAgdmFyIGluc2VydGlvblBvc2l0aW9uOwoKICAgICAgaWYgKGJyZWFrQXR0cmlidXRlcykgewogICAgICAgIGluc2VydGlvblBvc2l0aW9uID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKHBvc2l0aW9uLCB0cnVlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpbnNlcnRpb25Qb3NpdGlvbiA9IHBvc2l0aW9uLnBhcmVudC5pcygnJHRleHQnKSA/IGJyZWFrVGV4dE5vZGUocG9zaXRpb24pIDogcG9zaXRpb247CiAgICAgIH0KCiAgICAgIHZhciBsZW5ndGggPSBwYXJlbnRFbGVtZW50Ll9pbnNlcnRDaGlsZChpbnNlcnRpb25Qb3NpdGlvbi5vZmZzZXQsIG5vZGVzKTsKCiAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobm9kZXMpLAogICAgICAgICAgX3N0ZXA0OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykgewogICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDQudmFsdWU7CgogICAgICAgICAgdGhpcy5fYWRkVG9DbG9uZWRFbGVtZW50c0dyb3VwKG5vZGUpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7CiAgICAgIH0KCiAgICAgIHZhciBlbmRQb3NpdGlvbiA9IGluc2VydGlvblBvc2l0aW9uLmdldFNoaWZ0ZWRCeShsZW5ndGgpOwogICAgICB2YXIgc3RhcnQgPSB0aGlzLm1lcmdlQXR0cmlidXRlcyhpbnNlcnRpb25Qb3NpdGlvbik7IC8vIElmIHN0YXJ0IHBvc2l0aW9uIHdhcyBtZXJnZWQgLSBtb3ZlIGVuZCBwb3NpdGlvbi4KCiAgICAgIGlmICghc3RhcnQuaXNFcXVhbChpbnNlcnRpb25Qb3NpdGlvbikpIHsKICAgICAgICBlbmRQb3NpdGlvbi5vZmZzZXQtLTsKICAgICAgfQoKICAgICAgdmFyIGVuZCA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKGVuZFBvc2l0aW9uKTsKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogV3JhcHMgY2hpbGRyZW4gd2l0aCBwcm92aWRlZCBgd3JhcEVsZW1lbnRgLiBPbmx5IGNoaWxkcmVuIGNvbnRhaW5lZCBpbiBgcGFyZW50YCBlbGVtZW50IGJldHdlZW4KICAgICAqIGBzdGFydE9mZnNldGAgYW5kIGBlbmRPZmZzZXRgIHdpbGwgYmUgd3JhcHBlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydE9mZnNldAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZE9mZnNldAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB3cmFwRWxlbWVudAogICAgICovCgogIH0sIHsKICAgIGtleTogIl93cmFwQ2hpbGRyZW4iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF93cmFwQ2hpbGRyZW4ocGFyZW50LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB3cmFwRWxlbWVudCkgewogICAgICB2YXIgaSA9IHN0YXJ0T2Zmc2V0OwogICAgICB2YXIgd3JhcFBvc2l0aW9ucyA9IFtdOwoKICAgICAgd2hpbGUgKGkgPCBlbmRPZmZzZXQpIHsKICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuZ2V0Q2hpbGQoaSk7CiAgICAgICAgdmFyIGlzVGV4dCA9IGNoaWxkLmlzKCckdGV4dCcpOwogICAgICAgIHZhciBpc0F0dHJpYnV0ZSA9IGNoaWxkLmlzKCdhdHRyaWJ1dGVFbGVtZW50Jyk7CiAgICAgICAgdmFyIGlzQWxsb3dlZEluc2lkZUF0dHJpYnV0ZUVsZW1lbnQgPSBjaGlsZC5pc0FsbG93ZWRJbnNpZGVBdHRyaWJ1dGVFbGVtZW50OyAvLwogICAgICAgIC8vIChJbiBhbGwgZXhhbXBsZXMsIGFzc3VtZSB0aGF0IGB3cmFwRWxlbWVudGAgaXMgYDxzcGFuIGNsYXNzPSJmb28iPmAgZWxlbWVudC4pCiAgICAgICAgLy8KICAgICAgICAvLyBDaGVjayBpZiBgd3JhcEVsZW1lbnRgIGNhbiBiZSBqb2luZWQgd2l0aCB0aGUgd3JhcHBlZCBlbGVtZW50LiBPbmUgb2YgcmVxdWlyZW1lbnRzIGlzIGhhdmluZyBzYW1lIG5hbWUuCiAgICAgICAgLy8gSWYgcG9zc2libGUsIGpvaW4gZWxlbWVudHMuCiAgICAgICAgLy8KICAgICAgICAvLyA8cD48c3BhbiBjbGFzcz0iYmFyIj5hYmM8L3NwYW4+PC9wPiAgLS0+ICA8cD48c3BhbiBjbGFzcz0iZm9vIGJhciI+YWJjPC9zcGFuPjwvcD4KICAgICAgICAvLwoKICAgICAgICBpZiAoaXNBdHRyaWJ1dGUgJiYgdGhpcy5fd3JhcEF0dHJpYnV0ZUVsZW1lbnQod3JhcEVsZW1lbnQsIGNoaWxkKSkgewogICAgICAgICAgd3JhcFBvc2l0aW9ucy5wdXNoKG5ldyBQb3NpdGlvbihwYXJlbnQsIGkpKTsKICAgICAgICB9IC8vCiAgICAgICAgLy8gV3JhcCB0aGUgY2hpbGQgaWYgaXQgaXMgbm90IGFuIGF0dHJpYnV0ZSBlbGVtZW50IG9yIGlmIGl0IGlzIGFuIGF0dHJpYnV0ZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIGluc2lkZQogICAgICAgIC8vIGB3cmFwRWxlbWVudGAgKGR1ZSB0byBwcmlvcml0eSkuCiAgICAgICAgLy8KICAgICAgICAvLyA8cD5hYmM8L3A+ICAgICAgICAgICAgICAgICAgIC0tPiAgPHA+PHNwYW4gY2xhc3M9ImZvbyI+YWJjPC9zcGFuPjwvcD4KICAgICAgICAvLyA8cD48c3Ryb25nPmFiYzwvc3Ryb25nPjwvcD4gIC0tPiAgPHA+PHNwYW4gY2xhc3M9ImZvbyI+PHN0cm9uZz5hYmM8L3N0cm9uZz48L3NwYW4+PC9wPgogICAgICAgIGVsc2UgaWYgKGlzVGV4dCB8fCBpc0FsbG93ZWRJbnNpZGVBdHRyaWJ1dGVFbGVtZW50IHx8IGlzQXR0cmlidXRlICYmIHNob3VsZEFCZU91dHNpZGVCKHdyYXBFbGVtZW50LCBjaGlsZCkpIHsKICAgICAgICAgICAgLy8gQ2xvbmUgYXR0cmlidXRlLgogICAgICAgICAgICB2YXIgbmV3QXR0cmlidXRlID0gd3JhcEVsZW1lbnQuX2Nsb25lKCk7IC8vIFdyYXAgY3VycmVudCBub2RlIHdpdGggbmV3IGF0dHJpYnV0ZS4KCgogICAgICAgICAgICBjaGlsZC5fcmVtb3ZlKCk7CgogICAgICAgICAgICBuZXdBdHRyaWJ1dGUuX2FwcGVuZENoaWxkKGNoaWxkKTsKCiAgICAgICAgICAgIHBhcmVudC5faW5zZXJ0Q2hpbGQoaSwgbmV3QXR0cmlidXRlKTsKCiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ2xvbmVkRWxlbWVudHNHcm91cChuZXdBdHRyaWJ1dGUpOwoKICAgICAgICAgICAgd3JhcFBvc2l0aW9ucy5wdXNoKG5ldyBQb3NpdGlvbihwYXJlbnQsIGkpKTsKICAgICAgICAgIH0gLy8KICAgICAgICAgIC8vIElmIG90aGVyIG5lc3RlZCBhdHRyaWJ1dGUgaXMgZm91bmQgYW5kIGl0IHdhc24ndCB3cmFwcGVkIChzZWUgYWJvdmUpLCBjb250aW51ZSB3cmFwcGluZyBpbnNpZGUgaXQuCiAgICAgICAgICAvLwogICAgICAgICAgLy8gPHA+PGEgaHJlZj0iZm9vLmh0bWwiPmFiYzwvYT48L3A+ICAtLT4gIDxwPjxhIGhyZWY9ImZvby5odG1sIj48c3BhbiBjbGFzcz0iZm9vIj5hYmM8L3NwYW4+PC9hPjwvcD4KICAgICAgICAgIC8vCiAgICAgICAgICBlbHNlIGlmIChpc0F0dHJpYnV0ZSkgewogICAgICAgICAgICAgIHRoaXMuX3dyYXBDaGlsZHJlbihjaGlsZCwgMCwgY2hpbGQuY2hpbGRDb3VudCwgd3JhcEVsZW1lbnQpOwogICAgICAgICAgICB9CgogICAgICAgIGkrKzsKICAgICAgfSAvLyBNZXJnZSBhdCBlYWNoIHdyYXAuCgoKICAgICAgdmFyIG9mZnNldENoYW5nZSA9IDA7CgogICAgICBmb3IgKHZhciBfaSA9IDAsIF93cmFwUG9zaXRpb25zID0gd3JhcFBvc2l0aW9uczsgX2kgPCBfd3JhcFBvc2l0aW9ucy5sZW5ndGg7IF9pKyspIHsKICAgICAgICB2YXIgcG9zaXRpb24gPSBfd3JhcFBvc2l0aW9uc1tfaV07CiAgICAgICAgcG9zaXRpb24ub2Zmc2V0IC09IG9mZnNldENoYW5nZTsgLy8gRG8gbm90IG1lcmdlIHdpdGggZWxlbWVudHMgb3V0c2lkZSBzZWxlY3RlZCBjaGlsZHJlbi4KCiAgICAgICAgaWYgKHBvc2l0aW9uLm9mZnNldCA9PSBzdGFydE9mZnNldCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQoKICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSB0aGlzLm1lcmdlQXR0cmlidXRlcyhwb3NpdGlvbik7IC8vIElmIG5vZGVzIHdlcmUgbWVyZ2VkIC0gb3RoZXIgbWVyZ2Ugb2Zmc2V0cyB3aWxsIGNoYW5nZS4KCiAgICAgICAgaWYgKCFuZXdQb3NpdGlvbi5pc0VxdWFsKHBvc2l0aW9uKSkgewogICAgICAgICAgb2Zmc2V0Q2hhbmdlKys7CiAgICAgICAgICBlbmRPZmZzZXQtLTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBSYW5nZS5fY3JlYXRlRnJvbVBhcmVudHNBbmRPZmZzZXRzKHBhcmVudCwgc3RhcnRPZmZzZXQsIHBhcmVudCwgZW5kT2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogVW53cmFwcyBjaGlsZHJlbiBmcm9tIHByb3ZpZGVkIGB1bndyYXBFbGVtZW50YC4gT25seSBjaGlsZHJlbiBjb250YWluZWQgaW4gYHBhcmVudGAgZWxlbWVudCBiZXR3ZWVuCiAgICAgKiBgc3RhcnRPZmZzZXRgIGFuZCBgZW5kT2Zmc2V0YCB3aWxsIGJlIHVud3JhcHBlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydE9mZnNldAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZE9mZnNldAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB1bndyYXBFbGVtZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3Vud3JhcENoaWxkcmVuIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfdW53cmFwQ2hpbGRyZW4ocGFyZW50LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB1bndyYXBFbGVtZW50KSB7CiAgICAgIHZhciBpID0gc3RhcnRPZmZzZXQ7CiAgICAgIHZhciB1bndyYXBQb3NpdGlvbnMgPSBbXTsgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggZWxlbWVudCBiZXR3ZWVuIHByb3ZpZGVkIG9mZnNldHMgaW5zaWRlIHBhcmVudC4KICAgICAgLy8gV2UgZG9uJ3QgdXNlIHRyZWUgd2Fsa2VyIG9yIHJhbmdlIGl0ZXJhdG9yIGJlY2F1c2Ugd2Ugd2lsbCBiZSByZW1vdmluZyBhbmQgbWVyZ2luZyBwb3RlbnRpYWxseSBtdWx0aXBsZSBub2RlcywKICAgICAgLy8gc28gaXQgY291bGQgZ2V0IG1lc3N5LiBJdCBpcyBzYWZlciB0byBpdCBtYW51YWxseSBpbiB0aGlzIGNhc2UuCgogICAgICB3aGlsZSAoaSA8IGVuZE9mZnNldCkgewogICAgICAgIHZhciBjaGlsZCA9IHBhcmVudC5nZXRDaGlsZChpKTsgLy8gU2tpcCBhbGwgdGV4dCBub2Rlcy4gVGhlcmUgc2hvdWxkIGJlIG5vIGNvbnRhaW5lciBlbGVtZW50J3MgaGVyZSBlaXRoZXIuCgogICAgICAgIGlmICghY2hpbGQuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSkgewogICAgICAgICAgaSsrOwogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSAvLwogICAgICAgIC8vIChJbiBhbGwgZXhhbXBsZXMsIGFzc3VtZSB0aGF0IGB1bndyYXBFbGVtZW50YCBpcyBgPHNwYW4gY2xhc3M9ImZvbyI+YCBlbGVtZW50LikKICAgICAgICAvLwogICAgICAgIC8vIElmIHRoZSBjaGlsZCBpcyBzaW1pbGFyIHRvIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZWxlbWVudCwgdW53cmFwIGl0IC0gaXQgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQuCiAgICAgICAgLy8KICAgICAgICAvLyA8cD48c3BhbiBjbGFzcz0iZm9vIj5hYmM8L3NwYW4+eHl6PC9wPiAgLS0+ICA8cD5hYmN4eXo8L3A+CiAgICAgICAgLy8KCgogICAgICAgIGlmIChjaGlsZC5pc1NpbWlsYXIodW53cmFwRWxlbWVudCkpIHsKICAgICAgICAgIHZhciB1bndyYXBwZWQgPSBjaGlsZC5nZXRDaGlsZHJlbigpOwogICAgICAgICAgdmFyIGNvdW50ID0gY2hpbGQuY2hpbGRDb3VudDsgLy8gUmVwbGFjZSB3cmFwcGVyIGVsZW1lbnQgd2l0aCBpdHMgY2hpbGRyZW4KCiAgICAgICAgICBjaGlsZC5fcmVtb3ZlKCk7CgogICAgICAgICAgcGFyZW50Ll9pbnNlcnRDaGlsZChpLCB1bndyYXBwZWQpOwoKICAgICAgICAgIHRoaXMuX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKGNoaWxkKTsgLy8gU2F2ZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIG9mIG1vdmVkIGl0ZW1zLgoKCiAgICAgICAgICB1bndyYXBQb3NpdGlvbnMucHVzaChuZXcgUG9zaXRpb24ocGFyZW50LCBpKSwgbmV3IFBvc2l0aW9uKHBhcmVudCwgaSArIGNvdW50KSk7IC8vIFNraXAgZWxlbWVudHMgdGhhdCB3ZXJlIHVud3JhcHBlZC4gQXNzdW1pbmcgdGhlcmUgd29uJ3QgYmUgYW5vdGhlciBlbGVtZW50IHRvIHVud3JhcCBpbiBjaGlsZCBlbGVtZW50cy4KCiAgICAgICAgICBpICs9IGNvdW50OwogICAgICAgICAgZW5kT2Zmc2V0ICs9IGNvdW50IC0gMTsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gLy8KICAgICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgbm90IHNpbWlsYXIgYnV0IGlzIGFuIGF0dHJpYnV0ZSBlbGVtZW50LCB0cnkgcGFydGlhbCB1bndyYXBwaW5nIC0gcmVtb3ZlIHRoZSBzYW1lIGF0dHJpYnV0ZXMvc3R5bGVzL2NsYXNzZXMuCiAgICAgICAgLy8gUGFydGlhbCB1bndyYXBwaW5nIHdpbGwgaGFwcGVuIG9ubHkgaWYgdGhlIGVsZW1lbnRzIGhhdmUgdGhlIHNhbWUgbmFtZS4KICAgICAgICAvLwogICAgICAgIC8vIDxwPjxzcGFuIGNsYXNzPSJmb28gYmFyIj5hYmM8L3NwYW4+eHl6PC9wPiAgLS0+ICA8cD48c3BhbiBjbGFzcz0iYmFyIj5hYmM8L3NwYW4+eHl6PC9wPgogICAgICAgIC8vIDxwPjxpIGNsYXNzPSJmb28iPmFiYzwvaT54eXo8L3A+ICAgICAgICAgICAgLS0+ICA8cD48aSBjbGFzcz0iZm9vIj5hYmM8L2k+eHl6PC9wPgogICAgICAgIC8vCgoKICAgICAgICBpZiAodGhpcy5fdW53cmFwQXR0cmlidXRlRWxlbWVudCh1bndyYXBFbGVtZW50LCBjaGlsZCkpIHsKICAgICAgICAgIHVud3JhcFBvc2l0aW9ucy5wdXNoKG5ldyBQb3NpdGlvbihwYXJlbnQsIGkpLCBuZXcgUG9zaXRpb24ocGFyZW50LCBpICsgMSkpOwogICAgICAgICAgaSsrOwogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSAvLwogICAgICAgIC8vIElmIG90aGVyIG5lc3RlZCBhdHRyaWJ1dGUgaXMgZm91bmQsIGxvb2sgdGhyb3VnaCBpdCdzIGNoaWxkcmVuIGZvciBlbGVtZW50cyB0byB1bndyYXAuCiAgICAgICAgLy8KICAgICAgICAvLyA8cD48aT48c3BhbiBjbGFzcz0iZm9vIj5hYmM8L3NwYW4+PC9pPjxwPiAgLS0+ICA8cD48aT5hYmM8L2k+PHA+CiAgICAgICAgLy8KCgogICAgICAgIHRoaXMuX3Vud3JhcENoaWxkcmVuKGNoaWxkLCAwLCBjaGlsZC5jaGlsZENvdW50LCB1bndyYXBFbGVtZW50KTsKCiAgICAgICAgaSsrOwogICAgICB9IC8vIE1lcmdlIGF0IGVhY2ggdW53cmFwLgoKCiAgICAgIHZhciBvZmZzZXRDaGFuZ2UgPSAwOwoKICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3Vud3JhcFBvc2l0aW9ucyA9IHVud3JhcFBvc2l0aW9uczsgX2kyIDwgX3Vud3JhcFBvc2l0aW9ucy5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgdmFyIHBvc2l0aW9uID0gX3Vud3JhcFBvc2l0aW9uc1tfaTJdOwogICAgICAgIHBvc2l0aW9uLm9mZnNldCAtPSBvZmZzZXRDaGFuZ2U7IC8vIERvIG5vdCBtZXJnZSB3aXRoIGVsZW1lbnRzIG91dHNpZGUgc2VsZWN0ZWQgY2hpbGRyZW4uCgogICAgICAgIGlmIChwb3NpdGlvbi5vZmZzZXQgPT0gc3RhcnRPZmZzZXQgfHwgcG9zaXRpb24ub2Zmc2V0ID09IGVuZE9mZnNldCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQoKICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSB0aGlzLm1lcmdlQXR0cmlidXRlcyhwb3NpdGlvbik7IC8vIElmIG5vZGVzIHdlcmUgbWVyZ2VkIC0gb3RoZXIgbWVyZ2Ugb2Zmc2V0cyB3aWxsIGNoYW5nZS4KCiAgICAgICAgaWYgKCFuZXdQb3NpdGlvbi5pc0VxdWFsKHBvc2l0aW9uKSkgewogICAgICAgICAgb2Zmc2V0Q2hhbmdlKys7CiAgICAgICAgICBlbmRPZmZzZXQtLTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBSYW5nZS5fY3JlYXRlRnJvbVBhcmVudHNBbmRPZmZzZXRzKHBhcmVudCwgc3RhcnRPZmZzZXQsIHBhcmVudCwgZW5kT2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBgdmlldy53cml0ZXIud3JhcGAuIFdyYXBzIHJhbmdlIHdpdGggcHJvdmlkZWQgYXR0cmlidXRlIGVsZW1lbnQuCiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gbWVyZ2UgbmV3bHkgYWRkZWQgYXR0cmlidXRlIGVsZW1lbnQgd2l0aCBpdHMgc2libGluZ3Mgd2hlbmV2ZXIgcG9zc2libGUuCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItd3JhcC1pbnZhbGlkLWF0dHJpYnV0ZWAgd2hlbiBwYXNzZWQgYXR0cmlidXRlIGVsZW1lbnQgaXMgbm90CiAgICAgKiBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGF0dHJpYnV0ZQogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gTmV3IHJhbmdlIGFmdGVyIHdyYXBwaW5nLCBzcGFubmluZyBvdmVyIHdyYXBwaW5nIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogIl93cmFwUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF93cmFwUmFuZ2UocmFuZ2UsIGF0dHJpYnV0ZSkgewogICAgICAvLyBCcmVhayBhdHRyaWJ1dGVzIGF0IHJhbmdlIHN0YXJ0IGFuZCBlbmQuCiAgICAgIHZhciBfdGhpcyRfYnJlYWtBdHRyaWJ1dGUzID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UsIHRydWUpLAogICAgICAgICAgYnJlYWtTdGFydCA9IF90aGlzJF9icmVha0F0dHJpYnV0ZTMuc3RhcnQsCiAgICAgICAgICBicmVha0VuZCA9IF90aGlzJF9icmVha0F0dHJpYnV0ZTMuZW5kOwoKICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IGJyZWFrU3RhcnQucGFyZW50OyAvLyBXcmFwIGFsbCBjaGlsZHJlbiB3aXRoIGF0dHJpYnV0ZS4KCiAgICAgIHZhciBuZXdSYW5nZSA9IHRoaXMuX3dyYXBDaGlsZHJlbihwYXJlbnRDb250YWluZXIsIGJyZWFrU3RhcnQub2Zmc2V0LCBicmVha0VuZC5vZmZzZXQsIGF0dHJpYnV0ZSk7IC8vIE1lcmdlIGF0dHJpYnV0ZXMgYXQgdGhlIGJvdGggZW5kcyBhbmQgcmV0dXJuIGEgbmV3IHJhbmdlLgoKCiAgICAgIHZhciBzdGFydCA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKG5ld1JhbmdlLnN0YXJ0KTsgLy8gSWYgc3RhcnQgcG9zaXRpb24gd2FzIG1lcmdlZCAtIG1vdmUgZW5kIHBvc2l0aW9uIGJhY2suCgogICAgICBpZiAoIXN0YXJ0LmlzRXF1YWwobmV3UmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgbmV3UmFuZ2UuZW5kLm9mZnNldC0tOwogICAgICB9CgogICAgICB2YXIgZW5kID0gdGhpcy5tZXJnZUF0dHJpYnV0ZXMobmV3UmFuZ2UuZW5kKTsKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciB7QGxpbmsgI3dyYXB9LiBXcmFwcyBwb3NpdGlvbiB3aXRoIHByb3ZpZGVkIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICogVGhpcyBtZXRob2Qgd2lsbCBhbHNvIG1lcmdlIG5ld2x5IGFkZGVkIGF0dHJpYnV0ZSBlbGVtZW50IHdpdGggaXRzIHNpYmxpbmdzIHdoZW5ldmVyIHBvc3NpYmxlLgogICAgICoKICAgICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLXdyYXAtaW52YWxpZC1hdHRyaWJ1dGVgIHdoZW4gcGFzc2VkIGF0dHJpYnV0ZSBlbGVtZW50IGlzIG5vdAogICAgICogYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0uCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBhdHRyaWJ1dGUKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IE5ldyBwb3NpdGlvbiBhZnRlciB3cmFwcGluZy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfd3JhcFBvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfd3JhcFBvc2l0aW9uKHBvc2l0aW9uLCBhdHRyaWJ1dGUpIHsKICAgICAgLy8gUmV0dXJuIHNhbWUgcG9zaXRpb24gd2hlbiB0cnlpbmcgdG8gd3JhcCB3aXRoIGF0dHJpYnV0ZSBzaW1pbGFyIHRvIHBvc2l0aW9uIHBhcmVudC4KICAgICAgaWYgKGF0dHJpYnV0ZS5pc1NpbWlsYXIocG9zaXRpb24ucGFyZW50KSkgewogICAgICAgIHJldHVybiBtb3ZlUG9zaXRpb25Ub1RleHROb2RlKHBvc2l0aW9uLmNsb25lKCkpOwogICAgICB9IC8vIFdoZW4gcG9zaXRpb24gaXMgaW5zaWRlIHRleHQgbm9kZSAtIGJyZWFrIGl0IGFuZCBwbGFjZSBuZXcgcG9zaXRpb24gYmV0d2VlbiB0d28gdGV4dCBub2Rlcy4KCgogICAgICBpZiAocG9zaXRpb24ucGFyZW50LmlzKCckdGV4dCcpKSB7CiAgICAgICAgcG9zaXRpb24gPSBicmVha1RleHROb2RlKHBvc2l0aW9uKTsKICAgICAgfSAvLyBDcmVhdGUgZmFrZSBlbGVtZW50IHRoYXQgd2lsbCByZXByZXNlbnQgcG9zaXRpb24sIGFuZCB3aWxsIG5vdCBiZSBtZXJnZWQgd2l0aCBvdGhlciBhdHRyaWJ1dGVzLgoKCiAgICAgIHZhciBmYWtlUG9zaXRpb24gPSB0aGlzLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoKTsKICAgICAgZmFrZVBvc2l0aW9uLl9wcmlvcml0eSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsKCiAgICAgIGZha2VQb3NpdGlvbi5pc1NpbWlsYXIgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9OyAvLyBJbnNlcnQgZmFrZSBlbGVtZW50IGluIHBvc2l0aW9uIGxvY2F0aW9uLgoKCiAgICAgIHBvc2l0aW9uLnBhcmVudC5faW5zZXJ0Q2hpbGQocG9zaXRpb24ub2Zmc2V0LCBmYWtlUG9zaXRpb24pOyAvLyBSYW5nZSBhcm91bmQgaW5zZXJ0ZWQgZmFrZSBhdHRyaWJ1dGUgZWxlbWVudC4KCgogICAgICB2YXIgd3JhcFJhbmdlID0gbmV3IFJhbmdlKHBvc2l0aW9uLCBwb3NpdGlvbi5nZXRTaGlmdGVkQnkoMSkpOyAvLyBXcmFwIGZha2UgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZSAoaXQgd2lsbCBhbHNvIG1lcmdlIGlmIHBvc3NpYmxlKS4KCiAgICAgIHRoaXMud3JhcCh3cmFwUmFuZ2UsIGF0dHJpYnV0ZSk7IC8vIFJlbW92ZSBmYWtlIGVsZW1lbnQgYW5kIHBsYWNlIG5ldyBwb3NpdGlvbiB0aGVyZS4KCiAgICAgIHZhciBuZXdQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihmYWtlUG9zaXRpb24ucGFyZW50LCBmYWtlUG9zaXRpb24uaW5kZXgpOwoKICAgICAgZmFrZVBvc2l0aW9uLl9yZW1vdmUoKTsgLy8gSWYgcG9zaXRpb24gaXMgcGxhY2VkIGJldHdlZW4gdGV4dCBub2RlcyAtIG1lcmdlIHRoZW0gYW5kIHJldHVybiBwb3NpdGlvbiBpbnNpZGUuCgoKICAgICAgdmFyIG5vZGVCZWZvcmUgPSBuZXdQb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgICB2YXIgbm9kZUFmdGVyID0gbmV3UG9zaXRpb24ubm9kZUFmdGVyOwoKICAgICAgaWYgKG5vZGVCZWZvcmUgaW5zdGFuY2VvZiBUZXh0ICYmIG5vZGVBZnRlciBpbnN0YW5jZW9mIFRleHQpIHsKICAgICAgICByZXR1cm4gbWVyZ2VUZXh0Tm9kZXMobm9kZUJlZm9yZSwgbm9kZUFmdGVyKTsKICAgICAgfSAvLyBJZiBwb3NpdGlvbiBpcyBuZXh0IHRvIHRleHQgbm9kZSAtIG1vdmUgcG9zaXRpb24gaW5zaWRlLgoKCiAgICAgIHJldHVybiBtb3ZlUG9zaXRpb25Ub1RleHROb2RlKG5ld1Bvc2l0aW9uKTsKICAgIH0KICAgIC8qKgogICAgICogCVdyYXBzIG9uZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fSBpbnRvIGFub3RoZXIgYnkKICAgICAqIAltZXJnaW5nIHRoZW0gaWYgcG9zc2libGUuIFdoZW4gbWVyZ2luZyBpcyBwb3NzaWJsZSAtIGFsbCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGNsYXNzZXMgYXJlIG1vdmVkIGZyb20gd3JhcHBlcgogICAgICogCWVsZW1lbnQgdG8gZWxlbWVudCBiZWluZyB3cmFwcGVkLgogICAgICoKICAgICAqIAlAcHJpdmF0ZQogICAgICogCUBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gd3JhcHBlciBXcmFwcGVyIEF0dHJpYnV0ZUVsZW1lbnQuCiAgICAgKiAJQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSB0b1dyYXAgQXR0cmlidXRlRWxlbWVudCB0byB3cmFwIHVzaW5nIHdyYXBwZXIgZWxlbWVudC4KICAgICAqIAlAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgZWxlbWVudHMgYXJlIG1lcmdlZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfd3JhcEF0dHJpYnV0ZUVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF93cmFwQXR0cmlidXRlRWxlbWVudCh3cmFwcGVyLCB0b1dyYXApIHsKICAgICAgaWYgKCFjYW5CZUpvaW5lZCh3cmFwcGVyLCB0b1dyYXApKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9IC8vIENhbid0IG1lcmdlIGlmIG5hbWUgb3IgcHJpb3JpdHkgZGlmZmVycy4KCgogICAgICBpZiAod3JhcHBlci5uYW1lICE9PSB0b1dyYXAubmFtZSB8fCB3cmFwcGVyLnByaW9yaXR5ICE9PSB0b1dyYXAucHJpb3JpdHkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gQ2hlY2sgaWYgYXR0cmlidXRlcyBjYW4gYmUgbWVyZ2VkLgoKCiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIod3JhcHBlci5nZXRBdHRyaWJ1dGVLZXlzKCkpLAogICAgICAgICAgX3N0ZXA1OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGtleSA9IF9zdGVwNS52YWx1ZTsKCiAgICAgICAgICAvLyBDbGFzc2VzIGFuZCBzdHlsZXMgc2hvdWxkIGJlIGNoZWNrZWQgc2VwYXJhdGVseS4KICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSAvLyBJZiBzb21lIGF0dHJpYnV0ZXMgYXJlIGRpZmZlcmVudCB3ZSBjYW5ub3Qgd3JhcC4KCgogICAgICAgICAgaWYgKHRvV3JhcC5oYXNBdHRyaWJ1dGUoa2V5KSAmJiB0b1dyYXAuZ2V0QXR0cmlidXRlKGtleSkgIT09IHdyYXBwZXIuZ2V0QXR0cmlidXRlKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0gLy8gQ2hlY2sgaWYgc3R5bGVzIGNhbiBiZSBtZXJnZWQuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I1LmYoKTsKICAgICAgfQoKICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih3cmFwcGVyLmdldFN0eWxlTmFtZXMoKSksCiAgICAgICAgICBfc3RlcDY7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgX2tleSA9IF9zdGVwNi52YWx1ZTsKCiAgICAgICAgICBpZiAodG9XcmFwLmhhc1N0eWxlKF9rZXkpICYmIHRvV3JhcC5nZXRTdHlsZShfa2V5KSAhPT0gd3JhcHBlci5nZXRTdHlsZShfa2V5KSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBNb3ZlIGFsbCBhdHRyaWJ1dGVzL2NsYXNzZXMvc3R5bGVzIGZyb20gd3JhcHBlciB0byB3cmFwcGVkIEF0dHJpYnV0ZUVsZW1lbnQuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I2LmYoKTsKICAgICAgfQoKICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih3cmFwcGVyLmdldEF0dHJpYnV0ZUtleXMoKSksCiAgICAgICAgICBfc3RlcDc7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgX2tleTIgPSBfc3RlcDcudmFsdWU7CgogICAgICAgICAgLy8gQ2xhc3NlcyBhbmQgc3R5bGVzIHNob3VsZCBiZSBjaGVja2VkIHNlcGFyYXRlbHkuCiAgICAgICAgICBpZiAoX2tleTIgPT09ICdjbGFzcycgfHwgX2tleTIgPT09ICdzdHlsZScpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9IC8vIE1vdmUgb25seSB0aGVzZSBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCBwcmVzZW50IC0gb3RoZXIgYXJlIHNpbWlsYXIuCgoKICAgICAgICAgIGlmICghdG9XcmFwLmhhc0F0dHJpYnV0ZShfa2V5MikpIHsKICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoX2tleTIsIHdyYXBwZXIuZ2V0QXR0cmlidXRlKF9rZXkyKSwgdG9XcmFwKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjcuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjcuZigpOwogICAgICB9CgogICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHdyYXBwZXIuZ2V0U3R5bGVOYW1lcygpKSwKICAgICAgICAgIF9zdGVwODsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBfa2V5MyA9IF9zdGVwOC52YWx1ZTsKCiAgICAgICAgICBpZiAoIXRvV3JhcC5oYXNTdHlsZShfa2V5MykpIHsKICAgICAgICAgICAgdGhpcy5zZXRTdHlsZShfa2V5Mywgd3JhcHBlci5nZXRTdHlsZShfa2V5MyksIHRvV3JhcCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I4LmYoKTsKICAgICAgfQoKICAgICAgdmFyIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih3cmFwcGVyLmdldENsYXNzTmFtZXMoKSksCiAgICAgICAgICBfc3RlcDk7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yOS5zKCk7ICEoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgX2tleTQgPSBfc3RlcDkudmFsdWU7CgogICAgICAgICAgaWYgKCF0b1dyYXAuaGFzQ2xhc3MoX2tleTQpKSB7CiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoX2tleTQsIHRvV3JhcCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I5LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I5LmYoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIFVud3JhcHMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0gZnJvbSBhbm90aGVyIGJ5IHJlbW92aW5nCiAgICAgKiBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZXMsIGNsYXNzZXMgYW5kIHN0eWxlcy4gQWxsIGF0dHJpYnV0ZXMsIGNsYXNzZXMgYW5kIHN0eWxlcyBmcm9tIHdyYXBwZXIgc2hvdWxkIGJlIHByZXNlbnQKICAgICAqIGluc2lkZSBlbGVtZW50IGJlaW5nIHVud3JhcHBlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSB3cmFwcGVyIFdyYXBwZXIgQXR0cmlidXRlRWxlbWVudC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gdG9VbndyYXAgQXR0cmlidXRlRWxlbWVudCB0byB1bndyYXAgdXNpbmcgd3JhcHBlciBlbGVtZW50LgogICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGVsZW1lbnRzIGFyZSB1bndyYXBwZWQuCiAgICAgKiovCgogIH0sIHsKICAgIGtleTogIl91bndyYXBBdHRyaWJ1dGVFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfdW53cmFwQXR0cmlidXRlRWxlbWVudCh3cmFwcGVyLCB0b1Vud3JhcCkgewogICAgICBpZiAoIWNhbkJlSm9pbmVkKHdyYXBwZXIsIHRvVW53cmFwKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBDYW4ndCB1bndyYXAgaWYgbmFtZSBvciBwcmlvcml0eSBkaWZmZXJzLgoKCiAgICAgIGlmICh3cmFwcGVyLm5hbWUgIT09IHRvVW53cmFwLm5hbWUgfHwgd3JhcHBlci5wcmlvcml0eSAhPT0gdG9VbndyYXAucHJpb3JpdHkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gQ2hlY2sgaWYgQXR0cmlidXRlRWxlbWVudCBoYXMgYWxsIHdyYXBwZXIgYXR0cmlidXRlcy4KCgogICAgICB2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih3cmFwcGVyLmdldEF0dHJpYnV0ZUtleXMoKSksCiAgICAgICAgICBfc3RlcDEwOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjEwLnMoKTsgIShfc3RlcDEwID0gX2l0ZXJhdG9yMTAubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGtleSA9IF9zdGVwMTAudmFsdWU7CgogICAgICAgICAgLy8gQ2xhc3NlcyBhbmQgc3R5bGVzIHNob3VsZCBiZSBjaGVja2VkIHNlcGFyYXRlbHkuCiAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gLy8gSWYgc29tZSBhdHRyaWJ1dGVzIGFyZSBtaXNzaW5nIG9yIGRpZmZlcmVudCB3ZSBjYW5ub3QgdW53cmFwLgoKCiAgICAgICAgICBpZiAoIXRvVW53cmFwLmhhc0F0dHJpYnV0ZShrZXkpIHx8IHRvVW53cmFwLmdldEF0dHJpYnV0ZShrZXkpICE9PSB3cmFwcGVyLmdldEF0dHJpYnV0ZShrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9IC8vIENoZWNrIGlmIEF0dHJpYnV0ZUVsZW1lbnQgaGFzIGFsbCB3cmFwcGVyIGNsYXNzZXMuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IxMC5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMTAuZigpOwogICAgICB9CgogICAgICBpZiAoIXRvVW53cmFwLmhhc0NsYXNzLmFwcGx5KHRvVW53cmFwLCBfdG9Db25zdW1hYmxlQXJyYXkod3JhcHBlci5nZXRDbGFzc05hbWVzKCkpKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBDaGVjayBpZiBBdHRyaWJ1dGVFbGVtZW50IGhhcyBhbGwgd3JhcHBlciBzdHlsZXMuCgoKICAgICAgdmFyIF9pdGVyYXRvcjExID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIod3JhcHBlci5nZXRTdHlsZU5hbWVzKCkpLAogICAgICAgICAgX3N0ZXAxMTsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IxMS5zKCk7ICEoX3N0ZXAxMSA9IF9pdGVyYXRvcjExLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBfa2V5NSA9IF9zdGVwMTEudmFsdWU7CgogICAgICAgICAgLy8gSWYgc29tZSBzdHlsZXMgYXJlIG1pc3Npbmcgb3IgZGlmZmVyZW50IHdlIGNhbm5vdCB1bndyYXAuCiAgICAgICAgICBpZiAoIXRvVW53cmFwLmhhc1N0eWxlKF9rZXk1KSB8fCB0b1Vud3JhcC5nZXRTdHlsZShfa2V5NSkgIT09IHdyYXBwZXIuZ2V0U3R5bGUoX2tleTUpKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9IC8vIFJlbW92ZSBhbGwgd3JhcHBlcidzIGF0dHJpYnV0ZXMgZnJvbSB1bndyYXBwZWQgZWxlbWVudC4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjExLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IxMS5mKCk7CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3IxMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHdyYXBwZXIuZ2V0QXR0cmlidXRlS2V5cygpKSwKICAgICAgICAgIF9zdGVwMTI7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMTIucygpOyAhKF9zdGVwMTIgPSBfaXRlcmF0b3IxMi5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgX2tleTYgPSBfc3RlcDEyLnZhbHVlOwoKICAgICAgICAgIC8vIENsYXNzZXMgYW5kIHN0eWxlcyBzaG91bGQgYmUgY2hlY2tlZCBzZXBhcmF0ZWx5LgogICAgICAgICAgaWYgKF9rZXk2ID09PSAnY2xhc3MnIHx8IF9rZXk2ID09PSAnc3R5bGUnKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQoKICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKF9rZXk2LCB0b1Vud3JhcCk7CiAgICAgICAgfSAvLyBSZW1vdmUgYWxsIHdyYXBwZXIncyBjbGFzc2VzIGZyb20gdW53cmFwcGVkIGVsZW1lbnQuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IxMi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMTIuZigpOwogICAgICB9CgogICAgICB0aGlzLnJlbW92ZUNsYXNzKEFycmF5LmZyb20od3JhcHBlci5nZXRDbGFzc05hbWVzKCkpLCB0b1Vud3JhcCk7IC8vIFJlbW92ZSBhbGwgd3JhcHBlcidzIHN0eWxlcyBmcm9tIHVud3JhcHBlZCBlbGVtZW50LgoKICAgICAgdGhpcy5yZW1vdmVTdHlsZShBcnJheS5mcm9tKHdyYXBwZXIuZ2V0U3R5bGVOYW1lcygpKSwgdG9VbndyYXApOwogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgYnkgb3RoZXIgYERvd25jYXN0V3JpdGVyYCBtZXRob2RzLiBCcmVha3MgYXR0cmlidXRlIGVsZW1lbnRzIGF0IHRoZSBib3VuZGFyaWVzIG9mIGdpdmVuIHJhbmdlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2Ugd2hpY2ggYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zIHdpbGwgYmUgdXNlZCB0byBicmVhayBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VTcGxpdFRleHQ9ZmFsc2VdIElmIHNldCB0byBgdHJ1ZWAsIHdpbGwgYnJlYWsgdGV4dCBub2RlcyBldmVuIGlmIHRoZXkgYXJlIGRpcmVjdGx5IGluIGNvbnRhaW5lciBlbGVtZW50LgogICAgICogVGhpcyBiZWhhdmlvciB3aWxsIHJlc3VsdCBpbiBpbmNvcnJlY3QgdmlldyBzdGF0ZSwgYnV0IGlzIG5lZWRlZCBieSBvdGhlciB2aWV3IHdyaXRpbmcgbWV0aG9kcyB3aGljaCB0aGVuIGZpeGVzIHZpZXcgc3RhdGUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBOZXcgcmFuZ2Ugd2l0aCBsb2NhdGVkIGF0IGJyZWFrIHBvc2l0aW9ucy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfYnJlYWtBdHRyaWJ1dGVzUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9icmVha0F0dHJpYnV0ZXNSYW5nZShyYW5nZSkgewogICAgICB2YXIgZm9yY2VTcGxpdFRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlOwogICAgICB2YXIgcmFuZ2VTdGFydCA9IHJhbmdlLnN0YXJ0OwogICAgICB2YXIgcmFuZ2VFbmQgPSByYW5nZS5lbmQ7CiAgICAgIHZhbGlkYXRlUmFuZ2VDb250YWluZXIocmFuZ2UsIHRoaXMuZG9jdW1lbnQpOyAvLyBCcmVhayBhdCB0aGUgY29sbGFwc2VkIHBvc2l0aW9uLiBSZXR1cm4gbmV3IGNvbGxhcHNlZCByYW5nZS4KCiAgICAgIGlmIChyYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2JyZWFrQXR0cmlidXRlcyhyYW5nZS5zdGFydCwgZm9yY2VTcGxpdFRleHQpOwoKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uLCBwb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHZhciBicmVha0VuZCA9IHRoaXMuX2JyZWFrQXR0cmlidXRlcyhyYW5nZUVuZCwgZm9yY2VTcGxpdFRleHQpOwoKICAgICAgdmFyIGNvdW50ID0gYnJlYWtFbmQucGFyZW50LmNoaWxkQ291bnQ7CgogICAgICB2YXIgYnJlYWtTdGFydCA9IHRoaXMuX2JyZWFrQXR0cmlidXRlcyhyYW5nZVN0YXJ0LCBmb3JjZVNwbGl0VGV4dCk7IC8vIENhbGN1bGF0ZSBuZXcgYnJlYWsgZW5kIG9mZnNldC4KCgogICAgICBicmVha0VuZC5vZmZzZXQgKz0gYnJlYWtFbmQucGFyZW50LmNoaWxkQ291bnQgLSBjb3VudDsKICAgICAgcmV0dXJuIG5ldyBSYW5nZShicmVha1N0YXJ0LCBicmVha0VuZCk7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIGJ5IG90aGVyIGBEb3duY2FzdFdyaXRlcmAgbWV0aG9kcy4gQnJlYWtzIGF0dHJpYnV0ZSBlbGVtZW50cyBhdCBnaXZlbiBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay1lbXB0eS1lbGVtZW50YCB3aGVuIGJyZWFrIHBvc2l0aW9uCiAgICAgKiBpcyBwbGFjZWQgaW5zaWRlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudCBFbXB0eUVsZW1lbnR9LgogICAgICoKICAgICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItY2Fubm90LWJyZWFrLXVpLWVsZW1lbnRgIHdoZW4gYnJlYWsgcG9zaXRpb24KICAgICAqIGlzIHBsYWNlZCBpbnNpZGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50IFVJRWxlbWVudH0uCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiB3aGVyZSB0byBicmVhayBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VTcGxpdFRleHQ9ZmFsc2VdIElmIHNldCB0byBgdHJ1ZWAsIHdpbGwgYnJlYWsgdGV4dCBub2RlcyBldmVuIGlmIHRoZXkgYXJlIGRpcmVjdGx5IGluIGNvbnRhaW5lciBlbGVtZW50LgogICAgICogVGhpcyBiZWhhdmlvciB3aWxsIHJlc3VsdCBpbiBpbmNvcnJlY3QgdmlldyBzdGF0ZSwgYnV0IGlzIG5lZWRlZCBieSBvdGhlciB2aWV3IHdyaXRpbmcgbWV0aG9kcyB3aGljaCB0aGVuIGZpeGVzIHZpZXcgc3RhdGUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBOZXcgcG9zaXRpb24gYWZ0ZXIgYnJlYWtpbmcgdGhlIGF0dHJpYnV0ZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2JyZWFrQXR0cmlidXRlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2JyZWFrQXR0cmlidXRlcyhwb3NpdGlvbikgewogICAgICB2YXIgZm9yY2VTcGxpdFRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlOwogICAgICB2YXIgcG9zaXRpb25PZmZzZXQgPSBwb3NpdGlvbi5vZmZzZXQ7CiAgICAgIHZhciBwb3NpdGlvblBhcmVudCA9IHBvc2l0aW9uLnBhcmVudDsgLy8gSWYgcG9zaXRpb24gaXMgcGxhY2VkIGluc2lkZSBFbXB0eUVsZW1lbnQgLSB0aHJvdyBhbiBleGNlcHRpb24gYXMgd2UgY2Fubm90IGJyZWFrIGluc2lkZS4KCiAgICAgIGlmIChwb3NpdGlvbi5wYXJlbnQuaXMoJ2VtcHR5RWxlbWVudCcpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IGJyZWFrIGFuIGBFbXB0eUVsZW1lbnRgIGluc3RhbmNlLgogICAgICAgICAqCiAgICAgICAgICogVGhpcyBlcnJvciBpcyB0aHJvd24gaWYKICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQXR0cmlidXRlcyBgRG93bmNhc3RXcml0ZXIjYnJlYWtBdHRyaWJ1dGVzKClgfQogICAgICAgICAqIHdhcyBleGVjdXRlZCBpbiBhbiBpbmNvcnJlY3QgcG9zaXRpb24uCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItY2Fubm90LWJyZWFrLWVtcHR5LWVsZW1lbnQKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItY2Fubm90LWJyZWFrLWVtcHR5LWVsZW1lbnQnLCB0aGlzLmRvY3VtZW50KTsKICAgICAgfSAvLyBJZiBwb3NpdGlvbiBpcyBwbGFjZWQgaW5zaWRlIFVJRWxlbWVudCAtIHRocm93IGFuIGV4Y2VwdGlvbiBhcyB3ZSBjYW5ub3QgYnJlYWsgaW5zaWRlLgoKCiAgICAgIGlmIChwb3NpdGlvbi5wYXJlbnQuaXMoJ3VpRWxlbWVudCcpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IGJyZWFrIGEgYFVJRWxlbWVudGAgaW5zdGFuY2UuCiAgICAgICAgICoKICAgICAgICAgKiBUaGlzIGVycm9yIGlzIHRocm93biBpZgogICAgICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjYnJlYWtBdHRyaWJ1dGVzIGBEb3duY2FzdFdyaXRlciNicmVha0F0dHJpYnV0ZXMoKWB9CiAgICAgICAgICogd2FzIGV4ZWN1dGVkIGluIGFuIGluY29ycmVjdCBwb3NpdGlvbi4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB2aWV3LXdyaXRlci1jYW5ub3QtYnJlYWstdWktZWxlbWVudAogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci1jYW5ub3QtYnJlYWstdWktZWxlbWVudCcsIHRoaXMuZG9jdW1lbnQpOwogICAgICB9IC8vIElmIHBvc2l0aW9uIGlzIHBsYWNlZCBpbnNpZGUgUmF3RWxlbWVudCAtIHRocm93IGFuIGV4Y2VwdGlvbiBhcyB3ZSBjYW5ub3QgYnJlYWsgaW5zaWRlLgoKCiAgICAgIGlmIChwb3NpdGlvbi5wYXJlbnQuaXMoJ3Jhd0VsZW1lbnQnKSkgewogICAgICAgIC8qKgogICAgICAgICAqIENhbm5vdCBicmVhayBhIGBSYXdFbGVtZW50YCBpbnN0YW5jZS4KICAgICAgICAgKgogICAgICAgICAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIGlmCiAgICAgICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNicmVha0F0dHJpYnV0ZXMgYERvd25jYXN0V3JpdGVyI2JyZWFrQXR0cmlidXRlcygpYH0KICAgICAgICAgKiB3YXMgZXhlY3V0ZWQgaW4gYW4gaW5jb3JyZWN0IHBvc2l0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay1yYXctZWxlbWVudAogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci1jYW5ub3QtYnJlYWstcmF3LWVsZW1lbnQnLCB0aGlzLmRvY3VtZW50KTsKICAgICAgfSAvLyBUaGVyZSBhcmUgbm8gYXR0cmlidXRlcyB0byBicmVhayBhbmQgdGV4dCBub2RlcyBicmVha2luZyBpcyBub3QgZm9yY2VkLgoKCiAgICAgIGlmICghZm9yY2VTcGxpdFRleHQgJiYgcG9zaXRpb25QYXJlbnQuaXMoJyR0ZXh0JykgJiYgaXNDb250YWluZXJPckZyYWdtZW50KHBvc2l0aW9uUGFyZW50LnBhcmVudCkpIHsKICAgICAgICByZXR1cm4gcG9zaXRpb24uY2xvbmUoKTsKICAgICAgfSAvLyBQb3NpdGlvbidzIHBhcmVudCBpcyBjb250YWluZXIsIHNvIG5vIGF0dHJpYnV0ZXMgdG8gYnJlYWsuCgoKICAgICAgaWYgKGlzQ29udGFpbmVyT3JGcmFnbWVudChwb3NpdGlvblBhcmVudCkpIHsKICAgICAgICByZXR1cm4gcG9zaXRpb24uY2xvbmUoKTsKICAgICAgfSAvLyBCcmVhayB0ZXh0IGFuZCBzdGFydCBhZ2FpbiBpbiBuZXcgcG9zaXRpb24uCgoKICAgICAgaWYgKHBvc2l0aW9uUGFyZW50LmlzKCckdGV4dCcpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2JyZWFrQXR0cmlidXRlcyhicmVha1RleHROb2RlKHBvc2l0aW9uKSwgZm9yY2VTcGxpdFRleHQpOwogICAgICB9CgogICAgICB2YXIgbGVuZ3RoID0gcG9zaXRpb25QYXJlbnQuY2hpbGRDb3VudDsgLy8gPHA+Zm9vPGI+PHU+YmFye308L3U+PC9iPjwvcD4KICAgICAgLy8gPHA+Zm9vPGI+PHU+YmFyPC91PltdPC9iPjwvcD4KICAgICAgLy8gPHA+Zm9vPGI+PHU+YmFyPC91PjwvYj5bXTwvcD4KCiAgICAgIGlmIChwb3NpdGlvbk9mZnNldCA9PSBsZW5ndGgpIHsKICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBuZXcgUG9zaXRpb24ocG9zaXRpb25QYXJlbnQucGFyZW50LCBwb3NpdGlvblBhcmVudC5pbmRleCArIDEpOwogICAgICAgIHJldHVybiB0aGlzLl9icmVha0F0dHJpYnV0ZXMobmV3UG9zaXRpb24sIGZvcmNlU3BsaXRUZXh0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyA8cD5mb288Yj48dT57fWJhcjwvdT48L2I+PC9wPgogICAgICAgIC8vIDxwPmZvbzxiPltdPHU+YmFyPC91PjwvYj48L3A+CiAgICAgICAgLy8gPHA+Zm9ve308Yj48dT5iYXI8L3U+PC9iPjwvcD4KICAgICAgICBpZiAocG9zaXRpb25PZmZzZXQgPT09IDApIHsKICAgICAgICAgIHZhciBfbmV3UG9zaXRpb24gPSBuZXcgUG9zaXRpb24ocG9zaXRpb25QYXJlbnQucGFyZW50LCBwb3NpdGlvblBhcmVudC5pbmRleCk7CgogICAgICAgICAgcmV0dXJuIHRoaXMuX2JyZWFrQXR0cmlidXRlcyhfbmV3UG9zaXRpb24sIGZvcmNlU3BsaXRUZXh0KTsKICAgICAgICB9IC8vIDxwPmZvbzxiPjx1PmJ7fWFyPC91PjwvYj48L3A+CiAgICAgICAgLy8gPHA+Zm9vPGI+PHU+YltdYXI8L3U+PC9iPjwvcD4KICAgICAgICAvLyA8cD5mb288Yj48dT5iPC91PltdPHU+YXI8L3U+PC9iPjwvcD4KICAgICAgICAvLyA8cD5mb288Yj48dT5iPC91PjwvYj5bXTxiPjx1PmFyPC91PjwvYj48L3A+CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHZhciBvZmZzZXRBZnRlciA9IHBvc2l0aW9uUGFyZW50LmluZGV4ICsgMTsgLy8gQnJlYWsgZWxlbWVudC4KCiAgICAgICAgICAgIHZhciBjbG9uZWROb2RlID0gcG9zaXRpb25QYXJlbnQuX2Nsb25lKCk7IC8vIEluc2VydCBjbG9uZWQgbm9kZSB0byBwb3NpdGlvbidzIHBhcmVudCBub2RlLgoKCiAgICAgICAgICAgIHBvc2l0aW9uUGFyZW50LnBhcmVudC5faW5zZXJ0Q2hpbGQob2Zmc2V0QWZ0ZXIsIGNsb25lZE5vZGUpOwoKICAgICAgICAgICAgdGhpcy5fYWRkVG9DbG9uZWRFbGVtZW50c0dyb3VwKGNsb25lZE5vZGUpOyAvLyBHZXQgbm9kZXMgdG8gbW92ZS4KCgogICAgICAgICAgICB2YXIgY291bnQgPSBwb3NpdGlvblBhcmVudC5jaGlsZENvdW50IC0gcG9zaXRpb25PZmZzZXQ7CgogICAgICAgICAgICB2YXIgbm9kZXNUb01vdmUgPSBwb3NpdGlvblBhcmVudC5fcmVtb3ZlQ2hpbGRyZW4ocG9zaXRpb25PZmZzZXQsIGNvdW50KTsgLy8gTW92ZSBub2RlcyB0byBjbG9uZWQgbm9kZS4KCgogICAgICAgICAgICBjbG9uZWROb2RlLl9hcHBlbmRDaGlsZChub2Rlc1RvTW92ZSk7IC8vIENyZWF0ZSBuZXcgcG9zaXRpb24gdG8gd29yayBvbi4KCgogICAgICAgICAgICB2YXIgX25ld1Bvc2l0aW9uMiA9IG5ldyBQb3NpdGlvbihwb3NpdGlvblBhcmVudC5wYXJlbnQsIG9mZnNldEFmdGVyKTsKCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9icmVha0F0dHJpYnV0ZXMoX25ld1Bvc2l0aW9uMiwgZm9yY2VTcGxpdFRleHQpOwogICAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFN0b3JlcyB0aGUgaW5mb3JtYXRpb24gdGhhdCBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudH0gd2FzCiAgICAgKiBhZGRlZCB0byB0aGUgdHJlZS4gU2F2ZXMgdGhlIHJlZmVyZW5jZSB0byB0aGUgZ3JvdXAgaW4gdGhlIGdpdmVuIGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGdyb3VwLCBzbyBvdGhlciBlbGVtZW50cwogICAgICogZnJvbSB0aGUgZ3JvdXAgbm93IGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICoKICAgICAqIFRoZSBjbG9uZXMgZ3JvdXAgY2FuIGJlIG9idGFpbmVkIHVzaW5nIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I2dldEVsZW1lbnRzV2l0aFNhbWVJZH0uCiAgICAgKgogICAgICogRG9lcyBub3RoaW5nIGlmIGFkZGVkIGVsZW1lbnQgaGFzIG5vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I2lkIGlkfS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBlbGVtZW50IEF0dHJpYnV0ZSBlbGVtZW50IHRvIHNhdmUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2FkZFRvQ2xvbmVkRWxlbWVudHNHcm91cCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFRvQ2xvbmVkRWxlbWVudHNHcm91cChlbGVtZW50KSB7CiAgICAgIC8vIEFkZCBvbmx5IGlmIHRoZSBlbGVtZW50IGlzIGluIGRvY3VtZW50IHRyZWUuCiAgICAgIGlmICghZWxlbWVudC5yb290LmlzKCdyb290RWxlbWVudCcpKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIFRyYXZlcnNlIHRoZSBlbGVtZW50J3MgY2hpbGRyZW4gcmVjdXJzaXZlbHkgdG8gZmluZCBvdGhlciBhdHRyaWJ1dGUgZWxlbWVudHMgdGhhdCBhbHNvIG1pZ2h0IGdvdCBpbnNlcnRlZC4KICAgICAgLy8gVGhlIGxvb3AgaXMgYXQgdGhlIGJlZ2lubmluZyBzbyB3ZSBjYW4gbWFrZSBmYXN0IHJldHVybnMgbGF0ZXIgaW4gdGhlIGNvZGUuCgoKICAgICAgaWYgKGVsZW1lbnQuaXMoJ2VsZW1lbnQnKSkgewogICAgICAgIHZhciBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGVsZW1lbnQuZ2V0Q2hpbGRyZW4oKSksCiAgICAgICAgICAgIF9zdGVwMTM7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjEzLnMoKTsgIShfc3RlcDEzID0gX2l0ZXJhdG9yMTMubigpKS5kb25lOykgewogICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcDEzLnZhbHVlOwoKICAgICAgICAgICAgdGhpcy5fYWRkVG9DbG9uZWRFbGVtZW50c0dyb3VwKGNoaWxkKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjEzLmUoZXJyKTsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgX2l0ZXJhdG9yMTMuZigpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIGlkID0gZWxlbWVudC5pZDsKCiAgICAgIGlmICghaWQpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBncm91cCA9IHRoaXMuX2Nsb25lR3JvdXBzLmdldChpZCk7CgogICAgICBpZiAoIWdyb3VwKSB7CiAgICAgICAgZ3JvdXAgPSBuZXcgU2V0KCk7CgogICAgICAgIHRoaXMuX2Nsb25lR3JvdXBzLnNldChpZCwgZ3JvdXApOwogICAgICB9CgogICAgICBncm91cC5hZGQoZWxlbWVudCk7CiAgICAgIGVsZW1lbnQuX2Nsb25lc0dyb3VwID0gZ3JvdXA7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnR9CiAgICAgKiBmcm9tIGl0cyBjbG9uZXMgZ3JvdXAuCiAgICAgKgogICAgICogS2VlcCBpbiBtaW5kLCB0aGF0IHRoZSBlbGVtZW50IHdpbGwgc3RpbGwga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZ3JvdXAgKGJ1dCB0aGUgZ3JvdXAgd2lsbCBub3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdCkuCiAgICAgKiBUaGlzIGFsbG93cyB0byByZWZlcmVuY2UgdGhlIHdob2xlIGdyb3VwIGV2ZW4gaWYgdGhlIGVsZW1lbnQgd2FzIGFscmVhZHkgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLgogICAgICoKICAgICAqIERvZXMgbm90aGluZyBpZiB0aGUgZWxlbWVudCBoYXMgbm8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjaWQgaWR9LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGVsZW1lbnQgQXR0cmlidXRlIGVsZW1lbnQgdG8gcmVtb3ZlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmVGcm9tQ2xvbmVkRWxlbWVudHNHcm91cCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKGVsZW1lbnQpIHsKICAgICAgLy8gVHJhdmVyc2UgdGhlIGVsZW1lbnQncyBjaGlsZHJlbiByZWN1cnNpdmVseSB0byBmaW5kIG90aGVyIGF0dHJpYnV0ZSBlbGVtZW50cyB0aGF0IGFsc28gZ290IHJlbW92ZWQuCiAgICAgIC8vIFRoZSBsb29wIGlzIGF0IHRoZSBiZWdpbm5pbmcgc28gd2UgY2FuIG1ha2UgZmFzdCByZXR1cm5zIGxhdGVyIGluIHRoZSBjb2RlLgogICAgICBpZiAoZWxlbWVudC5pcygnZWxlbWVudCcpKSB7CiAgICAgICAgdmFyIF9pdGVyYXRvcjE0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZWxlbWVudC5nZXRDaGlsZHJlbigpKSwKICAgICAgICAgICAgX3N0ZXAxNDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMTQucygpOyAhKF9zdGVwMTQgPSBfaXRlcmF0b3IxNC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwMTQudmFsdWU7CgogICAgICAgICAgICB0aGlzLl9yZW1vdmVGcm9tQ2xvbmVkRWxlbWVudHNHcm91cChjaGlsZCk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfaXRlcmF0b3IxNC5lKGVycik7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIF9pdGVyYXRvcjE0LmYoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBpZCA9IGVsZW1lbnQuaWQ7CgogICAgICBpZiAoIWlkKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9jbG9uZUdyb3Vwcy5nZXQoaWQpOwoKICAgICAgaWYgKCFncm91cCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgZ3JvdXAuZGVsZXRlKGVsZW1lbnQpOyAvLyBOb3QgcmVtb3ZpbmcgZ3JvdXAgZnJvbSBlbGVtZW50IG9uIHB1cnBvc2UhCiAgICAgIC8vIElmIG90aGVyIHBhcnRzIG9mIGNvZGUgaGF2ZSByZWZlcmVuY2UgdG8gdGhpcyBlbGVtZW50LCB0aGV5IHdpbGwgYmUgYWJsZSB0byBnZXQgcmVmZXJlbmNlcyB0byBvdGhlciBlbGVtZW50cyBmcm9tIHRoZSBncm91cC4KICAgIH0KICB9XSk7CgogIHJldHVybiBEb3duY2FzdFdyaXRlcjsKfSgpOyAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGB2aWV3LndyaXRlci53cmFwYC4gQ2hlY2tzIGlmIGdpdmVuIGVsZW1lbnQgaGFzIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgdWkgZWxlbWVudHMuCgoKZXhwb3J0IHsgRG93bmNhc3RXcml0ZXIgYXMgZGVmYXVsdCB9OwoKZnVuY3Rpb24gX2hhc05vblVpQ2hpbGRyZW4ocGFyZW50KSB7CiAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LmdldENoaWxkcmVuKCkpLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7CiAgICByZXR1cm4gIWNoaWxkLmlzKCd1aUVsZW1lbnQnKTsKICB9KTsKfQovKioKICogVGhlIGBhdHRyaWJ1dGVgIHBhc3NlZCB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI3dyYXAgYERvd25jYXN0V3JpdGVyI3dyYXAoKWB9CiAqIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYEF0dHJpYnV0ZUVsZW1lbnRgfS4KICoKICogQGVycm9yIHZpZXctd3JpdGVyLXdyYXAtaW52YWxpZC1hdHRyaWJ1dGUKICovCi8vIFJldHVybnMgZmlyc3QgcGFyZW50IGNvbnRhaW5lciBvZiBzcGVjaWZpZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBQb3NpdGlvbn0uCi8vIFBvc2l0aW9uJ3MgcGFyZW50IG5vZGUgaXMgY2hlY2tlZCBhcyBmaXJzdCwgdGhlbiBuZXh0IHBhcmVudHMgYXJlIGNoZWNrZWQuCi8vIE5vdGUgdGhhdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBEb2N1bWVudEZyYWdtZW50fSBpcyB0cmVhdGVkIGxpa2UgYSBjb250YWluZXIuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiB1c2VkIGFzIGEgc3RhcnQgcG9pbnQgdG8gbG9jYXRlIHBhcmVudCBjb250YWluZXIuCi8vIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8dW5kZWZpbmVkfQovLyBQYXJlbnQgY29udGFpbmVyIGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgY29udGFpbmVyIGlzIG5vdCBmb3VuZC4KCgpmdW5jdGlvbiBnZXRQYXJlbnRDb250YWluZXIocG9zaXRpb24pIHsKICB2YXIgcGFyZW50ID0gcG9zaXRpb24ucGFyZW50OwoKICB3aGlsZSAoIWlzQ29udGFpbmVyT3JGcmFnbWVudChwYXJlbnQpKSB7CiAgICBpZiAoIXBhcmVudCkgewogICAgICByZXR1cm4gdW5kZWZpbmVkOwogICAgfQoKICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7CiAgfQoKICByZXR1cm4gcGFyZW50Owp9IC8vIENoZWNrcyBpZiBmaXJzdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fSBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24KLy8gY2FuIGJlIHdyYXBwZWQgb3V0c2lkZSBzZWNvbmQgZWxlbWVudC4gSXQgaXMgZG9uZSBieSBjb21wYXJpbmcgZWxlbWVudHMnCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I3ByaW9yaXR5IHByaW9yaXRpZXN9LCBpZiBib3RoIGhhdmUgc2FtZSBwcmlvcml0eQovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCNnZXRJZGVudGl0eSBpZGVudGl0aWVzfSBhcmUgY29tcGFyZWQuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gYQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGIKLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gc2hvdWxkQUJlT3V0c2lkZUIoYSwgYikgewogIGlmIChhLnByaW9yaXR5IDwgYi5wcmlvcml0eSkgewogICAgcmV0dXJuIHRydWU7CiAgfSBlbHNlIGlmIChhLnByaW9yaXR5ID4gYi5wcmlvcml0eSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0gLy8gV2hlbiBwcmlvcml0aWVzIGFyZSBlcXVhbCBhbmQgbmFtZXMgYXJlIGRpZmZlcmVudCAtIHVzZSBpZGVudGl0aWVzLgoKCiAgcmV0dXJuIGEuZ2V0SWRlbnRpdHkoKSA8IGIuZ2V0SWRlbnRpdHkoKTsKfSAvLyBSZXR1cm5zIG5ldyBwb3NpdGlvbiB0aGF0IGlzIG1vdmVkIHRvIG5lYXIgdGV4dCBub2RlLiBSZXR1cm5zIHNhbWUgcG9zaXRpb24gaWYgdGhlcmUgaXMgbm8gdGV4dCBub2RlIGJlZm9yZSBvZiBhZnRlcgovLyBzcGVjaWZpZWQgcG9zaXRpb24uCi8vCi8vCQk8cD5mb29bXTwvcD4gIC0+ICA8cD5mb297fTwvcD4KLy8JCTxwPltdZm9vPC9wPiAgLT4gIDxwPnt9Zm9vPC9wPgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24KLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gbG9jYXRlZCBpbnNpZGUgdGV4dCBub2RlIG9yIHNhbWUgcG9zaXRpb24gaWYgdGhlcmUgaXMgbm8gdGV4dCBub2RlcwovLyBiZWZvcmUgb3IgYWZ0ZXIgcG9zaXRpb24gbG9jYXRpb24uCgoKZnVuY3Rpb24gbW92ZVBvc2l0aW9uVG9UZXh0Tm9kZShwb3NpdGlvbikgewogIHZhciBub2RlQmVmb3JlID0gcG9zaXRpb24ubm9kZUJlZm9yZTsKCiAgaWYgKG5vZGVCZWZvcmUgJiYgbm9kZUJlZm9yZS5pcygnJHRleHQnKSkgewogICAgcmV0dXJuIG5ldyBQb3NpdGlvbihub2RlQmVmb3JlLCBub2RlQmVmb3JlLmRhdGEubGVuZ3RoKTsKICB9CgogIHZhciBub2RlQWZ0ZXIgPSBwb3NpdGlvbi5ub2RlQWZ0ZXI7CgogIGlmIChub2RlQWZ0ZXIgJiYgbm9kZUFmdGVyLmlzKCckdGV4dCcpKSB7CiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKG5vZGVBZnRlciwgMCk7CiAgfQoKICByZXR1cm4gcG9zaXRpb247Cn0gLy8gQnJlYWtzIHRleHQgbm9kZSBpbnRvIHR3byB0ZXh0IG5vZGVzIHdoZW4gcG9zc2libGUuCi8vCi8vCQk8cD5mb297fWJhcjwvcD4gLT4gPHA+Zm9vW11iYXI8L3A+Ci8vCQk8cD57fWZvb2JhcjwvcD4gLT4gPHA+W11mb29iYXI8L3A+Ci8vCQk8cD5mb29iYXJ7fTwvcD4gLT4gPHA+Zm9vYmFyW108L3A+Ci8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiB0aGF0IG5lZWQgdG8gYmUgcGxhY2VkIGluc2lkZSB0ZXh0IG5vZGUuCi8vIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IE5ldyBwb3NpdGlvbiBhZnRlciBicmVha2luZyB0ZXh0IG5vZGUuCgoKZnVuY3Rpb24gYnJlYWtUZXh0Tm9kZShwb3NpdGlvbikgewogIGlmIChwb3NpdGlvbi5vZmZzZXQgPT0gcG9zaXRpb24ucGFyZW50LmRhdGEubGVuZ3RoKSB7CiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHBvc2l0aW9uLnBhcmVudC5wYXJlbnQsIHBvc2l0aW9uLnBhcmVudC5pbmRleCArIDEpOwogIH0KCiAgaWYgKHBvc2l0aW9uLm9mZnNldCA9PT0gMCkgewogICAgcmV0dXJuIG5ldyBQb3NpdGlvbihwb3NpdGlvbi5wYXJlbnQucGFyZW50LCBwb3NpdGlvbi5wYXJlbnQuaW5kZXgpOwogIH0gLy8gR2V0IHBhcnQgb2YgdGhlIHRleHQgdGhhdCBuZWVkIHRvIGJlIG1vdmVkLgoKCiAgdmFyIHRleHRUb01vdmUgPSBwb3NpdGlvbi5wYXJlbnQuZGF0YS5zbGljZShwb3NpdGlvbi5vZmZzZXQpOyAvLyBMZWF2ZSByZXN0IG9mIHRoZSB0ZXh0IGluIHBvc2l0aW9uJ3MgcGFyZW50LgoKICBwb3NpdGlvbi5wYXJlbnQuX2RhdGEgPSBwb3NpdGlvbi5wYXJlbnQuZGF0YS5zbGljZSgwLCBwb3NpdGlvbi5vZmZzZXQpOyAvLyBJbnNlcnQgbmV3IHRleHQgbm9kZSBhZnRlciBwb3NpdGlvbidzIHBhcmVudCB0ZXh0IG5vZGUuCgogIHBvc2l0aW9uLnBhcmVudC5wYXJlbnQuX2luc2VydENoaWxkKHBvc2l0aW9uLnBhcmVudC5pbmRleCArIDEsIG5ldyBUZXh0KHBvc2l0aW9uLnJvb3QuZG9jdW1lbnQsIHRleHRUb01vdmUpKTsgLy8gUmV0dXJuIG5ldyBwb3NpdGlvbiBiZXR3ZWVuIHR3byBuZXdseSBjcmVhdGVkIHRleHQgbm9kZXMuCgoKICByZXR1cm4gbmV3IFBvc2l0aW9uKHBvc2l0aW9uLnBhcmVudC5wYXJlbnQsIHBvc2l0aW9uLnBhcmVudC5pbmRleCArIDEpOwp9IC8vIE1lcmdlcyB0d28gdGV4dCBub2RlcyBpbnRvIGZpcnN0IG5vZGUuIFJlbW92ZXMgc2Vjb25kIG5vZGUgYW5kIHJldHVybnMgbWVyZ2UgcG9zaXRpb24uCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gdDEgRmlyc3QgdGV4dCBub2RlIHRvIG1lcmdlLiBEYXRhIGZyb20gc2Vjb25kIHRleHQgbm9kZSB3aWxsIGJlIG1vdmVkIGF0IHRoZSBlbmQgb2YKLy8gdGhpcyB0ZXh0IG5vZGUuCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gdDIgU2Vjb25kIHRleHQgbm9kZSB0byBtZXJnZS4gVGhpcyBub2RlIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBtZXJnaW5nLgovLyBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBQb3NpdGlvbiBhZnRlciBtZXJnaW5nIHRleHQgbm9kZXMuCgoKZnVuY3Rpb24gbWVyZ2VUZXh0Tm9kZXModDEsIHQyKSB7CiAgLy8gTWVyZ2UgdGV4dCBkYXRhIGludG8gZmlyc3QgdGV4dCBub2RlIGFuZCByZW1vdmUgc2Vjb25kIG9uZS4KICB2YXIgbm9kZUJlZm9yZUxlbmd0aCA9IHQxLmRhdGEubGVuZ3RoOwogIHQxLl9kYXRhICs9IHQyLmRhdGE7CgogIHQyLl9yZW1vdmUoKTsKCiAgcmV0dXJuIG5ldyBQb3NpdGlvbih0MSwgbm9kZUJlZm9yZUxlbmd0aCk7Cn0gLy8gQ2hlY2tzIGlmIHByb3ZpZGVkIG5vZGVzIGFyZSB2YWxpZCB0byBpbnNlcnQuCi8vCi8vIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItaW5zZXJ0LWludmFsaWQtbm9kZWAgd2hlbiBub2RlcyB0byBpbnNlcnQKLy8gY29udGFpbnMgaW5zdGFuY2VzIHRoYXQgYXJlIG5vdCBzdXBwb3J0ZWQgb25lcyAoc2VlIGVycm9yIGRlc2NyaXB0aW9uIGZvciB2YWxpZCBvbmVzLgovLwovLyBAcGFyYW0gSXRlcmFibGUuPG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR8bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudD4gbm9kZXMKLy8gQHBhcmFtIHtPYmplY3R9IGVycm9yQ29udGV4dAoKCmZ1bmN0aW9uIHZhbGlkYXRlTm9kZXNUb0luc2VydChub2RlcywgZXJyb3JDb250ZXh0KSB7CiAgdmFyIF9pdGVyYXRvcjE1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobm9kZXMpLAogICAgICBfc3RlcDE1OwoKICB0cnkgewogICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7CiAgICAgIHZhciBub2RlID0gX3N0ZXAxNS52YWx1ZTsKCiAgICAgIGlmICghdmFsaWROb2Rlc1RvSW5zZXJ0LnNvbWUoZnVuY3Rpb24gKHZhbGlkTm9kZSkgewogICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdmFsaWROb2RlOwogICAgICB9KSkgewogICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmUKCiAgICAgICAgLyoqCiAgICAgICAgICogT25lIG9mIHRoZSBub2RlcyB0byBiZSBpbnNlcnRlZCBpcyBvZiBhbiBpbnZhbGlkIHR5cGUuCiAgICAgICAgICoKICAgICAgICAgKiBOb2RlcyB0byBiZSBpbnNlcnRlZCB3aXRoIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjaW5zZXJ0IGBEb3duY2FzdFdyaXRlciNpbnNlcnQoKWB9IHNob3VsZCBiZQogICAgICAgICAqIG9mIHRoZSBmb2xsb3dpbmcgdHlwZXM6CiAgICAgICAgICoKICAgICAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IEF0dHJpYnV0ZUVsZW1lbnR9LAogICAgICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgQ29udGFpbmVyRWxlbWVudH0sCiAgICAgICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50fSwKICAgICAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSUVsZW1lbnR9LAogICAgICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYXdlbGVtZW50flJhd0VsZW1lbnQgUmF3RWxlbWVudH0sCiAgICAgICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCBUZXh0fS4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB2aWV3LXdyaXRlci1pbnNlcnQtaW52YWxpZC1ub2RlLXR5cGUKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItaW5zZXJ0LWludmFsaWQtbm9kZS10eXBlJywgZXJyb3JDb250ZXh0KTsKICAgICAgfQoKICAgICAgaWYgKCFub2RlLmlzKCckdGV4dCcpKSB7CiAgICAgICAgdmFsaWRhdGVOb2Rlc1RvSW5zZXJ0KG5vZGUuZ2V0Q2hpbGRyZW4oKSwgZXJyb3JDb250ZXh0KTsKICAgICAgfQogICAgfTsKCiAgICBmb3IgKF9pdGVyYXRvcjE1LnMoKTsgIShfc3RlcDE1ID0gX2l0ZXJhdG9yMTUubigpKS5kb25lOykgewogICAgICBfbG9vcCgpOwogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMTUuZShlcnIpOwogIH0gZmluYWxseSB7CiAgICBfaXRlcmF0b3IxNS5mKCk7CiAgfQp9Cgp2YXIgdmFsaWROb2Rlc1RvSW5zZXJ0ID0gW1RleHQsIEF0dHJpYnV0ZUVsZW1lbnQsIENvbnRhaW5lckVsZW1lbnQsIEVtcHR5RWxlbWVudCwgUmF3RWxlbWVudCwgVUlFbGVtZW50XTsgLy8gQ2hlY2tzIGlmIG5vZGUgaXMgQ29udGFpbmVyRWxlbWVudCBvciBEb2N1bWVudEZyYWdtZW50LCBiZWNhdXNlIGluIG1vc3QgY2FzZXMgdGhleSBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSB3YXkuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZX0gbm9kZQovLyBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgbm9kZSBpcyBpbnN0YW5jZSBvZiBDb250YWluZXJFbGVtZW50IG9yIERvY3VtZW50RnJhZ21lbnQuCgpmdW5jdGlvbiBpc0NvbnRhaW5lck9yRnJhZ21lbnQobm9kZSkgewogIHJldHVybiBub2RlICYmIChub2RlLmlzKCdjb250YWluZXJFbGVtZW50JykgfHwgbm9kZS5pcygnZG9jdW1lbnRGcmFnbWVudCcpKTsKfSAvLyBDaGVja3MgaWYge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydCByYW5nZSBzdGFydH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UjZW5kIHJhbmdlIGVuZH0gYXJlIHBsYWNlZAovLyBpbnNpZGUgc2FtZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudH0uCi8vIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXJgIHdoZW4gdmFsaWRhdGlvbiBmYWlscy4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlCi8vIEBwYXJhbSB7T2JqZWN0fSBlcnJvckNvbnRleHQKCgpmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlQ29udGFpbmVyKHJhbmdlLCBlcnJvckNvbnRleHQpIHsKICB2YXIgc3RhcnRDb250YWluZXIgPSBnZXRQYXJlbnRDb250YWluZXIocmFuZ2Uuc3RhcnQpOwogIHZhciBlbmRDb250YWluZXIgPSBnZXRQYXJlbnRDb250YWluZXIocmFuZ2UuZW5kKTsKCiAgaWYgKCFzdGFydENvbnRhaW5lciB8fCAhZW5kQ29udGFpbmVyIHx8IHN0YXJ0Q29udGFpbmVyICE9PSBlbmRDb250YWluZXIpIHsKICAgIC8qKgogICAgICogVGhlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gcmFuZ2UgaXMgaW52YWxpZC4KICAgICAqCiAgICAgKiBUaGlzIG1heSBoYXBwZW4gaWYge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydCByYW5nZSBzdGFydH0gYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI2VuZCByYW5nZSBlbmR9IHBvc2l0aW9ucyBhcmUgbm90IHBsYWNlZCBpbnNpZGUgdGhlIHNhbWUgY29udGFpbmVyIGVsZW1lbnQgb3IKICAgICAqIGEgcGFyZW50IGNvbnRhaW5lciBmb3IgdGhlc2UgcG9zaXRpb25zIGNhbm5vdCBiZSBmb3VuZC4KICAgICAqCiAgICAgKiBNZXRob2RzIGxpa2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciN3cmFwIGBEb3duY2FzdFdyaXRlciNyZW1vdmUoKWB9LAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciN3cmFwIGBEb3duY2FzdFdyaXRlciNjbGVhbigpYH0sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI3dyYXAgYERvd25jYXN0V3JpdGVyI3dyYXAoKWB9LAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciN3cmFwIGBEb3duY2FzdFdyaXRlciN1bndyYXAoKWB9IG5lZWQgdG8gYmUgY2FsbGVkCiAgICAgKiBvbiBhIHJhbmdlIHRoYXQgaGFzIGl0cyBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBsb2NhdGVkIGluIHRoZSBzYW1lIGNvbnRhaW5lciBlbGVtZW50LiBCb3RoIHBvc2l0aW9ucyBjYW4gYmUKICAgICAqIG5lc3RlZCB3aXRoaW4gb3RoZXIgZWxlbWVudHMgKGUuZy4gYW4gYXR0cmlidXRlIGVsZW1lbnQpIGJ1dCB0aGUgY2xvc2VzdCBjb250YWluZXIgYW5jZXN0b3IgbXVzdCBiZSB0aGUgc2FtZS4KICAgICAqCiAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXIKICAgICAqLwogICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyJywgZXJyb3JDb250ZXh0KTsKICB9Cn0gLy8gQ2hlY2tzIGlmIHR3byBhdHRyaWJ1dGUgZWxlbWVudHMgY2FuIGJlIGpvaW5lZCB0b2dldGhlci4gRWxlbWVudHMgY2FuIGJlIGpvaW5lZCB0b2dldGhlciBpZiwgYW5kIG9ubHkgaWYKLy8gdGhleSBkbyBub3QgaGF2ZSBpZHMgc3BlY2lmaWVkLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGEKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBiCi8vIEByZXR1cm5zIHtCb29sZWFufQoKCmZ1bmN0aW9uIGNhbkJlSm9pbmVkKGEsIGIpIHsKICByZXR1cm4gYS5pZCA9PT0gbnVsbCAmJiBiLmlkID09PSBudWxsOwp9"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js"],"names":["Position","Range","Selection","ContainerElement","AttributeElement","EmptyElement","UIElement","RawElement","CKEditorError","DocumentFragment","isIterable","Text","EditableElement","isPlainObject","DowncastWriter","document","_cloneGroups","Map","selectable","placeOrOffset","options","selection","_setTo","itemOrPosition","offset","_setFocus","children","data","name","attributes","attributeElement","priority","_priority","id","_id","containerElement","isAllowedInsideAttributeElement","undefined","_isAllowedInsideAttributeElement","editableElement","_document","emptyElement","renderFunction","uiElement","render","rawElement","key","value","element","_setAttribute","_removeAttribute","className","_addClass","_removeClass","property","_setStyle","_removeStyle","_setCustomProperty","_removeCustomProperty","positionOrRange","_breakAttributes","_breakAttributesRange","position","parent","is","isAtStart","_createBefore","isAtEnd","newElement","_clone","insert","_createAfter","sourceRange","_createAt","targetPosition","move","positionOffset","positionParent","childCount","index","_remove","_removeFromClonedElementsGroup","mergeAttributes","nodeBefore","getChild","nodeAfter","mergeTextNodes","isSimilar","count","_appendChild","getChildren","prev","next","lastChild","newPosition","_createIn","remove","_createOn","nodes","validateNodesToInsert","nodeGroups","reduce","groups","node","lastGroup","length","breakAttributes","push","start","end","range","_insertNodes","rangeOrItem","validateRangeContainer","isCollapsed","breakStart","breakEnd","parentContainer","removed","_removeChildren","mergePosition","clone","walker","getWalker","direction","ignoreElementEnd","current","item","rangeToRemove","nextPosition","isAfter","parentElement","getAncestors","find","ancestor","isBefore","countBefore","attribute","_wrapRange","_hasNonUiChildren","getLastMatchingPosition","_wrapPosition","viewSelection","getFirstPosition","isEqual","setSelection","newRange","_unwrapChildren","newName","viewElement","getAttributes","groupName","delete","getParentContainer","insertionPosition","breakTextNode","_insertChild","_addToClonedElementsGroup","endPosition","getShiftedBy","startOffset","endOffset","wrapElement","i","wrapPositions","child","isText","isAttribute","_wrapAttributeElement","shouldABeOutsideB","newAttribute","_wrapChildren","offsetChange","_createFromParentsAndOffsets","unwrapElement","unwrapPositions","unwrapped","_unwrapAttributeElement","movePositionToTextNode","fakePosition","createAttributeElement","Number","POSITIVE_INFINITY","wrapRange","wrap","wrapper","toWrap","canBeJoined","getAttributeKeys","hasAttribute","getAttribute","getStyleNames","hasStyle","getStyle","setAttribute","setStyle","getClassNames","hasClass","addClass","toUnwrap","removeAttribute","removeClass","Array","from","removeStyle","forceSplitText","rangeStart","rangeEnd","isContainerOrFragment","offsetAfter","clonedNode","nodesToMove","root","group","get","Set","set","add","_clonesGroup","some","a","b","getIdentity","textToMove","slice","_data","t1","t2","nodeBeforeLength","errorContext","validNodesToInsert","validNode","startContainer","endContainer"],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,SAASC,aAAT,QAA8B,WAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,c;AACpB;AACD;AACA;AACC,0BAAaC,QAAb,EAAwB;AAAA;;AACvB;AACF;AACA;AACA;AACA;AACA;AACE,SAAKA,QAAL,GAAgBA,QAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,YAAL,GAAoB,IAAIC,GAAJ,EAApB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACC,sBAAcC,UAAd,EAA0BC,aAA1B,EAAyCC,OAAzC,EAAmD;AAClD,WAAKL,QAAL,CAAcM,SAAd,CAAwBC,MAAxB,CAAgCJ,UAAhC,EAA4CC,aAA5C,EAA2DC,OAA3D;AACA;AAED;AACD;AACA;AAC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EAAqC;AACpC,UAAKnC,aAAa,CAAEyC,QAAF,CAAb,IAA6BN,OAAO,KAAKX,SAA9C,EAA0D;AACzDW,QAAAA,OAAO,GAAGD,KAAV;AACA;;AAEDC,MAAAA,OAAO,CAACO,SAAR,CAAmBD,QAAnB,EAA6BP,KAA7B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,qBAAaO,QAAb,EAAuBN,OAAvB,EAAiC;AAChCA,MAAAA,OAAO,CAACQ,YAAR,CAAsBF,QAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,2BAAmBR,GAAnB,EAAwBC,KAAxB,EAA+BC,OAA/B,EAAyC;AACxCA,MAAAA,OAAO,CAACS,kBAAR,CAA4BX,GAA5B,EAAiCC,KAAjC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,8BAAsBD,GAAtB,EAA2BE,OAA3B,EAAqC;AACpC,aAAOA,OAAO,CAACU,qBAAR,CAA+BZ,GAA/B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAiBa,eAAjB,EAAmC;AAClC,UAAKA,eAAe,YAAY3D,QAAhC,EAA2C;AAC1C,eAAO,KAAK4D,gBAAL,CAAuBD,eAAvB,CAAP;AACA,OAFD,MAEO;AACN,eAAO,KAAKE,qBAAL,CAA4BF,eAA5B,CAAP;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,wBAAgBG,QAAhB,EAA2B;AAC1B,UAAMd,OAAO,GAAGc,QAAQ,CAACC,MAAzB;;AAEA,UAAK,CAAGf,OAAO,CAACgB,EAAR,CAAY,kBAAZ,CAAR,EAA6C;AAC5C;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,KAAX,EAAkBC,GAAlB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,uBAAekB,IAAf,EAAsB;AACrB,aAAO9H,KAAK,CAACgG,SAAN,CAAiB8B,IAAjB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAe/E,OAAf,EAAyB;AACxB,aAAO/C,KAAK,CAAC8F,SAAN,CAAiB/C,OAAjB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAiB9B,UAAjB,EAA6BC,aAA7B,EAA4CC,OAA5C,EAAsD;AACrD,aAAO,IAAIlB,SAAJ,CAAegB,UAAf,EAA2BC,aAA3B,EAA0CC,OAA1C,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sBAAc0C,QAAd,EAAwBoC,KAAxB,EAA+BQ,eAA/B,EAAiD;AAChD,UAAIyB,aAAJ,CADgD,CAGhD;AACA;;AACA,UAAKzB,eAAL,EAAuB;AACtByB,QAAAA,aAAa,GAAGsB,kBAAkB,CAAE3F,QAAF,CAAlC;AACA,OAFD,MAEO;AACNqE,QAAAA,aAAa,GAAGrE,QAAQ,CAACC,MAAT,CAAgBC,EAAhB,CAAoB,OAApB,IAAgCF,QAAQ,CAACC,MAAT,CAAgBA,MAAhD,GAAyDD,QAAQ,CAACC,MAAlF;AACA;;AAED,UAAK,CAACoE,aAAN,EAAsB;AACrB;AACH;AACA;AACA;AACA;AACG,cAAM,IAAI3H,aAAJ,CACL,wCADK,EAEL,KAAKO,QAFA,CAAN;AAIA;;AAED,UAAI2I,i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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/downcastwriter\n */\n\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport RawElement from './rawelement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\nexport default class DowncastWriter {\n\t/**\n\t * @param {module:engine/view/document~Document} document The view document instance.\n\t */\n\tconstructor( document ) {\n\t\t/**\n\t\t * The view document instance in which this writer operates.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t\t * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<String,Set>}\n\t\t */\n\t\tthis._cloneGroups = new Map();\n\t}\n\n\t/**\n\t * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n\t * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n\t *\n\t * Usage:\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets backward selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t * \t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t * \t\t// Removes all ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t *\t\t// Sets selection as fake.\n\t *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * \t\t// represented in other way, for example by applying proper CSS class.\n\t *\t\twriter.setSelection( range, { fake: true } );\n\t *\n\t * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * \t\t// (and be  properly handled by screen readers).\n\t *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n\t * parameters.\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.\n\t *\n\t * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n\t * A list of nodes to be inserted into the created document fragment.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} The created document fragment.\n\t */\n\tcreateDocumentFragment( children ) {\n\t\treturn new DocumentFragment( this.document, children );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\n\t * @param {String} data The text's data.\n\t * @returns {module:engine/view/text~Text} The created text node.\n\t */\n\tcreateText( data ) {\n\t\treturn new Text( this.document, data );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.\n\t *\n\t *\t\twriter.createAttributeElement( 'strong' );\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n\t *\n\t *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n\t *\n\t *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n\t *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n\t *\n\t * **Note:** By default an `AttributeElement` is split by a\n\t * {@link module:engine/view/containerelement~ContainerElement `ContainerElement`} but this behavior can be modified\n\t * with `isAllowedInsideAttributeElement` option set while {@link #createContainerElement creating the element}.\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Element's attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n\t * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n\t */\n\tcreateAttributeElement( name, attributes, options = {} ) {\n\t\tconst attributeElement = new AttributeElement( this.document, name, attributes );\n\n\t\tif ( options.priority ) {\n\t\t\tattributeElement._priority = options.priority;\n\t\t}\n\n\t\tif ( options.id ) {\n\t\t\tattributeElement._id = options.id;\n\t\t}\n\n\t\treturn attributeElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/containerelement~ContainerElement}.\n\t *\n\t *\t\twriter.createContainerElement( 'p' );\n\t *\n\t *\t\t// Create element with custom attributes.\n\t *\t\twriter.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );\n\t *\n\t *\t\t// Create element with custom styles.\n\t *\t\twriter.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );\n\t *\n\t *\t\t// Create element with custom classes.\n\t *\t\twriter.createContainerElement( 'p', { class: 'foo bar baz' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Boolean} [options.isAllowedInsideAttributeElement=false] Whether an element is\n\t * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n\t * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n\t */\n\tcreateContainerElement( name, attributes, options = {} ) {\n\t\tconst containerElement = new ContainerElement( this.document, name, attributes );\n\n\t\tif ( options.isAllowedInsideAttributeElement !== undefined ) {\n\t\t\tcontainerElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n\t\t}\n\n\t\treturn containerElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t *\t\twriter.createEditableElement( 'div' );\n\t *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n\t *\n\t * Note: The editable element is to be used in the editing pipeline. Usually, together with\n\t * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/editableelement~EditableElement} Created element.\n\t */\n\tcreateEditableElement( name, attributes ) {\n\t\tconst editableElement = new EditableElement( this.document, name, attributes );\n\t\teditableElement._document = this.document;\n\n\t\treturn editableElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.\n\t *\n\t *\t\twriter.createEmptyElement( 'img' );\n\t *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n\t * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n\t * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n\t */\n\tcreateEmptyElement( name, attributes, options = {} ) {\n\t\tconst emptyElement = new EmptyElement( this.document, name, attributes );\n\n\t\tif ( options.isAllowedInsideAttributeElement !== undefined ) {\n\t\t\temptyElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n\t\t}\n\n\t\treturn emptyElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/uielement~UIElement}.\n\t *\n\t *\t\twriter.createUIElement( 'span' );\n\t *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n\t *\n\t * A custom render function can be provided as the third parameter:\n\t *\n\t *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n\t *\t\t\tconst domElement = this.toDomElement( domDocument );\n\t *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n\t *\n\t *\t\t\treturn domElement;\n\t *\t\t} );\n\t *\n\t * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,\n\t * they are ignored by the editor selection system.\n\t *\n\t * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.\n\t *\n\t * @param {String} name The name of the element.\n\t * @param {Object} [attributes] Element attributes.\n\t * @param {Function} [renderFunction] A custom render function.\n\t * @param {Object} [options] Element's options.\n\t * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n\t * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n\t * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t * @returns {module:engine/view/uielement~UIElement} The created element.\n\t */\n\tcreateUIElement( name, attributes, renderFunction, options = {} ) {\n\t\tconst uiElement = new UIElement( this.document, name, attributes );\n\n\t\tif ( renderFunction ) {\n\t\t\tuiElement.render = renderFunction;\n\t\t}\n\n\t\tif ( options.isAllowedInsideAttributeElement !== undefined ) {\n\t\t\tuiElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n\t\t}\n\n\t\treturn uiElement;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/rawelement~RawElement}.\n\t *\n\t *\t\twriter.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {\n\t *\t\t\tdomElement.innerHTML = '<b>This is the raw content of the raw element.</b>';\n\t *\t\t} );\n\t *\n\t * Raw elements work as data containers (\"wrappers\", \"sandboxes\") but their children are not managed or\n\t * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures\n\t * in the editor content without, for instance, worrying about compatibility with other editor features.\n\t * Raw elements are a perfect tool for integration with external frameworks and data sources.\n\t *\n\t * Unlike {@link #createUIElement UI elements}, raw elements act like \"real\" editor content (similar to\n\t * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),\n\t * and they are considered by the editor selection.\n\t *\n\t * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}\n\t * instead.\n\t *\n\t * @param {String} name The name of the element.\n\t * @param {Object} [attributes] Element attributes.\n\t * @param {Function} [renderFunction] A custom render function.\n\t * @param {Object} [options] Element's options.\n\t * @param {Boolean} [options.isAllowedInsideAttributeElement=true] Whether an element is\n\t * {@link module:engine/view/element~Element#isAllowedInsideAttributeElement allowed inside an AttributeElement} and can be wrapped\n\t * with {@link module:engine/view/attributeelement~AttributeElement} by {@link module:engine/view/downcastwriter~DowncastWriter}.\n\t * @returns {module:engine/view/rawelement~RawElement} The created element.\n\t */\n\tcreateRawElement( name, attributes, renderFunction, options = {} ) {\n\t\tconst rawElement = new RawElement( this.document, name, attributes );\n\n\t\trawElement.render = renderFunction || ( () => {} );\n\n\t\tif ( options.isAllowedInsideAttributeElement !== undefined ) {\n\t\t\trawElement._isAllowedInsideAttributeElement = options.isAllowedInsideAttributeElement;\n\t\t}\n\n\t\treturn rawElement;\n\t}\n\n\t/**\n\t * Adds or overwrites the element's attribute with a specified key and value.\n\t *\n\t *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n\t *\n\t * @param {String} key The attribute key.\n\t * @param {String} value The attribute value.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetAttribute( key, value, element ) {\n\t\telement._setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes attribute from the element.\n\t *\n\t *\t\twriter.removeAttribute( 'href', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveAttribute( key, element ) {\n\t\telement._removeAttribute( key );\n\t}\n\n\t/**\n\t * Adds specified class to the element.\n\t *\n\t *\t\twriter.addClass( 'foo', linkElement );\n\t *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\taddClass( className, element ) {\n\t\telement._addClass( className );\n\t}\n\n\t/**\n\t * Removes specified class from the element.\n\t *\n\t *\t\twriter.removeClass( 'foo', linkElement );\n\t *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveClass( className, element ) {\n\t\telement._removeClass( className );\n\t}\n\n\t/**\n\t * Adds style to the element.\n\t *\n\t *\t\twriter.setStyle( 'color', 'red', element );\n\t *\t\twriter.setStyle( {\n\t *\t\t\tcolor: 'red',\n\t *\t\t\tposition: 'fixed'\n\t *\t\t}, element );\n\t *\n\t * **Note**: The passed style can be normalized if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n\t *\n\t * @param {String|Object} property Property name or object with key - value pairs.\n\t * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n\t * @param {module:engine/view/element~Element} element Element to set styles on.\n\t */\n\tsetStyle( property, value, element ) {\n\t\tif ( isPlainObject( property ) && element === undefined ) {\n\t\t\telement = value;\n\t\t}\n\n\t\telement._setStyle( property, value );\n\t}\n\n\t/**\n\t * Removes specified style from the element.\n\t *\n\t *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n\t *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n\t *\n\t * **Note**: This method can work with normalized style names if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n\t *\n\t * @param {Array.<String>|String} property\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveStyle( property, element ) {\n\t\telement._removeStyle( property );\n\t}\n\n\t/**\n\t * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n\t * so they can be used to add special data to elements.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {*} value\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetCustomProperty( key, value, element ) {\n\t\telement._setCustomProperty( key, value );\n\t}\n\n\t/**\n\t * Removes a custom property stored under the given key.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean} Returns true if property was removed.\n\t */\n\tremoveCustomProperty( key, element ) {\n\t\treturn element._removeCustomProperty( key );\n\t}\n\n\t/**\n\t * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements\n\t * up to their first ancestor that is a container element.\n\t *\n\t * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:\n\t *\n\t *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n\t *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n\t *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n\t *\n\t * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n\t *\n\t * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.\n\t *\n\t * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n\t * when the {@link module:engine/view/range~Range#start start}\n\t * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n\t *\n\t * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n\t * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n\t * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n\t * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange The position where\n\t * to break attribute elements.\n\t * @returns {module:engine/view/position~Position|module:engine/view/range~Range} The new position or range, after breaking the\n\t * attribute elements.\n\t */\n\tbreakAttributes( positionOrRange ) {\n\t\tif ( positionOrRange instanceof Position ) {\n\t\t\treturn this._breakAttributes( positionOrRange );\n\t\t} else {\n\t\t\treturn this._breakAttributesRange( positionOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.\n\t * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element\n\t * if the position is at the beginning or at the end of its parent element.\n\t *\n\t *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n\t *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n\t *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n\t *\t\t<p>foobar^</p> -> <p>foobar</p>^\n\t *\n\t * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n\t * @param {module:engine/view/position~Position} position The position where to break the element.\n\t * @returns {module:engine/view/position~Position} The position between broken elements. If an element has not been broken,\n\t * the returned position is placed either before or after it.\n\t */\n\tbreakContainer( position ) {\n\t\tconst element = position.parent;\n\n\t\tif ( !( element.is( 'containerElement' ) ) ) {\n\t\t\t/**\n\t\t\t * Trying to break an element which is not a container element.\n\t\t\t *\n\t\t\t * @error view-writer-break-non-container-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-break-non-container-element', this.document );\n\t\t}\n\n\t\tif ( !element.parent ) {\n\t\t\t/**\n\t\t\t * Trying to break root element.\n\t\t\t *\n\t\t\t * @error view-writer-break-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-break-root', this.document );\n\t\t}\n\n\t\tif ( position.isAtStart ) {\n\t\t\treturn Position._createBefore( element );\n\t\t} else if ( !position.isAtEnd ) {\n\t\t\tconst newElement = element._clone( false );\n\n\t\t\tthis.insert( Position._createAfter( element ), newElement );\n\n\t\t\tconst sourceRange = new Range( position, Position._createAt( element, 'end' ) );\n\t\t\tconst targetPosition = new Position( newElement, 0 );\n\n\t\t\tthis.move( sourceRange, targetPosition );\n\t\t}\n\n\t\treturn Position._createAfter( element );\n\t}\n\n\t/**\n\t * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n\t * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n\t *\n\t * In following examples `<p>` is a container and `<b>` is an attribute element:\n\t *\n\t *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n\t *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n\t *\n\t * It will also take care about empty attributes when merging:\n\t *\n\t *\t\t<p><b>[]</b></p> -> <p>[]</p>\n\t *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeAttributes( position ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// When inside text node - nothing to merge.\n\t\tif ( positionParent.is( '$text' ) ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When inside empty attribute - remove it.\n\t\tif ( positionParent.is( 'attributeElement' ) && positionParent.childCount === 0 ) {\n\t\t\tconst parent = positionParent.parent;\n\t\t\tconst offset = positionParent.index;\n\n\t\t\tpositionParent._remove();\n\t\t\tthis._removeFromClonedElementsGroup( positionParent );\n\n\t\t\treturn this.mergeAttributes( new Position( parent, offset ) );\n\t\t}\n\n\t\tconst nodeBefore = positionParent.getChild( positionOffset - 1 );\n\t\tconst nodeAfter = positionParent.getChild( positionOffset );\n\n\t\t// Position should be placed between two nodes.\n\t\tif ( !nodeBefore || !nodeAfter ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When position is between two text nodes.\n\t\tif ( nodeBefore.is( '$text' ) && nodeAfter.is( '$text' ) ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\t\t// When position is between two same attribute elements.\n\t\telse if ( nodeBefore.is( 'attributeElement' ) && nodeAfter.is( 'attributeElement' ) && nodeBefore.isSimilar( nodeAfter ) ) {\n\t\t\t// Move all children nodes from node placed after selection and remove that node.\n\t\t\tconst count = nodeBefore.childCount;\n\t\t\tnodeBefore._appendChild( nodeAfter.getChildren() );\n\n\t\t\tnodeAfter._remove();\n\t\t\tthis._removeFromClonedElementsGroup( nodeAfter );\n\n\t\t\t// New position is located inside the first node, before new nodes.\n\t\t\t// Call this method recursively to merge again if needed.\n\t\t\treturn this.mergeAttributes( new Position( nodeBefore, count ) );\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n\t * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n\t *\n\t *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n\t *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeContainers( position ) {\n\t\tconst prev = position.nodeBefore;\n\t\tconst next = position.nodeAfter;\n\n\t\tif ( !prev || !next || !prev.is( 'containerElement' ) || !next.is( 'containerElement' ) ) {\n\t\t\t/**\n\t\t\t * Element before and after given position cannot be merged.\n\t\t\t *\n\t\t\t * @error view-writer-merge-containers-invalid-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-merge-containers-invalid-position', this.document );\n\t\t}\n\n\t\tconst lastChild = prev.getChild( prev.childCount - 1 );\n\t\tconst newPosition = lastChild instanceof Text ? Position._createAt( lastChild, 'end' ) : Position._createAt( prev, 'end' );\n\n\t\tthis.move( Range._createIn( next ), Position._createAt( prev, 'end' ) );\n\t\tthis.remove( Range._createOn( next ) );\n\n\t\treturn newPosition;\n\t}\n\n\t/**\n\t * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion\n\t * and merging them afterwards.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n\t * contains instances that are not {@link module:engine/view/text~Text Texts},\n\t * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n\t * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n\t * {@link module:engine/view/rawelement~RawElement RawElements} or\n\t * {@link module:engine/view/uielement~UIElement UIElements}.\n\t *\n\t * @param {module:engine/view/position~Position} position Insertion position.\n\t * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n\t * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n\t * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n\t * Iterable.<module:engine/view/text~Text|\n\t * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n\t * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n\t * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n\t * @returns {module:engine/view/range~Range} Range around inserted nodes.\n\t */\n\tinsert( position, nodes ) {\n\t\tnodes = isIterable( nodes ) ? [ ...nodes ] : [ nodes ];\n\n\t\t// Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\t\tvalidateNodesToInsert( nodes, this.document );\n\n\t\t// Group nodes in batches of nodes that require or do not require breaking an AttributeElements.\n\t\tconst nodeGroups = nodes.reduce( ( groups, node ) => {\n\t\t\tconst lastGroup = groups[ groups.length - 1 ];\n\n\t\t\t// Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n\t\t\t// can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n\t\t\tconst breakAttributes = !( node.is( 'uiElement' ) && node.isAllowedInsideAttributeElement );\n\n\t\t\tif ( !lastGroup || lastGroup.breakAttributes != breakAttributes ) {\n\t\t\t\tgroups.push( {\n\t\t\t\t\tbreakAttributes,\n\t\t\t\t\tnodes: [ node ]\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tlastGroup.nodes.push( node );\n\t\t\t}\n\n\t\t\treturn groups;\n\t\t}, [] );\n\n\t\t// Insert nodes in batches.\n\t\tlet start = null;\n\t\tlet end = position;\n\n\t\tfor ( const { nodes, breakAttributes } of nodeGroups ) {\n\t\t\tconst range = this._insertNodes( end, nodes, breakAttributes );\n\n\t\t\tif ( !start ) {\n\t\t\t\tstart = range.start;\n\t\t\t}\n\n\t\t\tend = range.end;\n\t\t}\n\n\t\t// When no nodes were inserted - return collapsed range.\n\t\tif ( !start ) {\n\t\t\treturn new Range( position );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Removes provided range from the container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n\t * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n\t * to a collapsed range showing the new position.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n\t */\n\tremove( rangeOrItem ) {\n\t\tconst range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn( rangeOrItem );\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to remove.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn new DocumentFragment( this.document );\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\tconst count = breakEnd.offset - breakStart.offset;\n\n\t\t// Remove nodes in range.\n\t\tconst removed = parentContainer._removeChildren( breakStart.offset, count );\n\n\t\tfor ( const node of removed ) {\n\t\t\tthis._removeFromClonedElementsGroup( node );\n\t\t}\n\n\t\t// Merge after removing.\n\t\tconst mergePosition = this.mergeAttributes( breakStart );\n\t\trange.start = mergePosition;\n\t\trange.end = mergePosition.clone();\n\n\t\t// Return removed nodes.\n\t\treturn new DocumentFragment( this.document, removed );\n\t}\n\n\t/**\n\t * Removes matching elements from given range.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to clear.\n\t * @param {module:engine/view/element~Element} element Element to remove.\n\t */\n\tclear( range, element ) {\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Create walker on given range.\n\t\t// We walk backward because when we remove element during walk it modifies range end position.\n\t\tconst walker = range.getWalker( {\n\t\t\tdirection: 'backward',\n\t\t\tignoreElementEnd: true\n\t\t} );\n\n\t\t// Let's walk.\n\t\tfor ( const current of walker ) {\n\t\t\tconst item = current.item;\n\t\t\tlet rangeToRemove;\n\n\t\t\t// When current item matches to the given element.\n\t\t\tif ( item.is( 'element' ) && element.isSimilar( item ) ) {\n\t\t\t\t// Create range on this element.\n\t\t\t\trangeToRemove = Range._createOn( item );\n\t\t\t\t// When range starts inside Text or TextProxy element.\n\t\t\t} else if ( !current.nextPosition.isAfter( range.start ) && item.is( '$textProxy' ) ) {\n\t\t\t\t// We need to check if parent of this text matches to given element.\n\t\t\t\tconst parentElement = item.getAncestors().find( ancestor => {\n\t\t\t\t\treturn ancestor.is( 'element' ) && element.isSimilar( ancestor );\n\t\t\t\t} );\n\n\t\t\t\t// If it is then create range inside this element.\n\t\t\t\tif ( parentElement ) {\n\t\t\t\t\trangeToRemove = Range._createIn( parentElement );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have found element to remove.\n\t\t\tif ( rangeToRemove ) {\n\t\t\t\t// We need to check if element range stick out of the given range and truncate if it is.\n\t\t\t\tif ( rangeToRemove.end.isAfter( range.end ) ) {\n\t\t\t\t\trangeToRemove.end = range.end;\n\t\t\t\t}\n\n\t\t\t\tif ( rangeToRemove.start.isBefore( range.start ) ) {\n\t\t\t\t\trangeToRemove.start = range.start;\n\t\t\t\t}\n\n\t\t\t\t// At the end we remove range with found element.\n\t\t\t\tthis.remove( rangeToRemove );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves nodes from provided range to target position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n\t * @param {module:engine/view/position~Position} targetPosition Position to insert.\n\t * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n\t */\n\tmove( sourceRange, targetPosition ) {\n\t\tlet nodes;\n\n\t\tif ( targetPosition.isAfter( sourceRange.end ) ) {\n\t\t\ttargetPosition = this._breakAttributes( targetPosition, true );\n\n\t\t\tconst parent = targetPosition.parent;\n\t\t\tconst countBefore = parent.childCount;\n\n\t\t\tsourceRange = this._breakAttributesRange( sourceRange, true );\n\n\t\t\tnodes = this.remove( sourceRange );\n\n\t\t\ttargetPosition.offset += ( parent.childCount - countBefore );\n\t\t} else {\n\t\t\tnodes = this.remove( sourceRange );\n\t\t}\n\n\t\treturn this.insert( targetPosition, nodes );\n\t}\n\n\t/**\n\t * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n\t *\n\t * If a collapsed range was passed and is same as selection, the selection\n\t * will be moved to the inside of the wrapped attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start}\n\t * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n\t * is collapsed and different than view selection.\n\t *\n\t * **Note:** Attribute elements by default can wrap {@link module:engine/view/text~Text},\n\t * {@link module:engine/view/emptyelement~EmptyElement}, {@link module:engine/view/uielement~UIElement},\n\t * {@link module:engine/view/rawelement~RawElement} and other attribute elements with higher priority. Other elements while placed\n\t * inside an attribute element will split it (or nest it in case of an `AttributeElement`). This behavior can be modified by changing\n\t * the `isAllowedInsideAttributeElement` option while using\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement},\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement},\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement} or\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#createRawElement}.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to wrap.\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n\t * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n\t */\n\twrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-wrap-invalid-attribute',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\tif ( !range.isCollapsed ) {\n\t\t\t// Non-collapsed range. Wrap it with the attribute element.\n\t\t\treturn this._wrapRange( range, attribute );\n\t\t} else {\n\t\t\t// Collapsed range. Wrap position.\n\t\t\tlet position = range.start;\n\n\t\t\tif ( position.parent.is( 'element' ) && !_hasNonUiChildren( position.parent ) ) {\n\t\t\t\tposition = position.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );\n\t\t\t}\n\n\t\t\tposition = this._wrapPosition( position, attribute );\n\t\t\tconst viewSelection = this.document.selection;\n\n\t\t\t// If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\t\t\tif ( viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual( range.start ) ) {\n\t\t\t\tthis.setSelection( position );\n\t\t\t}\n\n\t\t\treturn new Range( position );\n\t\t}\n\t}\n\n\t/**\n\t * Unwraps nodes within provided range from attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t */\n\tunwrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\t/**\n\t\t\t * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#unwrap `DowncastWriter#unwrap()`}\n\t\t\t * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n\t\t\t *\n\t\t\t * @error view-writer-unwrap-invalid-attribute\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-unwrap-invalid-attribute',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to unwrap.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn range;\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Unwrap children located between break points.\n\t\tconst newRange = this._unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n\t * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n\t * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n\t *\n\t * New element has to be created because `Element#tagName` property in DOM is readonly.\n\t *\n\t * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n\t *\n\t * @param {String} newName New name for element.\n\t * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n\t * @returns {module:engine/view/containerelement~ContainerElement} Element created due to rename.\n\t */\n\trename( newName, viewElement ) {\n\t\tconst newElement = new ContainerElement( this.document, newName, viewElement.getAttributes() );\n\n\t\tthis.insert( Position._createAfter( viewElement ), newElement );\n\t\tthis.move( Range._createIn( viewElement ), Position._createAt( newElement, 0 ) );\n\t\tthis.remove( Range._createOn( viewElement ) );\n\n\t\treturn newElement;\n\t}\n\n\t/**\n\t * Cleans up memory by removing obsolete cloned elements group from the writer.\n\t *\n\t * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n\t * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n\t * the group will no longer be needed.\n\t *\n\t * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n\t * were removed from the view.\n\t *\n\t * Keep in mind that group names are equal to the `id` property of the attribute element.\n\t *\n\t * @param {String} groupName Name of the group to clear.\n\t */\n\tclearClonedElementsGroup( groupName ) {\n\t\tthis._cloneGroups.delete( groupName );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/view/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n\t *\n\t * This method is a shortcut to other constructors such as:\n\t *\n\t * * {@link #createPositionBefore},\n\t * * {@link #createPositionAfter},\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn Position._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item after which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn Position._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item before which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn Position._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn Range._createOn( item );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn Range._createIn( element );\n\t}\n\n\t/**\n\t Creates new {@link module:engine/view/selection~Selection} instance.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the document selection.\n\t *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} [selectable=null]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t * @returns {module:engine/view/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new Selection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion\n\t * and merging them afterwards if requested by the breakAttributes param.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position Insertion position.\n\t * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n\t * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n\t * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n\t * Iterable.<module:engine/view/text~Text|\n\t * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n\t * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n\t * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n\t * @param {Boolean} breakAttributes Whether attributes should be broken.\n\t * @returns {module:engine/view/range~Range} Range around inserted nodes.\n\t */\n\t_insertNodes( position, nodes, breakAttributes ) {\n\t\tlet parentElement;\n\n\t\t// Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n\t\t// can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n\t\tif ( breakAttributes ) {\n\t\t\tparentElement = getParentContainer( position );\n\t\t} else {\n\t\t\tparentElement = position.parent.is( '$text' ) ? position.parent.parent : position.parent;\n\t\t}\n\n\t\tif ( !parentElement ) {\n\t\t\t/**\n\t\t\t * Position's parent container cannot be found.\n\t\t\t *\n\t\t\t * @error view-writer-invalid-position-container\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-invalid-position-container',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tlet insertionPosition;\n\n\t\tif ( breakAttributes ) {\n\t\t\tinsertionPosition = this._breakAttributes( position, true );\n\t\t} else {\n\t\t\tinsertionPosition = position.parent.is( '$text' ) ? breakTextNode( position ) : position;\n\t\t}\n\n\t\tconst length = parentElement._insertChild( insertionPosition.offset, nodes );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tthis._addToClonedElementsGroup( node );\n\t\t}\n\n\t\tconst endPosition = insertionPosition.getShiftedBy( length );\n\t\tconst start = this.mergeAttributes( insertionPosition );\n\n\t\t// If start position was merged - move end position.\n\t\tif ( !start.isEqual( insertionPosition ) ) {\n\t\t\tendPosition.offset--;\n\t\t}\n\n\t\tconst end = this.mergeAttributes( endPosition );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be wrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} wrapElement\n\t */\n\t_wrapChildren( parent, startOffset, endOffset, wrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst wrapPositions = [];\n\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\t\t\tconst isText = child.is( '$text' );\n\t\t\tconst isAttribute = child.is( 'attributeElement' );\n\t\t\tconst isAllowedInsideAttributeElement = child.isAllowedInsideAttributeElement;\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n\t\t\t// If possible, join elements.\n\t\t\t//\n\t\t\t// <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n\t\t\t//\n\t\t\tif ( isAttribute && this._wrapAttributeElement( wrapElement, child ) ) {\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n\t\t\t// `wrapElement` (due to priority).\n\t\t\t//\n\t\t\t// <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n\t\t\t// <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n\t\t\telse if ( isText || isAllowedInsideAttributeElement || ( isAttribute && shouldABeOutsideB( wrapElement, child ) ) ) {\n\t\t\t\t// Clone attribute.\n\t\t\t\tconst newAttribute = wrapElement._clone();\n\n\t\t\t\t// Wrap current node with new attribute.\n\t\t\t\tchild._remove();\n\t\t\t\tnewAttribute._appendChild( child );\n\n\t\t\t\tparent._insertChild( i, newAttribute );\n\t\t\t\tthis._addToClonedElementsGroup( newAttribute );\n\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n\t\t\t//\n\t\t\t// <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n\t\t\t//\n\t\t\telse if ( isAttribute ) {\n\t\t\t\tthis._wrapChildren( child, 0, child.childCount, wrapElement );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each wrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of wrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} unwrapElement\n\t */\n\t_unwrapChildren( parent, startOffset, endOffset, unwrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst unwrapPositions = [];\n\n\t\t// Iterate over each element between provided offsets inside parent.\n\t\t// We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n\t\t// so it could get messy. It is safer to it manually in this case.\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\n\t\t\t// Skip all text nodes. There should be no container element's here either.\n\t\t\tif ( !child.is( 'attributeElement' ) ) {\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n\t\t\t//\n\t\t\t// <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n\t\t\t//\n\t\t\tif ( child.isSimilar( unwrapElement ) ) {\n\t\t\t\tconst unwrapped = child.getChildren();\n\t\t\t\tconst count = child.childCount;\n\n\t\t\t\t// Replace wrapper element with its children\n\t\t\t\tchild._remove();\n\t\t\t\tparent._insertChild( i, unwrapped );\n\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\n\t\t\t\t// Save start and end position of moved items.\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + count )\n\t\t\t\t);\n\n\t\t\t\t// Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n\t\t\t\ti += count;\n\t\t\t\tendOffset += count - 1;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n\t\t\t// Partial unwrapping will happen only if the elements have the same name.\n\t\t\t//\n\t\t\t// <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n\t\t\t// <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n\t\t\t//\n\t\t\tif ( this._unwrapAttributeElement( unwrapElement, child ) ) {\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + 1 )\n\t\t\t\t);\n\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If other nested attribute is found, look through it's children for elements to unwrap.\n\t\t\t//\n\t\t\t// <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n\t\t\t//\n\t\t\tthis._unwrapChildren( child, 0, child.childCount, unwrapElement );\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each unwrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of unwrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset || position.offset == endOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n\t */\n\t_wrapRange( range, attribute ) {\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Wrap all children with attribute.\n\t\tconst newRange = this._wrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/position~Position} New position after wrapping.\n\t */\n\t_wrapPosition( position, attribute ) {\n\t\t// Return same position when trying to wrap with attribute similar to position parent.\n\t\tif ( attribute.isSimilar( position.parent ) ) {\n\t\t\treturn movePositionToTextNode( position.clone() );\n\t\t}\n\n\t\t// When position is inside text node - break it and place new position between two text nodes.\n\t\tif ( position.parent.is( '$text' ) ) {\n\t\t\tposition = breakTextNode( position );\n\t\t}\n\n\t\t// Create fake element that will represent position, and will not be merged with other attributes.\n\t\tconst fakePosition = this.createAttributeElement();\n\t\tfakePosition._priority = Number.POSITIVE_INFINITY;\n\t\tfakePosition.isSimilar = () => false;\n\n\t\t// Insert fake element in position location.\n\t\tposition.parent._insertChild( position.offset, fakePosition );\n\n\t\t// Range around inserted fake attribute element.\n\t\tconst wrapRange = new Range( position, position.getShiftedBy( 1 ) );\n\n\t\t// Wrap fake element with attribute (it will also merge if possible).\n\t\tthis.wrap( wrapRange, attribute );\n\n\t\t// Remove fake element and place new position there.\n\t\tconst newPosition = new Position( fakePosition.parent, fakePosition.index );\n\t\tfakePosition._remove();\n\n\t\t// If position is placed between text nodes - merge them and return position inside.\n\t\tconst nodeBefore = newPosition.nodeBefore;\n\t\tconst nodeAfter = newPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof Text && nodeAfter instanceof Text ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\n\t\t// If position is next to text node - move position inside.\n\t\treturn movePositionToTextNode( newPosition );\n\t}\n\n\t/**\n\t * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n\t * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n\t * \telement to element being wrapped.\n\t *\n\t * \t@private\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n\t * \t@returns {Boolean} Returns `true` if elements are merged.\n\t */\n\t_wrapAttributeElement( wrapper, toWrap ) {\n\t\tif ( !canBeJoined( wrapper, toWrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't merge if name or priority differs.\n\t\tif ( wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if attributes can be merged.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are different we cannot wrap.\n\t\t\tif ( toWrap.hasAttribute( key ) && toWrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if styles can be merged.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( toWrap.hasStyle( key ) && toWrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Move only these attributes that are not present - other are similar.\n\t\t\tif ( !toWrap.hasAttribute( key ) ) {\n\t\t\t\tthis.setAttribute( key, wrapper.getAttribute( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( !toWrap.hasStyle( key ) ) {\n\t\t\t\tthis.setStyle( key, wrapper.getStyle( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getClassNames() ) {\n\t\t\tif ( !toWrap.hasClass( key ) ) {\n\t\t\t\tthis.addClass( key, toWrap );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n\t * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n\t * inside element being unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n\t * @returns {Boolean} Returns `true` if elements are unwrapped.\n\t **/\n\t_unwrapAttributeElement( wrapper, toUnwrap ) {\n\t\tif ( !canBeJoined( wrapper, toUnwrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't unwrap if name or priority differs.\n\t\tif ( wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper attributes.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasAttribute( key ) || toUnwrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper classes.\n\t\tif ( !toUnwrap.hasClass( ...wrapper.getClassNames() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper styles.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\t// If some styles are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasStyle( key ) || toUnwrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Remove all wrapper's attributes from unwrapped element.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.removeAttribute( key, toUnwrap );\n\t\t}\n\n\t\t// Remove all wrapper's classes from unwrapped element.\n\t\tthis.removeClass( Array.from( wrapper.getClassNames() ), toUnwrap );\n\n\t\t// Remove all wrapper's styles from unwrapped element.\n\t\tthis.removeStyle( Array.from( wrapper.getStyleNames() ), toUnwrap );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/range~Range} New range with located at break positions.\n\t */\n\t_breakAttributesRange( range, forceSplitText = false ) {\n\t\tconst rangeStart = range.start;\n\t\tconst rangeEnd = range.end;\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Break at the collapsed position. Return new collapsed range.\n\t\tif ( range.isCollapsed ) {\n\t\t\tconst position = this._breakAttributes( range.start, forceSplitText );\n\n\t\t\treturn new Range( position, position );\n\t\t}\n\n\t\tconst breakEnd = this._breakAttributes( rangeEnd, forceSplitText );\n\t\tconst count = breakEnd.parent.childCount;\n\t\tconst breakStart = this._breakAttributes( rangeStart, forceSplitText );\n\n\t\t// Calculate new break end offset.\n\t\tbreakEnd.offset += breakEnd.parent.childCount - count;\n\n\t\treturn new Range( breakStart, breakEnd );\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n\t * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n\t * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position Position where to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n\t */\n\t_breakAttributes( position, forceSplitText = false ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'emptyElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break an `EmptyElement` instance.\n\t\t\t *\n\t\t\t * This error is thrown if\n\t\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n\t\t\t * was executed in an incorrect position.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-empty-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-empty-element', this.document );\n\t\t}\n\n\t\t// If position is placed inside UIElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'uiElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break a `UIElement` instance.\n\t\t\t *\n\t\t\t * This error is thrown if\n\t\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n\t\t\t * was executed in an incorrect position.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-ui-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-ui-element', this.document );\n\t\t}\n\n\t\t// If position is placed inside RawElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'rawElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break a `RawElement` instance.\n\t\t\t *\n\t\t\t * This error is thrown if\n\t\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n\t\t\t * was executed in an incorrect position.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-raw-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-raw-element', this.document );\n\t\t}\n\n\t\t// There are no attributes to break and text nodes breaking is not forced.\n\t\tif ( !forceSplitText && positionParent.is( '$text' ) && isContainerOrFragment( positionParent.parent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Position's parent is container, so no attributes to break.\n\t\tif ( isContainerOrFragment( positionParent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Break text and start again in new position.\n\t\tif ( positionParent.is( '$text' ) ) {\n\t\t\treturn this._breakAttributes( breakTextNode( position ), forceSplitText );\n\t\t}\n\n\t\tconst length = positionParent.childCount;\n\n\t\t// <p>foo<b><u>bar{}</u></b></p>\n\t\t// <p>foo<b><u>bar</u>[]</b></p>\n\t\t// <p>foo<b><u>bar</u></b>[]</p>\n\t\tif ( positionOffset == length ) {\n\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index + 1 );\n\n\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t} else {\n\t\t\t// <p>foo<b><u>{}bar</u></b></p>\n\t\t\t// <p>foo<b>[]<u>bar</u></b></p>\n\t\t\t// <p>foo{}<b><u>bar</u></b></p>\n\t\t\tif ( positionOffset === 0 ) {\n\t\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t\t// <p>foo<b><u>b{}ar</u></b></p>\n\t\t\t// <p>foo<b><u>b[]ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t\t\telse {\n\t\t\t\tconst offsetAfter = positionParent.index + 1;\n\n\t\t\t\t// Break element.\n\t\t\t\tconst clonedNode = positionParent._clone();\n\n\t\t\t\t// Insert cloned node to position's parent node.\n\t\t\t\tpositionParent.parent._insertChild( offsetAfter, clonedNode );\n\t\t\t\tthis._addToClonedElementsGroup( clonedNode );\n\n\t\t\t\t// Get nodes to move.\n\t\t\t\tconst count = positionParent.childCount - positionOffset;\n\t\t\t\tconst nodesToMove = positionParent._removeChildren( positionOffset, count );\n\n\t\t\t\t// Move nodes to cloned node.\n\t\t\t\tclonedNode._appendChild( nodesToMove );\n\n\t\t\t\t// Create new position to work on.\n\t\t\t\tconst newPosition = new Position( positionParent.parent, offsetAfter );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n\t * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n\t * from the group now keep a reference to the given attribute element.\n\t *\n\t * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n\t *\n\t * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n\t */\n\t_addToClonedElementsGroup( element ) {\n\t\t// Add only if the element is in document tree.\n\t\tif ( !element.root.is( 'rootElement' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Traverse the element's children recursively to find other attribute elements that also might got inserted.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._addToClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\tgroup = new Set();\n\t\t\tthis._cloneGroups.set( id, group );\n\t\t}\n\n\t\tgroup.add( element );\n\t\telement._clonesGroup = group;\n\t}\n\n\t/**\n\t * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n\t * from its clones group.\n\t *\n\t * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n\t * This allows to reference the whole group even if the element was already removed from the tree.\n\t *\n\t * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n\t */\n\t_removeFromClonedElementsGroup( element ) {\n\t\t// Traverse the element's children recursively to find other attribute elements that also got removed.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\treturn;\n\t\t}\n\n\t\tgroup.delete( element );\n\t\t// Not removing group from element on purpose!\n\t\t// If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n\t}\n}\n\n// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\nfunction _hasNonUiChildren( parent ) {\n\treturn Array.from( parent.getChildren() ).some( child => !child.is( 'uiElement' ) );\n}\n\n/**\n * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`}\n * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\nfunction getParentContainer( position ) {\n\tlet parent = position.parent;\n\n\twhile ( !isContainerOrFragment( parent ) ) {\n\t\tif ( !parent ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\n\treturn parent;\n}\n\n// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped outside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\nfunction shouldABeOutsideB( a, b ) {\n\tif ( a.priority < b.priority ) {\n\t\treturn true;\n\t} else if ( a.priority > b.priority ) {\n\t\treturn false;\n\t}\n\n\t// When priorities are equal and names are different - use identities.\n\treturn a.getIdentity() < b.getIdentity();\n}\n\n// Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\nfunction movePositionToTextNode( position ) {\n\tconst nodeBefore = position.nodeBefore;\n\n\tif ( nodeBefore && nodeBefore.is( '$text' ) ) {\n\t\treturn new Position( nodeBefore, nodeBefore.data.length );\n\t}\n\n\tconst nodeAfter = position.nodeAfter;\n\n\tif ( nodeAfter && nodeAfter.is( '$text' ) ) {\n\t\treturn new Position( nodeAfter, 0 );\n\t}\n\n\treturn position;\n}\n\n// Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\nfunction breakTextNode( position ) {\n\tif ( position.offset == position.parent.data.length ) {\n\t\treturn new Position( position.parent.parent, position.parent.index + 1 );\n\t}\n\n\tif ( position.offset === 0 ) {\n\t\treturn new Position( position.parent.parent, position.parent.index );\n\t}\n\n\t// Get part of the text that need to be moved.\n\tconst textToMove = position.parent.data.slice( position.offset );\n\n\t// Leave rest of the text in position's parent.\n\tposition.parent._data = position.parent.data.slice( 0, position.offset );\n\n\t// Insert new text node after position's parent text node.\n\tposition.parent.parent._insertChild( position.parent.index + 1, new Text( position.root.document, textToMove ) );\n\n\t// Return new position between two newly created text nodes.\n\treturn new Position( position.parent.parent, position.parent.index + 1 );\n}\n\n// Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\nfunction mergeTextNodes( t1, t2 ) {\n\t// Merge text data into first text node and remove second one.\n\tconst nodeBeforeLength = t1.data.length;\n\tt1._data += t2.data;\n\tt2._remove();\n\n\treturn new Position( t1, nodeBeforeLength );\n}\n\n// Checks if provided nodes are valid to insert.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not supported ones (see error description for valid ones.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/element~Element> nodes\n// @param {Object} errorContext\nfunction validateNodesToInsert( nodes, errorContext ) {\n\tfor ( const node of nodes ) {\n\t\tif ( !validNodesToInsert.some( ( validNode => node instanceof validNode ) ) ) { // eslint-disable-line no-use-before-define\n\t\t\t/**\n\t\t\t * One of the nodes to be inserted is of an invalid type.\n\t\t\t *\n\t\t\t * Nodes to be inserted with {@link module:engine/view/downcastwriter~DowncastWriter#insert `DowncastWriter#insert()`} should be\n\t\t\t * of the following types:\n\t\t\t *\n\t\t\t * * {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n\t\t\t * * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n\t\t\t * * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n\t\t\t * * {@link module:engine/view/uielement~UIElement UIElement},\n\t\t\t * * {@link module:engine/view/rawelement~RawElement RawElement},\n\t\t\t * * {@link module:engine/view/text~Text Text}.\n\t\t\t *\n\t\t\t * @error view-writer-insert-invalid-node-type\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-insert-invalid-node-type', errorContext );\n\t\t}\n\n\t\tif ( !node.is( '$text' ) ) {\n\t\t\tvalidateNodesToInsert( node.getChildren(), errorContext );\n\t\t}\n\t}\n}\n\nconst validNodesToInsert = [ Text, AttributeElement, ContainerElement, EmptyElement, RawElement, UIElement ];\n\n// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\nfunction isContainerOrFragment( node ) {\n\treturn node && ( node.is( 'containerElement' ) || node.is( 'documentFragment' ) );\n}\n\n// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\nfunction validateRangeContainer( range, errorContext ) {\n\tconst startContainer = getParentContainer( range.start );\n\tconst endContainer = getParentContainer( range.end );\n\n\tif ( !startContainer || !endContainer || startContainer !== endContainer ) {\n\t\t/**\n\t\t * The container of the given range is invalid.\n\t\t *\n\t\t * This may happen if {@link module:engine/view/range~Range#start range start} and\n\t\t * {@link module:engine/view/range~Range#end range end} positions are not placed inside the same container element or\n\t\t * a parent container for these positions cannot be found.\n\t\t *\n\t\t * Methods like {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#remove()`},\n\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#clean()`},\n\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`},\n\t\t * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#unwrap()`} need to be called\n\t\t * on a range that has its start and end positions located in the same container element. Both positions can be\n\t\t * nested within other elements (e.g. an attribute element) but the closest container ancestor must be the same.\n\t\t *\n\t\t * @error view-writer-invalid-range-container\n\t\t */\n\t\tthrow new CKEditorError( 'view-writer-invalid-range-container', errorContext );\n\t}\n}\n\n// Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\nfunction canBeJoined( a, b ) {\n\treturn a.id === null && b.id === null;\n}\n"]}]}