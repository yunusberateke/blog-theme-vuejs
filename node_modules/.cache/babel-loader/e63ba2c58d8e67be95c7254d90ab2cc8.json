{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL3V0aWxzL3NlbGVjdGlvbi1wb3N0LWZpeGVyCiAqLwppbXBvcnQgUmFuZ2UgZnJvbSAnLi4vcmFuZ2UnOwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi4vcG9zaXRpb24nOwovKioKICogSW5qZWN0cyBzZWxlY3Rpb24gcG9zdC1maXhlciB0byB0aGUgbW9kZWwuCiAqCiAqIFRoZSByb2xlIG9mIHRoZSBzZWxlY3Rpb24gcG9zdC1maXhlciBpcyB0byBlbnN1cmUgdGhhdCB0aGUgc2VsZWN0aW9uIGlzIGluIGEgY29ycmVjdCBwbGFjZQogKiBhZnRlciBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NoYW5nZSBgY2hhbmdlKClgfSBibG9jayB3YXMgZXhlY3V0ZWQuCiAqCiAqIFRoZSBjb3JyZWN0IHBvc2l0aW9uIG1lYW5zIHRoYXQ6CiAqCiAqICogQWxsIGNvbGxhcHNlZCBzZWxlY3Rpb24gcmFuZ2VzIGFyZSBpbiBhIHBsYWNlIHdoZXJlIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hfQogKiBhbGxvd3MgYSBgJHRleHRgLgogKiAqIE5vbmUgb2YgdGhlIHNlbGVjdGlvbidzIG5vbi1jb2xsYXBzZWQgcmFuZ2VzIGNyb3NzZXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzTGltaXQgbGltaXQgZWxlbWVudH0KICogYm91bmRhcnkgKGEgcmFuZ2UgbXVzdCBiZSByb290ZWQgd2l0aGluIG9uZSBsaW1pdCBlbGVtZW50KS4KICogKiBPbmx5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjaXNTZWxlY3RhYmxlIHNlbGVjdGFibGUgZWxlbWVudHN9IGNhbiBiZSBzZWxlY3RlZCBmcm9tIHRoZSBvdXRzaWRlCiAqIChlLmcuIGBbPHBhcmFncmFwaD5mb288L3BhcmFncmFwaD5dYCBpcyBpbnZhbGlkKS4gVGhpcyBydWxlIGFwcGxpZXMgaW5kZXBlbmRlbnRseSB0byBib3RoIHNlbGVjdGlvbiBlbmRzLCBzbyB0aGlzCiAqIHNlbGVjdGlvbiBpcyBjb3JyZWN0OiBgPHBhcmFncmFwaD5mW29vPC9wYXJhZ3JhcGg+PGltYWdlPjwvaW1hZ2U+XWAuCiAqCiAqIElmIHRoZSBwb3NpdGlvbiBpcyBub3QgY29ycmVjdCwgdGhlIHBvc3QtZml4ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNvcnJlY3QgaXQuCiAqCiAqICMjIEZpeGluZyBhIG5vbi1jb2xsYXBzZWQgc2VsZWN0aW9uCiAqCiAqIFNlZSBhcyBhbiBleGFtcGxlIGEgc2VsZWN0aW9uIHRoYXQgc3RhcnRzIGluIGEgUDEgZWxlbWVudCBhbmQgZW5kcyBpbnNpZGUgdGhlIHRleHQgb2YgYSBURCBlbGVtZW50CiAqIChgW2AgYW5kIGBdYCBhcmUgcmFuZ2UgYm91bmRhcmllcyBhbmQgYChsKWAgZGVub3RlcyBhbiBlbGVtZW50IGRlZmluZWQgYXMgYGlzTGltaXQ9dHJ1ZWApOgogKgogKgkJcm9vdAogKgkJIHwtIGVsZW1lbnQgUDEKICoJCSB8ICAgfC0gImZvbyIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QKICoJCSB8LSBlbGVtZW50IFRBQkxFIChsKSAgICAgICAgICAgICAgICAgICBQMSAgICAgICAgIFRBQkxFICAgICAgICAgICAgIFAyCiAqCQkgfCAgIHwtIGVsZW1lbnQgVFIgKGwpICAgICAgICAgICAgICAgICBmIG9bbyAgICAgVFIgICAgICBUUiAgICAgICAgIGIgYSByCiAqCQkgfCAgIHwgICB8LSBlbGVtZW50IFREIChsKSAgICAgICAgICAgICAgICAgICAgICAgVEQgICAgICBURAogKgkJIHwgICB8ICAgICAgIHwtICJhYWEiICAgICAgICAgICAgICAgICAgICAgICAgICBhXWEgYSAgICBiIGIgYgogKgkJIHwgICB8LSBlbGVtZW50IFRSIChsKQogKgkJIHwgICB8ICAgfC0gZWxlbWVudCBURCAobCkgICAgICAgICAgICAgICAgICAgICAgICAgICB8fAogKgkJIHwgICB8ICAgICAgIHwtICJiYmIiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fAogKgkJIHwtIGVsZW1lbnQgUDIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWVgogKgkJIHwgICB8LSAiYmFyIgogKgkJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdAogKgkJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAxICAgICAgICAgVEFCTEVdICAgICAgICAgICAgUDIKICoJCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgb1tvICAgICBUUiAgICAgIFRSICAgICAgICAgYiBhIHIKICoJCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBURCAgICAgIFRECiAqCQkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgYSBhICAgIGIgYiBiCiAqCiAqIEluIHRoZSBleGFtcGxlIGFib3ZlLCB0aGUgVEFCTEUsIFRSIGFuZCBURCBhcmUgZGVmaW5lZCBhcyBgaXNMaW1pdD10cnVlYCBpbiB0aGUgc2NoZW1hLiBUaGUgcmFuZ2Ugd2hpY2ggaXMgbm90IGNvbnRhaW5lZCB3aXRoaW4KICogYSBzaW5nbGUgbGltaXQgZWxlbWVudCBtdXN0IGJlIGV4cGFuZGVkIHRvIHNlbGVjdCB0aGUgb3V0ZXJtb3N0IGxpbWl0IGVsZW1lbnQuIFRoZSByYW5nZSBlbmQgaXMgaW5zaWRlIHRoZSB0ZXh0IG5vZGUgb2YgdGhlIFREIGVsZW1lbnQuCiAqIEFzIHRoZSBURCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgdGhlIFRSIGFuZCBUQUJMRSBlbGVtZW50cywgd2hlcmUgYm90aCBhcmUgZGVmaW5lZCBhcyBgaXNMaW1pdD10cnVlYCBpbiB0aGUgc2NoZW1hLCB0aGUgcmFuZ2UgbXVzdCBiZQogKiBleHBhbmRlZCB0byBzZWxlY3QgdGhlIHdob2xlIFRBQkxFIGVsZW1lbnQuCiAqCiAqICoqTm90ZSoqIElmIHRoZSBzZWxlY3Rpb24gY29udGFpbnMgbXVsdGlwbGUgcmFuZ2VzLCB0aGUgbWV0aG9kIHJldHVybnMgYSBtaW5pbWFsIHNldCBvZiByYW5nZXMgdGhhdCBhcmUgbm90IGludGVyc2VjdGluZyBhZnRlciBleHBhbmRpbmcKICogdGhlbSB0byBzZWxlY3QgYGlzTGltaXQ9dHJ1ZWAgZWxlbWVudHMuCiAqCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0gbW9kZWwKICovCgpleHBvcnQgZnVuY3Rpb24gaW5qZWN0U2VsZWN0aW9uUG9zdEZpeGVyKG1vZGVsKSB7CiAgbW9kZWwuZG9jdW1lbnQucmVnaXN0ZXJQb3N0Rml4ZXIoZnVuY3Rpb24gKHdyaXRlcikgewogICAgcmV0dXJuIHNlbGVjdGlvblBvc3RGaXhlcih3cml0ZXIsIG1vZGVsKTsKICB9KTsKfSAvLyBUaGUgc2VsZWN0aW9uIHBvc3QtZml4ZXIuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSB3cml0ZXIKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBtb2RlbAoKZnVuY3Rpb24gc2VsZWN0aW9uUG9zdEZpeGVyKHdyaXRlciwgbW9kZWwpIHsKICB2YXIgc2VsZWN0aW9uID0gbW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uOwogIHZhciBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7CiAgdmFyIHJhbmdlcyA9IFtdOwogIHZhciB3YXNGaXhlZCA9IGZhbHNlOwoKICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc2VsZWN0aW9uLmdldFJhbmdlcygpKSwKICAgICAgX3N0ZXA7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykgewogICAgICB2YXIgbW9kZWxSYW5nZSA9IF9zdGVwLnZhbHVlOwogICAgICAvLyBHbyB0aHJvdWdoIGFsbCByYW5nZXMgaW4gc2VsZWN0aW9uIGFuZCB0cnkgZml4aW5nIGVhY2ggb2YgdGhlbS4KICAgICAgLy8gVGhvc2UgcmFuZ2VzIG1pZ2h0IG92ZXJsYXAgYnV0IHdpbGwgYmUgY29ycmVjdGVkIGxhdGVyLgogICAgICB2YXIgY29ycmVjdGVkUmFuZ2UgPSB0cnlGaXhpbmdSYW5nZShtb2RlbFJhbmdlLCBzY2hlbWEpOyAvLyAiU2VsZWN0aW9uIGZpeGluZyIgYWxnb3JpdGhtcyBzb21ldGltZXMgZ2V0IGxvc3QuIEluIGNvbnNlcXVlbmNlLCBpdCBtYXkgaGFwcGVuCiAgICAgIC8vIHRoYXQgYSBuZXcgcmFuZ2UgaXMgcmV0dXJuZWQgYnV0LCBpbiBmYWN0LCBpdCBoYXMgdGhlIHNhbWUgcG9zaXRpb25zIGFzIHRoZSBvcmlnaW5hbAogICAgICAvLyByYW5nZSBhbnl3YXkuIElmIHRoaXMgcmFuZ2UgaXMgbm90IGRpc2NhcmRlZCwgYSBuZXcgc2VsZWN0aW9uIHdpbGwgYmUgc2V0IGFuZCB0aGF0LAogICAgICAvLyBmb3IgaW5zdGFuY2UsIHdvdWxkIGRlc3Ryb3kgdGhlIHNlbGVjdGlvbiBhdHRyaWJ1dGVzLiBMZXQncyBtYWtlIHN1cmUgdGhhdCB0aGUgcG9zdC1maXhlcgogICAgICAvLyBhY3R1YWxseSB3b3JrZWQgZmlyc3QgYmVmb3JlIHNldHRpbmcgYSBuZXcgc2VsZWN0aW9uLgogICAgICAvLwogICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1L2lzc3Vlcy82NjkzCgogICAgICBpZiAoY29ycmVjdGVkUmFuZ2UgJiYgIWNvcnJlY3RlZFJhbmdlLmlzRXF1YWwobW9kZWxSYW5nZSkpIHsKICAgICAgICByYW5nZXMucHVzaChjb3JyZWN0ZWRSYW5nZSk7CiAgICAgICAgd2FzRml4ZWQgPSB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIHJhbmdlcy5wdXNoKG1vZGVsUmFuZ2UpOwogICAgICB9CiAgICB9IC8vIElmIGFueSBvZiByYW5nZXMgd2VyZSBjb3JyZWN0ZWQgdXBkYXRlIHRoZSBzZWxlY3Rpb24uCgogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yLmYoKTsKICB9CgogIGlmICh3YXNGaXhlZCkgewogICAgd3JpdGVyLnNldFNlbGVjdGlvbihtZXJnZUludGVyc2VjdGluZ1JhbmdlcyhyYW5nZXMpLCB7CiAgICAgIGJhY2t3YXJkOiBzZWxlY3Rpb24uaXNCYWNrd2FyZAogICAgfSk7CiAgfQp9IC8vIFRyaWVzIGZpeGluZyBhIHJhbmdlIGlmIGl0J3MgaW5jb3JyZWN0LgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hfSBzY2hlbWEKLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0gUmV0dXJucyBmaXhlZCByYW5nZSBvciBudWxsIGlmIHJhbmdlIGlzIHZhbGlkLgoKCmZ1bmN0aW9uIHRyeUZpeGluZ1JhbmdlKHJhbmdlLCBzY2hlbWEpIHsKICBpZiAocmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgIHJldHVybiB0cnlGaXhpbmdDb2xsYXBzZWRSYW5nZShyYW5nZSwgc2NoZW1hKTsKICB9CgogIHJldHVybiB0cnlGaXhpbmdOb25Db2xsYXBzZWRSYWdlKHJhbmdlLCBzY2hlbWEpOwp9IC8vIFRyaWVzIHRvIGZpeCBjb2xsYXBzZWQgcmFuZ2VzLgovLwovLyAqIEZpeGVzIHNpdHVhdGlvbiB3aGVuIGEgcmFuZ2UgaXMgaW4gYSBwbGFjZSB3aGVyZSAkdGV4dCBpcyBub3QgYWxsb3dlZAovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlIENvbGxhcHNlZCByYW5nZSB0byBmaXguCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hfSBzY2hlbWEKLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0gUmV0dXJucyBmaXhlZCByYW5nZSBvciBudWxsIGlmIHJhbmdlIGlzIHZhbGlkLgoKCmZ1bmN0aW9uIHRyeUZpeGluZ0NvbGxhcHNlZFJhbmdlKHJhbmdlLCBzY2hlbWEpIHsKICB2YXIgb3JpZ2luYWxQb3NpdGlvbiA9IHJhbmdlLnN0YXJ0OwogIHZhciBuZWFyZXN0U2VsZWN0aW9uUmFuZ2UgPSBzY2hlbWEuZ2V0TmVhcmVzdFNlbGVjdGlvblJhbmdlKG9yaWdpbmFsUG9zaXRpb24pOyAvLyBUaGlzIG1pZ2h0IGJlIG51bGwgaWUgd2hlbiBlZGl0b3IgZGF0YSBpcyBlbXB0eS4KICAvLyBJbiBzdWNoIGNhc2VzIHRoZXJlIGlzIG5vIG5lZWQgdG8gZml4IHRoZSBzZWxlY3Rpb24gcmFuZ2UuCgogIGlmICghbmVhcmVzdFNlbGVjdGlvblJhbmdlKSB7CiAgICByZXR1cm4gbnVsbDsKICB9CgogIGlmICghbmVhcmVzdFNlbGVjdGlvblJhbmdlLmlzQ29sbGFwc2VkKSB7CiAgICByZXR1cm4gbmVhcmVzdFNlbGVjdGlvblJhbmdlOwogIH0KCiAgdmFyIGZpeGVkUG9zaXRpb24gPSBuZWFyZXN0U2VsZWN0aW9uUmFuZ2Uuc3RhcnQ7IC8vIEZpeGVkIHBvc2l0aW9uIGlzIHRoZSBzYW1lIGFzIG9yaWdpbmFsIC0gbm8gbmVlZCB0byByZXR1cm4gY29ycmVjdGVkIHJhbmdlLgoKICBpZiAob3JpZ2luYWxQb3NpdGlvbi5pc0VxdWFsKGZpeGVkUG9zaXRpb24pKSB7CiAgICByZXR1cm4gbnVsbDsKICB9CgogIHJldHVybiBuZXcgUmFuZ2UoZml4ZWRQb3NpdGlvbik7Cn0gLy8gVHJpZXMgdG8gZml4IGFuIGV4cGFuZGVkIHJhbmdlLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlIEV4cGFuZGVkIHJhbmdlIHRvIGZpeC4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWF9IHNjaGVtYQovLyBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxudWxsfSBSZXR1cm5zIGZpeGVkIHJhbmdlIG9yIG51bGwgaWYgcmFuZ2UgaXMgdmFsaWQuCgoKZnVuY3Rpb24gdHJ5Rml4aW5nTm9uQ29sbGFwc2VkUmFnZShyYW5nZSwgc2NoZW1hKSB7CiAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsCiAgICAgIGVuZCA9IHJhbmdlLmVuZDsKICB2YXIgaXNUZXh0QWxsb3dlZE9uU3RhcnQgPSBzY2hlbWEuY2hlY2tDaGlsZChzdGFydCwgJyR0ZXh0Jyk7CiAgdmFyIGlzVGV4dEFsbG93ZWRPbkVuZCA9IHNjaGVtYS5jaGVja0NoaWxkKGVuZCwgJyR0ZXh0Jyk7CiAgdmFyIHN0YXJ0TGltaXRFbGVtZW50ID0gc2NoZW1hLmdldExpbWl0RWxlbWVudChzdGFydCk7CiAgdmFyIGVuZExpbWl0RWxlbWVudCA9IHNjaGVtYS5nZXRMaW1pdEVsZW1lbnQoZW5kKTsgLy8gUmFuZ2VzIHdoaWNoIGJvdGggZW5kIGFyZSBpbnNpZGUgdGhlIHNhbWUgbGltaXQgZWxlbWVudCAob3Igcm9vdCkgbWlnaHQgbmVlZHMgb25seSBtaW5vciBmaXguCgogIGlmIChzdGFydExpbWl0RWxlbWVudCA9PT0gZW5kTGltaXRFbGVtZW50KSB7CiAgICAvLyBSYW5nZSBpcyB2YWxpZCB3aGVuIGJvdGggcG9zaXRpb24gYWxsb3dzIHRvIHBsYWNlIGEgdGV4dDoKICAgIC8vIC0gPGJsb2NrPmZbb29iYXJiYV16PC9ibG9jaz4KICAgIC8vIFRoaXMgd291bGQgYmUgImZpeGVkIiBieSBhIG5leHQgY2hlY2sgYnV0IGFzIGl0IHdpbGwgYmUgdGhlIHNhbWUgaXQncyBiZXR0ZXIgdG8gcmV0dXJuIG51bGwgc28gdGhlIHNlbGVjdGlvbiBzdGF5cyB0aGUgc2FtZS4KICAgIGlmIChpc1RleHRBbGxvd2VkT25TdGFydCAmJiBpc1RleHRBbGxvd2VkT25FbmQpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9IC8vIFJhbmdlIHRoYXQgaXMgb24gbm9uLWxpbWl0IGVsZW1lbnQgKG9yIGlzIHBhcnRpYWxseSkgbXVzdCBiZSBmaXhlZCBzbyBpdCBpcyBwbGFjZWQgaW5zaWRlIHRoZSBibG9jayBhcm91bmQgJHRleHQ6CiAgICAvLyAtIFs8YmxvY2s+Zm9vPC9ibG9jaz5dICAgIC0+ICAgIDxibG9jaz5bZm9vXTwvYmxvY2s+CiAgICAvLyAtIFs8YmxvY2s+Zm9vXTwvYmxvY2s+ICAgIC0+ICAgIDxibG9jaz5bZm9vXTwvYmxvY2s+CiAgICAvLyAtIDxibG9jaz5mW29vPC9ibG9jaz5dICAgIC0+ICAgIDxibG9jaz5mW29vXTwvYmxvY2s+CiAgICAvLyAtIFs8YmxvY2s+Zm9vPC9ibG9jaz48c2VsZWN0YWJsZT48L3NlbGVjdGFibGU+XSAgICAtPiAgICA8YmxvY2s+W2ZvbzwvYmxvY2s+PHNlbGVjdGFibGU+PC9zZWxlY3RhYmxlPl0KCgogICAgaWYgKGNoZWNrU2VsZWN0aW9uT25Ob25MaW1pdEVsZW1lbnRzKHN0YXJ0LCBlbmQsIHNjaGVtYSkpIHsKICAgICAgdmFyIGlzU3RhcnRCZWZvcmVTZWxlY3RhYmxlID0gc3RhcnQubm9kZUFmdGVyICYmIHNjaGVtYS5pc1NlbGVjdGFibGUoc3RhcnQubm9kZUFmdGVyKTsKICAgICAgdmFyIGZpeGVkU3RhcnQgPSBpc1N0YXJ0QmVmb3JlU2VsZWN0YWJsZSA/IG51bGwgOiBzY2hlbWEuZ2V0TmVhcmVzdFNlbGVjdGlvblJhbmdlKHN0YXJ0LCAnZm9yd2FyZCcpOwogICAgICB2YXIgaXNFbmRBZnRlclNlbGVjdGFibGUgPSBlbmQubm9kZUJlZm9yZSAmJiBzY2hlbWEuaXNTZWxlY3RhYmxlKGVuZC5ub2RlQmVmb3JlKTsKICAgICAgdmFyIGZpeGVkRW5kID0gaXNFbmRBZnRlclNlbGVjdGFibGUgPyBudWxsIDogc2NoZW1hLmdldE5lYXJlc3RTZWxlY3Rpb25SYW5nZShlbmQsICdiYWNrd2FyZCcpOyAvLyBUaGUgc2NoZW1hLmdldE5lYXJlc3RTZWxlY3Rpb25SYW5nZSBtaWdodCByZXR1cm4gbnVsbCAtIGlmIHRoYXQgaGFwcGVucyB1c2Ugb3JpZ2luYWwgcG9zaXRpb24uCgogICAgICB2YXIgcmFuZ2VTdGFydCA9IGZpeGVkU3RhcnQgPyBmaXhlZFN0YXJ0LnN0YXJ0IDogc3RhcnQ7CiAgICAgIHZhciByYW5nZUVuZCA9IGZpeGVkRW5kID8gZml4ZWRFbmQuZW5kIDogZW5kOwogICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlU3RhcnQsIHJhbmdlRW5kKTsKICAgIH0KICB9CgogIHZhciBpc1N0YXJ0SW5MaW1pdCA9IHN0YXJ0TGltaXRFbGVtZW50ICYmICFzdGFydExpbWl0RWxlbWVudC5pcygncm9vdEVsZW1lbnQnKTsKICB2YXIgaXNFbmRJbkxpbWl0ID0gZW5kTGltaXRFbGVtZW50ICYmICFlbmRMaW1pdEVsZW1lbnQuaXMoJ3Jvb3RFbGVtZW50Jyk7IC8vIEF0IHRoaXMgcG9pbnQgd2UgZWxpbWluYXRlZCB2YWxpZCBwb3NpdGlvbnMgb24gdGV4dCBub2RlcyBzbyBpZiBvbmUgb2YgcmFuZ2UgcG9zaXRpb25zIGlzIHBsYWNlZCBpbnNpZGUgYSBsaW1pdCBlbGVtZW50CiAgLy8gdGhlbiB0aGUgcmFuZ2UgY3Jvc3NlZCBsaW1pdCBlbGVtZW50IGJvdW5kYXJpZXMgYW5kIG5lZWRzIHRvIGJlIGZpeGVkLgoKICBpZiAoaXNTdGFydEluTGltaXQgfHwgaXNFbmRJbkxpbWl0KSB7CiAgICB2YXIgYm90aEluU2FtZVBhcmVudCA9IHN0YXJ0Lm5vZGVBZnRlciAmJiBlbmQubm9kZUJlZm9yZSAmJiBzdGFydC5ub2RlQWZ0ZXIucGFyZW50ID09PSBlbmQubm9kZUJlZm9yZS5wYXJlbnQ7CiAgICB2YXIgZXhwYW5kU3RhcnQgPSBpc1N0YXJ0SW5MaW1pdCAmJiAoIWJvdGhJblNhbWVQYXJlbnQgfHwgIWlzU2VsZWN0YWJsZShzdGFydC5ub2RlQWZ0ZXIsIHNjaGVtYSkpOwogICAgdmFyIGV4cGFuZEVuZCA9IGlzRW5kSW5MaW1pdCAmJiAoIWJvdGhJblNhbWVQYXJlbnQgfHwgIWlzU2VsZWN0YWJsZShlbmQubm9kZUJlZm9yZSwgc2NoZW1hKSk7IC8vIEFsdGhvdWdoIHdlJ3ZlIGFscmVhZHkgZm91bmQgbGltaXQgZWxlbWVudCBvbiBzdGFydC9lbmQgcG9zaXRpb25zIHdlIG11c3QgZmluZCB0aGUgb3V0ZXItbW9zdCBsaW1pdCBlbGVtZW50LgogICAgLy8gYXMgbGltaXQgZWxlbWVudHMgbWlnaHQgYmUgbmVzdGVkIGRpcmVjdGx5IGluc2lkZSAoaWUgdGFibGUgPiB0YWJsZVJvdyA+IHRhYmxlQ2VsbCkuCgogICAgdmFyIF9maXhlZFN0YXJ0ID0gc3RhcnQ7CiAgICB2YXIgX2ZpeGVkRW5kID0gZW5kOwoKICAgIGlmIChleHBhbmRTdGFydCkgewogICAgICBfZml4ZWRTdGFydCA9IFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoZmluZE91dGVybW9zdExpbWl0QW5jZXN0b3Ioc3RhcnRMaW1pdEVsZW1lbnQsIHNjaGVtYSkpOwogICAgfQoKICAgIGlmIChleHBhbmRFbmQpIHsKICAgICAgX2ZpeGVkRW5kID0gUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGZpbmRPdXRlcm1vc3RMaW1pdEFuY2VzdG9yKGVuZExpbWl0RWxlbWVudCwgc2NoZW1hKSk7CiAgICB9CgogICAgcmV0dXJuIG5ldyBSYW5nZShfZml4ZWRTdGFydCwgX2ZpeGVkRW5kKTsKICB9IC8vIFJhbmdlIHdhcyBub3QgZml4ZWQgYXQgdGhpcyBwb2ludCBzbyBpdCBpcyB2YWxpZCAtIGllIGl0IHdhcyBwbGFjZWQgYXJvdW5kIGxpbWl0IGVsZW1lbnQgYWxyZWFkeS4KCgogIHJldHVybiBudWxsOwp9IC8vIEZpbmRzIHRoZSBvdXRlci1tb3N0IGFuY2VzdG9yLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBzdGFydGluZ05vZGUKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWF9IHNjaGVtYQovLyBAcGFyYW0ge1N0cmluZ30gZXhwYW5kVG9EaXJlY3Rpb24gRGlyZWN0aW9uIG9mIGV4cGFuc2lvbiAtIGVpdGhlciAnc3RhcnQnIG9yICdlbmQnIG9mIHRoZSByYW5nZS4KLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfQoKCmZ1bmN0aW9uIGZpbmRPdXRlcm1vc3RMaW1pdEFuY2VzdG9yKHN0YXJ0aW5nTm9kZSwgc2NoZW1hKSB7CiAgdmFyIGlzTGltaXROb2RlID0gc3RhcnRpbmdOb2RlOwogIHZhciBwYXJlbnQgPSBpc0xpbWl0Tm9kZTsgLy8gRmluZCBvdXRlciBtb3N0IGlzTGltaXQgYmxvY2sgYXMgc3VjaCBibG9ja3MgbWlnaHQgYmUgbmVzdGVkIChpZS4gaW4gdGFibGVzKS4KCiAgd2hpbGUgKHNjaGVtYS5pc0xpbWl0KHBhcmVudCkgJiYgcGFyZW50LnBhcmVudCkgewogICAgaXNMaW1pdE5vZGUgPSBwYXJlbnQ7CiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50OwogIH0KCiAgcmV0dXJuIGlzTGltaXROb2RlOwp9IC8vIENoZWNrcyB3aGV0aGVyIGFueSBvZiByYW5nZSBib3VuZGFyaWVzIGlzIHBsYWNlZCBhcm91bmQgbm9uLWxpbWl0IGVsZW1lbnRzLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHN0YXJ0Ci8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gZW5kCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hfSBzY2hlbWEKLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb25Pbk5vbkxpbWl0RWxlbWVudHMoc3RhcnQsIGVuZCwgc2NoZW1hKSB7CiAgdmFyIHN0YXJ0SXNPbkJsb2NrID0gc3RhcnQubm9kZUFmdGVyICYmICFzY2hlbWEuaXNMaW1pdChzdGFydC5ub2RlQWZ0ZXIpIHx8IHNjaGVtYS5jaGVja0NoaWxkKHN0YXJ0LCAnJHRleHQnKTsKICB2YXIgZW5kSXNPbkJsb2NrID0gZW5kLm5vZGVCZWZvcmUgJiYgIXNjaGVtYS5pc0xpbWl0KGVuZC5ub2RlQmVmb3JlKSB8fCBzY2hlbWEuY2hlY2tDaGlsZChlbmQsICckdGV4dCcpOyAvLyBXZSBzaG91bGQgZml4IHN1Y2ggc2VsZWN0aW9uIHdoZW4gb25lIG9mIHRob3NlIG5vZGVzIG5lZWRzIGZpeGluZy4KCiAgcmV0dXJuIHN0YXJ0SXNPbkJsb2NrIHx8IGVuZElzT25CbG9jazsKfSAvLyBSZXR1cm5zIGEgbWluaW1hbCBub24taW50ZXJzZWN0aW5nIGFycmF5IG9mIHJhbmdlcy4KLy8KLy8gQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IHJhbmdlcwovLyBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fQoKCmZ1bmN0aW9uIG1lcmdlSW50ZXJzZWN0aW5nUmFuZ2VzKHJhbmdlcykgewogIHZhciBub25JbnRlcnNlY3RpbmdSYW5nZXMgPSBbXTsgLy8gRmlyc3QgcmFuZ2Ugd2lsbCBhbHdheXMgYmUgZmluZS4KCiAgbm9uSW50ZXJzZWN0aW5nUmFuZ2VzLnB1c2gocmFuZ2VzLnNoaWZ0KCkpOwoKICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJhbmdlcyksCiAgICAgIF9zdGVwMjsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciByYW5nZSA9IF9zdGVwMi52YWx1ZTsKICAgICAgdmFyIHByZXZpb3VzUmFuZ2UgPSBub25JbnRlcnNlY3RpbmdSYW5nZXMucG9wKCk7CgogICAgICBpZiAocmFuZ2UuaXNFcXVhbChwcmV2aW91c1JhbmdlKSkgewogICAgICAgIC8vIFVzZSBvbmx5IG9uZSBvZiB0d28gaWRlbnRpY2FsIHJhbmdlcy4KICAgICAgICBub25JbnRlcnNlY3RpbmdSYW5nZXMucHVzaChwcmV2aW91c1JhbmdlKTsKICAgICAgfSBlbHNlIGlmIChyYW5nZS5pc0ludGVyc2VjdGluZyhwcmV2aW91c1JhbmdlKSkgewogICAgICAgIC8vIEdldCB0aGUgc3VtIG9mIHR3byByYW5nZXMuCiAgICAgICAgdmFyIHN0YXJ0ID0gcHJldmlvdXNSYW5nZS5zdGFydC5pc0FmdGVyKHJhbmdlLnN0YXJ0KSA/IHJhbmdlLnN0YXJ0IDogcHJldmlvdXNSYW5nZS5zdGFydDsKICAgICAgICB2YXIgZW5kID0gcHJldmlvdXNSYW5nZS5lbmQuaXNBZnRlcihyYW5nZS5lbmQpID8gcHJldmlvdXNSYW5nZS5lbmQgOiByYW5nZS5lbmQ7CiAgICAgICAgdmFyIG1lcmdlZCA9IG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgICAgICBub25JbnRlcnNlY3RpbmdSYW5nZXMucHVzaChtZXJnZWQpOwogICAgICB9IGVsc2UgewogICAgICAgIG5vbkludGVyc2VjdGluZ1Jhbmdlcy5wdXNoKHByZXZpb3VzUmFuZ2UpOwogICAgICAgIG5vbkludGVyc2VjdGluZ1Jhbmdlcy5wdXNoKHJhbmdlKTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjIuZigpOwogIH0KCiAgcmV0dXJuIG5vbkludGVyc2VjdGluZ1JhbmdlczsKfSAvLyBDaGVja3MgaWYgbm9kZSBleGlzdHMgYW5kIGlmIGl0J3MgYSBzZWxlY3RhYmxlLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hfSBzY2hlbWEKLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gaXNTZWxlY3RhYmxlKG5vZGUsIHNjaGVtYSkgewogIHJldHVybiBub2RlICYmIHNjaGVtYS5pc1NlbGVjdGFibGUobm9kZSk7Cn0="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js"],"names":["Range","Position","injectSelectionPostFixer","model","document","registerPostFixer","writer","selectionPostFixer","selection","schema","ranges","wasFixed","getRanges","modelRange","correctedRange","tryFixingRange","isEqual","push","setSelection","mergeIntersectingRanges","backward","isBackward","range","isCollapsed","tryFixingCollapsedRange","tryFixingNonCollapsedRage","originalPosition","start","nearestSelectionRange","getNearestSelectionRange","fixedPosition","end","isTextAllowedOnStart","checkChild","isTextAllowedOnEnd","startLimitElement","getLimitElement","endLimitElement","checkSelectionOnNonLimitElements","isStartBeforeSelectable","nodeAfter","isSelectable","fixedStart","isEndAfterSelectable","nodeBefore","fixedEnd","rangeStart","rangeEnd","isStartInLimit","is","isEndInLimit","bothInSameParent","parent","expandStart","expandEnd","_createBefore","findOutermostLimitAncestor","_createAfter","startingNode","isLimitNode","isLimit","startIsOnBlock","endIsOnBlock","nonIntersectingRanges","shift","previousRange","pop","isIntersecting","isAfter","merged","node"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/selection-post-fixer\n */\n\nimport Range from '../range';\nimport Position from '../position';\n\n/**\n * Injects selection post-fixer to the model.\n *\n * The role of the selection post-fixer is to ensure that the selection is in a correct place\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct position means that:\n *\n * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}\n * allows a `$text`.\n * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}\n * boundary (a range must be rooted within one limit element).\n * * Only {@link module:engine/model/schema~Schema#isSelectable selectable elements} can be selected from the outside\n * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this\n * selection is correct: `<paragraph>f[oo</paragraph><image></image>]`.\n *\n * If the position is not correct, the post-fixer will automatically correct it.\n *\n * ## Fixing a non-collapsed selection\n *\n * See as an example a selection that starts in a P1 element and ends inside the text of a TD element\n * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):\n *\n *\t\troot\n *\t\t |- element P1\n *\t\t |   |- \"foo\"                                      root\n *\t\t |- element TABLE (l)                   P1         TABLE             P2\n *\t\t |   |- element TR (l)                 f o[o     TR      TR         b a r\n *\t\t |   |   |- element TD (l)                       TD      TD\n *\t\t |   |       |- \"aaa\"                          a]a a    b b b\n *\t\t |   |- element TR (l)\n *\t\t |   |   |- element TD (l)                           ||\n *\t\t |   |       |- \"bbb\"                                ||\n *\t\t |- element P2                                       VV\n *\t\t |   |- \"bar\"\n *\t\t                                                   root\n *\t\t                                        P1         TABLE]            P2\n *\t\t                                       f o[o     TR      TR         b a r\n *\t\t                                                 TD      TD\n *\t\t                                               a a a    b b b\n *\n * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within\n * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.\n * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be\n * expanded to select the whole TABLE element.\n *\n * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding\n * them to select `isLimit=true` elements.\n *\n * @param {module:engine/model/model~Model} model\n */\nexport function injectSelectionPostFixer( model ) {\n\tmodel.document.registerPostFixer( writer => selectionPostFixer( writer, model ) );\n}\n\n// The selection post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\nfunction selectionPostFixer( writer, model ) {\n\tconst selection = model.document.selection;\n\tconst schema = model.schema;\n\n\tconst ranges = [];\n\n\tlet wasFixed = false;\n\n\tfor ( const modelRange of selection.getRanges() ) {\n\t\t// Go through all ranges in selection and try fixing each of them.\n\t\t// Those ranges might overlap but will be corrected later.\n\t\tconst correctedRange = tryFixingRange( modelRange, schema );\n\n\t\t// \"Selection fixing\" algorithms sometimes get lost. In consequence, it may happen\n\t\t// that a new range is returned but, in fact, it has the same positions as the original\n\t\t// range anyway. If this range is not discarded, a new selection will be set and that,\n\t\t// for instance, would destroy the selection attributes. Let's make sure that the post-fixer\n\t\t// actually worked first before setting a new selection.\n\t\t//\n\t\t// https://github.com/ckeditor/ckeditor5/issues/6693\n\t\tif ( correctedRange && !correctedRange.isEqual( modelRange ) ) {\n\t\t\tranges.push( correctedRange );\n\t\t\twasFixed = true;\n\t\t} else {\n\t\t\tranges.push( modelRange );\n\t\t}\n\t}\n\n\t// If any of ranges were corrected update the selection.\n\tif ( wasFixed ) {\n\t\twriter.setSelection( mergeIntersectingRanges( ranges ), { backward: selection.isBackward } );\n\t}\n}\n\n// Tries fixing a range if it's incorrect.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingRange( range, schema ) {\n\tif ( range.isCollapsed ) {\n\t\treturn tryFixingCollapsedRange( range, schema );\n\t}\n\n\treturn tryFixingNonCollapsedRage( range, schema );\n}\n\n// Tries to fix collapsed ranges.\n//\n// * Fixes situation when a range is in a place where $text is not allowed\n//\n// @param {module:engine/model/range~Range} range Collapsed range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingCollapsedRange( range, schema ) {\n\tconst originalPosition = range.start;\n\n\tconst nearestSelectionRange = schema.getNearestSelectionRange( originalPosition );\n\n\t// This might be null ie when editor data is empty.\n\t// In such cases there is no need to fix the selection range.\n\tif ( !nearestSelectionRange ) {\n\t\treturn null;\n\t}\n\n\tif ( !nearestSelectionRange.isCollapsed ) {\n\t\treturn nearestSelectionRange;\n\t}\n\n\tconst fixedPosition = nearestSelectionRange.start;\n\n\t// Fixed position is the same as original - no need to return corrected range.\n\tif ( originalPosition.isEqual( fixedPosition ) ) {\n\t\treturn null;\n\t}\n\n\treturn new Range( fixedPosition );\n}\n\n// Tries to fix an expanded range.\n//\n// @param {module:engine/model/range~Range} range Expanded range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\nfunction tryFixingNonCollapsedRage( range, schema ) {\n\tconst { start, end } = range;\n\n\tconst isTextAllowedOnStart = schema.checkChild( start, '$text' );\n\tconst isTextAllowedOnEnd = schema.checkChild( end, '$text' );\n\n\tconst startLimitElement = schema.getLimitElement( start );\n\tconst endLimitElement = schema.getLimitElement( end );\n\n\t// Ranges which both end are inside the same limit element (or root) might needs only minor fix.\n\tif ( startLimitElement === endLimitElement ) {\n\t\t// Range is valid when both position allows to place a text:\n\t\t// - <block>f[oobarba]z</block>\n\t\t// This would be \"fixed\" by a next check but as it will be the same it's better to return null so the selection stays the same.\n\t\tif ( isTextAllowedOnStart && isTextAllowedOnEnd ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:\n\t\t// - [<block>foo</block>]    ->    <block>[foo]</block>\n\t\t// - [<block>foo]</block>    ->    <block>[foo]</block>\n\t\t// - <block>f[oo</block>]    ->    <block>f[oo]</block>\n\t\t// - [<block>foo</block><selectable></selectable>]    ->    <block>[foo</block><selectable></selectable>]\n\t\tif ( checkSelectionOnNonLimitElements( start, end, schema ) ) {\n\t\t\tconst isStartBeforeSelectable = start.nodeAfter && schema.isSelectable( start.nodeAfter );\n\t\t\tconst fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange( start, 'forward' );\n\n\t\t\tconst isEndAfterSelectable = end.nodeBefore && schema.isSelectable( end.nodeBefore );\n\t\t\tconst fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange( end, 'backward' );\n\n\t\t\t// The schema.getNearestSelectionRange might return null - if that happens use original position.\n\t\t\tconst rangeStart = fixedStart ? fixedStart.start : start;\n\t\t\tconst rangeEnd = fixedEnd ? fixedEnd.end : end;\n\n\t\t\treturn new Range( rangeStart, rangeEnd );\n\t\t}\n\t}\n\n\tconst isStartInLimit = startLimitElement && !startLimitElement.is( 'rootElement' );\n\tconst isEndInLimit = endLimitElement && !endLimitElement.is( 'rootElement' );\n\n\t// At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element\n\t// then the range crossed limit element boundaries and needs to be fixed.\n\tif ( isStartInLimit || isEndInLimit ) {\n\t\tconst bothInSameParent = ( start.nodeAfter && end.nodeBefore ) && start.nodeAfter.parent === end.nodeBefore.parent;\n\n\t\tconst expandStart = isStartInLimit && ( !bothInSameParent || !isSelectable( start.nodeAfter, schema ) );\n\t\tconst expandEnd = isEndInLimit && ( !bothInSameParent || !isSelectable( end.nodeBefore, schema ) );\n\n\t\t// Although we've already found limit element on start/end positions we must find the outer-most limit element.\n\t\t// as limit elements might be nested directly inside (ie table > tableRow > tableCell).\n\t\tlet fixedStart = start;\n\t\tlet fixedEnd = end;\n\n\t\tif ( expandStart ) {\n\t\t\tfixedStart = Position._createBefore( findOutermostLimitAncestor( startLimitElement, schema ) );\n\t\t}\n\n\t\tif ( expandEnd ) {\n\t\t\tfixedEnd = Position._createAfter( findOutermostLimitAncestor( endLimitElement, schema ) );\n\t\t}\n\n\t\treturn new Range( fixedStart, fixedEnd );\n\t}\n\n\t// Range was not fixed at this point so it is valid - ie it was placed around limit element already.\n\treturn null;\n}\n\n// Finds the outer-most ancestor.\n//\n// @param {module:engine/model/node~Node} startingNode\n// @param {module:engine/model/schema~Schema} schema\n// @param {String} expandToDirection Direction of expansion - either 'start' or 'end' of the range.\n// @returns {module:engine/model/node~Node}\nfunction findOutermostLimitAncestor( startingNode, schema ) {\n\tlet isLimitNode = startingNode;\n\tlet parent = isLimitNode;\n\n\t// Find outer most isLimit block as such blocks might be nested (ie. in tables).\n\twhile ( schema.isLimit( parent ) && parent.parent ) {\n\t\tisLimitNode = parent;\n\t\tparent = parent.parent;\n\t}\n\n\treturn isLimitNode;\n}\n\n// Checks whether any of range boundaries is placed around non-limit elements.\n//\n// @param {module:engine/model/position~Position} start\n// @param {module:engine/model/position~Position} end\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction checkSelectionOnNonLimitElements( start, end, schema ) {\n\tconst startIsOnBlock = ( start.nodeAfter && !schema.isLimit( start.nodeAfter ) ) || schema.checkChild( start, '$text' );\n\tconst endIsOnBlock = ( end.nodeBefore && !schema.isLimit( end.nodeBefore ) ) || schema.checkChild( end, '$text' );\n\n\t// We should fix such selection when one of those nodes needs fixing.\n\treturn startIsOnBlock || endIsOnBlock;\n}\n\n// Returns a minimal non-intersecting array of ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @returns {Array.<module:engine/model/range~Range>}\nfunction mergeIntersectingRanges( ranges ) {\n\tconst nonIntersectingRanges = [];\n\n\t// First range will always be fine.\n\tnonIntersectingRanges.push( ranges.shift() );\n\n\tfor ( const range of ranges ) {\n\t\tconst previousRange = nonIntersectingRanges.pop();\n\n\t\tif ( range.isEqual( previousRange ) ) {\n\t\t\t// Use only one of two identical ranges.\n\t\t\tnonIntersectingRanges.push( previousRange );\n\t\t} else if ( range.isIntersecting( previousRange ) ) {\n\t\t\t// Get the sum of two ranges.\n\t\t\tconst start = previousRange.start.isAfter( range.start ) ? range.start : previousRange.start;\n\t\t\tconst end = previousRange.end.isAfter( range.end ) ? previousRange.end : range.end;\n\n\t\t\tconst merged = new Range( start, end );\n\t\t\tnonIntersectingRanges.push( merged );\n\t\t} else {\n\t\t\tnonIntersectingRanges.push( previousRange );\n\t\t\tnonIntersectingRanges.push( range );\n\t\t}\n\t}\n\n\treturn nonIntersectingRanges;\n}\n\n// Checks if node exists and if it's a selectable.\n//\n// @param {module:engine/model/node~Node} node\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\nfunction isSelectable( node, schema ) {\n\treturn node && schema.isSelectable( node );\n}\n"]}]}