{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIudXJsLnRvLWpzb24uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvbW9kZWwvcG9zaXRpb24KICovCmltcG9ydCBUcmVlV2Fsa2VyIGZyb20gJy4vdHJlZXdhbGtlcic7CmltcG9ydCBjb21wYXJlQXJyYXlzIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NvbXBhcmVhcnJheXMnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsgLy8gVG8gY2hlY2sgaWYgY29tcG9uZW50IGlzIGxvYWRlZCBtb3JlIHRoYW4gb25jZS4KCmltcG9ydCAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvdmVyc2lvbic7Ci8qKgogKiBSZXByZXNlbnRzIGEgcG9zaXRpb24gaW4gdGhlIG1vZGVsIHRyZWUuCiAqCiAqIEEgcG9zaXRpb24gaXMgcmVwcmVzZW50ZWQgYnkgaXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3Jvb3R9IGFuZAogKiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGh9IGluIHRoYXQgcm9vdC4KICoKICogWW91IGNhbiBjcmVhdGUgcG9zaXRpb24gaW5zdGFuY2VzIHZpYSBpdHMgY29uc3RydWN0b3Igb3IgdGhlIGBjcmVhdGVQb3NpdGlvbiooKWAgZmFjdG9yeSBtZXRob2RzIG9mCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0uCiAqCiAqICoqTm90ZToqKiBQb3NpdGlvbiBpcyBiYXNlZCBvbiBvZmZzZXRzLCBub3QgaW5kZXhlcy4gVGhpcyBtZWFucyB0aGF0IGEgcG9zaXRpb24gYmV0d2VlbiB0d28gdGV4dCBub2RlcwogKiBgZm9vYCBhbmQgYGJhcmAgaGFzIG9mZnNldCBgM2AsIG5vdCBgMWAuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRofSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4KICoKICogU2luY2UgYSBwb3NpdGlvbiBpbiB0aGUgbW9kZWwgaXMgcmVwcmVzZW50ZWQgYnkgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNyb290IHBvc2l0aW9uIHJvb3R9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRoIHBvc2l0aW9uIHBhdGh9IGl0IGlzIHBvc3NpYmxlIHRvIGNyZWF0ZSBwb3NpdGlvbnMgcGxhY2VkIGluIG5vbi1leGlzdGluZyBwbGFjZXMuCiAqIFRoaXMgcmVxdWlyZW1lbnQgaXMgaW1wb3J0YW50IGZvciBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiBhbGdvcml0aG1zLgogKgogKiBBbHNvLCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbiBvcGVyYXRpb25zfQogKiBrZXB0IGluIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNoaXN0b3J5IGRvY3VtZW50IGhpc3Rvcnl9CiAqIGFyZSBzdG9yaW5nIHBvc2l0aW9ucyAoYW5kIHJhbmdlcykgd2hpY2ggd2VyZSBjb3JyZWN0IHdoZW4gdGhvc2Ugb3BlcmF0aW9ucyB3ZXJlIGFwcGxpZWQsIGJ1dCBtYXkgbm90IGJlIGNvcnJlY3QKICogYWZ0ZXIgdGhlIGRvY3VtZW50IGhhcyBjaGFuZ2VkLgogKgogKiBXaGVuIGNoYW5nZXMgYXJlIGFwcGxpZWQgdG8gdGhlIG1vZGVsLCBpdCBtYXkgYWxzbyBoYXBwZW4gdGhhdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcG9zaXRpb24gcGFyZW50fQogKiB3aWxsIGNoYW5nZSBldmVuIGlmIHBvc2l0aW9uIHBhdGggaGFzIG5vdCBjaGFuZ2VkLiBLZWVwIGluIG1pbmQsIHRoYXQgaWYgYSBwb3NpdGlvbiBsZWFkcyB0byBub24tZXhpc3RpbmcgZWxlbWVudCwKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50fSBhbmQgc29tZSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHdpbGwgdGhyb3cgZXJyb3JzLgogKgogKiBJbiBtb3N0IGNhc2VzLCBwb3NpdGlvbiB3aXRoIHdyb25nIHBhdGggaXMgY2F1c2VkIGJ5IGFuIGVycm9yIGluIGNvZGUsIGJ1dCBpdCBpcyBzb21ldGltZXMgbmVlZGVkLCBhcyBkZXNjcmliZWQgYWJvdmUuCiAqLwoKdmFyIFBvc2l0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGEgcG9zaXRpb24uCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSByb290IFJvb3Qgb2YgdGhlIHBvc2l0aW9uLgogICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj59IHBhdGggUG9zaXRpb24gcGF0aC4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGh9LgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblN0aWNraW5lc3N9IFtzdGlja2luZXNzPSd0b05vbmUnXSBQb3NpdGlvbiBzdGlja2luZXNzLgogICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblN0aWNraW5lc3N9LgogICAqLwogIGZ1bmN0aW9uIFBvc2l0aW9uKHJvb3QsIHBhdGgpIHsKICAgIHZhciBzdGlja2luZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndG9Ob25lJzsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zaXRpb24pOwoKICAgIGlmICghcm9vdC5pcygnZWxlbWVudCcpICYmICFyb290LmlzKCdkb2N1bWVudEZyYWdtZW50JykpIHsKICAgICAgLyoqCiAgICAgICAqIFBvc2l0aW9uIHJvb3QgaXMgaW52YWxpZC4KICAgICAgICoKICAgICAgICogUG9zaXRpb25zIGNhbiBvbmx5IGJlIGFuY2hvcmVkIGluIGVsZW1lbnRzIG9yIGRvY3VtZW50IGZyYWdtZW50cy4KICAgICAgICoKICAgICAgICogQGVycm9yIG1vZGVsLXBvc2l0aW9uLXJvb3QtaW52YWxpZAogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXBvc2l0aW9uLXJvb3QtaW52YWxpZCcsIHJvb3QpOwogICAgfQoKICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkgfHwgcGF0aC5sZW5ndGggPT09IDApIHsKICAgICAgLyoqCiAgICAgICAqIFBvc2l0aW9uIHBhdGggbXVzdCBiZSBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBpdGVtLgogICAgICAgKgogICAgICAgKiBAZXJyb3IgbW9kZWwtcG9zaXRpb24tcGF0aC1pbmNvcnJlY3QtZm9ybWF0CiAgICAgICAqIEBwYXJhbSBwYXRoCiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tcGF0aC1pbmNvcnJlY3QtZm9ybWF0Jywgcm9vdCwgewogICAgICAgIHBhdGg6IHBhdGgKICAgICAgfSk7CiAgICB9IC8vIE5vcm1hbGl6ZSB0aGUgcm9vdCBhbmQgcGF0aCB3aGVuIGVsZW1lbnQgKG5vdCByb290KSBpcyBwYXNzZWQuCgoKICAgIGlmIChyb290LmlzKCdyb290RWxlbWVudCcpKSB7CiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKCk7CiAgICB9IGVsc2UgewogICAgICBwYXRoID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyb290LmdldFBhdGgoKSksIF90b0NvbnN1bWFibGVBcnJheShwYXRoKSk7CiAgICAgIHJvb3QgPSByb290LnJvb3Q7CiAgICB9CiAgICAvKioKICAgICAqIFJvb3Qgb2YgdGhlIHBvc2l0aW9uIHBhdGguCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcm9vdAogICAgICovCgoKICAgIHRoaXMucm9vdCA9IHJvb3Q7CiAgICAvKioKICAgICAqIFBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHRoZSB0cmVlLiAqKlBhdGggY29udGFpbnMgb2Zmc2V0cywgbm90IGluZGV4ZXMuKioKICAgICAqCiAgICAgKiBQb3NpdGlvbiBjYW4gYmUgcGxhY2VkIGJlZm9yZSwgYWZ0ZXIgb3IgaW4gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUgbm9kZX0gaWYgdGhhdCBub2RlIGhhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI29mZnNldFNpemV9IGdyZWF0ZXIgdGhhbiBgMWAuIEl0ZW1zIGluIHBvc2l0aW9uIHBhdGggYXJlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjc3RhcnRPZmZzZXQgc3RhcnRpbmcgb2Zmc2V0c30gb2YgcG9zaXRpb24gYW5jZXN0b3JzLCBzdGFydGluZyBmcm9tIGRpcmVjdCByb290IGNoaWxkcmVuLAogICAgICogZG93biB0byB0aGUgcG9zaXRpb24gb2Zmc2V0IGluIGl0J3MgcGFyZW50LgogICAgICoKICAgICAqCQkgUk9PVAogICAgICoJCSAgfC0gUCAgICAgICAgICAgIGJlZm9yZTogWyAwIF0gICAgICAgICBhZnRlcjogWyAxIF0KICAgICAqCQkgIHwtIFVMICAgICAgICAgICBiZWZvcmU6IFsgMSBdICAgICAgICAgYWZ0ZXI6IFsgMiBdCiAgICAgKgkJICAgICB8LSBMSSAgICAgICAgYmVmb3JlOiBbIDEsIDAgXSAgICAgIGFmdGVyOiBbIDEsIDEgXQogICAgICoJCSAgICAgfCAgfC0gZm9vICAgIGJlZm9yZTogWyAxLCAwLCAwIF0gICBhZnRlcjogWyAxLCAwLCAzIF0KICAgICAqCQkgICAgIHwtIExJICAgICAgICBiZWZvcmU6IFsgMSwgMSBdICAgICAgYWZ0ZXI6IFsgMSwgMiBdCiAgICAgKgkJICAgICAgICB8LSBiYXIgICAgYmVmb3JlOiBbIDEsIDEsIDAgXSAgIGFmdGVyOiBbIDEsIDEsIDMgXQogICAgICoKICAgICAqIGBmb29gIGFuZCBgYmFyYCBhcmUgcmVwcmVzZW50aW5nIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCB0ZXh0IG5vZGVzfS4gU2luY2UgdGV4dCBub2RlcyBoYXMgb2Zmc2V0IHNpemUKICAgICAqIGdyZWF0ZXIgdGhhbiBgMWAgeW91IGNhbiBwbGFjZSBwb3NpdGlvbiBvZmZzZXQgYmV0d2VlbiB0aGVpciBzdGFydCBhbmQgZW5kOgogICAgICoKICAgICAqCQkgUk9PVAogICAgICoJCSAgfC0gUAogICAgICoJCSAgfC0gVUwKICAgICAqCQkgICAgIHwtIExJCiAgICAgKgkJICAgICB8ICB8LSBmXm98byAgXiBoYXMgcGF0aDogWyAxLCAwLCAxIF0gICB8IGhhcyBwYXRoOiBbIDEsIDAsIDIgXQogICAgICoJCSAgICAgfC0gTEkKICAgICAqCQkgICAgICAgIHwtIGJeYXxyICBeIGhhcyBwYXRoOiBbIDEsIDEsIDEgXSAgIHwgaGFzIHBhdGg6IFsgMSwgMSwgMiBdCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtBcnJheS48TnVtYmVyPn0gbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRoCiAgICAgKi8KCiAgICB0aGlzLnBhdGggPSBwYXRoOwogICAgLyoqCiAgICAgKiBQb3NpdGlvbiBzdGlja2luZXNzLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfS4KICAgICAqCiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30gbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNzdGlja2luZXNzCiAgICAgKi8KCiAgICB0aGlzLnN0aWNraW5lc3MgPSBzdGlja2luZXNzOwogIH0KICAvKioKICAgKiBPZmZzZXQgYXQgd2hpY2ggdGhpcyBwb3NpdGlvbiBpcyBsb2NhdGVkIGluIGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcGFyZW50fS4gSXQgaXMgZXF1YWwKICAgKiB0byB0aGUgbGFzdCBpdGVtIGluIHBvc2l0aW9uIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGggcGF0aH0uCiAgICoKICAgKiBAdHlwZSB7TnVtYmVyfQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFBvc2l0aW9uLCBbewogICAga2V5OiAib2Zmc2V0IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTsKICAgIH0sCiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdPZmZzZXQpIHsKICAgICAgdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSA9IG5ld09mZnNldDsKICAgIH0KICAgIC8qKgogICAgICogUGFyZW50IGVsZW1lbnQgb2YgdGhpcyBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBLZWVwIGluIG1pbmQgdGhhdCBgcGFyZW50YCB2YWx1ZSBpcyBjYWxjdWxhdGVkIHdoZW4gdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkLgogICAgICogSWYge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aCBwb3NpdGlvbiBwYXRofQogICAgICogbGVhZHMgdG8gYSBub24tZXhpc3RpbmcgZWxlbWVudCwgYHBhcmVudGAgcHJvcGVydHkgd2lsbCB0aHJvdyBlcnJvci4KICAgICAqCiAgICAgKiBBbHNvIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGNhY2hlIGBwYXJlbnRgIHByb3BlcnR5IGlmIGl0IGlzIHVzZWQgZnJlcXVlbnRseSBpbiBhbiBhbGdvcml0aG0gKGkuZS4gaW4gYSBsb25nIGxvb3ApLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICovCgogIH0sIHsKICAgIGtleTogInBhcmVudCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIHBhcmVudCA9IHRoaXMucm9vdDsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aCAtIDE7IGkrKykgewogICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRDaGlsZChwYXJlbnQub2Zmc2V0VG9JbmRleCh0aGlzLnBhdGhbaV0pKTsKCiAgICAgICAgaWYgKCFwYXJlbnQpIHsKICAgICAgICAgIC8qKgogICAgICAgICAgICogVGhlIHBvc2l0aW9uJ3MgcGF0aCBpcyBpbmNvcnJlY3QuIFRoaXMgbWVhbnMgdGhhdCBhIHBvc2l0aW9uIGRvZXMgbm90IHBvaW50IHRvCiAgICAgICAgICAgKiBhIGNvcnJlY3QgcGxhY2UgaW4gdGhlIHRyZWUgYW5kIGhlbmNlLCBzb21lIG9mIGl0cyBtZXRob2RzIGFuZCBnZXR0ZXJzIGNhbm5vdCB3b3JrIGNvcnJlY3RseS4KICAgICAgICAgICAqCiAgICAgICAgICAgKiAqKk5vdGUqKjogVW5saWtlIERPTSBhbmQgdmlldyBwb3NpdGlvbnMsIGluIHRoZSBtb2RlbCwgdGhlCiAgICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcG9zaXRpb24ncyBwYXJlbnR9IGlzIGFsd2F5cyBhbiBlbGVtZW50IG9yIGEgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgICAgICAgKiBUaGUgbGFzdCBvZmZzZXQgaW4gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGggcG9zaXRpb24ncyBwYXRofSBpcyB0aGUgcG9pbnQgaW4gdGhpcyBlbGVtZW50CiAgICAgICAgICAgKiB3aGVyZSB0aGlzIHBvc2l0aW9uIHBvaW50cy4KICAgICAgICAgICAqCiAgICAgICAgICAgKiBSZWFkIG1vcmUgYWJvdXQgbW9kZWwgcG9zaXRpb25zIGFuZCBvZmZzZXRzIGluCiAgICAgICAgICAgKiB0aGUge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2FyY2hpdGVjdHVyZS9lZGl0aW5nLWVuZ2luZSNpbmRleGVzLWFuZC1vZmZzZXRzIEVkaXRpbmcgZW5naW5lIGFyY2hpdGVjdHVyZSBndWlkZX0uCiAgICAgICAgICAgKgogICAgICAgICAgICogQGVycm9yIG1vZGVsLXBvc2l0aW9uLXBhdGgtaW5jb3JyZWN0CiAgICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFRoZSBpbmNvcnJlY3QgcG9zaXRpb24uCiAgICAgICAgICAgKi8KICAgICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1wb3NpdGlvbi1wYXRoLWluY29ycmVjdCcsIHRoaXMsIHsKICAgICAgICAgICAgcG9zaXRpb246IHRoaXMKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHBhcmVudC5pcygnJHRleHQnKSkgewogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1wb3NpdGlvbi1wYXRoLWluY29ycmVjdCcsIHRoaXMsIHsKICAgICAgICAgIHBvc2l0aW9uOiB0aGlzCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBwYXJlbnQ7CiAgICB9CiAgICAvKioKICAgICAqIFBvc2l0aW9uIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI29mZnNldCBvZmZzZXR9IGNvbnZlcnRlZCB0byBhbiBpbmRleCBpbiBwb3NpdGlvbidzIHBhcmVudCBub2RlLiBJdCBpcwogICAgICogZXF1YWwgdG8gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNpbmRleCBpbmRleH0gb2YgYSBub2RlIGFmdGVyIHRoaXMgcG9zaXRpb24uIElmIHBvc2l0aW9uIGlzIHBsYWNlZAogICAgICogaW4gdGV4dCBub2RlLCBwb3NpdGlvbiBpbmRleCBpcyBlcXVhbCB0byB0aGUgaW5kZXggb2YgdGhhdCB0ZXh0IG5vZGUuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogIH0sIHsKICAgIGtleTogImluZGV4IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2Zmc2V0VG9JbmRleCh0aGlzLm9mZnNldCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0IHRleHQgbm9kZX0gaW5zdGFuY2UgaW4gd2hpY2ggdGhpcyBwb3NpdGlvbiBpcyBwbGFjZWQgb3IgYG51bGxgIGlmIHRoaXMKICAgICAqIHBvc2l0aW9uIGlzIG5vdCBpbiBhIHRleHQgbm9kZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogInRleHROb2RlIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gZ2V0VGV4dE5vZGVBdFBvc2l0aW9uKHRoaXMsIHRoaXMucGFyZW50KTsKICAgIH0KICAgIC8qKgogICAgICogTm9kZSBkaXJlY3RseSBhZnRlciB0aGlzIHBvc2l0aW9uIG9yIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGluIHRleHQgbm9kZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogIm5vZGVBZnRlciIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgLy8gQ2FjaGUgdGhlIHBhcmVudCBhbmQgcmV1c2UgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIFNlZSAjNjU3OSBhbmQgIzY1ODIuCiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDsKICAgICAgcmV0dXJuIGdldE5vZGVBZnRlclBvc2l0aW9uKHRoaXMsIHBhcmVudCwgZ2V0VGV4dE5vZGVBdFBvc2l0aW9uKHRoaXMsIHBhcmVudCkpOwogICAgfQogICAgLyoqCiAgICAgKiBOb2RlIGRpcmVjdGx5IGJlZm9yZSB0aGlzIHBvc2l0aW9uIG9yIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGluIHRleHQgbm9kZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogIm5vZGVCZWZvcmUiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIC8vIENhY2hlIHRoZSBwYXJlbnQgYW5kIHJldXNlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBTZWUgIzY1NzkgYW5kICM2NTgyLgogICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7CiAgICAgIHJldHVybiBnZXROb2RlQmVmb3JlUG9zaXRpb24odGhpcywgcGFyZW50LCBnZXRUZXh0Tm9kZUF0UG9zaXRpb24odGhpcywgcGFyZW50KSk7CiAgICB9CiAgICAvKioKICAgICAqIElzIGB0cnVlYCBpZiBwb3NpdGlvbiBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcGFyZW50fSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0F0U3RhcnQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLm9mZnNldCA9PT0gMDsKICAgIH0KICAgIC8qKgogICAgICogSXMgYHRydWVgIGlmIHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2YgaXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhcmVudCBwYXJlbnR9LCBgZmFsc2VgIG90aGVyd2lzZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQXRFbmQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLm9mZnNldCA9PSB0aGlzLnBhcmVudC5tYXhPZmZzZXQ7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcG9zaXRpb24gaXMgYmVmb3JlIG9yIGFmdGVyIGdpdmVuIHBvc2l0aW9uLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gdXNlIGl0IG9uIG5vbi1leGlzdGluZyBwb3NpdGlvbnMgKGZvciBleGFtcGxlIGR1cmluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbikuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBvdGhlclBvc2l0aW9uIFBvc2l0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uUmVsYXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29tcGFyZVdpdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKG90aGVyUG9zaXRpb24pIHsKICAgICAgaWYgKHRoaXMucm9vdCAhPSBvdGhlclBvc2l0aW9uLnJvb3QpIHsKICAgICAgICByZXR1cm4gJ2RpZmZlcmVudCc7CiAgICAgIH0KCiAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXJyYXlzKHRoaXMucGF0aCwgb3RoZXJQb3NpdGlvbi5wYXRoKTsKCiAgICAgIHN3aXRjaCAocmVzdWx0KSB7CiAgICAgICAgY2FzZSAnc2FtZSc6CiAgICAgICAgICByZXR1cm4gJ3NhbWUnOwoKICAgICAgICBjYXNlICdwcmVmaXgnOgogICAgICAgICAgcmV0dXJuICdiZWZvcmUnOwoKICAgICAgICBjYXNlICdleHRlbnNpb24nOgogICAgICAgICAgcmV0dXJuICdhZnRlcic7CgogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoW3Jlc3VsdF0gPCBvdGhlclBvc2l0aW9uLnBhdGhbcmVzdWx0XSA/ICdiZWZvcmUnIDogJ2FmdGVyJzsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBmYXJ0aGVzdCBwb3NpdGlvbiB3aGljaCBtYXRjaGVzIHRoZSBjYWxsYmFjayB1c2luZwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyIFRyZWVXYWxrZXJ9LgogICAgICoKICAgICAqIEZvciBleGFtcGxlOgogICAgICoKICAgICAqIAkJZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oIHZhbHVlID0+IHZhbHVlLnR5cGUgPT0gJ3RleHQnICk7CiAgICAgKiAJCS8vIDxwYXJhZ3JhcGg+W11mb288L3BhcmFncmFwaD4gLT4gPHBhcmFncmFwaD5mb29bXTwvcGFyYWdyYXBoPgogICAgICoKICAgICAqIAkJZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oIHZhbHVlID0+IHZhbHVlLnR5cGUgPT0gJ3RleHQnLCB7IGRpcmVjdGlvbjogJ2JhY2t3YXJkJyB9ICk7CiAgICAgKiAJCS8vIDxwYXJhZ3JhcGg+Zm9vW108L3BhcmFncmFwaD4gLT4gPHBhcmFncmFwaD5bXWZvbzwvcGFyYWdyYXBoPgogICAgICoKICAgICAqIAkJZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oIHZhbHVlID0+IGZhbHNlICk7CiAgICAgKiAJCS8vIERvIG5vdCBtb3ZlIHRoZSBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBza2lwIENhbGxiYWNrIGZ1bmN0aW9uLiBHZXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfSBhbmQgc2hvdWxkCiAgICAgKiByZXR1cm4gYHRydWVgIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgc2tpcHBlZCBvciBgZmFsc2VgIGlmIG5vdC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFRoZSBwb3NpdGlvbiBhZnRlciB0aGUgbGFzdCBpdGVtIHdoaWNoIG1hdGNoZXMgdGhlIGBza2lwYCBjYWxsYmFjayB0ZXN0LgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldExhc3RNYXRjaGluZ1Bvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihza2lwKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTsKICAgICAgb3B0aW9ucy5zdGFydFBvc2l0aW9uID0gdGhpczsKICAgICAgdmFyIHRyZWVXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKICAgICAgdHJlZVdhbGtlci5za2lwKHNraXApOwogICAgICByZXR1cm4gdHJlZVdhbGtlci5wb3NpdGlvbjsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHBhdGggdG8gdGhpcyBwb3NpdGlvbidzIHBhcmVudC4gUGFyZW50IHBhdGggaXMgZXF1YWwgdG8gcG9zaXRpb24ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aCBwYXRofQogICAgICogYnV0IHdpdGhvdXQgdGhlIGxhc3QgaXRlbS4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAgICoKICAgICAqIEByZXR1cm5zIHtBcnJheS48TnVtYmVyPn0gUGF0aCB0byB0aGUgcGFyZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFBhcmVudFBhdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcmVudFBhdGgoKSB7CiAgICAgIHJldHVybiB0aGlzLnBhdGguc2xpY2UoMCwgLTEpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuY2VzdG9ycyBhcnJheSBvZiB0aGlzIHBvc2l0aW9uLCB0aGF0IGlzIHRoaXMgcG9zaXRpb24ncyBwYXJlbnQgYW5kIGl0cyBhbmNlc3RvcnMuCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbT59IEFycmF5IHdpdGggYW5jZXN0b3JzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEFuY2VzdG9ycyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QW5jZXN0b3JzKCkgewogICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7CgogICAgICBpZiAocGFyZW50LmlzKCdkb2N1bWVudEZyYWdtZW50JykpIHsKICAgICAgICByZXR1cm4gW3BhcmVudF07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHBhcmVudC5nZXRBbmNlc3RvcnMoewogICAgICAgICAgaW5jbHVkZVNlbGY6IHRydWUKICAgICAgICB9KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbmFtZS4gUmV0dXJucyBudWxsIGlmIHRoZSBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIHRoZSBkZXNpcmVkIHBhcmVudC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFyZW50IGVsZW1lbnQgdG8gZmluZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImZpbmRBbmNlc3RvciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFuY2VzdG9yKHBhcmVudE5hbWUpIHsKICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50OwoKICAgICAgaWYgKHBhcmVudC5pcygnZWxlbWVudCcpKSB7CiAgICAgICAgcmV0dXJuIHBhcmVudC5maW5kQW5jZXN0b3IocGFyZW50TmFtZSwgewogICAgICAgICAgaW5jbHVkZVNlbGY6IHRydWUKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIHNsaWNlIG9mIHR3byBwb3NpdGlvbiB7QGxpbmsgI3BhdGggcGF0aHN9IHdoaWNoIGlzIGlkZW50aWNhbC4gVGhlIHtAbGluayAjcm9vdCByb290c30KICAgICAqIG9mIHRoZXNlIHR3byBwYXRocyBtdXN0IGJlIGlkZW50aWNhbC4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gVGhlIHNlY29uZCBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHtBcnJheS48TnVtYmVyPn0gVGhlIGNvbW1vbiBwYXRoLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENvbW1vblBhdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbW1vblBhdGgocG9zaXRpb24pIHsKICAgICAgaWYgKHRoaXMucm9vdCAhPSBwb3NpdGlvbi5yb290KSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9IC8vIFdlIGZpbmQgb24gd2hpY2ggdHJlZS1sZXZlbCBzdGFydCBhbmQgZW5kIGhhdmUgdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3IKCgogICAgICB2YXIgY21wID0gY29tcGFyZUFycmF5cyh0aGlzLnBhdGgsIHBvc2l0aW9uLnBhdGgpOyAvLyBJZiBjb21wYXJpc29uIHJldHVybmVkIHN0cmluZyBpdCBtZWFucyB0aGF0IGFycmF5cyBhcmUgc2FtZS4KCiAgICAgIHZhciBkaWZmQXQgPSB0eXBlb2YgY21wID09ICdzdHJpbmcnID8gTWF0aC5taW4odGhpcy5wYXRoLmxlbmd0aCwgcG9zaXRpb24ucGF0aC5sZW5ndGgpIDogY21wOwogICAgICByZXR1cm4gdGhpcy5wYXRoLnNsaWNlKDAsIGRpZmZBdCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICAgKiB3aGljaCBpcyBhIGNvbW1vbiBhbmNlc3RvciBvZiBib3RoIHBvc2l0aW9ucy4gVGhlIHtAbGluayAjcm9vdCByb290c30gb2YgdGhlc2UgdHdvIHBvc2l0aW9ucyBtdXN0IGJlIGlkZW50aWNhbC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFRoZSBzZWNvbmQgcG9zaXRpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDb21tb25BbmNlc3RvciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29tbW9uQW5jZXN0b3IocG9zaXRpb24pIHsKICAgICAgdmFyIGFuY2VzdG9yc0EgPSB0aGlzLmdldEFuY2VzdG9ycygpOwogICAgICB2YXIgYW5jZXN0b3JzQiA9IHBvc2l0aW9uLmdldEFuY2VzdG9ycygpOwogICAgICB2YXIgaSA9IDA7CgogICAgICB3aGlsZSAoYW5jZXN0b3JzQVtpXSA9PSBhbmNlc3RvcnNCW2ldICYmIGFuY2VzdG9yc0FbaV0pIHsKICAgICAgICBpKys7CiAgICAgIH0KCiAgICAgIHJldHVybiBpID09PSAwID8gbnVsbCA6IGFuY2VzdG9yc0FbaSAtIDFdOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIGBQb3NpdGlvbmAsIHRoYXQgaGFzIHNhbWUge0BsaW5rICNwYXJlbnQgcGFyZW50fSBidXQgaXQncyBvZmZzZXQKICAgICAqIGlzIHNoaWZ0ZWQgYnkgYHNoaWZ0YCB2YWx1ZSAoY2FuIGJlIGEgbmVnYXRpdmUgdmFsdWUpLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gdXNlIGl0IG9uIG5vbi1leGlzdGluZyBwb3NpdGlvbnMgKGZvciBleGFtcGxlIGR1cmluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbikuCiAgICAgKgogICAgICogQHBhcmFtIHtOdW1iZXJ9IHNoaWZ0IE9mZnNldCBzaGlmdC4gQ2FuIGJlIGEgbmVnYXRpdmUgdmFsdWUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gU2hpZnRlZCBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRTaGlmdGVkQnkiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoaWZ0ZWRCeShzaGlmdCkgewogICAgICB2YXIgc2hpZnRlZCA9IHRoaXMuY2xvbmUoKTsKICAgICAgdmFyIG9mZnNldCA9IHNoaWZ0ZWQub2Zmc2V0ICsgc2hpZnQ7CiAgICAgIHNoaWZ0ZWQub2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQ7CiAgICAgIHJldHVybiBzaGlmdGVkOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHBvc2l0aW9uIGlzIGFmdGVyIGdpdmVuIHBvc2l0aW9uLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gdXNlIGl0IG9uIG5vbi1leGlzdGluZyBwb3NpdGlvbnMgKGZvciBleGFtcGxlIGR1cmluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbikuCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI2lzQmVmb3JlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IG90aGVyUG9zaXRpb24gUG9zaXRpb24gdG8gY29tcGFyZSB3aXRoLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhpcyBwb3NpdGlvbiBpcyBhZnRlciBnaXZlbiBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0FmdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FmdGVyKG90aGVyUG9zaXRpb24pIHsKICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVdpdGgob3RoZXJQb3NpdGlvbikgPT0gJ2FmdGVyJzsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKgogICAgICogKipOb3RlOioqIHdhdGNoIG91dCB3aGVuIHVzaW5nIG5lZ2F0aW9uIG9mIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCwgYmVjYXVzZSB0aGUgbmVnYXRpb24gd2lsbCBhbHNvCiAgICAgKiBiZSBgdHJ1ZWAgaWYgcG9zaXRpb25zIGFyZSBpbiBkaWZmZXJlbnQgcm9vdHMgYW5kIHlvdSBtaWdodCBub3QgZXhwZWN0IHRoaXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlCiAgICAgKiBgYS5pc0FmdGVyKCBiICkgfHwgYS5pc0VxdWFsKCBiIClgIG9yIGAhYS5pc0JlZm9yZSggcCApICYmIGEucm9vdCA9PSBiLnJvb3RgIGluIG1vc3Qgc2NlbmFyaW9zLiBJZiB5b3VyCiAgICAgKiBjb25kaXRpb24gdXNlcyBtdWx0aXBsZSBgaXNBZnRlcmAgYW5kIGBpc0JlZm9yZWAgY2hlY2tzLCBidWlsZCB0aGVtIHNvIHRoZXkgZG8gbm90IHVzZSBuZWdhdGVkIHZhbHVlcywgaS5lLjoKICAgICAqCiAgICAgKgkJaWYgKCBhLmlzQmVmb3JlKCBiICkgJiYgYy5pc0FmdGVyKCBkICkgKSB7CiAgICAgKgkJCS8vIGRvIEEuCiAgICAgKgkJfSBlbHNlIHsKICAgICAqCQkJLy8gZG8gQi4KICAgICAqCQl9CiAgICAgKgogICAgICogb3IsIGlmIHlvdSBoYXZlIG9ubHkgb25lIGlmLWJyYW5jaDoKICAgICAqCiAgICAgKgkJaWYgKCAhKCBhLmlzQmVmb3JlKCBiICkgJiYgYy5pc0FmdGVyKCBkICkgKSB7CiAgICAgKgkJCS8vIGRvIEIuCiAgICAgKgkJfQogICAgICoKICAgICAqIHJhdGhlciB0aGFuOgogICAgICoKICAgICAqCQlpZiAoICFhLmlzQmVmb3JlKCBiICkgfHwgJiYgIWMuaXNBZnRlciggZCApICkgewogICAgICoJCQkvLyBkbyBCLgogICAgICoJCX0gZWxzZSB7CiAgICAgKgkJCS8vIGRvIEEuCiAgICAgKgkJfQogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gdXNlIGl0IG9uIG5vbi1leGlzdGluZyBwb3NpdGlvbnMgKGZvciBleGFtcGxlIGR1cmluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbikuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBvdGhlclBvc2l0aW9uIFBvc2l0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoaXMgcG9zaXRpb24gaXMgYmVmb3JlIGdpdmVuIHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQmVmb3JlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JlZm9yZShvdGhlclBvc2l0aW9uKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVXaXRoKG90aGVyUG9zaXRpb24pID09ICdiZWZvcmUnOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHBvc2l0aW9uIGlzIGVxdWFsIHRvIGdpdmVuIHBvc2l0aW9uLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gdXNlIGl0IG9uIG5vbi1leGlzdGluZyBwb3NpdGlvbnMgKGZvciBleGFtcGxlIGR1cmluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbikuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBvdGhlclBvc2l0aW9uIFBvc2l0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHBvc2l0aW9ucyBhcmUgc2FtZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0VxdWFsIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG90aGVyUG9zaXRpb24pIHsKICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVdpdGgob3RoZXJQb3NpdGlvbikgPT0gJ3NhbWUnOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHBvc2l0aW9uIGlzIHRvdWNoaW5nIGdpdmVuIHBvc2l0aW9uLiBQb3NpdGlvbnMgdG91Y2ggd2hlbiB0aGVyZSBhcmUgbm8gdGV4dCBub2RlcwogICAgICogb3IgZW1wdHkgbm9kZXMgaW4gYSByYW5nZSBiZXR3ZWVuIHRoZW0uIFRlY2huaWNhbGx5LCB0aG9zZSBwb3NpdGlvbnMgYXJlIG5vdCBlcXVhbCBidXQgaW4gbWFueSBjYXNlcwogICAgICogdGhleSBhcmUgdmVyeSBzaW1pbGFyIG9yIGV2ZW4gaW5kaXN0aW5ndWlzaGFibGUuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBvdGhlclBvc2l0aW9uIFBvc2l0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHBvc2l0aW9ucyB0b3VjaC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc1RvdWNoaW5nIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc1RvdWNoaW5nKG90aGVyUG9zaXRpb24pIHsKICAgICAgdmFyIGxlZnQgPSBudWxsOwogICAgICB2YXIgcmlnaHQgPSBudWxsOwogICAgICB2YXIgY29tcGFyZSA9IHRoaXMuY29tcGFyZVdpdGgob3RoZXJQb3NpdGlvbik7CgogICAgICBzd2l0Y2ggKGNvbXBhcmUpIHsKICAgICAgICBjYXNlICdzYW1lJzoKICAgICAgICAgIHJldHVybiB0cnVlOwoKICAgICAgICBjYXNlICdiZWZvcmUnOgogICAgICAgICAgbGVmdCA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzKTsKICAgICAgICAgIHJpZ2h0ID0gUG9zaXRpb24uX2NyZWF0ZUF0KG90aGVyUG9zaXRpb24pOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ2FmdGVyJzoKICAgICAgICAgIGxlZnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQob3RoZXJQb3NpdGlvbik7CiAgICAgICAgICByaWdodCA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzKTsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9IC8vIENhY2hlZCBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLgoKCiAgICAgIHZhciBsZWZ0UGFyZW50ID0gbGVmdC5wYXJlbnQ7CgogICAgICB3aGlsZSAobGVmdC5wYXRoLmxlbmd0aCArIHJpZ2h0LnBhdGgubGVuZ3RoKSB7CiAgICAgICAgaWYgKGxlZnQuaXNFcXVhbChyaWdodCkpIHsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KCiAgICAgICAgaWYgKGxlZnQucGF0aC5sZW5ndGggPiByaWdodC5wYXRoLmxlbmd0aCkgewogICAgICAgICAgaWYgKGxlZnQub2Zmc2V0ICE9PSBsZWZ0UGFyZW50Lm1heE9mZnNldCkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CgogICAgICAgICAgbGVmdC5wYXRoID0gbGVmdC5wYXRoLnNsaWNlKDAsIC0xKTsKICAgICAgICAgIGxlZnRQYXJlbnQgPSBsZWZ0UGFyZW50LnBhcmVudDsKICAgICAgICAgIGxlZnQub2Zmc2V0Kys7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChyaWdodC5vZmZzZXQgIT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQoKICAgICAgICAgIHJpZ2h0LnBhdGggPSByaWdodC5wYXRoLnNsaWNlKDAsIC0xKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2YgdGhlIGdpdmVuLgogICAgICoKICAgICAqCQlwb3NpdGlvbi5pcyggJ3Bvc2l0aW9uJyApOyAvLyAtPiB0cnVlCiAgICAgKgkJcG9zaXRpb24uaXMoICdtb2RlbDpwb3NpdGlvbicgKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqCQlwb3NpdGlvbi5pcyggJ3ZpZXc6cG9zaXRpb24nICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJcG9zaXRpb24uaXMoICdkb2N1bWVudFNlbGVjdGlvbicgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjaXMgQ2hlY2sgdGhlIGVudGlyZSBsaXN0IG9mIG1vZGVsIG9iamVjdHN9IHdoaWNoIGltcGxlbWVudCB0aGUgYGlzKClgIG1ldGhvZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZQogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzKHR5cGUpIHsKICAgICAgcmV0dXJuIHR5cGUgPT09ICdwb3NpdGlvbicgfHwgdHlwZSA9PT0gJ21vZGVsOnBvc2l0aW9uJzsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIGlmIHR3byBwb3NpdGlvbnMgYXJlIGluIHRoZSBzYW1lIHBhcmVudC4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gdG8gY29tcGFyZSB3aXRoLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBwb3NpdGlvbnMgaGF2ZSB0aGUgc2FtZSBwYXJlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImhhc1NhbWVQYXJlbnRBcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU2FtZVBhcmVudEFzKHBvc2l0aW9uKSB7CiAgICAgIGlmICh0aGlzLnJvb3QgIT09IHBvc2l0aW9uLnJvb3QpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciB0aGlzUGFyZW50UGF0aCA9IHRoaXMuZ2V0UGFyZW50UGF0aCgpOwogICAgICB2YXIgcG9zUGFyZW50UGF0aCA9IHBvc2l0aW9uLmdldFBhcmVudFBhdGgoKTsKICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheXModGhpc1BhcmVudFBhdGgsIHBvc1BhcmVudFBhdGgpID09ICdzYW1lJzsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB0aGF0IGlzIHRyYW5zZm9ybWVkIGJ5IGdpdmVuIGBvcGVyYXRpb25gLgogICAgICoKICAgICAqIFRoZSBuZXcgcG9zaXRpb24ncyBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGFjY29yZGluZ2x5IHRvIHRoZSBlZmZlY3Qgb2YgdGhlIGBvcGVyYXRpb25gLgogICAgICoKICAgICAqIEZvciBleGFtcGxlLCBpZiBgbmAgbm9kZXMgYXJlIGluc2VydGVkIGJlZm9yZSB0aGUgcG9zaXRpb24sIHRoZSByZXR1cm5lZCBwb3NpdGlvbiB7QGxpbmsgflBvc2l0aW9uI29mZnNldH0gd2lsbCBiZQogICAgICogaW5jcmVhc2VkIGJ5IGBuYC4gSWYgdGhlIHBvc2l0aW9uIHdhcyBpbiBhIG1lcmdlZCBlbGVtZW50LCBpdCB3aWxsIGJlIGFjY29yZGluZ2x5IG1vdmVkIHRvIHRoZSBuZXcgZWxlbWVudCwgZXRjLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gdXNlIGl0IG9uIG5vbi1leGlzdGluZyBwb3NpdGlvbnMgKGZvciBleGFtcGxlIGR1cmluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbikuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcGVyYXRpb24gT3BlcmF0aW9uIHRvIHRyYW5zZm9ybSBieS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBUcmFuc2Zvcm1lZCBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9uKG9wZXJhdGlvbikgewogICAgICB2YXIgcmVzdWx0OwoKICAgICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkgewogICAgICAgIGNhc2UgJ2luc2VydCc6CiAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKG9wZXJhdGlvbik7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAnbW92ZSc6CiAgICAgICAgY2FzZSAncmVtb3ZlJzoKICAgICAgICBjYXNlICdyZWluc2VydCc6CiAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihvcGVyYXRpb24pOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ3NwbGl0JzoKICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihvcGVyYXRpb24pOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJ21lcmdlJzoKICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihvcGVyYXRpb24pOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXN1bHQgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGhpcyk7CiAgICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB0cmFuc2Zvcm1lZCBieSBhbiBpbnNlcnQgb3BlcmF0aW9uLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vaW5zZXJ0b3BlcmF0aW9ufkluc2VydE9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKG9wZXJhdGlvbi5wb3NpdGlvbiwgb3BlcmF0aW9uLmhvd01hbnkpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHRyYW5zZm9ybWVkIGJ5IGEgbW92ZSBvcGVyYXRpb24uCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tb3Zlb3BlcmF0aW9ufk1vdmVPcGVyYXRpb259IG9wZXJhdGlvbgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShvcGVyYXRpb24uc291cmNlUG9zaXRpb24sIG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbiwgb3BlcmF0aW9uLmhvd01hbnkpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHRyYW5zZm9ybWVkIGJ5IGEgc3BsaXQgb3BlcmF0aW9uLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vc3BsaXRvcGVyYXRpb25+U3BsaXRPcGVyYXRpb259IG9wZXJhdGlvbgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgICAgdmFyIG1vdmVkUmFuZ2UgPSBvcGVyYXRpb24ubW92ZWRSYW5nZTsKICAgICAgdmFyIGlzQ29udGFpbmVkID0gbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKHRoaXMpIHx8IG1vdmVkUmFuZ2Uuc3RhcnQuaXNFcXVhbCh0aGlzKSAmJiB0aGlzLnN0aWNraW5lc3MgPT0gJ3RvTmV4dCc7CgogICAgICBpZiAoaXNDb250YWluZWQpIHsKICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29tYmluZWQob3BlcmF0aW9uLnNwbGl0UG9zaXRpb24sIG9wZXJhdGlvbi5tb3ZlVGFyZ2V0UG9zaXRpb24pOwogICAgICB9IGVsc2UgewogICAgICAgIGlmIChvcGVyYXRpb24uZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShvcGVyYXRpb24uZ3JhdmV5YXJkUG9zaXRpb24sIG9wZXJhdGlvbi5pbnNlcnRpb25Qb3NpdGlvbiwgMSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKG9wZXJhdGlvbi5pbnNlcnRpb25Qb3NpdGlvbiwgMSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdHJhbnNmb3JtZWQgYnkgbWVyZ2Ugb3BlcmF0aW9uLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbWVyZ2VvcGVyYXRpb25+TWVyZ2VPcGVyYXRpb259IG9wZXJhdGlvbgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgICAgdmFyIG1vdmVkUmFuZ2UgPSBvcGVyYXRpb24ubW92ZWRSYW5nZTsKICAgICAgdmFyIGlzQ29udGFpbmVkID0gbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKHRoaXMpIHx8IG1vdmVkUmFuZ2Uuc3RhcnQuaXNFcXVhbCh0aGlzKTsKICAgICAgdmFyIHBvczsKCiAgICAgIGlmIChpc0NvbnRhaW5lZCkgewogICAgICAgIHBvcyA9IHRoaXMuX2dldENvbWJpbmVkKG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbiwgb3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uKTsKCiAgICAgICAgaWYgKG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbi5pc0JlZm9yZShvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24pKSB7CiAgICAgICAgICAvLyBBYm92ZSBoYXBwZW5zIGR1cmluZyBPVCB3aGVuIHRoZSBtZXJnZWQgZWxlbWVudCBpcyBtb3ZlZCBiZWZvcmUgdGhlIG1lcmdlZC10byBlbGVtZW50LgogICAgICAgICAgcG9zID0gcG9zLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24ob3BlcmF0aW9uLmRlbGV0aW9uUG9zaXRpb24sIDEpOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRXF1YWwob3BlcmF0aW9uLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICAgICAgcG9zID0gUG9zaXRpb24uX2NyZWF0ZUF0KG9wZXJhdGlvbi5kZWxldGlvblBvc2l0aW9uKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBwb3MgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShvcGVyYXRpb24uZGVsZXRpb25Qb3NpdGlvbiwgb3BlcmF0aW9uLmdyYXZleWFyZFBvc2l0aW9uLCAxKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHBvczsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB0aGF0IGlzIHVwZGF0ZWQgYnkgcmVtb3ZpbmcgYGhvd01hbnlgIG5vZGVzIHN0YXJ0aW5nIGZyb20gYGRlbGV0ZVBvc2l0aW9uYC4KICAgICAqIEl0IG1heSBoYXBwZW4gdGhhdCB0aGlzIHBvc2l0aW9uIGlzIGluIGEgcmVtb3ZlZCBub2RlLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCBgbnVsbGAgaXMgcmV0dXJuZWQgaW5zdGVhZC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGRlbGV0ZVBvc2l0aW9uIFBvc2l0aW9uIGJlZm9yZSB0aGUgZmlyc3QgcmVtb3ZlZCBub2RlLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgSG93IG1hbnkgbm9kZXMgYXJlIHJlbW92ZWQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbnxudWxsfSBUcmFuc2Zvcm1lZCBwb3NpdGlvbiBvciBgbnVsbGAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihkZWxldGVQb3NpdGlvbiwgaG93TWFueSkgewogICAgICB2YXIgdHJhbnNmb3JtZWQgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGhpcyk7IC8vIFRoaXMgcG9zaXRpb24gY2FuJ3QgYmUgYWZmZWN0ZWQgaWYgZGVsZXRpb24gd2FzIGluIGEgZGlmZmVyZW50IHJvb3QuCgoKICAgICAgaWYgKHRoaXMucm9vdCAhPSBkZWxldGVQb3NpdGlvbi5yb290KSB7CiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkOwogICAgICB9CgogICAgICBpZiAoY29tcGFyZUFycmF5cyhkZWxldGVQb3NpdGlvbi5nZXRQYXJlbnRQYXRoKCksIHRoaXMuZ2V0UGFyZW50UGF0aCgpKSA9PSAnc2FtZScpIHsKICAgICAgICAvLyBJZiBub2RlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBub2RlIHRoYXQgaXMgcG9pbnRlZCBieSB0aGlzIHBvc2l0aW9uLi4uCiAgICAgICAgaWYgKGRlbGV0ZVBvc2l0aW9uLm9mZnNldCA8IHRoaXMub2Zmc2V0KSB7CiAgICAgICAgICAvLyBBbmQgYXJlIHJlbW92ZWQgZnJvbSBiZWZvcmUgYW4gb2Zmc2V0IG9mIHRoYXQgcG9zaXRpb24uLi4KICAgICAgICAgIGlmIChkZWxldGVQb3NpdGlvbi5vZmZzZXQgKyBob3dNYW55ID4gdGhpcy5vZmZzZXQpIHsKICAgICAgICAgICAgLy8gUG9zaXRpb24gaXMgaW4gcmVtb3ZlZCByYW5nZSwgaXQncyBubyBsb25nZXIgaW4gdGhlIHRyZWUuCiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gRGVjcmVtZW50IHRoZSBvZmZzZXQgYWNjb3JkaW5nbHkuCiAgICAgICAgICAgIHRyYW5zZm9ybWVkLm9mZnNldCAtPSBob3dNYW55OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChjb21wYXJlQXJyYXlzKGRlbGV0ZVBvc2l0aW9uLmdldFBhcmVudFBhdGgoKSwgdGhpcy5nZXRQYXJlbnRQYXRoKCkpID09ICdwcmVmaXgnKSB7CiAgICAgICAgLy8gSWYgbm9kZXMgYXJlIHJlbW92ZWQgZnJvbSBhIG5vZGUgdGhhdCBpcyBvbiBhIHBhdGggdG8gdGhpcyBwb3NpdGlvbi4uLgogICAgICAgIHZhciBpID0gZGVsZXRlUG9zaXRpb24ucGF0aC5sZW5ndGggLSAxOwoKICAgICAgICBpZiAoZGVsZXRlUG9zaXRpb24ub2Zmc2V0IDw9IHRoaXMucGF0aFtpXSkgewogICAgICAgICAgLy8gQW5kIGFyZSByZW1vdmVkIGZyb20gYmVmb3JlIG5leHQgbm9kZSBvZiB0aGF0IHBhdGguLi4KICAgICAgICAgIGlmIChkZWxldGVQb3NpdGlvbi5vZmZzZXQgKyBob3dNYW55ID4gdGhpcy5wYXRoW2ldKSB7CiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgb2YgdGhhdCBwYXRoIGlzIHJlbW92ZWQgcmV0dXJuIG51bGwKICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgbm9kZSBjb250YWluaW5nIHRoaXMgcG9zaXRpb24gZ290IHJlbW92ZWQuCiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkZWNyZW1lbnQgaW5kZXggb24gdGhhdCBwYXRoLgogICAgICAgICAgICB0cmFuc2Zvcm1lZC5wYXRoW2ldIC09IGhvd01hbnk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdGhhdCBpcyB1cGRhdGVkIGJ5IGluc2VydGluZyBgaG93TWFueWAgbm9kZXMgYXQgYGluc2VydFBvc2l0aW9uYC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGluc2VydFBvc2l0aW9uIFBvc2l0aW9uIHdoZXJlIG5vZGVzIGFyZSBpbnNlcnRlZC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IEhvdyBtYW55IG5vZGVzIGFyZSBpbnNlcnRlZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBUcmFuc2Zvcm1lZCBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oaW5zZXJ0UG9zaXRpb24sIGhvd01hbnkpIHsKICAgICAgdmFyIHRyYW5zZm9ybWVkID0gUG9zaXRpb24uX2NyZWF0ZUF0KHRoaXMpOyAvLyBUaGlzIHBvc2l0aW9uIGNhbid0IGJlIGFmZmVjdGVkIGlmIGluc2VydGlvbiB3YXMgaW4gYSBkaWZmZXJlbnQgcm9vdC4KCgogICAgICBpZiAodGhpcy5yb290ICE9IGluc2VydFBvc2l0aW9uLnJvb3QpIHsKICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7CiAgICAgIH0KCiAgICAgIGlmIChjb21wYXJlQXJyYXlzKGluc2VydFBvc2l0aW9uLmdldFBhcmVudFBhdGgoKSwgdGhpcy5nZXRQYXJlbnRQYXRoKCkpID09ICdzYW1lJykgewogICAgICAgIC8vIElmIG5vZGVzIGFyZSBpbnNlcnRlZCBpbiB0aGUgbm9kZSB0aGF0IGlzIHBvaW50ZWQgYnkgdGhpcyBwb3NpdGlvbi4uLgogICAgICAgIGlmIChpbnNlcnRQb3NpdGlvbi5vZmZzZXQgPCB0aGlzLm9mZnNldCB8fCBpbnNlcnRQb3NpdGlvbi5vZmZzZXQgPT0gdGhpcy5vZmZzZXQgJiYgdGhpcy5zdGlja2luZXNzICE9ICd0b1ByZXZpb3VzJykgewogICAgICAgICAgLy8gQW5kIGFyZSBpbnNlcnRlZCBiZWZvcmUgYW4gb2Zmc2V0IG9mIHRoYXQgcG9zaXRpb24uLi4KICAgICAgICAgIC8vICJQdXNoIiB0aGlzIHBvc2l0aW9ucyBvZmZzZXQuCiAgICAgICAgICB0cmFuc2Zvcm1lZC5vZmZzZXQgKz0gaG93TWFueTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoY29tcGFyZUFycmF5cyhpbnNlcnRQb3NpdGlvbi5nZXRQYXJlbnRQYXRoKCksIHRoaXMuZ2V0UGFyZW50UGF0aCgpKSA9PSAncHJlZml4JykgewogICAgICAgIC8vIElmIG5vZGVzIGFyZSBpbnNlcnRlZCBpbiBhIG5vZGUgdGhhdCBpcyBvbiBhIHBhdGggdG8gdGhpcyBwb3NpdGlvbi4uLgogICAgICAgIHZhciBpID0gaW5zZXJ0UG9zaXRpb24ucGF0aC5sZW5ndGggLSAxOwoKICAgICAgICBpZiAoaW5zZXJ0UG9zaXRpb24ub2Zmc2V0IDw9IHRoaXMucGF0aFtpXSkgewogICAgICAgICAgLy8gQW5kIGFyZSBpbnNlcnRlZCBiZWZvcmUgbmV4dCBub2RlIG9mIHRoYXQgcGF0aC4uLgogICAgICAgICAgLy8gIlB1c2giIHRoZSBpbmRleCBvbiB0aGF0IHBhdGguCiAgICAgICAgICB0cmFuc2Zvcm1lZC5wYXRoW2ldICs9IGhvd01hbnk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdGhhdCBpcyB1cGRhdGVkIGJ5IG1vdmluZyBgaG93TWFueWAgbm9kZXMgZnJvbSBgc291cmNlUG9zaXRpb25gIHRvIGB0YXJnZXRQb3NpdGlvbmAuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBzb3VyY2VQb3NpdGlvbiBQb3NpdGlvbiBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnQgdG8gbW92ZS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gdGFyZ2V0UG9zaXRpb24gUG9zaXRpb24gd2hlcmUgbW92ZWQgZWxlbWVudHMgd2lsbCBiZSBpbnNlcnRlZC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IEhvdyBtYW55IGNvbnNlY3V0aXZlIG5vZGVzIHRvIG1vdmUsIHN0YXJ0aW5nIGZyb20gYHNvdXJjZVBvc2l0aW9uYC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBUcmFuc2Zvcm1lZCBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeU1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhvd01hbnkpIHsKICAgICAgLy8gVXBkYXRlIHRhcmdldCBwb3NpdGlvbiwgYXMgaXQgY291bGQgYmUgYWZmZWN0ZWQgYnkgbm9kZXMgcmVtb3ZhbC4KICAgICAgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKHNvdXJjZVBvc2l0aW9uLCBob3dNYW55KTsKCiAgICAgIGlmIChzb3VyY2VQb3NpdGlvbi5pc0VxdWFsKHRhcmdldFBvc2l0aW9uKSkgewogICAgICAgIC8vIElmIGB0YXJnZXRQb3NpdGlvbmAgaXMgZXF1YWwgdG8gYHNvdXJjZVBvc2l0aW9uYCB0aGlzIGlzbid0IHJlYWxseSBhbnkgbW92ZS4gSnVzdCByZXR1cm4gcG9zaXRpb24gYXMgaXQgaXMuCiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzKTsKICAgICAgfSAvLyBNb3ZpbmcgYSByYW5nZSByZW1vdmVzIG5vZGVzIGZyb20gdGhlaXIgb3JpZ2luYWwgcG9zaXRpb24uIFdlIGFja25vd2xlZGdlIHRoaXMgYnkgcHJvcGVyIHRyYW5zZm9ybWF0aW9uLgoKCiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihzb3VyY2VQb3NpdGlvbiwgaG93TWFueSk7CgogICAgICB2YXIgaXNNb3ZlZCA9IHRyYW5zZm9ybWVkID09PSBudWxsIHx8IHNvdXJjZVBvc2l0aW9uLmlzRXF1YWwodGhpcykgJiYgdGhpcy5zdGlja2luZXNzID09ICd0b05leHQnIHx8IHNvdXJjZVBvc2l0aW9uLmdldFNoaWZ0ZWRCeShob3dNYW55KS5pc0VxdWFsKHRoaXMpICYmIHRoaXMuc3RpY2tpbmVzcyA9PSAndG9QcmV2aW91cyc7CgogICAgICBpZiAoaXNNb3ZlZCkgewogICAgICAgIC8vIFRoaXMgcG9zaXRpb24gaXMgaW5zaWRlIG1vdmVkIHJhbmdlIChvciBzdGlja3MgdG8gaXQpLgogICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgY2FsY3VsYXRlIGEgY29tYmluYXRpb24gb2YgdGhpcyBwb3NpdGlvbiwgbW92ZSBzb3VyY2UgcG9zaXRpb24gYW5kIHRhcmdldCBwb3NpdGlvbi4KICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29tYmluZWQoc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBUaGlzIHBvc2l0aW9uIGlzIG5vdCBpbnNpZGUgYSByZW1vdmVkIHJhbmdlLgogICAgICAgIC8vCiAgICAgICAgLy8gSW4gbmV4dCBzdGVwLCB3ZSBzaW1wbHkgcmVmbGVjdCBpbnNlcnRpbmcgYGhvd01hbnlgIG5vZGVzLCB3aGljaCBtaWdodCBmdXJ0aGVyIGFmZmVjdCB0aGUgcG9zaXRpb24uCiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKHRhcmdldFBvc2l0aW9uLCBob3dNYW55KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvc2l0aW9uIHRoYXQgaXMgYSBjb21iaW5hdGlvbiBvZiB0aGlzIHBvc2l0aW9uIGFuZCBnaXZlbiBwb3NpdGlvbnMuCiAgICAgKgogICAgICogVGhlIGNvbWJpbmVkIHBvc2l0aW9uIGlzIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHRyYW5zZm9ybWVkIGJ5IG1vdmluZyBhIHJhbmdlIHN0YXJ0aW5nIGF0IGBzb3VyY2VgIHBvc2l0aW9uCiAgICAgKiB0byB0aGUgYHRhcmdldGAgcG9zaXRpb24uIEl0IGlzIGV4cGVjdGVkIHRoYXQgdGhpcyBwb3NpdGlvbiBpcyBpbnNpZGUgdGhlIG1vdmVkIHJhbmdlLgogICAgICoKICAgICAqIEV4YW1wbGU6CiAgICAgKgogICAgICoJCWxldCBvcmlnaW5hbCA9IG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMiwgMywgMSBdICk7CiAgICAgKgkJbGV0IHNvdXJjZSA9IG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMiwgMiBdICk7CiAgICAgKgkJbGV0IHRhcmdldCA9IG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIG90aGVyUm9vdCwgWyAxLCAxLCAzIF0gKTsKICAgICAqCQlvcmlnaW5hbC5fZ2V0Q29tYmluZWQoIHNvdXJjZSwgdGFyZ2V0ICk7IC8vIHBhdGggaXMgWyAxLCAxLCA0LCAxIF0sIHJvb3QgaXMgYG90aGVyUm9vdGAKICAgICAqCiAgICAgKiBFeHBsYW5hdGlvbjoKICAgICAqCiAgICAgKiBXZSBoYXZlIGEgcG9zaXRpb24gYFsgMiwgMywgMSBdYCBhbmQgbW92ZSBzb21lIG5vZGVzIGZyb20gYFsgMiwgMiBdYCB0byBgWyAxLCAxLCAzIF1gLiBUaGUgb3JpZ2luYWwgcG9zaXRpb24KICAgICAqIHdhcyBpbnNpZGUgbW92ZWQgbm9kZXMgYW5kIG5vdyBzaG91bGQgcG9pbnQgdG8gdGhlIG5ldyBwbGFjZS4gVGhlIG1vdmVkIG5vZGVzIHdpbGwgYmUgYWZ0ZXIKICAgICAqIHBvc2l0aW9ucyBgWyAxLCAxLCAzIF1gLCBgWyAxLCAxLCA0IF1gLCBgWyAxLCAxLCA1IF1gLiBTaW5jZSBvdXIgcG9zaXRpb24gd2FzIGluIHRoZSBzZWNvbmQgbW92ZWQgbm9kZSwKICAgICAqIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiB3aWxsIGJlIGluIGEgc3ViLXRyZWUgb2YgYSBub2RlIGF0IGBbIDEsIDEsIDQgXWAuIExvb2tpbmcgYXQgb3JpZ2luYWwgcGF0aCwgd2UKICAgICAqIHRvb2sgY2FyZSBvZiBgWyAyLCAzIF1gIHBhcnQgb2YgaXQuIE5vdyB3ZSBoYXZlIHRvIGFkZCB0aGUgcmVzdCBvZiB0aGUgb3JpZ2luYWwgcGF0aCB0byB0aGUgdHJhbnNmb3JtZWQgcGF0aC4KICAgICAqIEZpbmFsbHksIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiB3aWxsIHBvaW50IHRvIGBbIDEsIDEsIDQsIDEgXWAuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBzb3VyY2UgQmVnaW5uaW5nIG9mIHRoZSBtb3ZlZCByYW5nZS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gdGFyZ2V0IFBvc2l0aW9uIHdoZXJlIHRoZSByYW5nZSBpcyBtb3ZlZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBDb21iaW5lZCBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0Q29tYmluZWQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb21iaW5lZChzb3VyY2UsIHRhcmdldCkgewogICAgICB2YXIgaSA9IHNvdXJjZS5wYXRoLmxlbmd0aCAtIDE7IC8vIFRoZSBmaXJzdCBwYXJ0IG9mIGEgcGF0aCB0byBjb21iaW5lZCBwb3NpdGlvbiBpcyBhIHBhdGggdG8gdGhlIHBsYWNlIHdoZXJlIG5vZGVzIHdlcmUgbW92ZWQuCgogICAgICB2YXIgY29tYmluZWQgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGFyZ2V0KTsKCiAgICAgIGNvbWJpbmVkLnN0aWNraW5lc3MgPSB0aGlzLnN0aWNraW5lc3M7IC8vIFRoZW4gd2UgaGF2ZSB0byB1cGRhdGUgdGhlIHJlc3Qgb2YgdGhlIHBhdGguCiAgICAgIC8vIEZpeCB0aGUgb2Zmc2V0IGJlY2F1c2UgdGhpcyBwb3NpdGlvbiBtaWdodCBiZSBhZnRlciBgZnJvbWAgcG9zaXRpb24gYW5kIHdlIGhhdmUgdG8gcmVmbGVjdCB0aGF0LgoKICAgICAgY29tYmluZWQub2Zmc2V0ID0gY29tYmluZWQub2Zmc2V0ICsgdGhpcy5wYXRoW2ldIC0gc291cmNlLm9mZnNldDsgLy8gVGhlbiwgYWRkIHRoZSByZXN0IG9mIHRoZSBwYXRoLgogICAgICAvLyBJZiB0aGlzIHBvc2l0aW9uIGlzIGF0IHRoZSBzYW1lIGxldmVsIGFzIGBmcm9tYCBwb3NpdGlvbiBub3RoaW5nIHdpbGwgZ2V0IGFkZGVkLgoKICAgICAgY29tYmluZWQucGF0aCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY29tYmluZWQucGF0aCksIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnBhdGguc2xpY2UoaSArIDEpKSk7CiAgICAgIHJldHVybiBjb21iaW5lZDsKICAgIH0KICAgIC8qKgogICAgICogQGluaGVyaXREb2MKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b0pTT04iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICByb290OiB0aGlzLnJvb3QudG9KU09OKCksCiAgICAgICAgcGF0aDogQXJyYXkuZnJvbSh0aGlzLnBhdGgpLAogICAgICAgIHN0aWNraW5lc3M6IHRoaXMuc3RpY2tpbmVzcwogICAgICB9OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvc2l0aW9uIHRoYXQgaXMgZXF1YWwgdG8gY3VycmVudCBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjbG9uZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnJvb3QsIHRoaXMucGF0aCwgdGhpcy5zdGlja2luZXNzKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uIFRoZSBsb2NhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzOgogICAgICoKICAgICAqICogYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0sCiAgICAgKiAqIHBhcmVudCBlbGVtZW50IGFuZCBvZmZzZXQgKG9mZnNldCBkZWZhdWx0cyB0byBgMGApLAogICAgICogKiBwYXJlbnQgZWxlbWVudCBhbmQgYCdlbmQnYCAoc2V0cyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoYXQgZWxlbWVudCksCiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfSBhbmQgYCdiZWZvcmUnYCBvciBgJ2FmdGVyJ2AgKHNldHMgcG9zaXRpb24gYmVmb3JlIG9yIGFmdGVyIGdpdmVuIG1vZGVsIGl0ZW0pLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc2hvcnRjdXQgdG8gb3RoZXIgZmFjdG9yeSBtZXRob2RzIHN1Y2ggYXM6CiAgICAgKgogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbi5fY3JlYXRlQmVmb3JlfSwKICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24uX2NyZWF0ZUFmdGVyfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4gdGhlCiAgICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfSBbc3RpY2tpbmVzcz0ndG9Ob25lJ10gUG9zaXRpb24gc3RpY2tpbmVzcy4gVXNlZCBvbmx5IHdoZW4gdGhlCiAgICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKi8KCiAgfV0sIFt7CiAgICBrZXk6ICJfY3JlYXRlQXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIHZhciBzdGlja2luZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndG9Ob25lJzsKCiAgICAgIGlmIChpdGVtT3JQb3NpdGlvbiBpbnN0YW5jZW9mIFBvc2l0aW9uKSB7CiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihpdGVtT3JQb3NpdGlvbi5yb290LCBpdGVtT3JQb3NpdGlvbi5wYXRoLCBpdGVtT3JQb3NpdGlvbi5zdGlja2luZXNzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgbm9kZSA9IGl0ZW1PclBvc2l0aW9uOwoKICAgICAgICBpZiAob2Zmc2V0ID09ICdlbmQnKSB7CiAgICAgICAgICBvZmZzZXQgPSBub2RlLm1heE9mZnNldDsKICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSAnYmVmb3JlJykgewogICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJlZm9yZShub2RlLCBzdGlja2luZXNzKTsKICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSAnYWZ0ZXInKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQWZ0ZXIobm9kZSwgc3RpY2tpbmVzcyk7CiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgIT09IDAgJiYgIW9mZnNldCkgewogICAgICAgICAgLyoqCiAgICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkF0IGBNb2RlbCNjcmVhdGVQb3NpdGlvbkF0KClgfQogICAgICAgICAgICogcmVxdWlyZXMgdGhlIG9mZnNldCB0byBiZSBzcGVjaWZpZWQgd2hlbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgbW9kZWwgaXRlbS4KICAgICAgICAgICAqCiAgICAgICAgICAgKiBAZXJyb3IgbW9kZWwtY3JlYXRlcG9zaXRpb25hdC1vZmZzZXQtcmVxdWlyZWQKICAgICAgICAgICAqLwogICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLWNyZWF0ZXBvc2l0aW9uYXQtb2Zmc2V0LXJlcXVpcmVkJywgW3RoaXMsIGl0ZW1PclBvc2l0aW9uXSk7CiAgICAgICAgfQoKICAgICAgICBpZiAoIW5vZGUuaXMoJ2VsZW1lbnQnKSAmJiAhbm9kZS5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgICAvKioKICAgICAgICAgICAqIFBvc2l0aW9uIHBhcmVudCBoYXZlIHRvIGJlIGEgbW9kZWwgZWxlbWVudCBvciBtb2RlbCBkb2N1bWVudCBmcmFnbWVudC4KICAgICAgICAgICAqCiAgICAgICAgICAgKiBAZXJyb3IgbW9kZWwtcG9zaXRpb24tcGFyZW50LWluY29ycmVjdAogICAgICAgICAgICovCiAgICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tcGFyZW50LWluY29ycmVjdCcsIFt0aGlzLCBpdGVtT3JQb3NpdGlvbl0pOwogICAgICAgIH0KCiAgICAgICAgdmFyIHBhdGggPSBub2RlLmdldFBhdGgoKTsKICAgICAgICBwYXRoLnB1c2gob2Zmc2V0KTsKICAgICAgICByZXR1cm4gbmV3IHRoaXMobm9kZS5yb290LCBwYXRoLCBzdGlja2luZXNzKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHBvc2l0aW9uLCBhZnRlciBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGFmdGVyIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgcGxhY2VkLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30gW3N0aWNraW5lc3M9J3RvTm9uZSddIFBvc2l0aW9uIHN0aWNraW5lc3MuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqIEBwcm90ZWN0ZWQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlQWZ0ZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZnRlcihpdGVtLCBzdGlja2luZXNzKSB7CiAgICAgIGlmICghaXRlbS5wYXJlbnQpIHsKICAgICAgICAvKioKICAgICAgICAgKiBZb3UgY2FuIG5vdCBtYWtlIGEgcG9zaXRpb24gYWZ0ZXIgYSByb290IGVsZW1lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgbW9kZWwtcG9zaXRpb24tYWZ0ZXItcm9vdAogICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IHJvb3QKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tYWZ0ZXItcm9vdCcsIFt0aGlzLCBpdGVtXSwgewogICAgICAgICAgcm9vdDogaXRlbQogICAgICAgIH0pOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQXQoaXRlbS5wYXJlbnQsIGl0ZW0uZW5kT2Zmc2V0LCBzdGlja2luZXNzKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyBwb3NpdGlvbiwgYmVmb3JlIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGJlZm9yZSB3aGljaCB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIHBsYWNlZC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblN0aWNraW5lc3N9IFtzdGlja2luZXNzPSd0b05vbmUnXSBQb3NpdGlvbiBzdGlja2luZXNzLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NyZWF0ZUJlZm9yZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUJlZm9yZShpdGVtLCBzdGlja2luZXNzKSB7CiAgICAgIGlmICghaXRlbS5wYXJlbnQpIHsKICAgICAgICAvKioKICAgICAgICAgKiBZb3UgY2FuIG5vdCBtYWtlIGEgcG9zaXRpb24gYmVmb3JlIGEgcm9vdCBlbGVtZW50LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIG1vZGVsLXBvc2l0aW9uLWJlZm9yZS1yb290CiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gcm9vdAogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1wb3NpdGlvbi1iZWZvcmUtcm9vdCcsIGl0ZW0sIHsKICAgICAgICAgIHJvb3Q6IGl0ZW0KICAgICAgICB9KTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUF0KGl0ZW0ucGFyZW50LCBpdGVtLnN0YXJ0T2Zmc2V0LCBzdGlja2luZXNzKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGBQb3NpdGlvbmAgaW5zdGFuY2UgZnJvbSBnaXZlbiBwbGFpbiBvYmplY3QgKGkuZS4gcGFyc2VkIEpTT04gc3RyaW5nKS4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBQbGFpbiBvYmplY3QgdG8gYmUgY29udmVydGVkIHRvIGBQb3NpdGlvbmAuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9IGRvYyBEb2N1bWVudCBvYmplY3QgdGhhdCB3aWxsIGJlIHBvc2l0aW9uIG93bmVyLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGBQb3NpdGlvbmAgaW5zdGFuY2UgY3JlYXRlZCB1c2luZyBnaXZlbiBwbGFpbiBvYmplY3QuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZnJvbUpTT04iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24sIGRvYykgewogICAgICBpZiAoanNvbi5yb290ID09PSAnJGdyYXZleWFyZCcpIHsKICAgICAgICB2YXIgcG9zID0gbmV3IFBvc2l0aW9uKGRvYy5ncmF2ZXlhcmQsIGpzb24ucGF0aCk7CiAgICAgICAgcG9zLnN0aWNraW5lc3MgPSBqc29uLnN0aWNraW5lc3M7CiAgICAgICAgcmV0dXJuIHBvczsKICAgICAgfQoKICAgICAgaWYgKCFkb2MuZ2V0Um9vdChqc29uLnJvb3QpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IGNyZWF0ZSBwb3NpdGlvbiBmb3IgZG9jdW1lbnQuIFJvb3Qgd2l0aCBzcGVjaWZpZWQgbmFtZSBkb2VzIG5vdCBleGlzdC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBtb2RlbC1wb3NpdGlvbi1mcm9tanNvbi1uby1yb290CiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJvb3ROYW1lCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXBvc2l0aW9uLWZyb21qc29uLW5vLXJvb3QnLCBkb2MsIHsKICAgICAgICAgIHJvb3ROYW1lOiBqc29uLnJvb3QKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihkb2MuZ2V0Um9vdChqc29uLnJvb3QpLCBqc29uLnBhdGgsIGpzb24uc3RpY2tpbmVzcyk7CiAgICB9IC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gdG9TdHJpbmcoKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlyZXR1cm4gYCR7IHRoaXMucm9vdCB9IFsgJHsgdGhpcy5wYXRoLmpvaW4oICcsICcgKSB9IF1gOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGxvZygpIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCWNvbnNvbGUubG9nKCAnTW9kZWxQb3NpdGlvbjogJyArIHRoaXMgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKICB9XSk7CgogIHJldHVybiBQb3NpdGlvbjsKfSgpOwovKioKICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGlzIHBvc2l0aW9uIGlzIGAnYmVmb3JlJ2Agb3IgYCdhZnRlcidgIG9yIGAnc2FtZSdgIGFzIGdpdmVuIHBvc2l0aW9uLgogKiBJZiBwb3NpdGlvbnMgYXJlIGluIGRpZmZlcmVudCByb290cyBgJ2RpZmZlcmVudCdgIGZsYWcgaXMgcmV0dXJuZWQuCiAqCiAqIEB0eXBlZGVmIHtTdHJpbmd9IG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25SZWxhdGlvbgogKi8KCi8qKgogKiBSZXByZXNlbnRzIGhvdyBwb3NpdGlvbiBpcyAic3RpY2tpbmciIHdpdGggbmVpZ2hib3VyIG5vZGVzLiBVc2VkIHRvIGRlZmluZSBob3cgcG9zaXRpb24gc2hvdWxkIGJlIHRyYW5zZm9ybWVkIChtb3ZlZCkKICogaW4gZWRnZSBjYXNlcy4gUG9zc2libGUgdmFsdWVzOiBgJ3RvTm9uZSdgLCBgJ3RvTmV4dCdgLCBgJ3RvUHJldmlvdXMnYC4KICoKICogRXhhbXBsZXM6CiAqCiAqCQlJbnNlcnQuIFBvc2l0aW9uIGlzIGF0IHwgYW5kIG5vZGVzIGFyZSBpbnNlcnRlZCBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgbWFya2VkIGFzIF46CiAqCiAqCQktIHN0aWNrcyB0byBub25lOiAgICAgICAgICAgPHA+Zl58b288L3A+ICAtPiAgPHA+ZmJhcnxvbzwvcD4KICoJCS0gc3RpY2tzIHRvIG5leHQgbm9kZTogICAgICA8cD5mXnxvbzwvcD4gIC0+ICA8cD5mYmFyfG9vPC9wPgogKgkJLSBzdGlja3MgdG8gcHJldmlvdXMgbm9kZTogIDxwPmZ8Xm9vPC9wPiAgLT4gIDxwPmZ8YmFyb288L3A+CiAqCiAqCiAqCQlNb3ZlLiBQb3NpdGlvbiBpcyBhdCB8IGFuZCByYW5nZSBbb29dIGlzIG1vdmVkIHRvIHBvc2l0aW9uIF46CiAqCiAqCQktIHN0aWNrcyB0byBub25lOiAgICAgICAgICAgPHA+Znxbb29dPC9wPjxwPmJeYXI8L3A+ICAtPiAgPHA+Znw8L3A+PHA+Ym9vYXI8L3A+CiAqCQktIHN0aWNrcyB0byBub25lOiAgICAgICAgICAgPHA+Zltvb118PC9wPjxwPmJeYXI8L3A+ICAtPiAgPHA+Znw8L3A+PHA+Ym9vYXI8L3A+CiAqCiAqCQktIHN0aWNrcyB0byBuZXh0IG5vZGU6ICAgICAgPHA+Znxbb29dPC9wPjxwPmJeYXI8L3A+ICAtPiAgPHA+ZjwvcD48cD5ifG9vYXI8L3A+CiAqCQktIHN0aWNrcyB0byBuZXh0IG5vZGU6ICAgICAgPHA+Zltvb118PC9wPjxwPmJeYXI8L3A+ICAtPiAgPHA+Znw8L3A+PHA+Ym9vYXI8L3A+CiAqCiAqCQktIHN0aWNrcyB0byBwcmV2aW91cyBub2RlOiAgPHA+Znxbb29dPC9wPjxwPmJeYXI8L3A+ICAtPiAgPHA+Znw8L3A+PHA+Ym9vYXI8L3A+CiAqCQktIHN0aWNrcyB0byBwcmV2aW91cyBub2RlOiAgPHA+Zltvb118PC9wPjxwPmJeYXI8L3A+ICAtPiAgPHA+ZjwvcD48cD5ib298YXI8L3A+CiAqCiAqIEB0eXBlZGVmIHtTdHJpbmd9IG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzCiAqLwoKLyoqCiAqIFJldHVybnMgYSB0ZXh0IG5vZGUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLgogKgogKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIG9wdGltaXplZCB0byByZXVzZSB0aGUgcG9zaXRpb24gcGFyZW50IGluc3RhbmNlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLgogKgogKiBOb3JtYWxseSwgeW91IHNob3VsZCB1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jdGV4dE5vZGUgYFBvc2l0aW9uI3RleHROb2RlYH0uCiAqIElmIHlvdSBzdGFydCBoaXR0aW5nIHBlcmZvcm1hbmNlIGlzc3VlcyB3aXRoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhcmVudCBgUG9zaXRpb24jcGFyZW50YH0KICogY2hlY2sgaWYgeW91ciBhbGdvcml0aG0gZG9lcyBub3QgYWNjZXNzIGl0IG11bHRpcGxlIHRpbWVzICh3aGljaCBjYW4gaGFwcGVuIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgdmlhIG90aGVyIHBvc2l0aW9uIHByb3BlcnRpZXMpLgogKgogKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS9pc3N1ZXMvNjU3OS4KICoKICogU2VlIGFsc286CiAqCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+Z2V0Tm9kZUFmdGVyUG9zaXRpb259CiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+Z2V0Tm9kZUJlZm9yZVBvc2l0aW9ufQogKgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHBvc2l0aW9uUGFyZW50IFRoZSBwYXJlbnQgb2YgdGhlCiAqIGdpdmVuIHBvc2l0aW9uLgogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHR8bnVsbH0KICovCgoKZXhwb3J0IHsgUG9zaXRpb24gYXMgZGVmYXVsdCB9OwpleHBvcnQgZnVuY3Rpb24gZ2V0VGV4dE5vZGVBdFBvc2l0aW9uKHBvc2l0aW9uLCBwb3NpdGlvblBhcmVudCkgewogIHZhciBub2RlID0gcG9zaXRpb25QYXJlbnQuZ2V0Q2hpbGQocG9zaXRpb25QYXJlbnQub2Zmc2V0VG9JbmRleChwb3NpdGlvbi5vZmZzZXQpKTsKCiAgaWYgKG5vZGUgJiYgbm9kZS5pcygnJHRleHQnKSAmJiBub2RlLnN0YXJ0T2Zmc2V0IDwgcG9zaXRpb24ub2Zmc2V0KSB7CiAgICByZXR1cm4gbm9kZTsKICB9CgogIHJldHVybiBudWxsOwp9Ci8qKgogKiBSZXR1cm5zIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3NpdGlvbi4KICoKICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBvcHRpbWl6ZWQgdG8gcmV1c2UgdGhlIHBvc2l0aW9uIHBhcmVudCBpbnN0YW5jZSBhbmQgdGhlIGNhbGN1bGF0aW9uIG9mIHRoZSB0ZXh0IG5vZGUgYXQgdGhlCiAqIHNwZWNpZmljIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLgogKgogKiBOb3JtYWxseSwgeW91IHNob3VsZCB1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jbm9kZUFmdGVyIGBQb3NpdGlvbiNub2RlQWZ0ZXJgfS4KICogSWYgeW91IHN0YXJ0IGhpdHRpbmcgcGVyZm9ybWFuY2UgaXNzdWVzIHdpdGgge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50IGBQb3NpdGlvbiNwYXJlbnRgfSBhbmQvb3IKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jdGV4dE5vZGUgYFBvc2l0aW9uI3RleHROb2RlYH0KICogY2hlY2sgaWYgeW91ciBhbGdvcml0aG0gZG9lcyBub3QgYWNjZXNzIHRob3NlIHByb3BlcnRpZXMgbXVsdGlwbGUgdGltZXMKICogKHdoaWNoIGNhbiBoYXBwZW4gZGlyZWN0bHkgb3IgaW5kaXJlY3RseSB2aWEgb3RoZXIgcG9zaXRpb24gcHJvcGVydGllcykuCiAqCiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1L2lzc3Vlcy82NTc5IGFuZCBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1L2lzc3Vlcy82NTgyLgogKgogKiBTZWUgYWxzbzoKICoKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5nZXRUZXh0Tm9kZUF0UG9zaXRpb259CiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+Z2V0Tm9kZUJlZm9yZVBvc2l0aW9ufQogKgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHBvc2l0aW9uUGFyZW50IFRoZSBwYXJlbnQgb2YgdGhlCiAqIGdpdmVuIHBvc2l0aW9uLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0fG51bGx9IHRleHROb2RlIFRleHQgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxudWxsfQogKi8KCmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlQWZ0ZXJQb3NpdGlvbihwb3NpdGlvbiwgcG9zaXRpb25QYXJlbnQsIHRleHROb2RlKSB7CiAgaWYgKHRleHROb2RlICE9PSBudWxsKSB7CiAgICByZXR1cm4gbnVsbDsKICB9CgogIHJldHVybiBwb3NpdGlvblBhcmVudC5nZXRDaGlsZChwb3NpdGlvblBhcmVudC5vZmZzZXRUb0luZGV4KHBvc2l0aW9uLm9mZnNldCkpOwp9Ci8qKgogKiBSZXR1cm5zIHRoZSBub2RlIGJlZm9yZSB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAqCiAqIFJlZmVyIHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9ufmdldE5vZGVCZWZvcmVQb3NpdGlvbn0gZm9yIGRvY3VtZW50YXRpb24gb24gd2hlbiB0byB1c2UgdGhpcyB1dGlsIG1ldGhvZC4KICoKICogU2VlIGFsc286CiAqCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+Z2V0VGV4dE5vZGVBdFBvc2l0aW9ufQogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9ufmdldE5vZGVBZnRlclBvc2l0aW9ufQogKgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHBvc2l0aW9uUGFyZW50IFRoZSBwYXJlbnQgb2YgdGhlCiAqIGdpdmVuIHBvc2l0aW9uLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0fG51bGx9IHRleHROb2RlIFRleHQgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxudWxsfQogKi8KCmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlQmVmb3JlUG9zaXRpb24ocG9zaXRpb24sIHBvc2l0aW9uUGFyZW50LCB0ZXh0Tm9kZSkgewogIGlmICh0ZXh0Tm9kZSAhPT0gbnVsbCkgewogICAgcmV0dXJuIG51bGw7CiAgfQoKICByZXR1cm4gcG9zaXRpb25QYXJlbnQuZ2V0Q2hpbGQocG9zaXRpb25QYXJlbnQub2Zmc2V0VG9JbmRleChwb3NpdGlvbi5vZmZzZXQpIC0gMSk7Cn0="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js"],"names":["TreeWalker","compareArrays","CKEditorError","Position","root","path","stickiness","is","Array","length","slice","getPath","newOffset","parent","i","getChild","offsetToIndex","position","offset","getTextNodeAtPosition","getNodeAfterPosition","getNodeBeforePosition","maxOffset","otherPosition","result","skip","options","startPosition","treeWalker","getAncestors","includeSelf","parentName","findAncestor","cmp","diffAt","Math","min","ancestorsA","ancestorsB","shift","shifted","clone","compareWith","left","right","compare","_createAt","leftParent","isEqual","type","thisParentPath","getParentPath","posParentPath","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","_getTransformedByInsertion","howMany","_getTransformedByMove","sourcePosition","targetPosition","movedRange","isContained","containsPosition","start","_getCombined","splitPosition","moveTargetPosition","graveyardPosition","insertionPosition","pos","isBefore","_getTransformedByDeletion","deletionPosition","deletePosition","transformed","insertPosition","isMoved","getShiftedBy","source","target","combined","toJSON","from","constructor","itemOrPosition","node","_createBefore","_createAfter","push","item","endOffset","startOffset","json","doc","graveyard","getRoot","rootName","positionParent","textNode"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,cAAvB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,aAAP,MAA0B,6CAA1B,C,CAEA;;AACA,OAAO,uCAAP;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,Q;AACpB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACC,oBAAaC,IAAb,EAAmBC,IAAnB,EAAiD;AAAA,QAAxBC,UAAwB,uEAAX,QAAW;;AAAA;;AAChD,QAAK,CAACF,IAAI,CAACG,EAAL,CAAS,SAAT,CAAD,IAAyB,CAACH,IAAI,CAACG,EAAL,CAAS,kBAAT,CAA/B,EAA+D;AAC9D;AACH;AACA;AACA;AACA;AACA;AACA;AACG,YAAM,IAAIL,aAAJ,CACL,6BADK,EAELE,IAFK,CAAN;AAIA;;AAED,QAAK,EAAGC,IAAI,YAAYG,KAAnB,KAA8BH,IAAI,CAACI,MAAL,KAAgB,CAAnD,EAAuD;AACtD;AACH;AACA;AACA;AACA;AACA;AACG,YAAM,IAAIP,aAAJ,CACL,sCADK,EAELE,IAFK,EAGL;AAAEC,QAAAA,IAAI,EAAJA;AAAF,OAHK,CAAN;AAKA,KA3B+C,CA6BhD;;;AACA,QAAKD,IAAI,CAACG,EAAL,CAAS,aAAT,CAAL,EAAgC;AAC/BF,MAAAA,IAAI,GAAGA,IAAI,CAACK,KAAL,EAAP;AACA,KAFD,MAEO;AACNL,MAAAA,IAAI,gCAAQD,IAAI,CAACO,OAAL,EAAR,sBAA2BN,IAA3B,EAAJ;AACAD,MAAAA,IAAI,GAAGA,IAAI,CAACA,IAAZ;AACA;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,SAAKA,IAAL,GAAYA,IAAZ;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,IAAL,GAAYA,IAAZ;AAEA;AACF;AACA;AACA;AACA;;AACE,SAAKC,UAAL,GAAkBA,UAAlB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;;SACC,eAAa;AACZ,aAAO,KAAKD,IAAL,CAAW,KAAKA,IAAL,CAAUI,MAAV,GAAmB,CAA9B,CAAP;AACA,K;SAED,aAAYG,SAAZ,EAAwB;AACvB,WAAKP,IAAL,CAAW,KAAKA,IAAL,CAAUI,MAAV,GAAmB,CAA9B,IAAoCG,SAApC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACC,eAAa;AACZ,UAAIC,MAAM,GAAG,KAAKT,IAAlB;;AAEA,WAAM,IAAIU,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,KAAKT,IAAL,CAAUI,MAAV,GAAmB,CAAxC,EAA2CK,CAAC,EAA5C,EAAiD;AAChDD,QAAAA,MAAM,GAAGA,MAAM,CAACE,QAAP,CAAiBF,MAAM,CAACG,aAAP,CAAsB,KAAKX,IAAL,CAAWS,CAAX,CAAtB,CAAjB,CAAT;;AAEA,YAAK,CAACD,MAAN,EAAe;AACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,gBAAM,IAAIX,aAAJ,CAAmB,+BAAnB,EAAoD,IAApD,EAA0D;AAAEe,YAAAA,QAAQ,EAAE;AAAZ,WAA1D,CAAN;AACA;AACD;;AAED,UAAKJ,MAAM,CAACN,EAAP,CAAW,OAAX,CAAL,EAA4B;AAC3B,cAAM,IAAIL,aAAJ,CAAmB,+BAAnB,EAAoD,IAApD,EAA0D;AAAEe,UAAAA,QAAQ,EAAE;AAAZ,SAA1D,CAAN;AACA;;AAED,aAAOJ,MAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACC,eAAY;AACX,aAAO,KAAKA,MAAL,CAAYG,aAAZ,CAA2B,KAAKE,MAAhC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;SACC,eAAe;AACd,aAAOC,qBAAqB,CAAE,IAAF,EAAQ,KAAKN,MAAb,CAA5B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAgB;AACf;AACA,UAAMA,MAAM,GAAG,KAAKA,MAApB;AAEA,aAAOO,oBAAoB,CAAE,IAAF,EAAQP,MAAR,EAAgBM,qBAAqB,CAAE,IAAF,EAAQN,MAAR,CAArC,CAA3B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAiB;AAChB;AACA,UAAMA,MAAM,GAAG,KAAKA,MAApB;AAEA,aAAOQ,qBAAqB,CAAE,IAAF,EAAQR,MAAR,EAAgBM,qBAAqB,CAAE,IAAF,EAAQN,MAAR,CAArC,CAA5B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAgB;AACf,aAAO,KAAKK,MAAL,KAAgB,CAAvB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAc;AACb,aAAO,KAAKA,MAAL,IAAe,KAAKL,MAAL,CAAYS,SAAlC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,qBAAaC,aAAb,EAA6B;AAC5B,UAAK,KAAKnB,IAAL,IAAamB,aAAa,CAACnB,IAAhC,EAAuC;AACtC,eAAO,WAAP;AACA;;AAED,UAAMoB,MAAM,GAAGvB,aAAa,CAAE,KAAKI,IAAP,EAAakB,aAAa,CAAClB,IAA3B,CAA5B;;AAEA,cAASmB,MAAT;AACC,aAAK,MAAL;AACC,iBAAO,MAAP;;AAED,aAAK,QAAL;AACC,iBAAO,QAAP;;AAED,aAAK,WAAL;AACC,iBAAO,OAAP;;AAED;AACC,iBAAO,KAAKnB,IAAL,CAAWmB,MAAX,IAAsBD,aAAa,CAAClB,IAAd,CAAoBmB,MAApB,CAAtB,GAAqD,QAArD,GAAgE,OAAvE;AAXF;AAaA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iCAAyBC,IAAzB,EAA8C;AAAA,UAAfC,OAAe,uEAAL,EAAK;AAC7CA,MAAAA,OAAO,CAACC,aAAR,GAAwB,IAAxB;AAEA,UAAMC,UAAU,GAAG,IAAI5B,UAAJ,CAAgB0B,OAAhB,CAAnB;AACAE,MAAAA,UAAU,CAACH,IAAX,CAAiBA,IAAjB;AAEA,aAAOG,UAAU,CAACX,QAAlB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAgB;AACf,aAAO,KAAKZ,IAAL,CAAUK,KAAV,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;;WACC,wBAAe;AACd,UAAMG,MAAM,GAAG,KAAKA,MAApB;;AAEA,UAAKA,MAAM,CAACN,EAAP,CAAW,kBAAX,CAAL,EAAuC;AACtC,eAAO,CAAEM,MAAF,CAAP;AACA,OAFD,MAEO;AACN,eAAOA,MAAM,CAACgB,YAAP,CAAqB;AAAEC,UAAAA,WAAW,EAAE;AAAf,SAArB,CAAP;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,sBAAcC,UAAd,EAA2B;AAC1B,UAAMlB,MAAM,GAAG,KAAKA,MAApB;;AAEA,UAAKA,MAAM,CAACN,EAAP,CAAW,SAAX,CAAL,EAA8B;AAC7B,eAAOM,MAAM,CAACmB,YAAP,CAAqBD,UAArB,EAAiC;AAAED,UAAAA,WAAW,EAAE;AAAf,SAAjC,CAAP;AACA;;AAED,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeb,QAAf,EAA0B;AACzB,UAAK,KAAKb,IAAL,IAAaa,QAAQ,CAACb,IAA3B,EAAkC;AACjC,eAAO,EAAP;AACA,OAHwB,CAKzB;;;AACA,UAAM6B,GAAG,GAAGhC,aAAa,CAAE,KAAKI,IAAP,EAAaY,QAAQ,CAACZ,IAAtB,CAAzB,CANyB,CAOzB;;AACA,UAAM6B,MAAM,GAAK,OAAOD,GAAP,IAAc,QAAhB,GAA6BE,IAAI,CAACC,GAAL,CAAU,KAAK/B,IAAL,CAAUI,MAApB,EAA4BQ,QAAQ,CAACZ,IAAT,CAAcI,MAA1C,CAA7B,GAAkFwB,GAAjG;AAEA,aAAO,KAAK5B,IAAL,CAAUK,KAAV,CAAiB,CAAjB,EAAoBwB,MAApB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,2BAAmBjB,QAAnB,EAA8B;AAC7B,UAAMoB,UAAU,GAAG,KAAKR,YAAL,EAAnB;AACA,UAAMS,UAAU,GAAGrB,QAAQ,CAACY,YAAT,EAAnB;AAEA,UAAIf,CAAC,GAAG,CAAR;;AAEA,aAAQuB,UAAU,CAAEvB,CAAF,CAAV,IAAmBwB,UAAU,CAAExB,CAAF,CAA7B,IAAsCuB,UAAU,CAAEvB,CAAF,CAAxD,EAAgE;AAC/DA,QAAAA,CAAC;AACD;;AAED,aAAOA,CAAC,KAAK,CAAN,GAAU,IAAV,GAAiBuB,UAAU,CAAEvB,CAAC,GAAG,CAAN,CAAlC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sBAAcyB,KAAd,EAAsB;AACrB,UAAMC,OAAO,GAAG,KAAKC,KAAL,EAAhB;AAEA,UAAMvB,MAAM,GAAGsB,OAAO,CAACtB,MAAR,GAAiBqB,KAAhC;AACAC,MAAAA,OAAO,CAACtB,MAAR,GAAiBA,MAAM,GAAG,CAAT,GAAa,CAAb,GAAiBA,MAAlC;AAEA,aAAOsB,OAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAASjB,aAAT,EAAyB;AACxB,aAAO,KAAKmB,WAAL,CAAkBnB,aAAlB,KAAqC,OAA5C;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,kBAAUA,aAAV,EAA0B;AACzB,aAAO,KAAKmB,WAAL,CAAkBnB,aAAlB,KAAqC,QAA5C;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAASA,aAAT,EAAyB;AACxB,aAAO,KAAKmB,WAAL,CAAkBnB,aAAlB,KAAqC,MAA5C;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,oBAAYA,aAAZ,EAA4B;AAC3B,UAAIoB,IAAI,GAAG,IAAX;AACA,UAAIC,KAAK,GAAG,IAAZ;AACA,UAAMC,OAAO,GAAG,KAAKH,WAAL,CAAkBnB,aAAlB,CAAhB;;AAEA,cAASsB,OAAT;AACC,aAAK,MAAL;AACC,iBAAO,IAAP;;AAED,aAAK,QAAL;AACCF,UAAAA,IAAI,GAAGxC,QAAQ,CAAC2C,SAAT,CAAoB,IAApB,CAAP;AACAF,UAAAA,KAAK,GAAGzC,QAAQ,CAAC2C,SAAT,CAAoBvB,aAApB,CAAR;AACA;;AAED,aAAK,OAAL;AACCoB,UAAAA,IAAI,GAAGxC,QAAQ,CAAC2C,SAAT,CAAoBvB,aAApB,CAAP;AACAqB,UAAAA,KAAK,GAAGzC,QAAQ,CAAC2C,SAAT,CAAoB,IAApB,CAAR;AACA;;AAED;AACC,iBAAO,KAAP;AAfF,OAL2B,CAuB3B;;;AACA,UAAIC,UAAU,GAAGJ,IAAI,CAAC9B,MAAtB;;AAEA,aAAQ8B,IAAI,CAACtC,IAAL,CAAUI,MAAV,GAAmBmC,KAAK,CAACvC,IAAN,CAAWI,MAAtC,EAA+C;AAC9C,YAAKkC,IAAI,CAACK,OAAL,CAAcJ,KAAd,CAAL,EAA6B;AAC5B,iBAAO,IAAP;AACA;;AAED,YAAKD,IAAI,CAACtC,IAAL,CAAUI,MAAV,GAAmBmC,KAAK,CAACvC,IAAN,CAAWI,MAAnC,EAA4C;AAC3C,cAAKkC,IAAI,CAACzB,MAAL,KAAgB6B,UAAU,CAACzB,SAAhC,EAA4C;AAC3C,mBAAO,KAAP;AACA;;AAEDqB,UAAAA,IAAI,CAACtC,IAAL,GAAYsC,IAAI,CAACtC,IAAL,CAAUK,KAAV,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAZ;AACAqC,UAAAA,UAAU,GAAGA,UAAU,CAAClC,MAAxB;AACA8B,UAAAA,IAAI,CAACzB,MAAL;AACA,SARD,MAQO;AACN,cAAK0B,KAAK,CAAC1B,MAAN,KAAiB,CAAtB,EAA0B;AACzB,mBAAO,KAAP;AACA;;AAED0B,UAAAA,KAAK,CAACvC,IAAN,GAAauC,KAAK,CAACvC,IAAN,CAAWK,KAAX,CAAkB,CAAlB,EAAqB,CAAC,CAAtB,CAAb;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,YAAIuC,IAAJ,EAAW;AACV,aAAOA,IAAI,KAAK,UAAT,IAAuBA,IAAI,KAAK,gBAAvC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAiBhC,QAAjB,EAA4B;AAC3B,UAAK,KAAKb,IAAL,KAAca,QAAQ,CAACb,IAA5B,EAAmC;AAClC,eAAO,KAAP;AACA;;AAED,UAAM8C,cAAc,GAAG,KAAKC,aAAL,EAAvB;AACA,UAAMC,aAAa,GAAGnC,QAAQ,CAACkC,aAAT,EAAtB;AAEA,aAAOlD,aAAa,CAAEiD,cAAF,EAAkBE,aAAlB,CAAb,IAAkD,MAAzD;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,mCAA2BC,SAA3B,EAAuC;AACtC,UAAI7B,MAAJ;;AAEA,cAAS6B,SAAS,CAACJ,IAAnB;AACC,aAAK,QAAL;AACCzB,UAAAA,MAAM,GAAG,KAAK8B,gCAAL,CAAuCD,SAAvC,CAAT;AACA;;AACD,aAAK,MAAL;AACA,aAAK,QAAL;AACA,aAAK,UAAL;AACC7B,UAAAA,MAAM,GAAG,KAAK+B,8BAAL,CAAqCF,SAArC,CAAT;AACA;;AACD,aAAK,OAAL;AACC7B,UAAAA,MAAM,GAAG,KAAKgC,+BAAL,CAAsCH,SAAtC,CAAT;AACA;;AACD,aAAK,OAAL;AACC7B,UAAAA,MAAM,GAAG,KAAKiC,+BAAL,CAAsCJ,SAAtC,CAAT;AACA;;AACD;AACC7B,UAAAA,MAAM,GAAGrB,QAAQ,CAAC2C,SAAT,CAAoB,IAApB,CAAT;AACA;AAjBF;;AAoBA,aAAOtB,MAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,0CAAkC6B,SAAlC,EAA8C;AAC7C,aAAO,KAAKK,0BAAL,CAAiCL,SAAS,CAACpC,QAA3C,EAAqDoC,SAAS,CAACM,OAA/D,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,wCAAgCN,SAAhC,EAA4C;AAC3C,aAAO,KAAKO,qBAAL,CAA4BP,SAAS,CAACQ,cAAtC,EAAsDR,SAAS,CAACS,cAAhE,EAAgFT,SAAS,CAACM,OAA1F,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,yCAAiCN,SAAjC,EAA6C;AAC5C,UAAMU,UAAU,GAAGV,SAAS,CAACU,UAA7B;AAEA,UAAMC,WAAW,GAAGD,UAAU,CAACE,gBAAX,CAA6B,IAA7B,KACjBF,UAAU,CAACG,KAAX,CAAiBlB,OAAjB,CAA0B,IAA1B,KAAoC,KAAK1C,UAAL,IAAmB,QAD1D;;AAGA,UAAK0D,WAAL,EAAmB;AAClB,eAAO,KAAKG,YAAL,CAAmBd,SAAS,CAACe,aAA7B,EAA4Cf,SAAS,CAACgB,kBAAtD,CAAP;AACA,OAFD,MAEO;AACN,YAAKhB,SAAS,CAACiB,iBAAf,EAAmC;AAClC,iBAAO,KAAKV,qBAAL,CAA4BP,SAAS,CAACiB,iBAAtC,EAAyDjB,SAAS,CAACkB,iBAAnE,EAAsF,CAAtF,CAAP;AACA,SAFD,MAEO;AACN,iBAAO,KAAKb,0BAAL,CAAiCL,SAAS,CAACkB,iBAA3C,EAA8D,CAA9D,CAAP;AACA;AACD;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,yCAAiClB,SAAjC,EAA6C;AAC5C,UAAMU,UAAU,GAAGV,SAAS,CAACU,UAA7B;AACA,UAAMC,WAAW,GAAGD,UAAU,CAACE,gBAAX,CAA6B,IAA7B,KAAuCF,UAAU,CAACG,KAAX,CAAiBlB,OAAjB,CAA0B,IAA1B,CAA3D;AAEA,UAAIwB,GAAJ;;AAEA,UAAKR,WAAL,EAAmB;AAClBQ,QAAAA,GAAG,GAAG,KAAKL,YAAL,CAAmBd,SAAS,CAACQ,cAA7B,EAA6CR,SAAS,CAACS,cAAvD,CAAN;;AAEA,YAAKT,SAAS,CAACQ,cAAV,CAAyBY,QAAzB,CAAmCpB,SAAS,CAACS,cAA7C,CAAL,EAAqE;AACpE;AACAU,UAAAA,GAAG,GAAGA,GAAG,CAACE,yBAAJ,CAA+BrB,SAAS,CAACsB,gBAAzC,EAA2D,CAA3D,CAAN;AACA;AACD,OAPD,MAOO,IAAK,KAAK3B,OAAL,CAAcK,SAAS,CAACsB,gBAAxB,CAAL,EAAkD;AACxDH,QAAAA,GAAG,GAAGrE,QAAQ,CAAC2C,SAAT,CAAoBO,SAAS,CAACsB,gBAA9B,CAAN;AACA,OAFM,MAEA;AACNH,QAAAA,GAAG,GAAG,KAAKZ,qBAAL,CAA4BP,SAAS,CAACsB,gBAAtC,EAAwDtB,SAAS,CAACiB,iBAAlE,EAAqF,CAArF,CAAN;AACA;;AAED,aAAOE,GAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,mCAA2BI,cAA3B,EAA2CjB,OAA3C,EAAqD;AACpD,UAAMkB,WAAW,GAAG1E,QAAQ,CAAC2C,SAAT,CAAoB,IAApB,CAApB,CADoD,CAGpD;;;AACA,UAAK,KAAK1C,IAAL,IAAawE,cAAc,CAACxE,IAAjC,EAAwC;AACvC,eAAOyE,WAAP;AACA;;AAED,UAAK5E,aAAa,CAAE2E,cAAc,CAACzB,aAAf,EAAF,EAAkC,KAAKA,aAAL,EAAlC,CAAb,IAAyE,MAA9E,EAAuF;AACtF;AACA,YAAKyB,cAAc,CAAC1D,MAAf,GAAwB,KAAKA,MAAlC,EAA2C;AAC1C;AACA,cAAK0D,cAAc,CAAC1D,MAAf,GAAwByC,OAAxB,GAAkC,KAAKzC,MAA5C,EAAqD;AACpD;AACA,mBAAO,IAAP;AACA,WAHD,MAGO;AACN;AACA2D,YAAAA,WAAW,CAAC3D,MAAZ,IAAsByC,OAAtB;AACA;AACD;AACD,OAZD,MAYO,IAAK1D,aAAa,CAAE2E,cAAc,CAACzB,aAAf,EAAF,EAAkC,KAAKA,aAAL,EAAlC,CAAb,IAAyE,QAA9E,EAAyF;AAC/F;AACA,YAAMrC,CAAC,GAAG8D,cAAc,CAACvE,IAAf,CAAoBI,MAApB,GAA6B,CAAvC;;AAEA,YAAKmE,cAAc,CAAC1D,MAAf,IAAyB,KAAKb,IAAL,CAAWS,CAAX,CAA9B,EAA+C;AAC9C;AACA,cAAK8D,cAAc,CAAC1D,MAAf,GAAwByC,OAAxB,GAAkC,KAAKtD,IAAL,CAAWS,CAAX,CAAvC,EAAwD;AACvD;AACA;AACA,mBAAO,IAAP;AACA,WAJD,MAIO;AACN;AACA+D,YAAAA,WAAW,CAACxE,IAAZ,CAAkBS,CAAlB,KAAyB6C,OAAzB;AACA;AACD;AACD;;AAED,aAAOkB,WAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,oCAA4BC,cAA5B,EAA4CnB,OAA5C,EAAsD;AACrD,UAAMkB,WAAW,GAAG1E,QAAQ,CAAC2C,SAAT,CAAoB,IAApB,CAApB,CADqD,CAGrD;;;AACA,UAAK,KAAK1C,IAAL,IAAa0E,cAAc,CAAC1E,IAAjC,EAAwC;AACvC,eAAOyE,WAAP;AACA;;AAED,UAAK5E,aAAa,CAAE6E,cAAc,CAAC3B,aAAf,EAAF,EAAkC,KAAKA,aAAL,EAAlC,CAAb,IAAyE,MAA9E,EAAuF;AACtF;AACA,YAAK2B,cAAc,CAAC5D,MAAf,GAAwB,KAAKA,MAA7B,IAAyC4D,cAAc,CAAC5D,MAAf,IAAyB,KAAKA,MAA9B,IAAwC,KAAKZ,UAAL,IAAmB,YAAzG,EAA0H;AACzH;AACA;AACAuE,UAAAA,WAAW,CAAC3D,MAAZ,IAAsByC,OAAtB;AACA;AACD,OAPD,MAOO,IAAK1D,aAAa,CAAE6E,cAAc,CAAC3B,aAAf,EAAF,EAAkC,KAAKA,aAAL,EAAlC,CAAb,IAAyE,QAA9E,EAAyF;AAC/F;AACA,YAAMrC,CAAC,GAAGgE,cAAc,CAACzE,IAAf,CAAoBI,MAApB,GAA6B,CAAvC;;AAEA,YAAKqE,cAAc,CAAC5D,MAAf,IAAyB,KAAKb,IAAL,CAAWS,CAAX,CAA9B,EAA+C;AAC9C;AACA;AACA+D,UAAAA,WAAW,CAACxE,IAAZ,CAAkBS,CAAlB,KAAyB6C,OAAzB;AACA;AACD;;AAED,aAAOkB,WAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,+BAAuBhB,cAAvB,EAAuCC,cAAvC,EAAuDH,OAAvD,EAAiE;AAChE;AACAG,MAAAA,cAAc,GAAGA,cAAc,CAACY,yBAAf,CAA0Cb,cAA1C,EAA0DF,OAA1D,CAAjB;;AAEA,UAAKE,cAAc,CAACb,OAAf,CAAwBc,cAAxB,CAAL,EAAgD;AAC/C;AACA,eAAO3D,QAAQ,CAAC2C,SAAT,CAAoB,IAApB,CAAP;AACA,OAP+D,CAShE;;;AACA,UAAM+B,WAAW,GAAG,KAAKH,yBAAL,CAAgCb,cAAhC,EAAgDF,OAAhD,CAApB;;AAEA,UAAMoB,OAAO,GAAGF,WAAW,KAAK,IAAhB,IACbhB,cAAc,CAACb,OAAf,CAAwB,IAAxB,KAAkC,KAAK1C,UAAL,IAAmB,QADxC,IAEbuD,cAAc,CAACmB,YAAf,CAA6BrB,OAA7B,EAAuCX,OAAvC,CAAgD,IAAhD,KAA0D,KAAK1C,UAAL,IAAmB,YAFhF;;AAIA,UAAKyE,OAAL,EAAe;AACd;AACA;AACA,eAAO,KAAKZ,YAAL,CAAmBN,cAAnB,EAAmCC,cAAnC,CAAP;AACA,OAJD,MAIO;AACN;AACA;AACA;AACA,eAAOe,WAAW,CAACnB,0BAAZ,CAAwCI,cAAxC,EAAwDH,OAAxD,CAAP;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sBAAcsB,MAAd,EAAsBC,MAAtB,EAA+B;AAC9B,UAAMpE,CAAC,GAAGmE,MAAM,CAAC5E,IAAP,CAAYI,MAAZ,GAAqB,CAA/B,CAD8B,CAG9B;;AACA,UAAM0E,QAAQ,GAAGhF,QAAQ,CAAC2C,SAAT,CAAoBoC,MAApB,CAAjB;;AACAC,MAAAA,QAAQ,CAAC7E,UAAT,GAAsB,KAAKA,UAA3B,CAL8B,CAO9B;AAEA;;AACA6E,MAAAA,QAAQ,CAACjE,MAAT,GAAkBiE,QAAQ,CAACjE,MAAT,GAAkB,KAAKb,IAAL,CAAWS,CAAX,CAAlB,GAAmCmE,MAAM,CAAC/D,MAA5D,CAV8B,CAY9B;AACA;;AACAiE,MAAAA,QAAQ,CAAC9E,IAAT,gCAAqB8E,QAAQ,CAAC9E,IAA9B,sBAAuC,KAAKA,IAAL,CAAUK,KAAV,CAAiBI,CAAC,GAAG,CAArB,CAAvC;AAEA,aAAOqE,QAAP;AACA;AAED;AACD;AACA;;;;WACC,kBAAS;AACR,aAAO;AACN/E,QAAAA,IAAI,EAAE,KAAKA,IAAL,CAAUgF,MAAV,EADA;AAEN/E,QAAAA,IAAI,EAAEG,KAAK,CAAC6E,IAAN,CAAY,KAAKhF,IAAjB,CAFA;AAGNC,QAAAA,UAAU,EAAE,KAAKA;AAHX,OAAP;AAKA;AAED;AACD;AACA;AACA;AACA;;;;WACC,iBAAQ;AACP,aAAO,IAAI,KAAKgF,WAAT,CAAsB,KAAKlF,IAA3B,EAAiC,KAAKC,IAAtC,EAA4C,KAAKC,UAAjD,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,mBAAkBiF,cAAlB,EAAkCrE,MAAlC,EAAkE;AAAA,UAAxBZ,UAAwB,uEAAX,QAAW;;AACjE,UAAKiF,cAAc,YAAYpF,QAA/B,EAA0C;AACzC,eAAO,IAAIA,QAAJ,CAAcoF,cAAc,CAACnF,IAA7B,EAAmCmF,cAAc,CAAClF,IAAlD,EAAwDkF,cAAc,CAACjF,UAAvE,CAAP;AACA,OAFD,MAEO;AACN,YAAMkF,IAAI,GAAGD,cAAb;;AAEA,YAAKrE,MAAM,IAAI,KAAf,EAAuB;AACtBA,UAAAA,MAAM,GAAGsE,IAAI,CAAClE,SAAd;AACA,SAFD,MAEO,IAAKJ,MAAM,IAAI,QAAf,EAA0B;AAChC,iBAAO,KAAKuE,aAAL,CAAoBD,IAApB,EAA0BlF,UAA1B,CAAP;AACA,SAFM,MAEA,IAAKY,MAAM,IAAI,OAAf,EAAyB;AAC/B,iBAAO,KAAKwE,YAAL,CAAmBF,IAAnB,EAAyBlF,UAAzB,CAAP;AACA,SAFM,MAEA,IAAKY,MAAM,KAAK,CAAX,IAAgB,CAACA,MAAtB,EAA+B;AACrC;AACJ;AACA;AACA;AACA;AACA;AACI,gBAAM,IAAIhB,aAAJ,CAAmB,wCAAnB,EAA6D,CAAE,IAAF,EAAQqF,cAAR,CAA7D,CAAN;AACA;;AAED,YAAK,CAACC,IAAI,CAACjF,EAAL,CAAS,SAAT,CAAD,IAAyB,CAACiF,IAAI,CAACjF,EAAL,CAAS,kBAAT,CAA/B,EAA+D;AAC9D;AACJ;AACA;AACA;AACA;AACI,gBAAM,IAAIL,aAAJ,CACL,iCADK,EAEL,CAAE,IAAF,EAAQqF,cAAR,CAFK,CAAN;AAIA;;AAED,YAAMlF,IAAI,GAAGmF,IAAI,CAAC7E,OAAL,EAAb;AAEAN,QAAAA,IAAI,CAACsF,IAAL,CAAWzE,MAAX;AAEA,eAAO,IAAI,IAAJ,CAAUsE,IAAI,CAACpF,IAAf,EAAqBC,IAArB,EAA2BC,UAA3B,CAAP;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sBAAqBsF,IAArB,EAA2BtF,UAA3B,EAAwC;AACvC,UAAK,CAACsF,IAAI,CAAC/E,MAAX,EAAoB;AACnB;AACH;AACA;AACA;AACA;AACA;AACG,cAAM,IAAIX,aAAJ,CACL,2BADK,EAEL,CAAE,IAAF,EAAQ0F,IAAR,CAFK,EAGL;AAAExF,UAAAA,IAAI,EAAEwF;AAAR,SAHK,CAAN;AAKA;;AAED,aAAO,KAAK9C,SAAL,CAAgB8C,IAAI,CAAC/E,MAArB,EAA6B+E,IAAI,CAACC,SAAlC,EAA6CvF,UAA7C,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAsBsF,IAAtB,EAA4BtF,UAA5B,EAAyC;AACxC,UAAK,CAACsF,IAAI,CAAC/E,MAAX,EAAoB;AACnB;AACH;AACA;AACA;AACA;AACA;AACG,cAAM,IAAIX,aAAJ,CACL,4BADK,EAEL0F,IAFK,EAGL;AAAExF,UAAAA,IAAI,EAAEwF;AAAR,SAHK,CAAN;AAKA;;AAED,aAAO,KAAK9C,SAAL,CAAgB8C,IAAI,CAAC/E,MAArB,EAA6B+E,IAAI,CAACE,WAAlC,EAA+CxF,UAA/C,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,kBAAiByF,IAAjB,EAAuBC,GAAvB,EAA6B;AAC5B,UAAKD,IAAI,CAAC3F,IAAL,KAAc,YAAnB,EAAkC;AACjC,YAAMoE,GAAG,GAAG,IAAIrE,QAAJ,CAAc6F,GAAG,CAACC,SAAlB,EAA6BF,IAAI,CAAC1F,IAAlC,CAAZ;AACAmE,QAAAA,GAAG,CAAClE,UAAJ,GAAiByF,IAAI,CAACzF,UAAtB;AAEA,eAAOkE,GAAP;AACA;;AAED,UAAK,CAACwB,GAAG,CAACE,OAAJ,CAAaH,IAAI,CAAC3F,IAAlB,CAAN,EAAiC;AAChC;AACH;AACA;AACA;AACA;AACA;AACG,cAAM,IAAIF,aAAJ,CACL,iCADK,EAEL8F,GAFK,EAGL;AAAEG,UAAAA,QAAQ,EAAEJ,IAAI,CAAC3F;AAAjB,SAHK,CAAN;AAKA;;AAED,aAAO,IAAID,QAAJ,CAAc6F,GAAG,CAACE,OAAJ,CAAaH,IAAI,CAAC3F,IAAlB,CAAd,EAAwC2F,IAAI,CAAC1F,IAA7C,EAAmD0F,IAAI,CAACzF,UAAxD,CAAP;AACA,K,CAED;AACA;AACA;AAEA;AACA;AACA;;;;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SA9hCqBH,Q;AA+hCrB,OAAO,SAASgB,qBAAT,CAAgCF,QAAhC,EAA0CmF,cAA1C,EAA2D;AACjE,MAAMZ,IAAI,GAAGY,cAAc,CAACrF,QAAf,CAAyBqF,cAAc,CAACpF,aAAf,CAA8BC,QAAQ,CAACC,MAAvC,CAAzB,CAAb;;AAEA,MAAKsE,IAAI,IAAIA,IAAI,CAACjF,EAAL,CAAS,OAAT,CAAR,IAA8BiF,IAAI,CAACM,WAAL,GAAmB7E,QAAQ,CAACC,MAA/D,EAAwE;AACvE,WAAOsE,IAAP;AACA;;AAED,SAAO,IAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASpE,oBAAT,CAA+BH,QAA/B,EAAyCmF,cAAzC,EAAyDC,QAAzD,EAAoE;AAC1E,MAAKA,QAAQ,KAAK,IAAlB,EAAyB;AACxB,WAAO,IAAP;AACA;;AAED,SAAOD,cAAc,CAACrF,QAAf,CAAyBqF,cAAc,CAACpF,aAAf,CAA8BC,QAAQ,CAACC,MAAvC,CAAzB,CAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,qBAAT,CAAgCJ,QAAhC,EAA0CmF,cAA1C,EAA0DC,QAA1D,EAAqE;AAC3E,MAAKA,QAAQ,KAAK,IAAlB,EAAyB;AACxB,WAAO,IAAP;AACA;;AAED,SAAOD,cAAc,CAACrF,QAAf,CAAyBqF,cAAc,CAACpF,aAAf,CAA8BC,QAAQ,CAACC,MAAvC,IAAkD,CAA3E,CAAP;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/position\n */\n\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\nexport default class Position {\n\t/**\n\t * Creates a position.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t */\n\tconstructor( root, path, stickiness = 'toNone' ) {\n\t\tif ( !root.is( 'element' ) && !root.is( 'documentFragment' ) ) {\n\t\t\t/**\n\t\t\t * Position root is invalid.\n\t\t\t *\n\t\t\t * Positions can only be anchored in elements or document fragments.\n\t\t\t *\n\t\t\t * @error model-position-root-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-root-invalid',\n\t\t\t\troot\n\t\t\t);\n\t\t}\n\n\t\tif ( !( path instanceof Array ) || path.length === 0 ) {\n\t\t\t/**\n\t\t\t * Position path must be an array with at least one item.\n\t\t\t *\n\t\t\t * @error model-position-path-incorrect-format\n\t\t\t * @param path\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-path-incorrect-format',\n\t\t\t\troot,\n\t\t\t\t{ path }\n\t\t\t);\n\t\t}\n\n\t\t// Normalize the root and path when element (not root) is passed.\n\t\tif ( root.is( 'rootElement' ) ) {\n\t\t\tpath = path.slice();\n\t\t} else {\n\t\t\tpath = [ ...root.getPath(), ...path ];\n\t\t\troot = root.root;\n\t\t}\n\n\t\t/**\n\t\t * Root of the position path.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/position~Position#root\n\t\t */\n\t\tthis.root = root;\n\n\t\t/**\n\t\t * Position of the node in the tree. **Path contains offsets, not indexes.**\n\t\t *\n\t\t * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n\t\t * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n\t\t * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n\t\t * down to the position offset in it's parent.\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n\t\t *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n\t\t *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n\t\t *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n\t\t *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n\t\t *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n\t\t *\n\t\t * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n\t\t * greater than `1` you can place position offset between their start and end:\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P\n\t\t *\t\t  |- UL\n\t\t *\t\t     |- LI\n\t\t *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n\t\t *\t\t     |- LI\n\t\t *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<Number>} module:engine/model/position~Position#path\n\t\t */\n\t\tthis.path = path;\n\n\t\t/**\n\t\t * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n\t\t *\n\t\t * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n\t\t */\n\t\tthis.stickiness = stickiness;\n\t}\n\n\t/**\n\t * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n\t * to the last item in position {@link module:engine/model/position~Position#path path}.\n\t *\n\t * @type {Number}\n\t */\n\tget offset() {\n\t\treturn this.path[ this.path.length - 1 ];\n\t}\n\n\tset offset( newOffset ) {\n\t\tthis.path[ this.path.length - 1 ] = newOffset;\n\t}\n\n\t/**\n\t * Parent element of this position.\n\t *\n\t * Keep in mind that `parent` value is calculated when the property is accessed.\n\t * If {@link module:engine/model/position~Position#path position path}\n\t * leads to a non-existing element, `parent` property will throw error.\n\t *\n\t * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n\t *\n\t * @readonly\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget parent() {\n\t\tlet parent = this.root;\n\n\t\tfor ( let i = 0; i < this.path.length - 1; i++ ) {\n\t\t\tparent = parent.getChild( parent.offsetToIndex( this.path[ i ] ) );\n\n\t\t\tif ( !parent ) {\n\t\t\t\t/**\n\t\t\t\t * The position's path is incorrect. This means that a position does not point to\n\t\t\t\t * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n\t\t\t\t *\n\t\t\t\t * **Note**: Unlike DOM and view positions, in the model, the\n\t\t\t\t * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n\t\t\t\t * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element\n\t\t\t\t * where this position points.\n\t\t\t\t *\n\t\t\t\t * Read more about model positions and offsets in\n\t\t\t\t * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n\t\t\t\t *\n\t\t\t\t * @error model-position-path-incorrect\n\t\t\t\t * @param {module:engine/model/position~Position} position The incorrect position.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'model-position-path-incorrect', this, { position: this } );\n\t\t\t}\n\t\t}\n\n\t\tif ( parent.is( '$text' ) ) {\n\t\t\tthrow new CKEditorError( 'model-position-path-incorrect', this, { position: this } );\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n\t * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n\t * in text node, position index is equal to the index of that text node.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget index() {\n\t\treturn this.parent.offsetToIndex( this.offset );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n\t * position is not in a text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/text~Text|null}\n\t */\n\tget textNode() {\n\t\treturn getTextNodeAtPosition( this, this.parent );\n\t}\n\n\t/**\n\t * Node directly after this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nodeAfter() {\n\t\t// Cache the parent and reuse for performance reasons. See #6579 and #6582.\n\t\tconst parent = this.parent;\n\n\t\treturn getNodeAfterPosition( this, parent, getTextNodeAtPosition( this, parent ) );\n\t}\n\n\t/**\n\t * Node directly before this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nodeBefore() {\n\t\t// Cache the parent and reuse for performance reasons. See #6579 and #6582.\n\t\tconst parent = this.parent;\n\n\t\treturn getNodeBeforePosition( this, parent, getTextNodeAtPosition( this, parent ) );\n\t}\n\n\t/**\n\t * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtStart() {\n\t\treturn this.offset === 0;\n\t}\n\n\t/**\n\t * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtEnd() {\n\t\treturn this.offset == this.parent.maxOffset;\n\t}\n\n\t/**\n\t * Checks whether this position is before or after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {module:engine/model/position~PositionRelation}\n\t */\n\tcompareWith( otherPosition ) {\n\t\tif ( this.root != otherPosition.root ) {\n\t\t\treturn 'different';\n\t\t}\n\n\t\tconst result = compareArrays( this.path, otherPosition.path );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'same':\n\t\t\t\treturn 'same';\n\n\t\t\tcase 'prefix':\n\t\t\t\treturn 'before';\n\n\t\t\tcase 'extension':\n\t\t\t\treturn 'after';\n\n\t\t\tdefault:\n\t\t\t\treturn this.path[ result ] < otherPosition.path[ result ] ? 'before' : 'after';\n\t\t}\n\t}\n\n\t/**\n\t * Gets the farthest position which matches the callback using\n\t * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n\t *\n\t * For example:\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n\t * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n\t * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => false );\n\t * \t\t// Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t *\n\t * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n\t */\n\tgetLastMatchingPosition( skip, options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\t\ttreeWalker.skip( skip );\n\n\t\treturn treeWalker.position;\n\t}\n\n\t/**\n\t * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n\t * but without the last item.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @returns {Array.<Number>} Path to the parent.\n\t */\n\tgetParentPath() {\n\t\treturn this.path.slice( 0, -1 );\n\t}\n\n\t/**\n\t * Returns ancestors array of this position, that is this position's parent and its ancestors.\n\t *\n\t * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n\t */\n\tgetAncestors() {\n\t\tconst parent = this.parent;\n\n\t\tif ( parent.is( 'documentFragment' ) ) {\n\t\t\treturn [ parent ];\n\t\t} else {\n\t\t\treturn parent.getAncestors( { includeSelf: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.\n\t *\n\t * @param {String} parentName The name of the parent element to find.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tfindAncestor( parentName ) {\n\t\tconst parent = this.parent;\n\n\t\tif ( parent.is( 'element' ) ) {\n\t\t\treturn parent.findAncestor( parentName, { includeSelf: true } );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n\t * of these two paths must be identical.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {Array.<Number>} The common path.\n\t */\n\tgetCommonPath( position ) {\n\t\tif ( this.root != position.root ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// We find on which tree-level start and end have the lowest common ancestor\n\t\tconst cmp = compareArrays( this.path, position.path );\n\t\t// If comparison returned string it means that arrays are same.\n\t\tconst diffAt = ( typeof cmp == 'string' ) ? Math.min( this.path.length, position.path.length ) : cmp;\n\n\t\treturn this.path.slice( 0, diffAt );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( position ) {\n\t\tconst ancestorsA = this.getAncestors();\n\t\tconst ancestorsB = position.getAncestors();\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n\t * is shifted by `shift` value (can be a negative value).\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {Number} shift Offset shift. Can be a negative value.\n\t * @returns {module:engine/model/position~Position} Shifted position.\n\t */\n\tgetShiftedBy( shift ) {\n\t\tconst shifted = this.clone();\n\n\t\tconst offset = shifted.offset + shift;\n\t\tshifted.offset = offset < 0 ? 0 : offset;\n\n\t\treturn shifted;\n\t}\n\n\t/**\n\t * Checks whether this position is after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @see module:engine/model/position~Position#isBefore\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is after given position.\n\t */\n\tisAfter( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'after';\n\t}\n\n\t/**\n\t * Checks whether this position is before given position.\n\t *\n\t * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n\t * be `true` if positions are in different roots and you might not expect this. You should probably use\n\t * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n\t * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n\t *\n\t *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do A.\n\t *\t\t} else {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * or, if you have only one if-branch:\n\t *\n\t *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * rather than:\n\t *\n\t *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t} else {\n\t *\t\t\t// do A.\n\t *\t\t}\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is before given position.\n\t */\n\tisBefore( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'before';\n\t}\n\n\t/**\n\t * Checks whether this position is equal to given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions are same.\n\t */\n\tisEqual( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'same';\n\t}\n\n\t/**\n\t * Checks whether this position is touching given position. Positions touch when there are no text nodes\n\t * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n\t * they are very similar or even indistinguishable.\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions touch.\n\t */\n\tisTouching( otherPosition ) {\n\t\tlet left = null;\n\t\tlet right = null;\n\t\tconst compare = this.compareWith( otherPosition );\n\n\t\tswitch ( compare ) {\n\t\t\tcase 'same':\n\t\t\t\treturn true;\n\n\t\t\tcase 'before':\n\t\t\t\tleft = Position._createAt( this );\n\t\t\t\tright = Position._createAt( otherPosition );\n\t\t\t\tbreak;\n\n\t\t\tcase 'after':\n\t\t\t\tleft = Position._createAt( otherPosition );\n\t\t\t\tright = Position._createAt( this );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\t// Cached for optimization purposes.\n\t\tlet leftParent = left.parent;\n\n\t\twhile ( left.path.length + right.path.length ) {\n\t\t\tif ( left.isEqual( right ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( left.path.length > right.path.length ) {\n\t\t\t\tif ( left.offset !== leftParent.maxOffset ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tleft.path = left.path.slice( 0, -1 );\n\t\t\t\tleftParent = leftParent.parent;\n\t\t\t\tleft.offset++;\n\t\t\t} else {\n\t\t\t\tif ( right.offset !== 0 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tright.path = right.path.slice( 0, -1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tposition.is( 'position' ); // -> true\n\t *\t\tposition.is( 'model:position' ); // -> true\n\t *\n\t *\t\tposition.is( 'view:position' ); // -> false\n\t *\t\tposition.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'position' || type === 'model:position';\n\t}\n\n\t/**\n\t * Checks if two positions are in the same parent.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position Position to compare with.\n\t * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n\t */\n\thasSameParentAs( position ) {\n\t\tif ( this.root !== position.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisParentPath = this.getParentPath();\n\t\tconst posParentPath = position.getParentPath();\n\n\t\treturn compareArrays( thisParentPath, posParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Returns a copy of this position that is transformed by given `operation`.\n\t *\n\t * The new position's parameters are updated accordingly to the effect of the `operation`.\n\t *\n\t * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n\t * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tlet result;\n\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\tresult = this._getTransformedByInsertOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\tresult = this._getTransformedByMoveOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'split':\n\t\t\t\tresult = this._getTransformedBySplitOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'merge':\n\t\t\t\tresult = this._getTransformedByMergeOperation( operation );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = Position._createAt( this );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by an insert operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByInsertOperation( operation ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a move operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMoveOperation( operation ) {\n\t\treturn this._getTransformedByMove( operation.sourcePosition, operation.targetPosition, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a split operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\n\t\tconst isContained = movedRange.containsPosition( this ) ||\n\t\t\t( movedRange.start.isEqual( this ) && this.stickiness == 'toNext' );\n\n\t\tif ( isContained ) {\n\t\t\treturn this._getCombined( operation.splitPosition, operation.moveTargetPosition );\n\t\t} else {\n\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\treturn this._getTransformedByMove( operation.graveyardPosition, operation.insertionPosition, 1 );\n\t\t\t} else {\n\t\t\t\treturn this._getTransformedByInsertion( operation.insertionPosition, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by merge operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\t\tconst isContained = movedRange.containsPosition( this ) || movedRange.start.isEqual( this );\n\n\t\tlet pos;\n\n\t\tif ( isContained ) {\n\t\t\tpos = this._getCombined( operation.sourcePosition, operation.targetPosition );\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Above happens during OT when the merged element is moved before the merged-to element.\n\t\t\t\tpos = pos._getTransformedByDeletion( operation.deletionPosition, 1 );\n\t\t\t}\n\t\t} else if ( this.isEqual( operation.deletionPosition ) ) {\n\t\t\tpos = Position._createAt( operation.deletionPosition );\n\t\t} else {\n\t\t\tpos = this._getTransformedByMove( operation.deletionPosition, operation.graveyardPosition, 1 );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n\t * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if deletion was in a different root.\n\t\tif ( this.root != deletePosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are removed from the node that is pointed by this position...\n\t\t\tif ( deletePosition.offset < this.offset ) {\n\t\t\t\t// And are removed from before an offset of that position...\n\t\t\t\tif ( deletePosition.offset + howMany > this.offset ) {\n\t\t\t\t\t// Position is in removed range, it's no longer in the tree.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the offset accordingly.\n\t\t\t\t\ttransformed.offset -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are removed from a node that is on a path to this position...\n\t\t\tconst i = deletePosition.path.length - 1;\n\n\t\t\tif ( deletePosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are removed from before next node of that path...\n\t\t\t\tif ( deletePosition.offset + howMany > this.path[ i ] ) {\n\t\t\t\t\t// If the next node of that path is removed return null\n\t\t\t\t\t// because the node containing this position got removed.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, decrement index on that path.\n\t\t\t\t\ttransformed.path[ i ] -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if insertion was in a different root.\n\t\tif ( this.root != insertPosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are inserted in the node that is pointed by this position...\n\t\t\tif ( insertPosition.offset < this.offset || ( insertPosition.offset == this.offset && this.stickiness != 'toPrevious' ) ) {\n\t\t\t\t// And are inserted before an offset of that position...\n\t\t\t\t// \"Push\" this positions offset.\n\t\t\t\ttransformed.offset += howMany;\n\t\t\t}\n\t\t} else if ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are inserted in a node that is on a path to this position...\n\t\t\tconst i = insertPosition.path.length - 1;\n\n\t\t\tif ( insertPosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are inserted before next node of that path...\n\t\t\t\t// \"Push\" the index on that path.\n\t\t\t\ttransformed.path[ i ] += howMany;\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n\t * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n\t * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany ) {\n\t\t// Update target position, as it could be affected by nodes removal.\n\t\ttargetPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( sourcePosition.isEqual( targetPosition ) ) {\n\t\t\t// If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n\t\t\treturn Position._createAt( this );\n\t\t}\n\n\t\t// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\t\tconst transformed = this._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tconst isMoved = transformed === null ||\n\t\t\t( sourcePosition.isEqual( this ) && this.stickiness == 'toNext' ) ||\n\t\t\t( sourcePosition.getShiftedBy( howMany ).isEqual( this ) && this.stickiness == 'toPrevious' );\n\n\t\tif ( isMoved ) {\n\t\t\t// This position is inside moved range (or sticks to it).\n\t\t\t// In this case, we calculate a combination of this position, move source position and target position.\n\t\t\treturn this._getCombined( sourcePosition, targetPosition );\n\t\t} else {\n\t\t\t// This position is not inside a removed range.\n\t\t\t//\n\t\t\t// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n\t\t\treturn transformed._getTransformedByInsertion( targetPosition, howMany );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new position that is a combination of this position and given positions.\n\t *\n\t * The combined position is a copy of this position transformed by moving a range starting at `source` position\n\t * to the `target` position. It is expected that this position is inside the moved range.\n\t *\n\t * Example:\n\t *\n\t *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n\t *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n\t *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n\t *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n\t *\n\t * Explanation:\n\t *\n\t * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n\t * was inside moved nodes and now should point to the new place. The moved nodes will be after\n\t * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n\t * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n\t * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n\t * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} source Beginning of the moved range.\n\t * @param {module:engine/model/position~Position} target Position where the range is moved.\n\t * @returns {module:engine/model/position~Position} Combined position.\n\t */\n\t_getCombined( source, target ) {\n\t\tconst i = source.path.length - 1;\n\n\t\t// The first part of a path to combined position is a path to the place where nodes were moved.\n\t\tconst combined = Position._createAt( target );\n\t\tcombined.stickiness = this.stickiness;\n\n\t\t// Then we have to update the rest of the path.\n\n\t\t// Fix the offset because this position might be after `from` position and we have to reflect that.\n\t\tcombined.offset = combined.offset + this.path[ i ] - source.offset;\n\n\t\t// Then, add the rest of the path.\n\t\t// If this position is at the same level as `from` position nothing will get added.\n\t\tcombined.path = [ ...combined.path, ...this.path.slice( i + 1 ) ];\n\n\t\treturn combined;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\troot: this.root.toJSON(),\n\t\t\tpath: Array.from( this.path ),\n\t\t\tstickiness: this.stickiness\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new position that is equal to current position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.root, this.path, this.stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/position~Position._createBefore},\n\t * * {@link module:engine/model/position~Position._createAfter}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @protected\n\t */\n\tstatic _createAt( itemOrPosition, offset, stickiness = 'toNone' ) {\n\t\tif ( itemOrPosition instanceof Position ) {\n\t\t\treturn new Position( itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness );\n\t\t} else {\n\t\t\tconst node = itemOrPosition;\n\n\t\t\tif ( offset == 'end' ) {\n\t\t\t\toffset = node.maxOffset;\n\t\t\t} else if ( offset == 'before' ) {\n\t\t\t\treturn this._createBefore( node, stickiness );\n\t\t\t} else if ( offset == 'after' ) {\n\t\t\t\treturn this._createAfter( node, stickiness );\n\t\t\t} else if ( offset !== 0 && !offset ) {\n\t\t\t\t/**\n\t\t\t\t * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n\t\t\t\t * requires the offset to be specified when the first parameter is a model item.\n\t\t\t\t *\n\t\t\t\t * @error model-createpositionat-offset-required\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'model-createpositionat-offset-required', [ this, itemOrPosition ] );\n\t\t\t}\n\n\t\t\tif ( !node.is( 'element' ) && !node.is( 'documentFragment' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Position parent have to be a model element or model document fragment.\n\t\t\t\t *\n\t\t\t\t * @error model-position-parent-incorrect\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-position-parent-incorrect',\n\t\t\t\t\t[ this, itemOrPosition ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst path = node.getPath();\n\n\t\t\tpath.push( offset );\n\n\t\t\treturn new this( node.root, path, stickiness );\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createAfter( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position after a root element.\n\t\t\t *\n\t\t\t * @error model-position-after-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-after-root',\n\t\t\t\t[ this, item ],\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.endOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createBefore( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position before a root element.\n\t\t\t *\n\t\t\t * @error model-position-before-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-before-root',\n\t\t\t\titem,\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.startOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Position`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n\t * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\tif ( json.root === '$graveyard' ) {\n\t\t\tconst pos = new Position( doc.graveyard, json.path );\n\t\t\tpos.stickiness = json.stickiness;\n\n\t\t\treturn pos;\n\t\t}\n\n\t\tif ( !doc.getRoot( json.root ) ) {\n\t\t\t/**\n\t\t\t * Cannot create position for document. Root with specified name does not exist.\n\t\t\t *\n\t\t\t * @error model-position-fromjson-no-root\n\t\t\t * @param {String} rootName\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-fromjson-no-root',\n\t\t\t\tdoc,\n\t\t\t\t{ rootName: json.root }\n\t\t\t);\n\t\t}\n\n\t\treturn new Position( doc.getRoot( json.root ), json.path, json.stickiness );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.path.join( ', ' ) } ]`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n\n/**\n * Represents how position is \"sticking\" with neighbour nodes. Used to define how position should be transformed (moved)\n * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.\n *\n * Examples:\n *\n *\t\tInsert. Position is at | and nodes are inserted at the same position, marked as ^:\n *\n *\t\t- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>\n *\n *\n *\t\tMove. Position is at | and range [oo] is moved to position ^:\n *\n *\t\t- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>\n *\t\t- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */\n\n/**\n * Returns a text node at the given position.\n *\n * This is a helper function optimized to reuse the position parent instance for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#textNode `Position#textNode`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`}\n * check if your algorithm does not access it multiple times (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getNodeAfterPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @returns {module:engine/model/text~Text|null}\n */\nexport function getTextNodeAtPosition( position, positionParent ) {\n\tconst node = positionParent.getChild( positionParent.offsetToIndex( position.offset ) );\n\n\tif ( node && node.is( '$text' ) && node.startOffset < position.offset ) {\n\t\treturn node;\n\t}\n\n\treturn null;\n}\n\n/**\n * Returns the node after the given position.\n *\n * This is a helper function optimized to reuse the position parent instance and the calculation of the text node at the\n * specific position for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#nodeAfter `Position#nodeAfter`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`} and/or\n * {@link module:engine/model/position~Position#textNode `Position#textNode`}\n * check if your algorithm does not access those properties multiple times\n * (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579 and https://github.com/ckeditor/ckeditor5/issues/6582.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\nexport function getNodeAfterPosition( position, positionParent, textNode ) {\n\tif ( textNode !== null ) {\n\t\treturn null;\n\t}\n\n\treturn positionParent.getChild( positionParent.offsetToIndex( position.offset ) );\n}\n\n/**\n * Returns the node before the given position.\n *\n * Refer to {@link module:engine/model/position~getNodeBeforePosition} for documentation on when to use this util method.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeAfterPosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\nexport function getNodeBeforePosition( position, positionParent, textNode ) {\n\tif ( textNode !== null ) {\n\t\treturn null;\n\t}\n\n\treturn positionParent.getChild( positionParent.offsetToIndex( position.offset ) - 1 );\n}\n"]}]}