{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSB1dGlscy9mYXN0ZGlmZgogKi8KCi8qKgogKiBGaW5kcyBwb3NpdGlvbnMgb2YgdGhlIGZpcnN0IGFuZCBsYXN0IGNoYW5nZSBpbiB0aGUgZ2l2ZW4gc3RyaW5nL2FycmF5IGFuZCBnZW5lcmF0ZXMgYSBzZXQgb2YgY2hhbmdlczoKICoKICoJCWZhc3REaWZmKCAnMTJhJywgJzEyeHl6YScgKTsKICoJCS8vIFsgeyBpbmRleDogMiwgdHlwZTogJ2luc2VydCcsIHZhbHVlczogWyAneCcsICd5JywgJ3onIF0gfSBdCiAqCiAqCQlmYXN0RGlmZiggJzEyYScsICcxMmFhJyApOwogKgkJLy8gWyB7IGluZGV4OiAzLCB0eXBlOiAnaW5zZXJ0JywgdmFsdWVzOiBbICdhJyBdIH0gXQogKgogKgkJZmFzdERpZmYoICcxMnh5emEnLCAnMTJhJyApOwogKgkJLy8gWyB7IGluZGV4OiAyLCB0eXBlOiAnZGVsZXRlJywgaG93TWFueTogMyB9IF0KICoKICoJCWZhc3REaWZmKCBbICcxJywgJzInLCAnYScsICdhJyBdLCBbICcxJywgJzInLCAnYScgXSApOwogKgkJLy8gWyB7IGluZGV4OiAzLCB0eXBlOiAnZGVsZXRlJywgaG93TWFueTogMSB9IF0KICoKICoJCWZhc3REaWZmKCBbICcxJywgJzInLCAnYScsICdiJywgJ2MnLCAnMycgXSwgWyAnMicsICdhJywgJ2InIF0gKTsKICoJCS8vIFsgeyBpbmRleDogMCwgdHlwZTogJ2luc2VydCcsIHZhbHVlczogWyAnMicsICdhJywgJ2InIF0gfSwgeyBpbmRleDogMywgdHlwZTogJ2RlbGV0ZScsIGhvd01hbnk6IDYgfSBdCiAqCiAqIFBhc3NlZCBhcnJheXMgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YSwgaG93ZXZlciB0byBjb21wYXJlIHRoZW0gY29ycmVjdGx5IGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uCiAqIHNob3VsZCBiZSBwYXNzZWQgYXMgYSB0aGlyZCBwYXJhbWV0ZXI6CiAqCiAqCQlmYXN0RGlmZiggWyB7IHZhbHVlOiAxIH0sIHsgdmFsdWU6IDIgfSBdLCBbIHsgdmFsdWU6IDEgfSwgeyB2YWx1ZTogMyB9IF0sICggYSwgYiApID0+IHsKICoJCQlyZXR1cm4gYS52YWx1ZSA9PT0gYi52YWx1ZTsKICoJCX0gKTsKICoJCS8vIFsgeyBpbmRleDogMSwgdHlwZTogJ2luc2VydCcsIHZhbHVlczogWyB7IHZhbHVlOiAzIH0gXSB9LCB7IGluZGV4OiAyLCB0eXBlOiAnZGVsZXRlJywgaG93TWFueTogMSB9IF0KICoKICogVGhlIHJlc3VsdGVkIHNldCBvZiBjaGFuZ2VzIGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBpbnB1dCBpbiBvcmRlciB0byB0cmFuc2Zvcm0gaXQgaW50byB0aGUgb3V0cHV0LCBmb3IgZXhhbXBsZToKICoKICoJCWxldCBpbnB1dCA9ICcxMmFiYzMnOwogKgkJY29uc3Qgb3V0cHV0ID0gJzJhYic7CiAqCQljb25zdCBjaGFuZ2VzID0gZmFzdERpZmYoIGlucHV0LCBvdXRwdXQgKTsKICoKICoJCWNoYW5nZXMuZm9yRWFjaCggY2hhbmdlID0+IHsKICoJCQlpZiAoIGNoYW5nZS50eXBlID09ICdpbnNlcnQnICkgewogKgkJCQlpbnB1dCA9IGlucHV0LnN1YnN0cmluZyggMCwgY2hhbmdlLmluZGV4ICkgKyBjaGFuZ2UudmFsdWVzLmpvaW4oICcnICkgKyBpbnB1dC5zdWJzdHJpbmcoIGNoYW5nZS5pbmRleCApOwogKgkJCX0gZWxzZSBpZiAoIGNoYW5nZS50eXBlID09ICdkZWxldGUnICkgewogKgkJCQlpbnB1dCA9IGlucHV0LnN1YnN0cmluZyggMCwgY2hhbmdlLmluZGV4ICkgKyBpbnB1dC5zdWJzdHJpbmcoIGNoYW5nZS5pbmRleCArIGNoYW5nZS5ob3dNYW55ICk7CiAqCQkJfQogKgkJfSApOwogKgogKgkJLy8gaW5wdXQgZXF1YWxzIG91dHB1dCBub3cKICoKICogb3IgaW4gY2FzZSBvZiBhcnJheXM6CiAqCiAqCQlsZXQgaW5wdXQgPSBbICcxJywgJzInLCAnYScsICdiJywgJ2MnLCAnMycgXTsKICoJCWNvbnN0IG91dHB1dCA9IFsgJzInLCAnYScsICdiJyBdOwogKgkJY29uc3QgY2hhbmdlcyA9IGZhc3REaWZmKCBpbnB1dCwgb3V0cHV0ICk7CiAqCiAqCQljaGFuZ2VzLmZvckVhY2goIGNoYW5nZSA9PiB7CiAqCQkJaWYgKCBjaGFuZ2UudHlwZSA9PSAnaW5zZXJ0JyApIHsKICoJCQkJaW5wdXQgPSBpbnB1dC5zbGljZSggMCwgY2hhbmdlLmluZGV4ICkuY29uY2F0KCBjaGFuZ2UudmFsdWVzLCBpbnB1dC5zbGljZSggY2hhbmdlLmluZGV4ICkgKTsKICoJCQl9IGVsc2UgaWYgKCBjaGFuZ2UudHlwZSA9PSAnZGVsZXRlJyApIHsKICoJCQkJaW5wdXQgPSBpbnB1dC5zbGljZSggMCwgY2hhbmdlLmluZGV4ICkuY29uY2F0KCBpbnB1dC5zbGljZSggY2hhbmdlLmluZGV4ICsgY2hhbmdlLmhvd01hbnkgKSApOwogKgkJCX0KICoJCX0gKTsKICoKICoJCS8vIGlucHV0IGVxdWFscyBvdXRwdXQgbm93CiAqCiAqIEJ5IHBhc3NpbmcgYHRydWVgIGFzIHRoZSBmb3VydGggcGFyYW1ldGVyIChgYXRvbWljQ2hhbmdlc2ApIHRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiB3aWxsIGJlY29tZSBjb21wYXRpYmxlIHdpdGgKICogdGhlIHtAbGluayBtb2R1bGU6dXRpbHMvZGlmZn5kaWZmIGBkaWZmKClgfSBmdW5jdGlvbjoKICoKICoJCWZhc3REaWZmKCAnMTJhJywgJzEyeHl6YScgKTsKICoJCS8vIFsgJ2VxdWFsJywgJ2VxdWFsJywgJ2luc2VydCcsICdpbnNlcnQnLCAnaW5zZXJ0JywgJ2VxdWFsJyBdCiAqCiAqIFRoZSBkZWZhdWx0IG91dHB1dCBmb3JtYXQgb2YgdGhpcyBmdW5jdGlvbiBpcyBjb21wYXRpYmxlIHdpdGggdGhlIG91dHB1dCBmb3JtYXQgb2YKICoge0BsaW5rIG1vZHVsZTp1dGlscy9kaWZmdG9jaGFuZ2VzfmRpZmZUb0NoYW5nZXMgYGRpZmZUb0NoYW5nZXMoKWB9LiBUaGUgYGRpZmZUb0NoYW5nZXMoKWAgaW5wdXQgZm9ybWF0IGlzLCBpbiB0dXJuLAogKiBjb21wYXRpYmxlIHdpdGggdGhlIG91dHB1dCBvZiB7QGxpbmsgbW9kdWxlOnV0aWxzL2RpZmZ+ZGlmZiBgZGlmZigpYH06CiAqCiAqCQljb25zdCBhID0gJzEyMzQnOwogKgkJY29uc3QgYiA9ICcxMnh5ejM0JzsKICoKICoJCS8vIEJvdGggY2FsbHMgd2lsbCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0cyAoZ3JvdXBlZCBjaGFuZ2VzIGZvcm1hdCkuCiAqCQlmYXN0RGlmZiggYSwgYiApOwogKgkJZGlmZlRvQ2hhbmdlcyggZGlmZiggYSwgYiApICk7CiAqCiAqCQkvLyBBZ2FpbiwgYm90aCBjYWxscyB3aWxsIHJldHVybiB0aGUgc2FtZSByZXN1bHRzIChhdG9taWMgY2hhbmdlcyBmb3JtYXQpLgogKgkJZmFzdERpZmYoIGEsIGIsIG51bGwsIHRydWUgKTsKICoJCWRpZmYoIGEsIGIgKTsKICoKICoKICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGEgSW5wdXQgYXJyYXkgb3Igc3RyaW5nLgogKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYiBJbnB1dCBhcnJheSBvciBzdHJpbmcuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjbXBdIE9wdGlvbmFsIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSBhcnJheSB2YWx1ZXMsIGJ5IGRlZmF1bHQgYD09PWAgKHN0cmljdCBlcXVhbCBvcGVyYXRvcikgaXMgdXNlZC4KICogQHBhcmFtIHtCb29sZWFufSBbYXRvbWljQ2hhbmdlcz1mYWxzZV0gV2hldGhlciBhbiBhcnJheSBvZiBgaW5zZXR8ZGVsZXRlfGVxdWFsYCBvcGVyYXRpb25zIHNob3VsZAogKiBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGNoYW5nZXMgc2V0LiBUaGlzIG1ha2VzIHRoaXMgZnVuY3Rpb24gY29tcGF0aWJsZSB3aXRoIHtAbGluayBtb2R1bGU6dXRpbHMvZGlmZn5kaWZmIGBkaWZmKClgfS4KICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBjaGFuZ2VzLgogKi8KZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmFzdERpZmYoYSwgYiwgY21wKSB7CiAgdmFyIGF0b21pY0NoYW5nZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlOwoKICAvLyBTZXQgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24uCiAgY21wID0gY21wIHx8IGZ1bmN0aW9uIChhLCBiKSB7CiAgICByZXR1cm4gYSA9PT0gYjsKICB9OyAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgKG9yIGFueSBhcnJheS1saWtlIG9iamVjdCAtIGVnLiBOb2RlTGlzdCkgdG8gYW4gYXJyYXkgYnkgdXNpbmcgdGhlIHNsaWNlKCkgbWV0aG9kIGJlY2F1c2UsCiAgLy8gdW5saWtlIEFycmF5LmZyb20oKSwgaXQgcmV0dXJucyBhcnJheSBvZiBVVEYtMTYgY29kZSB1bml0cyBpbnN0ZWFkIG9mIHRoZSBjb2RlIHBvaW50cyBvZiBhIHN0cmluZy4KICAvLyBPbmUgY29kZSBwb2ludCBtaWdodCBiZSBhIHN1cnJvZ2F0ZSBwYWlyIG9mIHR3byBjb2RlIHVuaXRzLiBBbGwgdGV4dCBvZmZzZXRzIGFyZSBleHBlY3RlZCB0byBiZSBpbiBjb2RlIHVuaXRzLgogIC8vIFNlZSBja2VkaXRvci9ja2VkaXRvcjUjMzE0Ny4KICAvLwogIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIGhlcmUgdGhhdCBmYXN0RGlmZigpIHdvcmtzIGlkZW50aWNhbCB0byBkaWZmKCkuCgoKICBpZiAoIUFycmF5LmlzQXJyYXkoYSkpIHsKICAgIGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKTsKICB9CgogIGlmICghQXJyYXkuaXNBcnJheShiKSkgewogICAgYiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGIpOwogIH0gLy8gRmluZCBmaXJzdCBhbmQgbGFzdCBjaGFuZ2UuCgoKICB2YXIgY2hhbmdlSW5kZXhlcyA9IGZpbmRDaGFuZ2VCb3VuZGFyeUluZGV4ZXMoYSwgYiwgY21wKTsgLy8gVHJhbnNmb3JtIGludG8gY2hhbmdlcyBhcnJheS4KCiAgcmV0dXJuIGF0b21pY0NoYW5nZXMgPyBjaGFuZ2VJbmRleGVzVG9BdG9taWNDaGFuZ2VzKGNoYW5nZUluZGV4ZXMsIGIubGVuZ3RoKSA6IGNoYW5nZUluZGV4ZXNUb0NoYW5nZXMoYiwgY2hhbmdlSW5kZXhlcyk7Cn0gLy8gRmluZHMgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGFuZCBsYXN0IGNoYW5nZSBpbiB0aGUgZ2l2ZW4gYXJyYXlzLiBGb3IgZXhhbXBsZToKLy8KLy8JCWNvbnN0IGluZGV4ZXMgPSBmaW5kQ2hhbmdlQm91bmRhcnlJbmRleGVzKCBbICcxJywgJzInLCAnMycsICc0JyBdLCBbICcxJywgJzMnLCAnNCcsICcyJywgJzQnIF0gKTsKLy8JCWNvbnNvbGUubG9nKCBpbmRleGVzICk7IC8vIHsgZmlyc3RJbmRleDogMSwgbGFzdEluZGV4T2xkOiAzLCBsYXN0SW5kZXhOZXc6IDQgfQovLwovLyBUaGUgYWJvdmUgaW5kZXhlcyBtZWFucyB0aGF0IGluIHRoZSBmaXJzdCBhcnJheSB0aGUgbW9kaWZpZWQgcGFydCBpcyBgMVsyM100YCBhbmQgaW4gdGhlIHNlY29uZCBhcnJheSBpdCBpcyBgMVszNDJdNGAuCi8vIEJhc2VkIG9uIHN1Y2ggaW5kZXhlcywgYXJyYXkgd2l0aCBgaW5zZXJ0YC9gZGVsZXRlYCBvcGVyYXRpb25zIHdoaWNoIGFsbG93cyB0cmFuc2Zvcm1pbmcgZmlyc3QgdmFsdWUgaW50byB0aGUgc2Vjb25kIG9uZQovLyBjYW4gYmUgZ2VuZXJhdGVkLgovLwovLyBAcGFyYW0ge0FycmF5fSBhcnIxCi8vIEBwYXJhbSB7QXJyYXl9IGFycjIKLy8gQHBhcmFtIHtGdW5jdGlvbn0gY21wIENvbXBhcmF0b3IgZnVuY3Rpb24uCi8vIEByZXR1cm5zIHtPYmplY3R9Ci8vIEByZXR1cm5zIHtOdW1iZXJ9IHJldHVybi5maXJzdEluZGV4IEluZGV4IG9mIHRoZSBmaXJzdCBjaGFuZ2UgaW4gYm90aCB2YWx1ZXMgKGFsd2F5cyB0aGUgc2FtZSBmb3IgYm90aCkuCi8vIEByZXR1cm5zIHtOdW1iZXJ9IHJlc3VsdC5sYXN0SW5kZXhPbGQgSW5kZXggb2YgdGhlIGxhc3QgY29tbW9uIHZhbHVlIGluIGBhcnIxYC4KLy8gQHJldHVybnMge051bWJlcn0gcmVzdWx0Lmxhc3RJbmRleE5ldyBJbmRleCBvZiB0aGUgbGFzdCBjb21tb24gdmFsdWUgaW4gYGFycjJgLgoKZnVuY3Rpb24gZmluZENoYW5nZUJvdW5kYXJ5SW5kZXhlcyhhcnIxLCBhcnIyLCBjbXApIHsKICAvLyBGaW5kIHRoZSBmaXJzdCBkaWZmZXJlbmNlIGJldHdlZW4gcGFzc2VkIHZhbHVlcy4KICB2YXIgZmlyc3RJbmRleCA9IGZpbmRGaXJzdERpZmZlcmVuY2VJbmRleChhcnIxLCBhcnIyLCBjbXApOyAvLyBJZiBhcnJheXMgYXJlIGVxdWFsIHJldHVybiAtMSBpbmRleGVzIG9iamVjdC4KCiAgaWYgKGZpcnN0SW5kZXggPT09IC0xKSB7CiAgICByZXR1cm4gewogICAgICBmaXJzdEluZGV4OiAtMSwKICAgICAgbGFzdEluZGV4T2xkOiAtMSwKICAgICAgbGFzdEluZGV4TmV3OiAtMQogICAgfTsKICB9IC8vIFJlbW92ZSB0aGUgY29tbW9uIHBhcnQgb2YgZWFjaCB2YWx1ZSBhbmQgcmV2ZXJzZSB0aGVtIHRvIG1ha2UgaXQgc2ltcGxlciB0byBmaW5kIHRoZSBsYXN0IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVtLgoKCiAgdmFyIG9sZEFycmF5UmV2ZXJzZWQgPSBjdXRBbmRSZXZlcnNlKGFycjEsIGZpcnN0SW5kZXgpOwogIHZhciBuZXdBcnJheVJldmVyc2VkID0gY3V0QW5kUmV2ZXJzZShhcnIyLCBmaXJzdEluZGV4KTsgLy8gRmluZCB0aGUgZmlyc3QgZGlmZmVyZW5jZSBiZXR3ZWVuIHJldmVyc2VkIHZhbHVlcy4KICAvLyBJdCBzaG91bGQgYmUgdHJlYXRlZCBhcyAiaG93IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kIHRoZSBsYXN0IGRpZmZlcmVuY2Ugb2NjdXJyZWQiLgogIC8vCiAgLy8gRm9yIGV4YW1wbGU6CiAgLy8KICAvLyAJCQkJaW5pdGlhbAktPglhZnRlciBjdXQJLT4gcmV2ZXJzZWQ6CiAgLy8gb2xkVmFsdWU6CSczMjFiYScJLT4JJzIxYmEnCQktPiAnYWIxMicKICAvLyBuZXdWYWx1ZToJJzMxeGJhJwktPgknMXhiYScJCS0+ICdhYngxJwogIC8vIGxhc3RJbmRleDoJCQkJCQkJLT4gMgogIC8vCiAgLy8gU28gdGhlIGxhc3QgY2hhbmdlIG9jY3VycmVkIHR3byBjaGFyYWN0ZXJzIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXlzLgoKICB2YXIgbGFzdEluZGV4ID0gZmluZEZpcnN0RGlmZmVyZW5jZUluZGV4KG9sZEFycmF5UmV2ZXJzZWQsIG5ld0FycmF5UmV2ZXJzZWQsIGNtcCk7IC8vIFVzZSBgbGFzdEluZGV4YCB0byBjYWxjdWxhdGUgcHJvcGVyIG9mZnNldCwgc3RhcnRpbmcgZnJvbSB0aGUgYmVnaW5uaW5nIChgbGFzdEluZGV4YCBraW5kIG9mIHN0YXJ0cyBmcm9tIHRoZSBlbmQpLgoKICB2YXIgbGFzdEluZGV4T2xkID0gYXJyMS5sZW5ndGggLSBsYXN0SW5kZXg7CiAgdmFyIGxhc3RJbmRleE5ldyA9IGFycjIubGVuZ3RoIC0gbGFzdEluZGV4OwogIHJldHVybiB7CiAgICBmaXJzdEluZGV4OiBmaXJzdEluZGV4LAogICAgbGFzdEluZGV4T2xkOiBsYXN0SW5kZXhPbGQsCiAgICBsYXN0SW5kZXhOZXc6IGxhc3RJbmRleE5ldwogIH07Cn0gLy8gUmV0dXJucyBhIGZpcnN0IGluZGV4IG9uIHdoaWNoIGdpdmVuIGFycmF5cyBkaWZmZXIuIElmIGJvdGggYXJyYXlzIGFyZSB0aGUgc2FtZSwgLTEgaXMgcmV0dXJuZWQuCi8vCi8vIEBwYXJhbSB7QXJyYXl9IGFycjEKLy8gQHBhcmFtIHtBcnJheX0gYXJyMgovLyBAcGFyYW0ge0Z1bmN0aW9ufSBjbXAgQ29tcGFyYXRvciBmdW5jdGlvbi4KLy8gQHJldHVybnMge051bWJlcn0KCgpmdW5jdGlvbiBmaW5kRmlyc3REaWZmZXJlbmNlSW5kZXgoYXJyMSwgYXJyMiwgY21wKSB7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1heChhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpOyBpKyspIHsKICAgIGlmIChhcnIxW2ldID09PSB1bmRlZmluZWQgfHwgYXJyMltpXSA9PT0gdW5kZWZpbmVkIHx8ICFjbXAoYXJyMVtpXSwgYXJyMltpXSkpIHsKICAgICAgcmV0dXJuIGk7CiAgICB9CiAgfQoKICByZXR1cm4gLTE7IC8vIFJldHVybiAtMSBpZiBhcnJheXMgYXJlIGVxdWFsLgp9IC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBnaXZlbiBhcnJheSB3aXRoIGBob3dNYW55YCBlbGVtZW50cyByZW1vdmVkIHN0YXJ0aW5nIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgaW4gcmV2ZXJzZWQgb3JkZXIuCi8vCi8vIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSB0byBiZSBwcm9jZXNzZWQuCi8vIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IEhvdyBtYW55IGVsZW1lbnRzIGZyb20gYXJyYXkgYmVnaW5uaW5nIHRvIHJlbW92ZS4KLy8gQHJldHVybnMge0FycmF5fSBTaG9ydGVuZWQgYW5kIHJldmVyc2VkIGFycmF5LgoKCmZ1bmN0aW9uIGN1dEFuZFJldmVyc2UoYXJyLCBob3dNYW55KSB7CiAgcmV0dXJuIGFyci5zbGljZShob3dNYW55KS5yZXZlcnNlKCk7Cn0gLy8gR2VuZXJhdGVzIGNoYW5nZXMgYXJyYXkgYmFzZWQgb24gY2hhbmdlIGluZGV4ZXMgZnJvbSBgZmluZENoYW5nZUJvdW5kYXJ5SW5kZXhlc2AgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gd2lsbAovLyBnZW5lcmF0ZSBhcnJheSB3aXRoIDAgKG5vIGNoYW5nZXMpLCAxIChkZWxldGlvbiBvciBpbnNlcnRpb24pIG9yIDIgcmVjb3JkcyAoaW5zZXJ0aW9uIGFuZCBkZWxldGlvbikuCi8vCi8vIEBwYXJhbSB7QXJyYXl9IG5ld0FycmF5IE5ldyBhcnJheSBmb3Igd2hpY2ggY2hhbmdlIGluZGV4ZXMgd2VyZSBjYWxjdWxhdGVkLgovLyBAcGFyYW0ge09iamVjdH0gY2hhbmdlSW5kZXhlcyBDaGFuZ2UgaW5kZXhlcyBvYmplY3QgZnJvbSBgZmluZENoYW5nZUJvdW5kYXJ5SW5kZXhlc2AgZnVuY3Rpb24uCi8vIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn0gQXJyYXkgb2YgY2hhbmdlcyBjb21wYXRpYmxlIHdpdGgge0BsaW5rIG1vZHVsZTp1dGlscy9kaWZmdG9jaGFuZ2VzfmRpZmZUb0NoYW5nZXN9IGZvcm1hdC4KCgpmdW5jdGlvbiBjaGFuZ2VJbmRleGVzVG9DaGFuZ2VzKG5ld0FycmF5LCBjaGFuZ2VJbmRleGVzKSB7CiAgdmFyIHJlc3VsdCA9IFtdOwogIHZhciBmaXJzdEluZGV4ID0gY2hhbmdlSW5kZXhlcy5maXJzdEluZGV4LAogICAgICBsYXN0SW5kZXhPbGQgPSBjaGFuZ2VJbmRleGVzLmxhc3RJbmRleE9sZCwKICAgICAgbGFzdEluZGV4TmV3ID0gY2hhbmdlSW5kZXhlcy5sYXN0SW5kZXhOZXc7IC8vIE9yZGVyIG9wZXJhdGlvbnMgYXMgJ2luc2VydCcsICdkZWxldGUnIGFycmF5IHRvIGtlZXAgY29tcGF0aWJpbGl0eSB3aXRoIHtAbGluayBtb2R1bGU6dXRpbHMvZGlmZnRvY2hhbmdlc35kaWZmVG9DaGFuZ2VzfQogIC8vIGluIG1vc3QgY2FzZXMuIEhvd2V2ZXIsICdkaWZmVG9DaGFuZ2VzJyBkb2VzIG5vdCBzdGljayB0byBhbnkgb3JkZXIgc28gaW4gc29tZSBjYXNlcwogIC8vIChmb3IgZXhhbXBsZSByZXBsYWNpbmcgJzEyMzQ1JyB3aXRoICdhYmNkJykgaXQgd2lsbCBnZW5lcmF0ZSAnZGVsZXRlJywgJ2luc2VydCcgb3JkZXIuCgogIGlmIChsYXN0SW5kZXhOZXcgLSBmaXJzdEluZGV4ID4gMCkgewogICAgcmVzdWx0LnB1c2goewogICAgICBpbmRleDogZmlyc3RJbmRleCwKICAgICAgdHlwZTogJ2luc2VydCcsCiAgICAgIHZhbHVlczogbmV3QXJyYXkuc2xpY2UoZmlyc3RJbmRleCwgbGFzdEluZGV4TmV3KQogICAgfSk7CiAgfQoKICBpZiAobGFzdEluZGV4T2xkIC0gZmlyc3RJbmRleCA+IDApIHsKICAgIHJlc3VsdC5wdXNoKHsKICAgICAgaW5kZXg6IGZpcnN0SW5kZXggKyAobGFzdEluZGV4TmV3IC0gZmlyc3RJbmRleCksCiAgICAgIC8vIEluY3JlYXNlIGluZGV4IG9mIHdoYXQgd2FzIGluc2VydGVkLgogICAgICB0eXBlOiAnZGVsZXRlJywKICAgICAgaG93TWFueTogbGFzdEluZGV4T2xkIC0gZmlyc3RJbmRleAogICAgfSk7CiAgfQoKICByZXR1cm4gcmVzdWx0Owp9IC8vIEdlbmVyYXRlcyBhcnJheSB3aXRoIHNldCBgZXF1YWx8aW5zZXJ0fGRlbGV0ZWAgb3BlcmF0aW9ucyBiYXNlZCBvbiBjaGFuZ2UgaW5kZXhlcyBmcm9tIGBmaW5kQ2hhbmdlQm91bmRhcnlJbmRleGVzYCBmdW5jdGlvbi4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNoYW5nZUluZGV4ZXMgQ2hhbmdlIGluZGV4ZXMgb2JqZWN0IGZyb20gYGZpbmRDaGFuZ2VCb3VuZGFyeUluZGV4ZXNgIGZ1bmN0aW9uLgovLyBAcGFyYW0ge051bWJlcn0gbmV3TGVuZ3RoIExlbmd0aCBvZiB0aGUgbmV3IGFycmF5IG9uIHdoaWNoIGBmaW5kQ2hhbmdlQm91bmRhcnlJbmRleGVzYCBjYWxjdWxhdGVkIGNoYW5nZSBpbmRleGVzLgovLyBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59IEFycmF5IG9mIGNoYW5nZXMgY29tcGF0aWJsZSB3aXRoIHtAbGluayBtb2R1bGU6dXRpbHMvZGlmZn5kaWZmfSBmb3JtYXQuCgoKZnVuY3Rpb24gY2hhbmdlSW5kZXhlc1RvQXRvbWljQ2hhbmdlcyhjaGFuZ2VJbmRleGVzLCBuZXdMZW5ndGgpIHsKICB2YXIgZmlyc3RJbmRleCA9IGNoYW5nZUluZGV4ZXMuZmlyc3RJbmRleCwKICAgICAgbGFzdEluZGV4T2xkID0gY2hhbmdlSW5kZXhlcy5sYXN0SW5kZXhPbGQsCiAgICAgIGxhc3RJbmRleE5ldyA9IGNoYW5nZUluZGV4ZXMubGFzdEluZGV4TmV3OyAvLyBObyBjaGFuZ2VzLgoKICBpZiAoZmlyc3RJbmRleCA9PT0gLTEpIHsKICAgIHJldHVybiBBcnJheShuZXdMZW5ndGgpLmZpbGwoJ2VxdWFsJyk7CiAgfQoKICB2YXIgcmVzdWx0ID0gW107CgogIGlmIChmaXJzdEluZGV4ID4gMCkgewogICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChBcnJheShmaXJzdEluZGV4KS5maWxsKCdlcXVhbCcpKTsKICB9CgogIGlmIChsYXN0SW5kZXhOZXcgLSBmaXJzdEluZGV4ID4gMCkgewogICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChBcnJheShsYXN0SW5kZXhOZXcgLSBmaXJzdEluZGV4KS5maWxsKCdpbnNlcnQnKSk7CiAgfQoKICBpZiAobGFzdEluZGV4T2xkIC0gZmlyc3RJbmRleCA+IDApIHsKICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoQXJyYXkobGFzdEluZGV4T2xkIC0gZmlyc3RJbmRleCkuZmlsbCgnZGVsZXRlJykpOwogIH0KCiAgaWYgKGxhc3RJbmRleE5ldyA8IG5ld0xlbmd0aCkgewogICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChBcnJheShuZXdMZW5ndGggLSBsYXN0SW5kZXhOZXcpLmZpbGwoJ2VxdWFsJykpOwogIH0KCiAgcmV0dXJuIHJlc3VsdDsKfQ=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js"],"names":["fastDiff","a","b","cmp","atomicChanges","Array","isArray","prototype","slice","call","changeIndexes","findChangeBoundaryIndexes","changeIndexesToAtomicChanges","length","changeIndexesToChanges","arr1","arr2","firstIndex","findFirstDifferenceIndex","lastIndexOld","lastIndexNew","oldArrayReversed","cutAndReverse","newArrayReversed","lastIndex","i","Math","max","undefined","arr","howMany","reverse","newArray","result","push","index","type","values","newLength","fill","concat"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/fastdiff\n */\n\n/**\n * Finds positions of the first and last change in the given string/array and generates a set of changes:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ { index: 2, type: 'insert', values: [ 'x', 'y', 'z' ] } ]\n *\n *\t\tfastDiff( '12a', '12aa' );\n *\t\t// [ { index: 3, type: 'insert', values: [ 'a' ] } ]\n *\n *\t\tfastDiff( '12xyza', '12a' );\n *\t\t// [ { index: 2, type: 'delete', howMany: 3 } ]\n *\n *\t\tfastDiff( [ '1', '2', 'a', 'a' ], [ '1', '2', 'a' ] );\n *\t\t// [ { index: 3, type: 'delete', howMany: 1 } ]\n *\n *\t\tfastDiff( [ '1', '2', 'a', 'b', 'c', '3' ], [ '2', 'a', 'b' ] );\n *\t\t// [ { index: 0, type: 'insert', values: [ '2', 'a', 'b' ] }, { index: 3, type: 'delete', howMany: 6 } ]\n *\n * Passed arrays can contain any type of data, however to compare them correctly custom comparator function\n * should be passed as a third parameter:\n *\n *\t\tfastDiff( [ { value: 1 }, { value: 2 } ], [ { value: 1 }, { value: 3 } ], ( a, b ) => {\n *\t\t\treturn a.value === b.value;\n *\t\t} );\n *\t\t// [ { index: 1, type: 'insert', values: [ { value: 3 } ] }, { index: 2, type: 'delete', howMany: 1 } ]\n *\n * The resulted set of changes can be applied to the input in order to transform it into the output, for example:\n *\n *\t\tlet input = '12abc3';\n *\t\tconst output = '2ab';\n *\t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + change.values.join( '' ) + input.substring( change.index );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.substring( 0, change.index ) + input.substring( change.index + change.howMany );\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// input equals output now\n *\n * or in case of arrays:\n *\n *\t\tlet input = [ '1', '2', 'a', 'b', 'c', '3' ];\n *\t\tconst output = [ '2', 'a', 'b' ];\n *\t\tconst changes = fastDiff( input, output );\n *\n *\t\tchanges.forEach( change => {\n *\t\t\tif ( change.type == 'insert' ) {\n *\t\t\t\tinput = input.slice( 0, change.index ).concat( change.values, input.slice( change.index ) );\n *\t\t\t} else if ( change.type == 'delete' ) {\n *\t\t\t\tinput = input.slice( 0, change.index ).concat( input.slice( change.index + change.howMany ) );\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// input equals output now\n *\n * By passing `true` as the fourth parameter (`atomicChanges`) the output of this function will become compatible with\n * the {@link module:utils/diff~diff `diff()`} function:\n *\n *\t\tfastDiff( '12a', '12xyza' );\n *\t\t// [ 'equal', 'equal', 'insert', 'insert', 'insert', 'equal' ]\n *\n * The default output format of this function is compatible with the output format of\n * {@link module:utils/difftochanges~diffToChanges `diffToChanges()`}. The `diffToChanges()` input format is, in turn,\n * compatible with the output of {@link module:utils/diff~diff `diff()`}:\n *\n *\t\tconst a = '1234';\n *\t\tconst b = '12xyz34';\n *\n *\t\t// Both calls will return the same results (grouped changes format).\n *\t\tfastDiff( a, b );\n *\t\tdiffToChanges( diff( a, b ) );\n *\n *\t\t// Again, both calls will return the same results (atomic changes format).\n *\t\tfastDiff( a, b, null, true );\n *\t\tdiff( a, b );\n *\n *\n * @param {Array|String} a Input array or string.\n * @param {Array|String} b Input array or string.\n * @param {Function} [cmp] Optional function used to compare array values, by default `===` (strict equal operator) is used.\n * @param {Boolean} [atomicChanges=false] Whether an array of `inset|delete|equal` operations should\n * be returned instead of changes set. This makes this function compatible with {@link module:utils/diff~diff `diff()`}.\n * @returns {Array} Array of changes.\n */\nexport default function fastDiff( a, b, cmp, atomicChanges = false ) {\n\t// Set the comparator function.\n\tcmp = cmp || function( a, b ) {\n\t\treturn a === b;\n\t};\n\n\t// Convert the string (or any array-like object - eg. NodeList) to an array by using the slice() method because,\n\t// unlike Array.from(), it returns array of UTF-16 code units instead of the code points of a string.\n\t// One code point might be a surrogate pair of two code units. All text offsets are expected to be in code units.\n\t// See ckeditor/ckeditor5#3147.\n\t//\n\t// We need to make sure here that fastDiff() works identical to diff().\n\tif ( !Array.isArray( a ) ) {\n\t\ta = Array.prototype.slice.call( a );\n\t}\n\n\tif ( !Array.isArray( b ) ) {\n\t\tb = Array.prototype.slice.call( b );\n\t}\n\n\t// Find first and last change.\n\tconst changeIndexes = findChangeBoundaryIndexes( a, b, cmp );\n\n\t// Transform into changes array.\n\treturn atomicChanges ? changeIndexesToAtomicChanges( changeIndexes, b.length ) : changeIndexesToChanges( b, changeIndexes );\n}\n\n// Finds position of the first and last change in the given arrays. For example:\n//\n//\t\tconst indexes = findChangeBoundaryIndexes( [ '1', '2', '3', '4' ], [ '1', '3', '4', '2', '4' ] );\n//\t\tconsole.log( indexes ); // { firstIndex: 1, lastIndexOld: 3, lastIndexNew: 4 }\n//\n// The above indexes means that in the first array the modified part is `1[23]4` and in the second array it is `1[342]4`.\n// Based on such indexes, array with `insert`/`delete` operations which allows transforming first value into the second one\n// can be generated.\n//\n// @param {Array} arr1\n// @param {Array} arr2\n// @param {Function} cmp Comparator function.\n// @returns {Object}\n// @returns {Number} return.firstIndex Index of the first change in both values (always the same for both).\n// @returns {Number} result.lastIndexOld Index of the last common value in `arr1`.\n// @returns {Number} result.lastIndexNew Index of the last common value in `arr2`.\nfunction findChangeBoundaryIndexes( arr1, arr2, cmp ) {\n\t// Find the first difference between passed values.\n\tconst firstIndex = findFirstDifferenceIndex( arr1, arr2, cmp );\n\n\t// If arrays are equal return -1 indexes object.\n\tif ( firstIndex === -1 ) {\n\t\treturn { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };\n\t}\n\n\t// Remove the common part of each value and reverse them to make it simpler to find the last difference between them.\n\tconst oldArrayReversed = cutAndReverse( arr1, firstIndex );\n\tconst newArrayReversed = cutAndReverse( arr2, firstIndex );\n\n\t// Find the first difference between reversed values.\n\t// It should be treated as \"how many elements from the end the last difference occurred\".\n\t//\n\t// For example:\n\t//\n\t// \t\t\t\tinitial\t->\tafter cut\t-> reversed:\n\t// oldValue:\t'321ba'\t->\t'21ba'\t\t-> 'ab12'\n\t// newValue:\t'31xba'\t->\t'1xba'\t\t-> 'abx1'\n\t// lastIndex:\t\t\t\t\t\t\t-> 2\n\t//\n\t// So the last change occurred two characters from the end of the arrays.\n\tconst lastIndex = findFirstDifferenceIndex( oldArrayReversed, newArrayReversed, cmp );\n\n\t// Use `lastIndex` to calculate proper offset, starting from the beginning (`lastIndex` kind of starts from the end).\n\tconst lastIndexOld = arr1.length - lastIndex;\n\tconst lastIndexNew = arr2.length - lastIndex;\n\n\treturn { firstIndex, lastIndexOld, lastIndexNew };\n}\n\n// Returns a first index on which given arrays differ. If both arrays are the same, -1 is returned.\n//\n// @param {Array} arr1\n// @param {Array} arr2\n// @param {Function} cmp Comparator function.\n// @returns {Number}\nfunction findFirstDifferenceIndex( arr1, arr2, cmp ) {\n\tfor ( let i = 0; i < Math.max( arr1.length, arr2.length ); i++ ) {\n\t\tif ( arr1[ i ] === undefined || arr2[ i ] === undefined || !cmp( arr1[ i ], arr2[ i ] ) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1; // Return -1 if arrays are equal.\n}\n\n// Returns a copy of the given array with `howMany` elements removed starting from the beginning and in reversed order.\n//\n// @param {Array} arr Array to be processed.\n// @param {Number} howMany How many elements from array beginning to remove.\n// @returns {Array} Shortened and reversed array.\nfunction cutAndReverse( arr, howMany ) {\n\treturn arr.slice( howMany ).reverse();\n}\n\n// Generates changes array based on change indexes from `findChangeBoundaryIndexes` function. This function will\n// generate array with 0 (no changes), 1 (deletion or insertion) or 2 records (insertion and deletion).\n//\n// @param {Array} newArray New array for which change indexes were calculated.\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @returns {Array.<Object>} Array of changes compatible with {@link module:utils/difftochanges~diffToChanges} format.\nfunction changeIndexesToChanges( newArray, changeIndexes ) {\n\tconst result = [];\n\tconst { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;\n\n\t// Order operations as 'insert', 'delete' array to keep compatibility with {@link module:utils/difftochanges~diffToChanges}\n\t// in most cases. However, 'diffToChanges' does not stick to any order so in some cases\n\t// (for example replacing '12345' with 'abcd') it will generate 'delete', 'insert' order.\n\tif ( lastIndexNew - firstIndex > 0 ) {\n\t\tresult.push( {\n\t\t\tindex: firstIndex,\n\t\t\ttype: 'insert',\n\t\t\tvalues: newArray.slice( firstIndex, lastIndexNew )\n\t\t} );\n\t}\n\n\tif ( lastIndexOld - firstIndex > 0 ) {\n\t\tresult.push( {\n\t\t\tindex: firstIndex + ( lastIndexNew - firstIndex ), // Increase index of what was inserted.\n\t\t\ttype: 'delete',\n\t\t\thowMany: lastIndexOld - firstIndex\n\t\t} );\n\t}\n\n\treturn result;\n}\n\n// Generates array with set `equal|insert|delete` operations based on change indexes from `findChangeBoundaryIndexes` function.\n//\n// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.\n// @param {Number} newLength Length of the new array on which `findChangeBoundaryIndexes` calculated change indexes.\n// @returns {Array.<String>} Array of changes compatible with {@link module:utils/diff~diff} format.\nfunction changeIndexesToAtomicChanges( changeIndexes, newLength ) {\n\tconst { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;\n\n\t// No changes.\n\tif ( firstIndex === -1 ) {\n\t\treturn Array( newLength ).fill( 'equal' );\n\t}\n\n\tlet result = [];\n\tif ( firstIndex > 0 ) {\n\t\tresult = result.concat( Array( firstIndex ).fill( 'equal' ) );\n\t}\n\n\tif ( lastIndexNew - firstIndex > 0 ) {\n\t\tresult = result.concat( Array( lastIndexNew - firstIndex ).fill( 'insert' ) );\n\t}\n\n\tif ( lastIndexOld - firstIndex > 0 ) {\n\t\tresult = result.concat( Array( lastIndexOld - firstIndex ).fill( 'delete' ) );\n\t}\n\n\tif ( lastIndexNew < newLength ) {\n\t\tresult = result.concat( Array( newLength - lastIndexNew ).fill( 'equal' ) );\n\t}\n\n\treturn result;\n}\n"]}]}