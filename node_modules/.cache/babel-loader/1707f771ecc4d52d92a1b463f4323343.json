{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBlYXQuanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9kaWZmZXIKICovCmltcG9ydCBQb3NpdGlvbiBmcm9tICcuL3Bvc2l0aW9uJzsKaW1wb3J0IFJhbmdlIGZyb20gJy4vcmFuZ2UnOwovKioKICogQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBtb2RlbCBzdGF0ZXMuCiAqCiAqIFJlY2VpdmVzIG9wZXJhdGlvbnMgdGhhdCBhcmUgdG8gYmUgYXBwbGllZCBvbiB0aGUgbW9kZWwgZG9jdW1lbnQuIE1hcmtzIHBhcnRzIG9mIHRoZSBtb2RlbCBkb2N1bWVudCB0cmVlIHdoaWNoCiAqIGFyZSBjaGFuZ2VkIGFuZCBzYXZlcyB0aGUgc3RhdGUgb2YgdGhlc2UgZWxlbWVudHMgYmVmb3JlIHRoZSBjaGFuZ2UuIFRoZW4sIGl0IGNvbXBhcmVzIHNhdmVkIGVsZW1lbnRzIHdpdGggdGhlCiAqIGNoYW5nZWQgZWxlbWVudHMsIGFmdGVyIGFsbCBjaGFuZ2VzIGFyZSBhcHBsaWVkIG9uIHRoZSBtb2RlbCBkb2N1bWVudC4gQ2FsY3VsYXRlcyB0aGUgZGlmZiBiZXR3ZWVuIHNhdmVkCiAqIGVsZW1lbnRzIGFuZCBuZXcgb25lcyBhbmQgcmV0dXJucyBhIGNoYW5nZSBzZXQuCiAqLwoKdmFyIERpZmZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIGBEaWZmZXJgIGluc3RhbmNlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyQ29sbGVjdGlvbn0gbWFya2VyQ29sbGVjdGlvbiBNb2RlbCdzIG1hcmtlciBjb2xsZWN0aW9uLgogICAqLwogIGZ1bmN0aW9uIERpZmZlcihtYXJrZXJDb2xsZWN0aW9uKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlmZmVyKTsKCiAgICAvKioKICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbW9kZWwncyBtYXJrZXIgY29sbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9ufQogICAgICovCiAgICB0aGlzLl9tYXJrZXJDb2xsZWN0aW9uID0gbWFya2VyQ29sbGVjdGlvbjsKICAgIC8qKgogICAgICogQSBtYXAgdGhhdCBzdG9yZXMgY2hhbmdlcyB0aGF0IGhhcHBlbmVkIGluIGEgZ2l2ZW4gZWxlbWVudC4KICAgICAqCiAgICAgKiBUaGUga2V5cyBvZiB0aGUgbWFwIGFyZSByZWZlcmVuY2VzIHRvIHRoZSBtb2RlbCBlbGVtZW50cy4KICAgICAqIFRoZSB2YWx1ZXMgb2YgdGhlIG1hcCBhcmUgYXJyYXlzIHdpdGggY2hhbmdlcyB0aGF0IHdlcmUgZG9uZSBvbiB0aGlzIGVsZW1lbnQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtNYXB9CiAgICAgKi8KCiAgICB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50ID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBBIG1hcCB0aGF0IHN0b3JlcyAiZWxlbWVudCdzIGNoaWxkcmVuIHNuYXBzaG90cyIuIEEgc25hcHNob3QgaXMgcmVwcmVzZW50aW5nIGNoaWxkcmVuIG9mIGEgZ2l2ZW4gZWxlbWVudCBiZWZvcmUKICAgICAqIHRoZSBmaXJzdCBjaGFuZ2Ugd2FzIGFwcGxpZWQgb24gdGhhdCBlbGVtZW50LiBTbmFwc2hvdCBpdGVtcyBhcmUgb2JqZWN0cyB3aXRoIHR3byBwcm9wZXJ0aWVzOiBgbmFtZWAsCiAgICAgKiBjb250YWluaW5nIHRoZSBlbGVtZW50IG5hbWUgKG9yIGAnJHRleHQnYCBmb3IgYSB0ZXh0IG5vZGUpIGFuZCBgYXR0cmlidXRlc2Agd2hpY2ggaXMgYSBtYXAgb2YgdGhlIG5vZGUncyBhdHRyaWJ1dGVzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7TWFwfQogICAgICovCgogICAgdGhpcy5fZWxlbWVudFNuYXBzaG90cyA9IG5ldyBNYXAoKTsKICAgIC8qKgogICAgICogQSBtYXAgdGhhdCBzdG9yZXMgYWxsIGNoYW5nZWQgbWFya2Vycy4KICAgICAqCiAgICAgKiBUaGUga2V5cyBvZiB0aGUgbWFwIGFyZSBtYXJrZXIgbmFtZXMuCiAgICAgKiBUaGUgdmFsdWVzIG9mIHRoZSBtYXAgYXJlIG9iamVjdHMgd2l0aCB0aGUgYG9sZFJhbmdlYCBhbmQgYG5ld1JhbmdlYCBwcm9wZXJ0aWVzLiBUaGV5IHN0b3JlIHRoZSBtYXJrZXIgcmFuZ2UKICAgICAqIHN0YXRlIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNoYW5nZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge01hcH0KICAgICAqLwoKICAgIHRoaXMuX2NoYW5nZWRNYXJrZXJzID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBTdG9yZXMgdGhlIG51bWJlciBvZiBjaGFuZ2VzIHRoYXQgd2VyZSBwcm9jZXNzZWQuIFVzZWQgdG8gb3JkZXIgdGhlIGNoYW5nZXMgY2hyb25vbG9naWNhbGx5LiBJdCBpcyBpbXBvcnRhbnQKICAgICAqIHdoZW4gY2hhbmdlcyBhcmUgc29ydGVkLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogICAgdGhpcy5fY2hhbmdlQ291bnQgPSAwOwogICAgLyoqCiAgICAgKiBGb3IgZWZmaWNpZW5jeSBwdXJwb3NlcywgYERpZmZlcmAgc3RvcmVzIHRoZSBjaGFuZ2Ugc2V0IHJldHVybmVkIGJ5IHRoZSBkaWZmZXIgYWZ0ZXIge0BsaW5rICNnZXRDaGFuZ2VzfSBjYWxsLgogICAgICogQ2FjaGUgaXMgcmVzZXQgZWFjaCB0aW1lIGEgbmV3IG9wZXJhdGlvbiBpcyBidWZmZXJlZC4gSWYgdGhlIGNhY2hlIGhhcyBub3QgYmVlbiByZXNldCwge0BsaW5rICNnZXRDaGFuZ2VzfSB3aWxsCiAgICAgKiByZXR1cm4gdGhlIGNhY2hlZCB2YWx1ZSBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIGl0IGFnYWluLgogICAgICoKICAgICAqIFRoaXMgcHJvcGVydHkgc3RvcmVzIHRob3NlIGNoYW5nZXMgdGhhdCBkaWQgbm90IHRha2UgcGxhY2UgaW4gZ3JhdmV5YXJkIHJvb3QuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0PnxudWxsfQogICAgICovCgogICAgdGhpcy5fY2FjaGVkQ2hhbmdlcyA9IG51bGw7CiAgICAvKioKICAgICAqIEZvciBlZmZpY2llbmN5IHB1cnBvc2VzLCBgRGlmZmVyYCBzdG9yZXMgdGhlIGNoYW5nZSBzZXQgcmV0dXJuZWQgYnkgdGhlIGRpZmZlciBhZnRlciB0aGUge0BsaW5rICNnZXRDaGFuZ2VzfSBjYWxsLgogICAgICogVGhlIGNhY2hlIGlzIHJlc2V0IGVhY2ggdGltZSBhIG5ldyBvcGVyYXRpb24gaXMgYnVmZmVyZWQuIElmIHRoZSBjYWNoZSBoYXMgbm90IGJlZW4gcmVzZXQsIHtAbGluayAjZ2V0Q2hhbmdlc30gd2lsbAogICAgICogcmV0dXJuIHRoZSBjYWNoZWQgdmFsdWUgaW5zdGVhZCBvZiBjYWxjdWxhdGluZyBpdCBhZ2Fpbi4KICAgICAqCiAgICAgKiBUaGlzIHByb3BlcnR5IHN0b3JlcyBhbGwgY2hhbmdlcyBldmFsdWF0ZWQgYnkgYERpZmZlcmAsIGluY2x1ZGluZyB0aG9zZSB0aGF0IHRvb2sgcGxhY2UgaW4gdGhlIGdyYXZleWFyZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fG51bGx9CiAgICAgKi8KCiAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzV2l0aEdyYXZleWFyZCA9IG51bGw7CiAgfQogIC8qKgogICAqIEluZm9ybXMgd2hldGhlciB0aGVyZSBhcmUgYW55IGNoYW5nZXMgYnVmZmVyZWQgaW4gYERpZmZlcmAuCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhEaWZmZXIsIFt7CiAgICBrZXk6ICJpc0VtcHR5IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5fY2hhbmdlc0luRWxlbWVudC5zaXplID09IDAgJiYgdGhpcy5fY2hhbmdlZE1hcmtlcnMuc2l6ZSA9PSAwOwogICAgfQogICAgLyoqCiAgICAgKiBNYXJrcyBnaXZlbiBgaXRlbWAgaW4gZGlmZmVyIHRvIGJlICJyZWZyZXNoZWQiLiBJdCBtZWFucyB0aGF0IHRoZSBpdGVtIHdpbGwgYmUgbWFya2VkIGFzIHJlbW92ZWQgYW5kIGluc2VydGVkIGluIHRoZSBkaWZmZXIgY2hhbmdlcwogICAgICogc2V0LCBzbyBpdCB3aWxsIGJlIGVmZmVjdGl2ZWx5IHJlLWNvbnZlcnRlZCB3aGVuIGRpZmZlciBjaGFuZ2VzIHdpbGwgYmUgaGFuZGxlZCBieSBhIGRpc3BhdGNoZXIuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIHRvIHJlZnJlc2guCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVmcmVzaEl0ZW0iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2hJdGVtKGl0ZW0pIHsKICAgICAgaWYgKHRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQoaXRlbS5wYXJlbnQpKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB0aGlzLl9tYXJrUmVtb3ZlKGl0ZW0ucGFyZW50LCBpdGVtLnN0YXJ0T2Zmc2V0LCBpdGVtLm9mZnNldFNpemUpOwoKICAgICAgdGhpcy5fbWFya0luc2VydChpdGVtLnBhcmVudCwgaXRlbS5zdGFydE9mZnNldCwgaXRlbS5vZmZzZXRTaXplKTsKCiAgICAgIHZhciByYW5nZSA9IFJhbmdlLl9jcmVhdGVPbihpdGVtKTsKCiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLl9tYXJrZXJDb2xsZWN0aW9uLmdldE1hcmtlcnNJbnRlcnNlY3RpbmdSYW5nZShyYW5nZSkpLAogICAgICAgICAgX3N0ZXA7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbWFya2VyID0gX3N0ZXAudmFsdWU7CiAgICAgICAgICB2YXIgbWFya2VyUmFuZ2UgPSBtYXJrZXIuZ2V0UmFuZ2UoKTsKICAgICAgICAgIHRoaXMuYnVmZmVyTWFya2VyQ2hhbmdlKG1hcmtlci5uYW1lLCBtYXJrZXJSYW5nZSwgbWFya2VyUmFuZ2UsIG1hcmtlci5hZmZlY3RzRGF0YSk7CiAgICAgICAgfSAvLyBDbGVhciBjYWNoZSBhZnRlciBlYWNoIGJ1ZmZlcmVkIG9wZXJhdGlvbiBhcyBpdCBpcyBubyBsb25nZXIgdmFsaWQuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvci5mKCk7CiAgICAgIH0KCiAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBCdWZmZXJzIHRoZSBnaXZlbiBvcGVyYXRpb24uIEFuIG9wZXJhdGlvbiBoYXMgdG8gYmUgYnVmZmVyZWQgYmVmb3JlIGl0IGlzIGV4ZWN1dGVkLgogICAgICoKICAgICAqIE9wZXJhdGlvbiB0eXBlIGlzIGNoZWNrZWQgYW5kIGl0IGlzIGNoZWNrZWQgd2hpY2ggbm9kZXMgaXQgd2lsbCBhZmZlY3QuIFRoZXNlIG5vZGVzIGFyZSB0aGVuIHN0b3JlZCBpbiBgRGlmZmVyYAogICAgICogaW4gdGhlIHN0YXRlIGJlZm9yZSB0aGUgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BlcmF0aW9uIEFuIG9wZXJhdGlvbiB0byBidWZmZXIuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYnVmZmVyT3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBidWZmZXJPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAgIC8vIEJlbG93IHdlIHRha2UgYW4gb3BlcmF0aW9uLCBjaGVjayBpdHMgdHlwZSwgdGhlbiB1c2UgaXRzIHBhcmFtZXRlcnMgaW4gbWFya2luZyAocHJpdmF0ZSkgbWV0aG9kcy4KICAgICAgLy8gVGhlIGdlbmVyYWwgcnVsZSBpcyB0byBub3QgbWFyayBlbGVtZW50cyBpbnNpZGUgaW5zZXJ0ZWQgZWxlbWVudC4gQWxsIGluc2VydGVkIGVsZW1lbnRzIGFyZSByZS1yZW5kZXJlZC4KICAgICAgLy8gTWFya2luZyBjaGFuZ2VzIGluIHRoZW0gd291bGQgY2F1c2UgYSAiZG91YmxlIiBjaGFuZ2luZyB0aGVuLgogICAgICAvLwogICAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7CiAgICAgICAgY2FzZSAnaW5zZXJ0JzoKICAgICAgICAgIHsKICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQob3BlcmF0aW9uLnBvc2l0aW9uLnBhcmVudCkpIHsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuX21hcmtJbnNlcnQob3BlcmF0aW9uLnBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLnBvc2l0aW9uLm9mZnNldCwgb3BlcmF0aW9uLm5vZGVzLm1heE9mZnNldCk7CgogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgY2FzZSAnYWRkQXR0cmlidXRlJzoKICAgICAgICBjYXNlICdyZW1vdmVBdHRyaWJ1dGUnOgogICAgICAgIGNhc2UgJ2NoYW5nZUF0dHJpYnV0ZSc6CiAgICAgICAgICB7CiAgICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3BlcmF0aW9uLnJhbmdlLmdldEl0ZW1zKHsKICAgICAgICAgICAgICBzaGFsbG93OiB0cnVlCiAgICAgICAgICAgIH0pKSwKICAgICAgICAgICAgICAgIF9zdGVwMjsKCiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAyLnZhbHVlOwoKICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KGl0ZW0ucGFyZW50KSkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrQXR0cmlidXRlKGl0ZW0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICBjYXNlICdyZW1vdmUnOgogICAgICAgIGNhc2UgJ21vdmUnOgogICAgICAgIGNhc2UgJ3JlaW5zZXJ0JzoKICAgICAgICAgIHsKICAgICAgICAgICAgLy8gV2hlbiByYW5nZSBpcyBtb3ZlZCB0byB0aGUgc2FtZSBwb3NpdGlvbiB0aGVuIG5vdCBtYXJrIGl0IGFzIGEgY2hhbmdlLgogICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy8xNjY0LgogICAgICAgICAgICBpZiAob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwob3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uKSB8fCBvcGVyYXRpb24uc291cmNlUG9zaXRpb24uZ2V0U2hpZnRlZEJ5KG9wZXJhdGlvbi5ob3dNYW55KS5pc0VxdWFsKG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbikpIHsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBzb3VyY2VQYXJlbnRJbnNlcnRlZCA9IHRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLnBhcmVudCk7CgogICAgICAgICAgICB2YXIgdGFyZ2V0UGFyZW50SW5zZXJ0ZWQgPSB0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbi5wYXJlbnQpOwoKICAgICAgICAgICAgaWYgKCFzb3VyY2VQYXJlbnRJbnNlcnRlZCkgewogICAgICAgICAgICAgIHRoaXMuX21hcmtSZW1vdmUob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLm9mZnNldCwgb3BlcmF0aW9uLmhvd01hbnkpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoIXRhcmdldFBhcmVudEluc2VydGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5fbWFya0luc2VydChvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24ucGFyZW50LCBvcGVyYXRpb24uZ2V0TW92ZWRSYW5nZVN0YXJ0KCkub2Zmc2V0LCBvcGVyYXRpb24uaG93TWFueSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICBjYXNlICdyZW5hbWUnOgogICAgICAgICAgewogICAgICAgICAgICBpZiAodGhpcy5faXNJbkluc2VydGVkRWxlbWVudChvcGVyYXRpb24ucG9zaXRpb24ucGFyZW50KSkgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdGhpcy5fbWFya1JlbW92ZShvcGVyYXRpb24ucG9zaXRpb24ucGFyZW50LCBvcGVyYXRpb24ucG9zaXRpb24ub2Zmc2V0LCAxKTsKCiAgICAgICAgICAgIHRoaXMuX21hcmtJbnNlcnQob3BlcmF0aW9uLnBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLnBvc2l0aW9uLm9mZnNldCwgMSk7CgogICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQob3BlcmF0aW9uLnBvc2l0aW9uLCAxKTsKCiAgICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fbWFya2VyQ29sbGVjdGlvbi5nZXRNYXJrZXJzSW50ZXJzZWN0aW5nUmFuZ2UocmFuZ2UpKSwKICAgICAgICAgICAgICAgIF9zdGVwMzsKCiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICAgIHZhciBtYXJrZXIgPSBfc3RlcDMudmFsdWU7CiAgICAgICAgICAgICAgICB2YXIgbWFya2VyUmFuZ2UgPSBtYXJrZXIuZ2V0UmFuZ2UoKTsKICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTWFya2VyQ2hhbmdlKG1hcmtlci5uYW1lLCBtYXJrZXJSYW5nZSwgbWFya2VyUmFuZ2UsIG1hcmtlci5hZmZlY3RzRGF0YSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTsKICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICBfaXRlcmF0b3IzLmYoKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgIGNhc2UgJ3NwbGl0JzoKICAgICAgICAgIHsKICAgICAgICAgICAgdmFyIHNwbGl0RWxlbWVudCA9IG9wZXJhdGlvbi5zcGxpdFBvc2l0aW9uLnBhcmVudDsgLy8gTWFyayB0aGF0IGNoaWxkcmVuIG9mIHRoZSBzcGxpdCBlbGVtZW50IHdlcmUgcmVtb3ZlZC4KCiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbkluc2VydGVkRWxlbWVudChzcGxpdEVsZW1lbnQpKSB7CiAgICAgICAgICAgICAgdGhpcy5fbWFya1JlbW92ZShzcGxpdEVsZW1lbnQsIG9wZXJhdGlvbi5zcGxpdFBvc2l0aW9uLm9mZnNldCwgb3BlcmF0aW9uLmhvd01hbnkpOwogICAgICAgICAgICB9IC8vIE1hcmsgdGhhdCB0aGUgbmV3IGVsZW1lbnQgKHNwbGl0IGNvcHkpIHdhcyBpbnNlcnRlZC4KCgogICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQob3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uLnBhcmVudCkpIHsKICAgICAgICAgICAgICB0aGlzLl9tYXJrSW5zZXJ0KG9wZXJhdGlvbi5pbnNlcnRpb25Qb3NpdGlvbi5wYXJlbnQsIG9wZXJhdGlvbi5pbnNlcnRpb25Qb3NpdGlvbi5vZmZzZXQsIDEpOwogICAgICAgICAgICB9IC8vIElmIHRoZSBzcGxpdCB0b29rIHRoZSBlbGVtZW50IGZyb20gdGhlIGdyYXZleWFyZCwgbWFyayB0aGF0IHRoZSBlbGVtZW50IGZyb20gdGhlIGdyYXZleWFyZCB3YXMgcmVtb3ZlZC4KCgogICAgICAgICAgICBpZiAob3BlcmF0aW9uLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICAgICAgICAgICAgdGhpcy5fbWFya1JlbW92ZShvcGVyYXRpb24uZ3JhdmV5YXJkUG9zaXRpb24ucGFyZW50LCBvcGVyYXRpb24uZ3JhdmV5YXJkUG9zaXRpb24ub2Zmc2V0LCAxKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgIGNhc2UgJ21lcmdlJzoKICAgICAgICAgIHsKICAgICAgICAgICAgLy8gTWFyayB0aGF0IHRoZSBtZXJnZWQgZWxlbWVudCB3YXMgcmVtb3ZlZC4KICAgICAgICAgICAgdmFyIG1lcmdlZEVsZW1lbnQgPSBvcGVyYXRpb24uc291cmNlUG9zaXRpb24ucGFyZW50OwoKICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KG1lcmdlZEVsZW1lbnQucGFyZW50KSkgewogICAgICAgICAgICAgIHRoaXMuX21hcmtSZW1vdmUobWVyZ2VkRWxlbWVudC5wYXJlbnQsIG1lcmdlZEVsZW1lbnQuc3RhcnRPZmZzZXQsIDEpOwogICAgICAgICAgICB9IC8vIE1hcmsgdGhhdCB0aGUgbWVyZ2VkIGVsZW1lbnQgd2FzIGluc2VydGVkIGludG8gZ3JhdmV5YXJkLgoKCiAgICAgICAgICAgIHZhciBncmF2ZXlhcmRQYXJlbnQgPSBvcGVyYXRpb24uZ3JhdmV5YXJkUG9zaXRpb24ucGFyZW50OwoKICAgICAgICAgICAgdGhpcy5fbWFya0luc2VydChncmF2ZXlhcmRQYXJlbnQsIG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbi5vZmZzZXQsIDEpOyAvLyBNYXJrIHRoYXQgY2hpbGRyZW4gb2YgbWVyZ2VkIGVsZW1lbnQgd2VyZSBpbnNlcnRlZCBhdCBuZXcgcGFyZW50LgoKCiAgICAgICAgICAgIHZhciBtZXJnZWRJbnRvRWxlbWVudCA9IG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbi5wYXJlbnQ7CgogICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQobWVyZ2VkSW50b0VsZW1lbnQpKSB7CiAgICAgICAgICAgICAgdGhpcy5fbWFya0luc2VydChtZXJnZWRJbnRvRWxlbWVudCwgb3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uLm9mZnNldCwgbWVyZ2VkRWxlbWVudC5tYXhPZmZzZXQpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgfSAvLyBDbGVhciBjYWNoZSBhZnRlciBlYWNoIGJ1ZmZlcmVkIG9wZXJhdGlvbiBhcyBpdCBpcyBubyBsb25nZXIgdmFsaWQuCgoKICAgICAgdGhpcy5fY2FjaGVkQ2hhbmdlcyA9IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIEJ1ZmZlcnMgYSBtYXJrZXIgY2hhbmdlLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXJrZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBtYXJrZXIgdGhhdCBjaGFuZ2VkLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9IG9sZFJhbmdlIE1hcmtlciByYW5nZSBiZWZvcmUgdGhlIGNoYW5nZSBvciBgbnVsbGAgaWYgdGhlIG1hcmtlciBoYXMganVzdAogICAgICogYmVlbiBjcmVhdGVkLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9IG5ld1JhbmdlIE1hcmtlciByYW5nZSBhZnRlciB0aGUgY2hhbmdlIG9yIGBudWxsYCBpZiB0aGUgbWFya2VyIHdhcyByZW1vdmVkLgogICAgICogQHBhcmFtIHtCb29sZWFufSBhZmZlY3RzRGF0YSBGbGFnIGluZGljYXRpbmcgd2hldGhlciBtYXJrZXIgYWZmZWN0cyB0aGUgZWRpdG9yIGRhdGEuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYnVmZmVyTWFya2VyQ2hhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBidWZmZXJNYXJrZXJDaGFuZ2UobWFya2VyTmFtZSwgb2xkUmFuZ2UsIG5ld1JhbmdlLCBhZmZlY3RzRGF0YSkgewogICAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLl9jaGFuZ2VkTWFya2Vycy5nZXQobWFya2VyTmFtZSk7CgogICAgICBpZiAoIWJ1ZmZlcmVkKSB7CiAgICAgICAgdGhpcy5fY2hhbmdlZE1hcmtlcnMuc2V0KG1hcmtlck5hbWUsIHsKICAgICAgICAgIG9sZFJhbmdlOiBvbGRSYW5nZSwKICAgICAgICAgIG5ld1JhbmdlOiBuZXdSYW5nZSwKICAgICAgICAgIGFmZmVjdHNEYXRhOiBhZmZlY3RzRGF0YQogICAgICAgIH0pOwogICAgICB9IGVsc2UgewogICAgICAgIGJ1ZmZlcmVkLm5ld1JhbmdlID0gbmV3UmFuZ2U7CiAgICAgICAgYnVmZmVyZWQuYWZmZWN0c0RhdGEgPSBhZmZlY3RzRGF0YTsKCiAgICAgICAgaWYgKGJ1ZmZlcmVkLm9sZFJhbmdlID09IG51bGwgJiYgYnVmZmVyZWQubmV3UmFuZ2UgPT0gbnVsbCkgewogICAgICAgICAgLy8gVGhlIG1hcmtlciBpcyBnb2luZyB0byBiZSByZW1vdmVkIChgbmV3UmFuZ2UgPT0gbnVsbGApIGJ1dCBpdCBkaWQgbm90IGV4aXN0IGJlZm9yZSB0aGUgZmlyc3QgYnVmZmVyZWQgY2hhbmdlCiAgICAgICAgICAvLyAoYGJ1ZmZlcmVkLm9sZFJhbmdlID09IG51bGxgKS4gSW4gdGhpcyBjYXNlLCBkbyBub3Qga2VlcCB0aGUgbWFya2VyIGluIGJ1ZmZlciBhdCBhbGwuCiAgICAgICAgICB0aGlzLl9jaGFuZ2VkTWFya2Vycy5kZWxldGUobWFya2VyTmFtZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYWxsIG1hcmtlcnMgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCBhcyBhIHJlc3VsdCBvZiBidWZmZXJlZCBjaGFuZ2VzLgogICAgICoKICAgICAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn0gTWFya2VycyB0byByZW1vdmUuIEVhY2ggYXJyYXkgaXRlbSBpcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYG5hbWVgIGFuZCBgcmFuZ2VgIHByb3BlcnRpZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0TWFya2Vyc1RvUmVtb3ZlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXJrZXJzVG9SZW1vdmUoKSB7CiAgICAgIHZhciByZXN1bHQgPSBbXTsKCiAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fY2hhbmdlZE1hcmtlcnMpLAogICAgICAgICAgX3N0ZXA0OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykgewogICAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMiksCiAgICAgICAgICAgICAgbmFtZSA9IF9zdGVwNCR2YWx1ZVswXSwKICAgICAgICAgICAgICBjaGFuZ2UgPSBfc3RlcDQkdmFsdWVbMV07CgogICAgICAgICAgaWYgKGNoYW5nZS5vbGRSYW5nZSAhPSBudWxsKSB7CiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsKICAgICAgICAgICAgICBuYW1lOiBuYW1lLAogICAgICAgICAgICAgIHJhbmdlOiBjaGFuZ2Uub2xkUmFuZ2UKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I0LmYoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbGwgbWFya2VycyB3aGljaCBzaG91bGQgYmUgYWRkZWQgYXMgYSByZXN1bHQgb2YgYnVmZmVyZWQgY2hhbmdlcy4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59IE1hcmtlcnMgdG8gYWRkLiBFYWNoIGFycmF5IGl0ZW0gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBuYW1lYCBhbmQgYHJhbmdlYCBwcm9wZXJ0aWVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldE1hcmtlcnNUb0FkZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2Vyc1RvQWRkKCkgewogICAgICB2YXIgcmVzdWx0ID0gW107CgogICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX2NoYW5nZWRNYXJrZXJzKSwKICAgICAgICAgIF9zdGVwNTsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBfc3RlcDUkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDUudmFsdWUsIDIpLAogICAgICAgICAgICAgIG5hbWUgPSBfc3RlcDUkdmFsdWVbMF0sCiAgICAgICAgICAgICAgY2hhbmdlID0gX3N0ZXA1JHZhbHVlWzFdOwoKICAgICAgICAgIGlmIChjaGFuZ2UubmV3UmFuZ2UgIT0gbnVsbCkgewogICAgICAgICAgICByZXN1bHQucHVzaCh7CiAgICAgICAgICAgICAgbmFtZTogbmFtZSwKICAgICAgICAgICAgICByYW5nZTogY2hhbmdlLm5ld1JhbmdlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYWxsIG1hcmtlcnMgd2hpY2ggY2hhbmdlZC4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Q2hhbmdlZE1hcmtlcnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYW5nZWRNYXJrZXJzKCkgewogICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9jaGFuZ2VkTWFya2VycykubWFwKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIG5hbWU6IGl0ZW1bMF0sCiAgICAgICAgICBkYXRhOiB7CiAgICAgICAgICAgIG9sZFJhbmdlOiBpdGVtWzFdLm9sZFJhbmdlLAogICAgICAgICAgICBuZXdSYW5nZTogaXRlbVsxXS5uZXdSYW5nZQogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciBzb21lIG9mIHRoZSBidWZmZXJlZCBjaGFuZ2VzIGFmZmVjdCB0aGUgZWRpdG9yIGRhdGEuCiAgICAgKgogICAgICogVHlwZXMgb2YgY2hhbmdlcyB3aGljaCBhZmZlY3QgdGhlIGVkaXRvciBkYXRhOgogICAgICoKICAgICAqICogbW9kZWwgc3RydWN0dXJlIGNoYW5nZXMsCiAgICAgKiAqIGF0dHJpYnV0ZSBjaGFuZ2VzLAogICAgICogKiBjaGFuZ2VzIG9mIG1hcmtlcnMgd2hpY2ggd2VyZSBkZWZpbmVkIGFzIGBhZmZlY3RpbmdEYXRhYC4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJoYXNEYXRhQ2hhbmdlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzRGF0YUNoYW5nZXMoKSB7CiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fY2hhbmdlZE1hcmtlcnMpLAogICAgICAgICAgX3N0ZXA2OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykgewogICAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksCiAgICAgICAgICAgICAgY2hhbmdlID0gX3N0ZXA2JHZhbHVlWzFdOwoKICAgICAgICAgIGlmIChjaGFuZ2UuYWZmZWN0c0RhdGEpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBJZiBtYXJrZXJzIGRvIG5vdCBhZmZlY3QgdGhlIGRhdGEsIGNoZWNrIHdoZXRoZXIgdGhlcmUgYXJlIHNvbWUgY2hhbmdlcyBpbiBlbGVtZW50cy4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjYuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjYuZigpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5fY2hhbmdlc0luRWxlbWVudC5zaXplID4gMDsKICAgIH0KICAgIC8qKgogICAgICogQ2FsY3VsYXRlcyB0aGUgZGlmZiBiZXR3ZWVuIHRoZSBvbGQgbW9kZWwgdHJlZSBzdGF0ZSAodGhlIHN0YXRlIGJlZm9yZSB0aGUgZmlyc3QgYnVmZmVyZWQgb3BlcmF0aW9ucyBzaW5jZSB0aGUgbGFzdCB7QGxpbmsgI3Jlc2V0fQogICAgICogY2FsbCkgYW5kIHRoZSBuZXcgbW9kZWwgdHJlZSBzdGF0ZSAoYWN0dWFsIG9uZSkuIEl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIGJ1ZmZlcmVkIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkLgogICAgICoKICAgICAqIFRoZSBkaWZmIHNldCBpcyByZXR1cm5lZCBhcyBhbiBhcnJheSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW0gZGlmZiBpdGVtc30sIGVhY2ggZGVzY3JpYmluZyBhIGNoYW5nZSBkb25lCiAgICAgKiBvbiB0aGUgbW9kZWwuIFRoZSBpdGVtcyBhcmUgc29ydGVkIGJ5IHRoZSBwb3NpdGlvbiBvbiB3aGljaCB0aGUgY2hhbmdlIGhhcHBlbmVkLiBJZiBhIHBvc2l0aW9uCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNpc0JlZm9yZSBpcyBiZWZvcmV9IGFub3RoZXIgb25lLCBpdCB3aWxsIGJlIG9uIGFuIGVhcmxpZXIgaW5kZXggaW4gdGhlIGRpZmYgc2V0LgogICAgICoKICAgICAqICoqTm90ZSoqOiBFbGVtZW50cyBpbnNpZGUgaW5zZXJ0ZWQgZWxlbWVudCB3aWxsIG5vdCBoYXZlIGEgc2VwYXJhdGUgZGlmZiBpdGVtLCBvbmx5IHRoZSB0b3AgbW9zdCBlbGVtZW50IGNoYW5nZSB3aWxsIGJlIHJlcG9ydGVkLgogICAgICoKICAgICAqIEJlY2F1c2UgY2FsY3VsYXRpbmcgdGhlIGRpZmYgaXMgYSBjb3N0bHkgb3BlcmF0aW9uLCB0aGUgcmVzdWx0IGlzIGNhY2hlZC4gSWYgbm8gbmV3IG9wZXJhdGlvbiB3YXMgYnVmZmVyZWQgc2luY2UgdGhlCiAgICAgKiBwcmV2aW91cyB7QGxpbmsgI2dldENoYW5nZXN9IGNhbGwsIHRoZSBuZXh0IGNhbGwgd2lsbCByZXR1cm4gdGhlIGNhY2hlZCB2YWx1ZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVDaGFuZ2VzSW5HcmF2ZXlhcmQ9ZmFsc2VdIElmIHNldCB0byBgdHJ1ZWAsIGFsc28gY2hhbmdlcyB0aGF0IGhhcHBlbmVkCiAgICAgKiBpbiB0aGUgZ3JhdmV5YXJkIHJvb3Qgd2lsbCBiZSByZXR1cm5lZC4gQnkgZGVmYXVsdCwgY2hhbmdlcyBpbiB0aGUgZ3JhdmV5YXJkIHJvb3QgYXJlIG5vdCByZXR1cm5lZC4KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW0+fSBEaWZmIGJldHdlZW4gdGhlIG9sZCBhbmQgdGhlIG5ldyBtb2RlbCB0cmVlIHN0YXRlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENoYW5nZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoYW5nZXMoKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7CiAgICAgICAgaW5jbHVkZUNoYW5nZXNJbkdyYXZleWFyZDogZmFsc2UKICAgICAgfTsKCiAgICAgIC8vIElmIHRoZXJlIGFyZSBjYWNoZWQgY2hhbmdlcywganVzdCByZXR1cm4gdGhlbSBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIGNoYW5nZXMgYWdhaW4uCiAgICAgIGlmICh0aGlzLl9jYWNoZWRDaGFuZ2VzKSB7CiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUNoYW5nZXNJbkdyYXZleWFyZCkgewogICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZENoYW5nZXNXaXRoR3JhdmV5YXJkLnNsaWNlKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRDaGFuZ2VzLnNsaWNlKCk7CiAgICAgICAgfQogICAgICB9IC8vIFdpbGwgY29udGFpbiByZXR1cm5lZCByZXN1bHRzLgoKCiAgICAgIHZhciBkaWZmU2V0ID0gW107IC8vIENoZWNrIGFsbCBjaGFuZ2VkIGVsZW1lbnRzLgoKICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LmtleXMoKSksCiAgICAgICAgICBfc3RlcDc7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgZWxlbWVudCA9IF9zdGVwNy52YWx1ZTsKCiAgICAgICAgICAvLyBHZXQgY2hhbmdlcyBmb3IgdGhpcyBlbGVtZW50IGFuZCBzb3J0IHRoZW0uCiAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXNJbkVsZW1lbnQuZ2V0KGVsZW1lbnQpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICAgICAgaWYgKGEub2Zmc2V0ID09PSBiLm9mZnNldCkgewogICAgICAgICAgICAgIGlmIChhLnR5cGUgIT0gYi50eXBlKSB7CiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2hhbmdlcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgInJlbW92ZSIgY2hhbmdlIHNob3VsZCBiZSBmaXJzdC4KICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcmRlciBpcyBkaWZmZXJlbnQsIGZvciBleGFtcGxlLCB3ZSB3b3VsZCBmaXJzdCBhZGQgc29tZSBub2RlcyBhbmQgdGhlbiByZW1vdmVkIHRoZW0KICAgICAgICAgICAgICAgIC8vIChpbnN0ZWFkIG9mIHRoZSBub2RlcyB0aGF0IHdlIHNob3VsZCByZW1vdmUpLgogICAgICAgICAgICAgICAgcmV0dXJuIGEudHlwZSA9PSAncmVtb3ZlJyA/IC0xIDogMTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgICB9CgogICAgICAgICAgICByZXR1cm4gYS5vZmZzZXQgPCBiLm9mZnNldCA/IC0xIDogMTsKICAgICAgICAgIH0pOyAvLyBHZXQgY2hpbGRyZW4gb2YgdGhpcyBlbGVtZW50IGJlZm9yZSBhbnkgY2hhbmdlIHdhcyBhcHBsaWVkIG9uIGl0LgoKCiAgICAgICAgICB2YXIgc25hcHNob3RDaGlsZHJlbiA9IHRoaXMuX2VsZW1lbnRTbmFwc2hvdHMuZ2V0KGVsZW1lbnQpOyAvLyBHZXQgc25hcHNob3Qgb2YgY3VycmVudCBlbGVtZW50J3MgY2hpbGRyZW4uCgoKICAgICAgICAgIHZhciBlbGVtZW50Q2hpbGRyZW4gPSBfZ2V0Q2hpbGRyZW5TbmFwc2hvdChlbGVtZW50LmdldENoaWxkcmVuKCkpOyAvLyBHZW5lcmF0ZSBhY3Rpb25zIGJhc2luZyBvbiBjaGFuZ2VzIGRvbmUgb24gZWxlbWVudC4KCgogICAgICAgICAgdmFyIGFjdGlvbnMgPSBfZ2VuZXJhdGVBY3Rpb25zRnJvbUNoYW5nZXMoc25hcHNob3RDaGlsZHJlbi5sZW5ndGgsIGNoYW5nZXMpOwoKICAgICAgICAgIHZhciBfaSA9IDA7IC8vIEl0ZXJhdG9yIGluIGBlbGVtZW50Q2hpbGRyZW5gIGFycmF5IC0tIGl0ZXJhdGVzIHRocm91Z2ggY3VycmVudCBjaGlsZHJlbiBvZiBlbGVtZW50LgoKICAgICAgICAgIHZhciBqID0gMDsgLy8gSXRlcmF0b3IgaW4gYHNuYXBzaG90Q2hpbGRyZW5gIGFycmF5IC0tIGl0ZXJhdGVzIHRocm91Z2ggb2xkIGNoaWxkcmVuIG9mIGVsZW1lbnQuCiAgICAgICAgICAvLyBQcm9jZXNzIGV2ZXJ5IGFjdGlvbi4KCiAgICAgICAgICB2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFjdGlvbnMpLAogICAgICAgICAgICAgIF9zdGVwOTsKCiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykgewogICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfc3RlcDkudmFsdWU7CgogICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdpJykgewogICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgZGlmZiBpdGVtIGZvciB0aGlzIGVsZW1lbnQgYW5kIGluc2VydCBpdCBpbnRvIHRoZSBkaWZmIHNldC4KICAgICAgICAgICAgICAgIGRpZmZTZXQucHVzaCh0aGlzLl9nZXRJbnNlcnREaWZmKGVsZW1lbnQsIF9pLCBlbGVtZW50Q2hpbGRyZW5bX2ldLm5hbWUpKTsKICAgICAgICAgICAgICAgIF9pKys7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09ICdyJykgewogICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgZGlmZiBpdGVtIGZvciB0aGlzIGVsZW1lbnQgYW5kIGluc2VydCBpdCBpbnRvIHRoZSBkaWZmIHNldC4KICAgICAgICAgICAgICAgIGRpZmZTZXQucHVzaCh0aGlzLl9nZXRSZW1vdmVEaWZmKGVsZW1lbnQsIF9pLCBzbmFwc2hvdENoaWxkcmVuW2pdLm5hbWUpKTsKICAgICAgICAgICAgICAgIGorKzsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2EnKSB7CiAgICAgICAgICAgICAgICB2YXIgX2RpZmZTZXQ7CgogICAgICAgICAgICAgICAgLy8gVGFrZSBhdHRyaWJ1dGVzIGZyb20gc2F2ZWQgYW5kIGN1cnJlbnQgY2hpbGRyZW4uCiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEF0dHJpYnV0ZXMgPSBlbGVtZW50Q2hpbGRyZW5bX2ldLmF0dHJpYnV0ZXM7CiAgICAgICAgICAgICAgICB2YXIgc25hcHNob3RBdHRyaWJ1dGVzID0gc25hcHNob3RDaGlsZHJlbltqXS5hdHRyaWJ1dGVzOwogICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdm9pZCAwOwoKICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Q2hpbGRyZW5bX2ldLm5hbWUgPT0gJyR0ZXh0JykgewogICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudCwgX2kpLCBQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudCwgX2kgKyAxKSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBlbGVtZW50Lm9mZnNldFRvSW5kZXgoX2kpOwogICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudCwgX2kpLCBQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudC5nZXRDaGlsZChpbmRleCksIDApKTsKICAgICAgICAgICAgICAgIH0gLy8gR2VuZXJhdGUgZGlmZiBpdGVtcyBmb3IgdGhpcyBjaGFuZ2UgKHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGF0dHJpYnV0ZXMgY2hhbmdlZCBhbmQKICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgc2luZ2xlIGRpZmYgZm9yIGVhY2ggb2YgdGhlbSkgYW5kIGluc2VydCB0aGVtIGludG8gdGhlIGRpZmYgc2V0LgoKCiAgICAgICAgICAgICAgICAoX2RpZmZTZXQgPSBkaWZmU2V0KS5wdXNoLmFwcGx5KF9kaWZmU2V0LCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fZ2V0QXR0cmlidXRlc0RpZmYocmFuZ2UsIHNuYXBzaG90QXR0cmlidXRlcywgZWxlbWVudEF0dHJpYnV0ZXMpKSk7CgogICAgICAgICAgICAgICAgX2krKzsKICAgICAgICAgICAgICAgIGorKzsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgLy8gYGFjdGlvbmAgaXMgJ2VxdWFsJy4gQ2hpbGQgbm90IGNoYW5nZWQuCiAgICAgICAgICAgICAgICBfaSsrOwogICAgICAgICAgICAgICAgaisrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjkuZShlcnIpOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgX2l0ZXJhdG9yOS5mKCk7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBUaGVuLCBzb3J0IHRoZSBjaGFuZ2VzIGJ5IHRoZSBwb3NpdGlvbiAoY2hhbmdlIGF0IHBvc2l0aW9uIGJlZm9yZSBvdGhlciBjaGFuZ2VzIGlzIGZpcnN0KS4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjcuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjcuZigpOwogICAgICB9CgogICAgICBkaWZmU2V0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluIGRpZmZlcmVudCByb290LCB3ZSBkb24ndCBjYXJlIG11Y2gsIGJ1dCB3ZSdkIGxpa2UgdG8gaGF2ZSBhbGwgY2hhbmdlcyBpbiBnaXZlbgogICAgICAgIC8vIHJvb3QgInRvZ2V0aGVyIiBpbiB0aGUgYXJyYXkuIFNvIGxldCdzIGp1c3Qgc29ydCB0aGVtIGJ5IHRoZSByb290IG5hbWUuIEl0IGRvZXMgbm90IG1hdHRlciB3aGljaCByb290CiAgICAgICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgZmlyc3QuCiAgICAgICAgaWYgKGEucG9zaXRpb24ucm9vdCAhPSBiLnBvc2l0aW9uLnJvb3QpIHsKICAgICAgICAgIHJldHVybiBhLnBvc2l0aW9uLnJvb3Qucm9vdE5hbWUgPCBiLnBvc2l0aW9uLnJvb3Qucm9vdE5hbWUgPyAtMSA6IDE7CiAgICAgICAgfSAvLyBJZiBjaGFuZ2UgaGFwcGVucyBhdCB0aGUgc2FtZSBwb3NpdGlvbi4uLgoKCiAgICAgICAgaWYgKGEucG9zaXRpb24uaXNFcXVhbChiLnBvc2l0aW9uKSkgewogICAgICAgICAgLy8gS2VlcCBjaHJvbm9sb2dpY2FsIG9yZGVyIG9mIG9wZXJhdGlvbnMuCiAgICAgICAgICByZXR1cm4gYS5jaGFuZ2VDb3VudCAtIGIuY2hhbmdlQ291bnQ7CiAgICAgICAgfSAvLyBJZiBwb3NpdGlvbnMgZGlmZmVyLCBwb3NpdGlvbiAib24gdGhlIGxlZnQiIHNob3VsZCBiZSBlYXJsaWVyIGluIHRoZSByZXN1bHQuCgoKICAgICAgICByZXR1cm4gYS5wb3NpdGlvbi5pc0JlZm9yZShiLnBvc2l0aW9uKSA/IC0xIDogMTsKICAgICAgfSk7IC8vIEdsdWUgdG9nZXRoZXIgbXVsdGlwbGUgY2hhbmdlcyAobW9zdGx5IG9uIHRleHQgbm9kZXMpLgoKICAgICAgZm9yICh2YXIgaSA9IDEsIHByZXZJbmRleCA9IDA7IGkgPCBkaWZmU2V0Lmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIHByZXZEaWZmID0gZGlmZlNldFtwcmV2SW5kZXhdOwogICAgICAgIHZhciB0aGlzRGlmZiA9IGRpZmZTZXRbaV07IC8vIEdsdWUgcmVtb3ZlIGNoYW5nZXMgaWYgdGhleSBoYXBwZW4gb24gdGV4dCBvbiBzYW1lIHBvc2l0aW9uLgoKICAgICAgICB2YXIgaXNDb25zZWN1dGl2ZVRleHRSZW1vdmUgPSBwcmV2RGlmZi50eXBlID09ICdyZW1vdmUnICYmIHRoaXNEaWZmLnR5cGUgPT0gJ3JlbW92ZScgJiYgcHJldkRpZmYubmFtZSA9PSAnJHRleHQnICYmIHRoaXNEaWZmLm5hbWUgPT0gJyR0ZXh0JyAmJiBwcmV2RGlmZi5wb3NpdGlvbi5pc0VxdWFsKHRoaXNEaWZmLnBvc2l0aW9uKTsgLy8gR2x1ZSBpbnNlcnQgY2hhbmdlcyBpZiB0aGV5IGhhcHBlbiBvbiB0ZXh0IG9uIGNvbnNlY3V0aXZlIGZyYWdtZW50cy4KCiAgICAgICAgdmFyIGlzQ29uc2VjdXRpdmVUZXh0QWRkID0gcHJldkRpZmYudHlwZSA9PSAnaW5zZXJ0JyAmJiB0aGlzRGlmZi50eXBlID09ICdpbnNlcnQnICYmIHByZXZEaWZmLm5hbWUgPT0gJyR0ZXh0JyAmJiB0aGlzRGlmZi5uYW1lID09ICckdGV4dCcgJiYgcHJldkRpZmYucG9zaXRpb24ucGFyZW50ID09IHRoaXNEaWZmLnBvc2l0aW9uLnBhcmVudCAmJiBwcmV2RGlmZi5wb3NpdGlvbi5vZmZzZXQgKyBwcmV2RGlmZi5sZW5ndGggPT0gdGhpc0RpZmYucG9zaXRpb24ub2Zmc2V0OyAvLyBHbHVlIGF0dHJpYnV0ZSBjaGFuZ2VzIGlmIHRoZXkgaGFwcGVuIG9uIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhbmQgaGF2ZSBzYW1lIGtleSwgb2xkIHZhbHVlIGFuZCBuZXcgdmFsdWUuCgogICAgICAgIHZhciBpc0NvbnNlY3V0aXZlQXR0cmlidXRlQ2hhbmdlID0gcHJldkRpZmYudHlwZSA9PSAnYXR0cmlidXRlJyAmJiB0aGlzRGlmZi50eXBlID09ICdhdHRyaWJ1dGUnICYmIHByZXZEaWZmLnBvc2l0aW9uLnBhcmVudCA9PSB0aGlzRGlmZi5wb3NpdGlvbi5wYXJlbnQgJiYgcHJldkRpZmYucmFuZ2UuaXNGbGF0ICYmIHRoaXNEaWZmLnJhbmdlLmlzRmxhdCAmJiBwcmV2RGlmZi5wb3NpdGlvbi5vZmZzZXQgKyBwcmV2RGlmZi5sZW5ndGggPT0gdGhpc0RpZmYucG9zaXRpb24ub2Zmc2V0ICYmIHByZXZEaWZmLmF0dHJpYnV0ZUtleSA9PSB0aGlzRGlmZi5hdHRyaWJ1dGVLZXkgJiYgcHJldkRpZmYuYXR0cmlidXRlT2xkVmFsdWUgPT0gdGhpc0RpZmYuYXR0cmlidXRlT2xkVmFsdWUgJiYgcHJldkRpZmYuYXR0cmlidXRlTmV3VmFsdWUgPT0gdGhpc0RpZmYuYXR0cmlidXRlTmV3VmFsdWU7CgogICAgICAgIGlmIChpc0NvbnNlY3V0aXZlVGV4dFJlbW92ZSB8fCBpc0NvbnNlY3V0aXZlVGV4dEFkZCB8fCBpc0NvbnNlY3V0aXZlQXR0cmlidXRlQ2hhbmdlKSB7CiAgICAgICAgICBwcmV2RGlmZi5sZW5ndGgrKzsKCiAgICAgICAgICBpZiAoaXNDb25zZWN1dGl2ZUF0dHJpYnV0ZUNoYW5nZSkgewogICAgICAgICAgICBwcmV2RGlmZi5yYW5nZS5lbmQgPSBwcmV2RGlmZi5yYW5nZS5lbmQuZ2V0U2hpZnRlZEJ5KDEpOwogICAgICAgICAgfQoKICAgICAgICAgIGRpZmZTZXRbaV0gPSBudWxsOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwcmV2SW5kZXggPSBpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgZGlmZlNldCA9IGRpZmZTZXQuZmlsdGVyKGZ1bmN0aW9uICh2KSB7CiAgICAgICAgcmV0dXJuIHY7CiAgICAgIH0pOyAvLyBSZW1vdmUgYGNoYW5nZUNvdW50YCBwcm9wZXJ0eSBmcm9tIGRpZmYgaXRlbXMuIEl0IGlzIHVzZWQgb25seSBmb3Igc29ydGluZyBhbmQgaXMgaW50ZXJuYWwgdGhpbmcuCgogICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRpZmZTZXQpLAogICAgICAgICAgX3N0ZXA4OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDgudmFsdWU7CiAgICAgICAgICBkZWxldGUgaXRlbS5jaGFuZ2VDb3VudDsKCiAgICAgICAgICBpZiAoaXRlbS50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnBvc2l0aW9uOwogICAgICAgICAgICBkZWxldGUgaXRlbS5sZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I4LmYoKTsKICAgICAgfQoKICAgICAgdGhpcy5fY2hhbmdlQ291bnQgPSAwOyAvLyBDYWNoZSBjaGFuZ2VzLgoKICAgICAgdGhpcy5fY2FjaGVkQ2hhbmdlc1dpdGhHcmF2ZXlhcmQgPSBkaWZmU2V0LnNsaWNlKCk7CiAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBkaWZmU2V0LmZpbHRlcihfY2hhbmdlc0luR3JhdmV5YXJkRmlsdGVyKTsKCiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVDaGFuZ2VzSW5HcmF2ZXlhcmQpIHsKICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ2hhbmdlc1dpdGhHcmF2ZXlhcmQ7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZENoYW5nZXM7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmVzZXRzIGBEaWZmZXJgLiBSZW1vdmVzIGFsbCBidWZmZXJlZCBjaGFuZ2VzLgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlc2V0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHsKICAgICAgdGhpcy5fY2hhbmdlc0luRWxlbWVudC5jbGVhcigpOwoKICAgICAgdGhpcy5fZWxlbWVudFNuYXBzaG90cy5jbGVhcigpOwoKICAgICAgdGhpcy5fY2hhbmdlZE1hcmtlcnMuY2xlYXIoKTsKCiAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBTYXZlcyBhbmQgaGFuZGxlcyBhbiBpbnNlcnQgY2hhbmdlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21hcmtJbnNlcnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXJrSW5zZXJ0KHBhcmVudCwgb2Zmc2V0LCBob3dNYW55KSB7CiAgICAgIHZhciBjaGFuZ2VJdGVtID0gewogICAgICAgIHR5cGU6ICdpbnNlcnQnLAogICAgICAgIG9mZnNldDogb2Zmc2V0LAogICAgICAgIGhvd01hbnk6IGhvd01hbnksCiAgICAgICAgY291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgfTsKCiAgICAgIHRoaXMuX21hcmtDaGFuZ2UocGFyZW50LCBjaGFuZ2VJdGVtKTsKICAgIH0KICAgIC8qKgogICAgICogU2F2ZXMgYW5kIGhhbmRsZXMgYSByZW1vdmUgY2hhbmdlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21hcmtSZW1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXJrUmVtb3ZlKHBhcmVudCwgb2Zmc2V0LCBob3dNYW55KSB7CiAgICAgIHZhciBjaGFuZ2VJdGVtID0gewogICAgICAgIHR5cGU6ICdyZW1vdmUnLAogICAgICAgIG9mZnNldDogb2Zmc2V0LAogICAgICAgIGhvd01hbnk6IGhvd01hbnksCiAgICAgICAgY291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgfTsKCiAgICAgIHRoaXMuX21hcmtDaGFuZ2UocGFyZW50LCBjaGFuZ2VJdGVtKTsKCiAgICAgIHRoaXMuX3JlbW92ZUFsbE5lc3RlZENoYW5nZXMocGFyZW50LCBvZmZzZXQsIGhvd01hbnkpOwogICAgfQogICAgLyoqCiAgICAgKiBTYXZlcyBhbmQgaGFuZGxlcyBhbiBhdHRyaWJ1dGUgY2hhbmdlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21hcmtBdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXJrQXR0cmlidXRlKGl0ZW0pIHsKICAgICAgdmFyIGNoYW5nZUl0ZW0gPSB7CiAgICAgICAgdHlwZTogJ2F0dHJpYnV0ZScsCiAgICAgICAgb2Zmc2V0OiBpdGVtLnN0YXJ0T2Zmc2V0LAogICAgICAgIGhvd01hbnk6IGl0ZW0ub2Zmc2V0U2l6ZSwKICAgICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICB9OwoKICAgICAgdGhpcy5fbWFya0NoYW5nZShpdGVtLnBhcmVudCwgY2hhbmdlSXRlbSk7CiAgICB9CiAgICAvKioKICAgICAqIFNhdmVzIGFuZCBoYW5kbGVzIGEgbW9kZWwgY2hhbmdlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VJdGVtCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21hcmtDaGFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXJrQ2hhbmdlKHBhcmVudCwgY2hhbmdlSXRlbSkgewogICAgICAvLyBGaXJzdCwgbWFrZSBhIHNuYXBzaG90IG9mIHRoaXMgcGFyZW50J3MgY2hpbGRyZW4gKGl0IHdpbGwgYmUgbWFkZSBvbmx5IGlmIGl0IHdhcyBub3QgbWFkZSBiZWZvcmUpLgogICAgICB0aGlzLl9tYWtlU25hcHNob3QocGFyZW50KTsgLy8gVGhlbiwgZ2V0IGFsbCBjaGFuZ2VzIHRoYXQgYWxyZWFkeSB3ZXJlIGRvbmUgb24gdGhlIGVsZW1lbnQgKGVtcHR5IGFycmF5IGlmIHRoaXMgaXMgdGhlIGZpcnN0IGNoYW5nZSkuCgoKICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9nZXRDaGFuZ2VzRm9yRWxlbWVudChwYXJlbnQpOyAvLyBUaGVuLCBsb29rIHRocm91Z2ggYWxsIHRoZSBjaGFuZ2VzLCBhbmQgdHJhbnNmb3JtIHRoZW0gb3IgdGhlIG5ldyBjaGFuZ2UuCgoKICAgICAgdGhpcy5faGFuZGxlQ2hhbmdlKGNoYW5nZUl0ZW0sIGNoYW5nZXMpOyAvLyBBZGQgdGhlIG5ldyBjaGFuZ2UuCgoKICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZUl0ZW0pOyAvLyBSZW1vdmUgaW5jb3JyZWN0IGNoYW5nZXMuIER1cmluZyB0cmFuc2Zvcm1hdGlvbiBzb21lIGNoYW5nZSBtaWdodCBiZSwgZm9yIGV4YW1wbGUsIGluY2x1ZGVkIGluIGFub3RoZXIuCiAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIGNoYW5nZSB3aWxsIGhhdmUgYGhvd01hbnlgIHByb3BlcnR5IHNldCB0byBgMGAgb3IgbGVzcy4gV2UgbmVlZCB0byByZW1vdmUgdGhvc2UgY2hhbmdlcy4KCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykgewogICAgICAgIGlmIChjaGFuZ2VzW2ldLmhvd01hbnkgPCAxKSB7CiAgICAgICAgICBjaGFuZ2VzLnNwbGljZShpLCAxKTsKICAgICAgICAgIGktLTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogR2V0cyBhbiBhcnJheSBvZiBjaGFuZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gc2F2ZWQgZm9yIGEgZ2l2ZW4gZWxlbWVudC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAgICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRDaGFuZ2VzRm9yRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENoYW5nZXNGb3JFbGVtZW50KGVsZW1lbnQpIHsKICAgICAgdmFyIGNoYW5nZXM7CgogICAgICBpZiAodGhpcy5fY2hhbmdlc0luRWxlbWVudC5oYXMoZWxlbWVudCkpIHsKICAgICAgICBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlc0luRWxlbWVudC5nZXQoZWxlbWVudCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY2hhbmdlcyA9IFtdOwoKICAgICAgICB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LnNldChlbGVtZW50LCBjaGFuZ2VzKTsKICAgICAgfQoKICAgICAgcmV0dXJuIGNoYW5nZXM7CiAgICB9CiAgICAvKioKICAgICAqIFNhdmVzIGEgY2hpbGRyZW4gc25hcHNob3QgZm9yIGEgZ2l2ZW4gZWxlbWVudC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9tYWtlU25hcHNob3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU25hcHNob3QoZWxlbWVudCkgewogICAgICBpZiAoIXRoaXMuX2VsZW1lbnRTbmFwc2hvdHMuaGFzKGVsZW1lbnQpKSB7CiAgICAgICAgdGhpcy5fZWxlbWVudFNuYXBzaG90cy5zZXQoZWxlbWVudCwgX2dldENoaWxkcmVuU25hcHNob3QoZWxlbWVudC5nZXRDaGlsZHJlbigpKSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogRm9yIGEgZ2l2ZW4gbmV3bHkgc2F2ZWQgY2hhbmdlLCBjb21wYXJlcyBpdCB3aXRoIGEgY2hhbmdlIGFscmVhZHkgZG9uZSBvbiB0aGUgZWxlbWVudCBhbmQgbW9kaWZpZXMgdGhlIGluY29taW5nCiAgICAgKiBjaGFuZ2UgYW5kL29yIHRoZSBvbGQgY2hhbmdlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5jIEluY29taW5nIChuZXcpIGNoYW5nZS4KICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNoYW5nZXMgQW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIGNoYW5nZXMgZG9uZSBvbiB0aGF0IGVsZW1lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2hhbmRsZUNoYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShpbmMsIGNoYW5nZXMpIHsKICAgICAgLy8gV2UgbmVlZCBhIGhlbHBlciB2YXJpYWJsZSB0aGF0IHdpbGwgc3RvcmUgaG93IG1hbnkgbm9kZXMgYXJlIHRvIGJlIHN0aWxsIGhhbmRsZWQgZm9yIHRoaXMgY2hhbmdlIGl0ZW0uCiAgICAgIC8vIGBub2Rlc1RvSGFuZGxlYCAoaG93IG1hbnkgbm9kZXMgc3RpbGwgbmVlZCB0byBiZSBoYW5kbGVkKSBhbmQgYGhvd01hbnlgIChob3cgbWFueSBub2RlcyB3ZXJlIGFmZmVjdGVkKQogICAgICAvLyBuZWVkcyB0byBiZSBkaWZmZXJlbnRpYXRlZC4KICAgICAgLy8KICAgICAgLy8gVGhpcyBjb21lcyB1cCB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBjaGFuZ2VzIHRoYXQgYXJlIGFmZmVjdGVkIGJ5IGBpbmNgIGNoYW5nZSBpdGVtLgogICAgICAvLwogICAgICAvLyBGb3IgZXhhbXBsZTogYXNzdW1lIHR3byBpbnNlcnQgY2hhbmdlczogYHsgb2Zmc2V0OiAyLCBob3dNYW55OiAxIH1gIGFuZCBgeyBvZmZzZXQ6IDUsIGhvd01hbnk6IDEgfWAuCiAgICAgIC8vIEFzc3VtZSB0aGF0IGBpbmNgIGNoYW5nZSBpcyByZW1vdmUgYHsgb2Zmc2V0OiAyLCBob3dNYW55OiAyLCBub2Rlc1RvSGFuZGxlOiAyIH1gLgogICAgICAvLwogICAgICAvLyBUaGVuLCB3ZToKICAgICAgLy8gLSAiZm9yZ2V0IiBhYm91dCBmaXJzdCBpbnNlcnQgY2hhbmdlIChpdCBpcyAiZWF0ZW4iIGJ5IHJlbW92ZSksCiAgICAgIC8vIC0gYmVjYXVzZSBvZiB0aGF0LCBhdCB0aGUgZW5kIHdlIHdpbGwgd2FudCB0byByZW1vdmUgb25seSBvbmUgbm9kZSAoYG5vZGVzVG9IYW5kbGUgPSAxYCksCiAgICAgIC8vIC0gYnV0IHN0aWxsIHdlIGhhdmUgdG8gY2hhbmdlIG9mZnNldCBvZiB0aGUgc2Vjb25kIGluc2VydCBjaGFuZ2UgZnJvbSBgNWAgdG8gYDNgIQogICAgICAvLwogICAgICAvLyBTbywgYGhvd01hbnlgIGRvZXMgbm90IGNoYW5nZSB0aHJvdWdob3V0IGl0ZW1zIHRyYW5zZm9ybWF0aW9uIGFuZCBrZWVwcyBpbmZvcm1hdGlvbiBhYm91dCBob3cgbWFueSBub2RlcyB3ZXJlIGFmZmVjdGVkLAogICAgICAvLyB3aGlsZSBgbm9kZXNUb0hhbmRsZWAgbWVhbnMgaG93IG1hbnkgbm9kZXMgbmVlZCB0byBiZSBoYW5kbGVkIGFmdGVyIHRoZSBjaGFuZ2UgaXRlbSBpcyB0cmFuc2Zvcm1lZCBieSBvdGhlciBjaGFuZ2VzLgogICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IGluYy5ob3dNYW55OwoKICAgICAgdmFyIF9pdGVyYXRvcjEwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY2hhbmdlcyksCiAgICAgICAgICBfc3RlcDEwOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjEwLnMoKTsgIShfc3RlcDEwID0gX2l0ZXJhdG9yMTAubigpKS5kb25lOykgewogICAgICAgICAgdmFyIG9sZCA9IF9zdGVwMTAudmFsdWU7CiAgICAgICAgICB2YXIgaW5jRW5kID0gaW5jLm9mZnNldCArIGluYy5ob3dNYW55OwogICAgICAgICAgdmFyIG9sZEVuZCA9IG9sZC5vZmZzZXQgKyBvbGQuaG93TWFueTsKCiAgICAgICAgICBpZiAoaW5jLnR5cGUgPT0gJ2luc2VydCcpIHsKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdpbnNlcnQnKSB7CiAgICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPD0gb2xkLm9mZnNldCkgewogICAgICAgICAgICAgICAgb2xkLm9mZnNldCArPSBpbmMuaG93TWFueTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPCBvbGRFbmQpIHsKICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55ICs9IGluYy5ub2Rlc1RvSGFuZGxlOwogICAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdyZW1vdmUnKSB7CiAgICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPCBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgICAgICBvbGQub2Zmc2V0ICs9IGluYy5ob3dNYW55OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPD0gb2xkLm9mZnNldCkgewogICAgICAgICAgICAgICAgb2xkLm9mZnNldCArPSBpbmMuaG93TWFueTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPCBvbGRFbmQpIHsKICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FzZSBpcyBtb3JlIGNvbXBsaWNhdGVkLCBiZWNhdXNlIGF0dHJpYnV0ZSBjaGFuZ2UgaGFzIHRvIGJlIHNwbGl0IGludG8gdHdvLgogICAgICAgICAgICAgICAgLy8gRXhhbXBsZSAoYXNzdW1lIHRoYXQgdXBwZXJjYXNlIGFuZCBsb3dlcmNhc2UgbGV0dGVycyBtZWFuIGRpZmZlcmVudCBhdHRyaWJ1dGVzKToKICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHN0YXRlOgkJYWJjeHl6CiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgY2hhbmdlOglhQkNYWXoKICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGluc2VydDoJCWFCQ2Zvb1hZegogICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgIC8vIENoYW5nZSByYW5nZXMgY2Fubm90IGludGVyc2VjdCBiZWNhdXNlIGVhY2ggaXRlbSBoYXMgdG8gYmUgZGVzY3JpYmVkIGV4YWN0bHkgKGl0IHdhcyBlaXRoZXIKICAgICAgICAgICAgICAgIC8vIG5vdCBjaGFuZ2VkLCBpbnNlcnRlZCwgcmVtb3ZlZCwgb3IgaXRzIGF0dHJpYnV0ZSB3YXMgY2hhbmdlZCkuIFRoYXQncyB3aHkgb2xkIGF0dHJpYnV0ZQogICAgICAgICAgICAgICAgLy8gY2hhbmdlIGhhcyB0byBiZSBzcGxpdCBhbmQgYm90aCBwYXJ0cyBoYXMgdG8gYmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGZyb20gbm93IG9uLgogICAgICAgICAgICAgICAgdmFyIGhvd01hbnkgPSBvbGQuaG93TWFueTsKICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55ID0gaW5jLm9mZnNldCAtIG9sZC5vZmZzZXQ7IC8vIEFkZCB0aGUgc2Vjb25kIHBhcnQgb2YgYXR0cmlidXRlIGNoYW5nZSB0byB0aGUgYmVnaW5uaW5nIG9mIHByb2Nlc3NlZCBhcnJheSBzbyBpdCB3b24ndAogICAgICAgICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFnYWluIGluIHRoaXMgbG9vcC4KCiAgICAgICAgICAgICAgICBjaGFuZ2VzLnVuc2hpZnQoewogICAgICAgICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBpbmNFbmQsCiAgICAgICAgICAgICAgICAgIGhvd01hbnk6IGhvd01hbnkgLSBvbGQuaG93TWFueSwKICAgICAgICAgICAgICAgICAgY291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGlmIChpbmMudHlwZSA9PSAncmVtb3ZlJykgewogICAgICAgICAgICBpZiAob2xkLnR5cGUgPT0gJ2luc2VydCcpIHsKICAgICAgICAgICAgICBpZiAoaW5jRW5kIDw9IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgIG9sZC5vZmZzZXQgLT0gaW5jLmhvd01hbnk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmNFbmQgPD0gb2xkRW5kKSB7CiAgICAgICAgICAgICAgICBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbkxlbmd0aCA9IGluY0VuZCAtIG9sZC5vZmZzZXQ7CiAgICAgICAgICAgICAgICAgIG9sZC5vZmZzZXQgPSBpbmMub2Zmc2V0OwogICAgICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBpbnRlcnNlY3Rpb25MZW5ndGg7CiAgICAgICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlIC09IGludGVyc2VjdGlvbkxlbmd0aDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55IC09IGluYy5ub2Rlc1RvSGFuZGxlOwogICAgICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmIChpbmMub2Zmc2V0IDw9IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgLT0gb2xkLmhvd01hbnk7CiAgICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55ID0gMDsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jLm9mZnNldCA8IG9sZEVuZCkgewogICAgICAgICAgICAgICAgICB2YXIgX2ludGVyc2VjdGlvbkxlbmd0aCA9IG9sZEVuZCAtIGluYy5vZmZzZXQ7CgogICAgICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBfaW50ZXJzZWN0aW9uTGVuZ3RoOwogICAgICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSAtPSBfaW50ZXJzZWN0aW9uTGVuZ3RoOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdyZW1vdmUnKSB7CiAgICAgICAgICAgICAgaWYgKGluY0VuZCA8PSBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgICAgICBvbGQub2Zmc2V0IC09IGluYy5ob3dNYW55OwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlICs9IG9sZC5ob3dNYW55OwogICAgICAgICAgICAgICAgb2xkLmhvd01hbnkgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICAgICAgaWYgKGluY0VuZCA8PSBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgICAgICBvbGQub2Zmc2V0IC09IGluYy5ob3dNYW55OwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgIHZhciBfaW50ZXJzZWN0aW9uTGVuZ3RoMiA9IGluY0VuZCAtIG9sZC5vZmZzZXQ7CgogICAgICAgICAgICAgICAgb2xkLm9mZnNldCA9IGluYy5vZmZzZXQ7CiAgICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBfaW50ZXJzZWN0aW9uTGVuZ3RoMjsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPCBvbGRFbmQpIHsKICAgICAgICAgICAgICAgIGlmIChpbmNFbmQgPD0gb2xkRW5kKSB7CiAgICAgICAgICAgICAgICAgIC8vIE9uIGZpcnN0IHNpZ2h0IGluIHRoaXMgY2FzZSB3ZSBkb24ndCBuZWVkIHRvIHNwbGl0IGF0dHJpYnV0ZSBvcGVyYXRpb24gaW50byB0d28uCiAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhlIGNoYW5nZXMgc2V0IGlzIGxhdGVyIGNvbnZlcnRlZCB0byBhY3Rpb25zIChzZWUgYF9nZW5lcmF0ZUFjdGlvbnNGcm9tQ2hhbmdlc2ApLgogICAgICAgICAgICAgICAgICAvLyBGb3IgdGhhdCByZWFzb24sIG5vIHR3byBjaGFuZ2VzIG1heSBpbnRlcnNlY3QuCiAgICAgICAgICAgICAgICAgIC8vIFNvIHdlIGNhbm5vdCBoYXZlIGFuIGF0dHJpYnV0ZSBjaGFuZ2UgdGhhdCAiY29udGFpbnMiIHJlbW92ZSBjaGFuZ2UuCiAgICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBjaGFuZ2UgbmVlZHMgdG8gYmUgc3BsaXQuCiAgICAgICAgICAgICAgICAgIHZhciBfaG93TWFueSA9IG9sZC5ob3dNYW55OwogICAgICAgICAgICAgICAgICBvbGQuaG93TWFueSA9IGluYy5vZmZzZXQgLSBvbGQub2Zmc2V0OwogICAgICAgICAgICAgICAgICB2YXIgaG93TWFueUFmdGVyID0gX2hvd01hbnkgLSBvbGQuaG93TWFueSAtIGluYy5ub2Rlc1RvSGFuZGxlOyAvLyBBZGQgdGhlIHNlY29uZCBwYXJ0IG9mIGF0dHJpYnV0ZSBjaGFuZ2UgdG8gdGhlIGJlZ2lubmluZyBvZiBwcm9jZXNzZWQgYXJyYXkgc28gaXQgd29uJ3QKICAgICAgICAgICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFnYWluIGluIHRoaXMgbG9vcC4KCiAgICAgICAgICAgICAgICAgIGNoYW5nZXMudW5zaGlmdCh7CiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F0dHJpYnV0ZScsCiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBpbmMub2Zmc2V0LAogICAgICAgICAgICAgICAgICAgIGhvd01hbnk6IGhvd01hbnlBZnRlciwKICAgICAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55IC09IG9sZEVuZCAtIGluYy5vZmZzZXQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGluYy50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYXR0cmlidXRlIGNoYW5nZSwgYGhvd01hbnlgIHNob3VsZCBiZSBrZXB0IHNhbWUgYXMgYG5vZGVzVG9IYW5kbGVgLiBJdCdzIG5vdCBhbiBlcnJvci4KICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdpbnNlcnQnKSB7CiAgICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPCBvbGQub2Zmc2V0ICYmIGluY0VuZCA+IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgIGlmIChpbmNFbmQgPiBvbGRFbmQpIHsKICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYXNlIGlzIHNpbWlsYXIgdG8gYSBjYXNlIGRlc2NyaWJlZCB3aGVuIGluY29taW5nIGNoYW5nZSB3YXMgaW5zZXJ0IGFuZCBvbGQgY2hhbmdlIHdhcyBhdHRyaWJ1dGUuCiAgICAgICAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlLgogICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICAvLyBUaGlzIHRpbWUgaW5jb21pbmcgY2hhbmdlIGlzIGF0dHJpYnV0ZS4gV2UgbmVlZCB0byBzcGxpdCBpbmNvbWluZyBjaGFuZ2UgaW4gdGhpcyBjYXNlIHRvby4KICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciB0aGlzIHRpbWUsIHRoZSBzZWNvbmQgcGFydCBvZiB0aGUgYXR0cmlidXRlIGNoYW5nZSBuZWVkcyB0byBiZSBwcm9jZXNzZWQgZnVydGhlcgogICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIG90aGVyIGNoYW5nZXMgdGhhdCBpdCBjb2xsaWRlcyB3aXRoLgogICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlUGFydCA9IHsKICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9sZEVuZCwKICAgICAgICAgICAgICAgICAgICBob3dNYW55OiBpbmNFbmQgLSBvbGRFbmQsCiAgICAgICAgICAgICAgICAgICAgY291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNoYW5nZShhdHRyaWJ1dGVQYXJ0LCBjaGFuZ2VzKTsKCiAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChhdHRyaWJ1dGVQYXJ0KTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IG9sZC5vZmZzZXQgLSBpbmMub2Zmc2V0OwogICAgICAgICAgICAgICAgaW5jLmhvd01hbnkgPSBpbmMubm9kZXNUb0hhbmRsZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPj0gb2xkLm9mZnNldCAmJiBpbmMub2Zmc2V0IDwgb2xkRW5kKSB7CiAgICAgICAgICAgICAgICBpZiAoaW5jRW5kID4gb2xkRW5kKSB7CiAgICAgICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlID0gaW5jRW5kIC0gb2xkRW5kOwogICAgICAgICAgICAgICAgICBpbmMub2Zmc2V0ID0gb2xkRW5kOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdyZW1vdmUnKSB7CiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNhc2Ugd2hlbiBhdHRyaWJ1dGUgY2hhbmdlICJjb250YWlucyIgcmVtb3ZlIGNoYW5nZS4KICAgICAgICAgICAgICAvLyBUaGUgYXR0cmlidXRlIGNoYW5nZSBuZWVkcyB0byBiZSBzcGxpdCBpbnRvIHR3byBiZWNhdXNlIGNoYW5nZXMgY2Fubm90IGludGVyc2VjdC4KICAgICAgICAgICAgICBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQgJiYgaW5jRW5kID4gb2xkLm9mZnNldCkgewogICAgICAgICAgICAgICAgdmFyIF9hdHRyaWJ1dGVQYXJ0ID0gewogICAgICAgICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvbGQub2Zmc2V0LAogICAgICAgICAgICAgICAgICBob3dNYW55OiBpbmNFbmQgLSBvbGQub2Zmc2V0LAogICAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UoX2F0dHJpYnV0ZVBhcnQsIGNoYW5nZXMpOwoKICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChfYXR0cmlidXRlUGFydCk7CiAgICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IG9sZC5vZmZzZXQgLSBpbmMub2Zmc2V0OwogICAgICAgICAgICAgICAgaW5jLmhvd01hbnkgPSBpbmMubm9kZXNUb0hhbmRsZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChvbGQudHlwZSA9PSAnYXR0cmlidXRlJykgewogICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBvbmx5IHR3byBjb25mbGljdGluZyBzY2VuYXJpb3MgcG9zc2libGUgaGVyZToKICAgICAgICAgICAgICBpZiAoaW5jLm9mZnNldCA+PSBvbGQub2Zmc2V0ICYmIGluY0VuZCA8PSBvbGRFbmQpIHsKICAgICAgICAgICAgICAgIC8vIGBvbGRgIGNoYW5nZSBpbmNsdWRlcyBgaW5jYCBjaGFuZ2UsIG9yIHRoZXkgYXJlIHRoZSBzYW1lLgogICAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgPSAwOwogICAgICAgICAgICAgICAgaW5jLmhvd01hbnkgPSAwOwogICAgICAgICAgICAgICAgaW5jLm9mZnNldCA9IDA7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmMub2Zmc2V0IDw9IG9sZC5vZmZzZXQgJiYgaW5jRW5kID49IG9sZEVuZCkgewogICAgICAgICAgICAgICAgLy8gYGluY2AgY2hhbmdlIGluY2x1ZGVzIGBvbGRgIGNoYW5nZS4KICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55ID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjEwLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IxMC5mKCk7CiAgICAgIH0KCiAgICAgIGluYy5ob3dNYW55ID0gaW5jLm5vZGVzVG9IYW5kbGU7CiAgICAgIGRlbGV0ZSBpbmMubm9kZXNUb0hhbmRsZTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBpbnNlcnQgY2hhbmdlIGRlc2NyaXB0aW9uLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQgVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNoYW5nZSBoYXBwZW5lZC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCBjaGFuZ2UgaGFwcGVuZWQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50IG9yIGAnJHRleHQnYCBmb3IgYSBjaGFyYWN0ZXIuCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGlmZiBpdGVtLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRJbnNlcnREaWZmIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5zZXJ0RGlmZihwYXJlbnQsIG9mZnNldCwgbmFtZSkgewogICAgICByZXR1cm4gewogICAgICAgIHR5cGU6ICdpbnNlcnQnLAogICAgICAgIHBvc2l0aW9uOiBQb3NpdGlvbi5fY3JlYXRlQXQocGFyZW50LCBvZmZzZXQpLAogICAgICAgIG5hbWU6IG5hbWUsCiAgICAgICAgbGVuZ3RoOiAxLAogICAgICAgIGNoYW5nZUNvdW50OiB0aGlzLl9jaGFuZ2VDb3VudCsrCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUgcmVtb3ZlIGNoYW5nZSBkZXNjcmlwdGlvbi4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gcGFyZW50IFRoZSBlbGVtZW50IGluIHdoaWNoIGNoYW5nZSBoYXBwZW5lZC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCBjaGFuZ2UgaGFwcGVuZWQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50IG9yIGAnJHRleHQnYCBmb3IgYSBjaGFyYWN0ZXIuCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGlmZiBpdGVtLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRSZW1vdmVEaWZmIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UmVtb3ZlRGlmZihwYXJlbnQsIG9mZnNldCwgbmFtZSkgewogICAgICByZXR1cm4gewogICAgICAgIHR5cGU6ICdyZW1vdmUnLAogICAgICAgIHBvc2l0aW9uOiBQb3NpdGlvbi5fY3JlYXRlQXQocGFyZW50LCBvZmZzZXQpLAogICAgICAgIG5hbWU6IG5hbWUsCiAgICAgICAgbGVuZ3RoOiAxLAogICAgICAgIGNoYW5nZUNvdW50OiB0aGlzLl9jaGFuZ2VDb3VudCsrCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aGVyZSBlYWNoIG9uZSBpcyBhIHNpbmdsZSBhdHRyaWJ1dGUgY2hhbmdlIGRlc2NyaXB0aW9uLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlIFRoZSByYW5nZSB3aGVyZSB0aGUgY2hhbmdlIGhhcHBlbmVkLgogICAgICogQHBhcmFtIHtNYXB9IG9sZEF0dHJpYnV0ZXMgQSBtYXAsIG1hcCBpdGVyYXRvciBvciBjb21wYXRpYmxlIG9iamVjdCB0aGF0IGNvbnRhaW5zIGF0dHJpYnV0ZXMgYmVmb3JlIHRoZSBjaGFuZ2UuCiAgICAgKiBAcGFyYW0ge01hcH0gbmV3QXR0cmlidXRlcyBBIG1hcCwgbWFwIGl0ZXJhdG9yIG9yIGNvbXBhdGlibGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYXR0cmlidXRlcyBhZnRlciB0aGUgY2hhbmdlLgogICAgICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fSBBbiBhcnJheSBjb250YWluaW5nIG9uZSBvciBtb3JlIGRpZmYgaXRlbXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldEF0dHJpYnV0ZXNEaWZmIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QXR0cmlidXRlc0RpZmYocmFuZ2UsIG9sZEF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpIHsKICAgICAgLy8gUmVzdWx0cyBob2xkZXIuCiAgICAgIHZhciBkaWZmcyA9IFtdOyAvLyBDbG9uZSBuZXcgYXR0cmlidXRlcyBhcyB3ZSB3aWxsIGJlIHBlcmZvcm1pbmcgY2hhbmdlcyBvbiB0aGlzIG9iamVjdC4KCiAgICAgIG5ld0F0dHJpYnV0ZXMgPSBuZXcgTWFwKG5ld0F0dHJpYnV0ZXMpOyAvLyBMb29rIHRocm91Z2ggb2xkIGF0dHJpYnV0ZXMuCgogICAgICB2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvbGRBdHRyaWJ1dGVzKSwKICAgICAgICAgIF9zdGVwMTE7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMTEucygpOyAhKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgX3N0ZXAxMSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMTEudmFsdWUsIDIpLAogICAgICAgICAgICAgIGtleSA9IF9zdGVwMTEkdmFsdWVbMF0sCiAgICAgICAgICAgICAgb2xkVmFsdWUgPSBfc3RlcDExJHZhbHVlWzFdOwoKICAgICAgICAgIC8vIENoZWNrIHdoYXQgaXMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIChvciBpZiBpdCB3YXMgcmVtb3ZlZCkuCiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBuZXdBdHRyaWJ1dGVzLmhhcyhrZXkpID8gbmV3QXR0cmlidXRlcy5nZXQoa2V5KSA6IG51bGw7IC8vIElmIHZhbHVlcyBhcmUgZGlmZmVyZW50IChvciBhdHRyaWJ1dGUgd2FzIHJlbW92ZWQpLi4uCgogICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkgewogICAgICAgICAgICAvLyBBZGQgZGlmZiBpdGVtLgogICAgICAgICAgICBkaWZmcy5wdXNoKHsKICAgICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgICBwb3NpdGlvbjogcmFuZ2Uuc3RhcnQsCiAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLmNsb25lKCksCiAgICAgICAgICAgICAgbGVuZ3RoOiAxLAogICAgICAgICAgICAgIGF0dHJpYnV0ZUtleToga2V5LAogICAgICAgICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiBvbGRWYWx1ZSwKICAgICAgICAgICAgICBhdHRyaWJ1dGVOZXdWYWx1ZTogbmV3VmFsdWUsCiAgICAgICAgICAgICAgY2hhbmdlQ291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IC8vIFByZXZlbnQgcmV0dXJuaW5nIHR3byBkaWZmIGl0ZW1zIGZvciB0aGUgc2FtZSBjaGFuZ2UuCgoKICAgICAgICAgIG5ld0F0dHJpYnV0ZXMuZGVsZXRlKGtleSk7CiAgICAgICAgfSAvLyBMb29rIHRocm91Z2ggbmV3IGF0dHJpYnV0ZXMgdGhhdCB3ZXJlbid0IGhhbmRsZWQgYWJvdmUuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IxMS5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMTEuZigpOwogICAgICB9CgogICAgICB2YXIgX2l0ZXJhdG9yMTIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihuZXdBdHRyaWJ1dGVzKSwKICAgICAgICAgIF9zdGVwMTI7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMTIucygpOyAhKF9zdGVwMTIgPSBfaXRlcmF0b3IxMi5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgX3N0ZXAxMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMTIudmFsdWUsIDIpLAogICAgICAgICAgICAgIF9rZXkgPSBfc3RlcDEyJHZhbHVlWzBdLAogICAgICAgICAgICAgIF9uZXdWYWx1ZSA9IF9zdGVwMTIkdmFsdWVbMV07CgogICAgICAgICAgLy8gRWFjaCBvZiB0aGVtIGlzIGEgbmV3IGF0dHJpYnV0ZS4gQWRkIGRpZmYgaXRlbS4KICAgICAgICAgIGRpZmZzLnB1c2goewogICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgcG9zaXRpb246IHJhbmdlLnN0YXJ0LAogICAgICAgICAgICByYW5nZTogcmFuZ2UuY2xvbmUoKSwKICAgICAgICAgICAgbGVuZ3RoOiAxLAogICAgICAgICAgICBhdHRyaWJ1dGVLZXk6IF9rZXksCiAgICAgICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiBudWxsLAogICAgICAgICAgICBhdHRyaWJ1dGVOZXdWYWx1ZTogX25ld1ZhbHVlLAogICAgICAgICAgICBjaGFuZ2VDb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IxMi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMTIuZigpOwogICAgICB9CgogICAgICByZXR1cm4gZGlmZnM7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIGVsZW1lbnQgb3IgYW55IG9mIGl0cyBwYXJlbnRzIGlzIGFuIGVsZW1lbnQgdGhhdCBpcyBidWZmZXJlZCBhcyBhbiBpbnNlcnRlZCBlbGVtZW50LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfaXNJbkluc2VydGVkRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzSW5JbnNlcnRlZEVsZW1lbnQoZWxlbWVudCkgewogICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQ7CgogICAgICBpZiAoIXBhcmVudCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LmdldChwYXJlbnQpOwoKICAgICAgdmFyIG9mZnNldCA9IGVsZW1lbnQuc3RhcnRPZmZzZXQ7CgogICAgICBpZiAoY2hhbmdlcykgewogICAgICAgIHZhciBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNoYW5nZXMpLAogICAgICAgICAgICBfc3RlcDEzOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3IxMy5zKCk7ICEoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIGNoYW5nZSA9IF9zdGVwMTMudmFsdWU7CgogICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT0gJ2luc2VydCcgJiYgb2Zmc2V0ID49IGNoYW5nZS5vZmZzZXQgJiYgb2Zmc2V0IDwgY2hhbmdlLm9mZnNldCArIGNoYW5nZS5ob3dNYW55KSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjEzLmUoZXJyKTsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgX2l0ZXJhdG9yMTMuZigpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQocGFyZW50KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBkZWVwbHkgYWxsIGJ1ZmZlcmVkIGNoYW5nZXMgdGhhdCBhcmUgcmVnaXN0ZXJlZCBpbiBlbGVtZW50cyBmcm9tIHJhbmdlIHNwZWNpZmllZCBieSBgcGFyZW50YCwgYG9mZnNldGAKICAgICAqIGFuZCBgaG93TWFueWAuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudAogICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcmVtb3ZlQWxsTmVzdGVkQ2hhbmdlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUFsbE5lc3RlZENoYW5nZXMocGFyZW50LCBvZmZzZXQsIGhvd01hbnkpIHsKICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKFBvc2l0aW9uLl9jcmVhdGVBdChwYXJlbnQsIG9mZnNldCksIFBvc2l0aW9uLl9jcmVhdGVBdChwYXJlbnQsIG9mZnNldCArIGhvd01hbnkpKTsKCiAgICAgIHZhciBfaXRlcmF0b3IxNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJhbmdlLmdldEl0ZW1zKHsKICAgICAgICBzaGFsbG93OiB0cnVlCiAgICAgIH0pKSwKICAgICAgICAgIF9zdGVwMTQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMTQucygpOyAhKF9zdGVwMTQgPSBfaXRlcmF0b3IxNC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwMTQudmFsdWU7CgogICAgICAgICAgaWYgKGl0ZW0uaXMoJ2VsZW1lbnQnKSkgewogICAgICAgICAgICB0aGlzLl9lbGVtZW50U25hcHNob3RzLmRlbGV0ZShpdGVtKTsKCiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNJbkVsZW1lbnQuZGVsZXRlKGl0ZW0pOwoKICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsTmVzdGVkQ2hhbmdlcyhpdGVtLCAwLCBpdGVtLm1heE9mZnNldCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IxNC5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMTQuZigpOwogICAgICB9CiAgICB9CiAgfV0pOwoKICByZXR1cm4gRGlmZmVyOwp9KCk7IC8vIFJldHVybnMgYW4gYXJyYXkgdGhhdCBpcyBhIGNvcHkgb2YgcGFzc2VkIGNoaWxkIGxpc3Qgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgdGV4dCBub2RlcyBhcmUgc3BsaXQgdG8gb25lIG9yIG1vcmUKLy8gb2JqZWN0cywgZWFjaCByZXByZXNlbnRpbmcgb25lIGNoYXJhY3RlciBhbmQgYXR0cmlidXRlcyBzZXQgb24gdGhhdCBjaGFyYWN0ZXIuCgoKZXhwb3J0IHsgRGlmZmVyIGFzIGRlZmF1bHQgfTsKCmZ1bmN0aW9uIF9nZXRDaGlsZHJlblNuYXBzaG90KGNoaWxkcmVuKSB7CiAgdmFyIHNuYXBzaG90ID0gW107CgogIHZhciBfaXRlcmF0b3IxNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNoaWxkcmVuKSwKICAgICAgX3N0ZXAxNTsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMTUucygpOyAhKF9zdGVwMTUgPSBfaXRlcmF0b3IxNS5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBjaGlsZCA9IF9zdGVwMTUudmFsdWU7CgogICAgICBpZiAoY2hpbGQuaXMoJyR0ZXh0JykpIHsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmRhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHNuYXBzaG90LnB1c2goewogICAgICAgICAgICBuYW1lOiAnJHRleHQnLAogICAgICAgICAgICBhdHRyaWJ1dGVzOiBuZXcgTWFwKGNoaWxkLmdldEF0dHJpYnV0ZXMoKSkKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBzbmFwc2hvdC5wdXNoKHsKICAgICAgICAgIG5hbWU6IGNoaWxkLm5hbWUsCiAgICAgICAgICBhdHRyaWJ1dGVzOiBuZXcgTWFwKGNoaWxkLmdldEF0dHJpYnV0ZXMoKSkKICAgICAgICB9KTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMTUuZShlcnIpOwogIH0gZmluYWxseSB7CiAgICBfaXRlcmF0b3IxNS5mKCk7CiAgfQoKICByZXR1cm4gc25hcHNob3Q7Cn0gLy8gR2VuZXJhdGVzIGFycmF5IG9mIGFjdGlvbnMgZm9yIGdpdmVuIGNoYW5nZXMgc2V0LgovLyBJdCBzaW11bGF0ZXMgd2hhdCBgZGlmZmAgZnVuY3Rpb24gZG9lcy4KLy8gR2VuZXJhdGVkIGFjdGlvbnMgYXJlOgovLyAtICdlJyBmb3IgJ2VxdWFsJyAtIHdoZW4gaXRlbSBhdCB0aGF0IHBvc2l0aW9uIGRpZCBub3QgY2hhbmdlLAovLyAtICdpJyBmb3IgJ2luc2VydCcgLSB3aGVuIGl0ZW0gYXQgdGhhdCBwb3NpdGlvbiB3YXMgaW5zZXJ0ZWQsCi8vIC0gJ3InIGZvciAncmVtb3ZlJyAtIHdoZW4gaXRlbSBhdCB0aGF0IHBvc2l0aW9uIHdhcyByZW1vdmVkLAovLyAtICdhJyBmb3IgJ2F0dHJpYnV0ZScgLSB3aGVuIGl0ZW0gYXQgdGhhdCBwb3NpdGlvbiBoYXMgaXQgYXR0cmlidXRlcyBjaGFuZ2VkLgovLwovLyBFeGFtcGxlIChhc3N1bWUgdGhhdCB1cHBlcmNhc2UgbGV0dGVycyBoYXZlIGJvbGQgYXR0cmlidXRlLCBjb21wYXJlIHdpdGggZnVuY3Rpb24gY29kZSk6Ci8vCi8vIGNoaWxkcmVuIGJlZm9yZToJZm9vQkFSCi8vIGNoaWxkcmVuIGFmdGVyOglmb3h5YkFSCi8vCi8vIGNoYW5nZXM6IHR5cGU6IHJlbW92ZSwgb2Zmc2V0OiAxLCBob3dNYW55OiAxCi8vCQkJdHlwZTogaW5zZXJ0LCBvZmZzZXQ6IDIsIGhvd01hbnk6IDIKLy8JCQl0eXBlOiBhdHRyaWJ1dGUsIG9mZnNldDogNCwgaG93TWFueTogMQovLwovLyBleHBlY3RlZCBhY3Rpb25zOiBlcXVhbCAoZiksIHJlbW92ZSAobyksIGVxdWFsIChvKSwgaW5zZXJ0ICh4KSwgaW5zZXJ0ICh5KSwgYXR0cmlidXRlIChiKSwgZXF1YWwgKEEpLCBlcXVhbCAoUikKLy8KLy8gc3RlcHMgdGFrZW4gYnkgdGggc2NyaXB0OgovLwovLyAxLiBjaGFuZ2UgPSAidHlwZTogcmVtb3ZlLCBvZmZzZXQ6IDEsIGhvd01hbnk6IDEiOyBvZmZzZXQgPSAwOyBvbGRDaGlsZHJlbkhhbmRsZWQgPSAwCi8vICAgIDEuMSBiZXR3ZWVuIHRoaXMgY2hhbmdlIGFuZCB0aGUgYmVnaW5uaW5nIGlzIG9uZSBub3QtY2hhbmdlZCBub2RlLCBmaWxsIHdpdGggb25lIGVxdWFsIGFjdGlvbiwgb25lIG9sZCBjaGlsZCBoYXMgYmVlbiBoYW5kbGVkCi8vICAgIDEuMiB0aGlzIGNoYW5nZSByZW1vdmVzIG9uZSBub2RlLCBhZGQgb25lIHJlbW92ZSBhY3Rpb24KLy8gICAgMS4zIGNoYW5nZSBsYXN0IHZpc2l0ZWQgYG9mZnNldGAgdG8gMQovLyAgICAxLjQgc2luY2UgYW4gb2xkIGNoaWxkIGhhcyBiZWVuIHJlbW92ZWQsIG9uZSBtb3JlIG9sZCBjaGlsZCBoYXMgYmVlbiBoYW5kbGVkCi8vICAgIDEuNSBhY3Rpb25zIGF0IHRoaXMgcG9pbnQgYXJlOiBlcXVhbCwgcmVtb3ZlCi8vCi8vIDIuIGNoYW5nZSA9ICJ0eXBlOiBpbnNlcnQsIG9mZnNldDogMiwgaG93TWFueTogMiI7IG9mZnNldCA9IDE7IG9sZENoaWxkcmVuSGFuZGxlZCA9IDIKLy8gICAgMi4xIGJldHdlZW4gdGhpcyBjaGFuZ2UgYW5kIHByZXZpb3VzIGNoYW5nZSBpcyBvbmUgbm90LWNoYW5nZWQgbm9kZSwgYWRkIGVxdWFsIGFjdGlvbiwgYW5vdGhlciBvbmUgb2xkIGNoaWxkcmVuIGhhcyBiZWVuIGhhbmRsZWQKLy8gICAgMi4yIHRoaXMgY2hhbmdlIGluc2VydHMgdHdvIG5vZGVzLCBhZGQgdHdvIGluc2VydCBhY3Rpb25zCi8vICAgIDIuMyBjaGFuZ2UgbGFzdCB2aXNpdGVkIG9mZnNldCB0byB0aGUgZW5kIG9mIHRoZSBpbnNlcnRlZCByYW5nZSwgdGhhdCBpcyA0Ci8vICAgIDIuNCBhY3Rpb25zIGF0IHRoaXMgcG9pbnQgYXJlOiBlcXVhbCwgcmVtb3ZlLCBlcXVhbCwgaW5zZXJ0LCBpbnNlcnQKLy8KLy8gMy4gY2hhbmdlID0gInR5cGU6IGF0dHJpYnV0ZSwgb2Zmc2V0OiA0LCBob3dNYW55OiAxIjsgb2Zmc2V0ID0gNCwgb2xkQ2hpbGRyZW5IYW5kbGVkID0gMwovLyAgICAzLjEgYmV0d2VlbiB0aGlzIGNoYW5nZSBhbmQgcHJldmlvdXMgY2hhbmdlIGFyZSBubyBub3QtY2hhbmdlZCBub2RlcwovLyAgICAzLjIgdGhpcyBjaGFuZ2UgY2hhbmdlcyBvbmUgbm9kZSwgYWRkIG9uZSBhdHRyaWJ1dGUgYWN0aW9uCi8vICAgIDMuMyBjaGFuZ2UgbGFzdCB2aXNpdGVkIGBvZmZzZXRgIHRvIHRoZSBlbmQgb2YgY2hhbmdlIHJhbmdlLCB0aGF0IGlzIDUKLy8gICAgMy40IHNpbmNlIGFuIG9sZCBjaGlsZCBoYXMgYmVlbiBjaGFuZ2VkLCBvbmUgbW9yZSBvbGQgY2hpbGQgaGFzIGJlZW4gaGFuZGxlZAovLyAgICAzLjUgYWN0aW9ucyBhdCB0aGlzIHBvaW50IGFyZTogZXF1YWwsIHJlbW92ZSwgZXF1YWwsIGluc2VydCwgaW5zZXJ0LCBhdHRyaWJ1dGUKLy8KLy8gNC4gYWZ0ZXIgbG9vcCBvbGRDaGlsZHJlbkhhbmRsZWQgPSA0LCBvbGRDaGlsZHJlbkxlbmd0aCA9IDYgKGZvb0JBUiBpcyA2IGNoYXJhY3RlcnMpCi8vICAgIDQuMSBmaWxsIHVwIHdpdGggdHdvIGVxdWFsIGFjdGlvbnMKLy8KLy8gVGhlIHJlc3VsdCBhY3Rpb25zIGFyZTogZXF1YWwsIHJlbW92ZSwgZXF1YWwsIGluc2VydCwgaW5zZXJ0LCBhdHRyaWJ1dGUsIGVxdWFsLCBlcXVhbC4KCgpmdW5jdGlvbiBfZ2VuZXJhdGVBY3Rpb25zRnJvbUNoYW5nZXMob2xkQ2hpbGRyZW5MZW5ndGgsIGNoYW5nZXMpIHsKICB2YXIgYWN0aW9ucyA9IFtdOwogIHZhciBvZmZzZXQgPSAwOwogIHZhciBvbGRDaGlsZHJlbkhhbmRsZWQgPSAwOyAvLyBHbyB0aHJvdWdoIGFsbCBidWZmZXJlZCBjaGFuZ2VzLgoKICB2YXIgX2l0ZXJhdG9yMTYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjaGFuZ2VzKSwKICAgICAgX3N0ZXAxNjsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMTYucygpOyAhKF9zdGVwMTYgPSBfaXRlcmF0b3IxNi5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBjaGFuZ2UgPSBfc3RlcDE2LnZhbHVlOwoKICAgICAgLy8gRmlyc3QsIGZpbGwgImhvbGVzIiBiZXR3ZWVuIGNoYW5nZXMgd2l0aCAiZXF1YWwiIGFjdGlvbnMuCiAgICAgIGlmIChjaGFuZ2Uub2Zmc2V0ID4gb2Zmc2V0KSB7CiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2hhbmdlLm9mZnNldCAtIG9mZnNldDsgX2kyKyspIHsKICAgICAgICAgIGFjdGlvbnMucHVzaCgnZScpOwogICAgICAgIH0KCiAgICAgICAgb2xkQ2hpbGRyZW5IYW5kbGVkICs9IGNoYW5nZS5vZmZzZXQgLSBvZmZzZXQ7CiAgICAgIH0gLy8gVGhlbiwgZmlsbCB1cCBhY3Rpb25zIGFjY29yZGluZ2x5IHRvIGNoYW5nZSB0eXBlLgoKCiAgICAgIGlmIChjaGFuZ2UudHlwZSA9PSAnaW5zZXJ0JykgewogICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGNoYW5nZS5ob3dNYW55OyBfaTMrKykgewogICAgICAgICAgYWN0aW9ucy5wdXNoKCdpJyk7CiAgICAgICAgfSAvLyBUaGUgbGFzdCBoYW5kbGVkIG9mZnNldCBpcyBhZnRlciBpbnNlcnRlZCByYW5nZS4KCgogICAgICAgIG9mZnNldCA9IGNoYW5nZS5vZmZzZXQgKyBjaGFuZ2UuaG93TWFueTsKICAgICAgfSBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PSAncmVtb3ZlJykgewogICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGNoYW5nZS5ob3dNYW55OyBfaTQrKykgewogICAgICAgICAgYWN0aW9ucy5wdXNoKCdyJyk7CiAgICAgICAgfSAvLyBUaGUgbGFzdCBoYW5kbGVkIG9mZnNldCBpcyBhdCB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIG5vZGVzIHdlcmUgcmVtb3ZlZC4KCgogICAgICAgIG9mZnNldCA9IGNoYW5nZS5vZmZzZXQ7IC8vIFdlIHJlbW92ZWQgYGhvd01hbnlgIG9sZCBub2RlcywgdXBkYXRlIGBvbGRDaGlsZHJlbkhhbmRsZWRgLgoKICAgICAgICBvbGRDaGlsZHJlbkhhbmRsZWQgKz0gY2hhbmdlLmhvd01hbnk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYWN0aW9ucy5wdXNoLmFwcGx5KGFjdGlvbnMsIF90b0NvbnN1bWFibGVBcnJheSgnYScucmVwZWF0KGNoYW5nZS5ob3dNYW55KS5zcGxpdCgnJykpKTsgLy8gVGhlIGxhc3QgaGFuZGxlZCBvZmZzZXQgaXMgYXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBjaGFuZ2VkIHJhbmdlLgoKICAgICAgICBvZmZzZXQgPSBjaGFuZ2Uub2Zmc2V0ICsgY2hhbmdlLmhvd01hbnk7IC8vIFdlIGNoYW5nZWQgYGhvd01hbnlgIG9sZCBub2RlcywgdXBkYXRlIGBvbGRDaGlsZHJlbkhhbmRsZWRgLgoKICAgICAgICBvbGRDaGlsZHJlbkhhbmRsZWQgKz0gY2hhbmdlLmhvd01hbnk7CiAgICAgIH0KICAgIH0gLy8gRmlsbCAiZXF1YWwiIGFjdGlvbnMgYXQgdGhlIGVuZCBvZiBhY3Rpb25zIHNldC4gVXNlIGBvbGRDaGlsZHJlbkhhbmRsZWRgIHRvIHNlZSBob3cgbWFueSBjaGlsZHJlbgogICAgLy8gaGFzIG5vdCBiZWVuIGNoYW5nZWQgLyByZW1vdmVkIGF0IHRoZSBlbmQgb2YgdGhlaXIgcGFyZW50LgoKICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjE2LmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yMTYuZigpOwogIH0KCiAgaWYgKG9sZENoaWxkcmVuSGFuZGxlZCA8IG9sZENoaWxkcmVuTGVuZ3RoKSB7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZENoaWxkcmVuTGVuZ3RoIC0gb2xkQ2hpbGRyZW5IYW5kbGVkIC0gb2Zmc2V0OyBpKyspIHsKICAgICAgYWN0aW9ucy5wdXNoKCdlJyk7CiAgICB9CiAgfQoKICByZXR1cm4gYWN0aW9uczsKfSAvLyBGaWx0ZXIgY2FsbGJhY2sgZm9yIEFycmF5LmZpbHRlciB0aGF0IGZpbHRlcnMgb3V0IGNoYW5nZSBlbnRyaWVzIHRoYXQgYXJlIGluIGdyYXZleWFyZC4KCgpmdW5jdGlvbiBfY2hhbmdlc0luR3JhdmV5YXJkRmlsdGVyKGVudHJ5KSB7CiAgdmFyIHBvc0luR3kgPSBlbnRyeS5wb3NpdGlvbiAmJiBlbnRyeS5wb3NpdGlvbi5yb290LnJvb3ROYW1lID09ICckZ3JhdmV5YXJkJzsKICB2YXIgcmFuZ2VJbkd5ID0gZW50cnkucmFuZ2UgJiYgZW50cnkucmFuZ2Uucm9vdC5yb290TmFtZSA9PSAnJGdyYXZleWFyZCc7CiAgcmV0dXJuICFwb3NJbkd5ICYmICFyYW5nZUluR3k7Cn0KLyoqCiAqIFRoZSBzaW5nbGUgZGlmZiBpdGVtLgogKgogKiBDb3VsZCBiZSBvbmUgb2Y6CiAqCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZGlmZmVyfkRpZmZJdGVtSW5zZXJ0IGBEaWZmSXRlbUluc2VydGB9LAogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RpZmZlcn5EaWZmSXRlbVJlbW92ZSBgRGlmZkl0ZW1SZW1vdmVgfSwKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1BdHRyaWJ1dGUgYERpZmZJdGVtQXR0cmlidXRlYH0uCiAqCiAqIEBpbnRlcmZhY2UgRGlmZkl0ZW0KICovCgovKioKICogVGhlIHNpbmdsZSBkaWZmIGl0ZW0gZm9yIGluc2VydGVkIG5vZGVzLgogKgogKiBAY2xhc3MgRGlmZkl0ZW1JbnNlcnQKICogQGltcGxlbWVudHMgbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW0KICovCgovKioKICogVGhlIHR5cGUgb2YgZGlmZiBpdGVtLgogKgogKiBAbWVtYmVyIHsnaW5zZXJ0J30gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1JbnNlcnQjdHlwZQogKi8KCi8qKgogKiBUaGUgbmFtZSBvZiB0aGUgaW5zZXJ0ZWQgZWxlbWVudHMgb3IgYCckdGV4dCdgIGZvciBhIHRleHQgbm9kZS4KICoKICogQG1lbWJlciB7U3RyaW5nfSBtb2R1bGU6ZW5naW5lL21vZGVsL2RpZmZlcn5EaWZmSXRlbUluc2VydCNuYW1lCiAqLwoKLyoqCiAqIFRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgbm9kZSB3YXMgaW5zZXJ0ZWQuCiAqCiAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IG1vZHVsZTplbmdpbmUvbW9kZWwvZGlmZmVyfkRpZmZJdGVtSW5zZXJ0I3Bvc2l0aW9uCiAqLwoKLyoqCiAqIFRoZSBsZW5ndGggb2YgYW4gaW5zZXJ0ZWQgdGV4dCBub2RlLiBGb3IgZWxlbWVudHMgaXQgaXMgYWx3YXlzIDEgYXMgZWFjaCBpbnNlcnRlZCBlbGVtZW50IGlzIGNvdW50ZWQgYXMgYSBvbmUuCiAqCiAqIEBtZW1iZXIge051bWJlcn0gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1JbnNlcnQjbGVuZ3RoCiAqLwoKLyoqCiAqIFRoZSBzaW5nbGUgZGlmZiBpdGVtIGZvciByZW1vdmVkIG5vZGVzLgogKgogKiBAY2xhc3MgRGlmZkl0ZW1SZW1vdmUKICogQGltcGxlbWVudHMgbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW0KICovCgovKioKICogVGhlIHR5cGUgb2YgZGlmZiBpdGVtLgogKgogKiBAbWVtYmVyIHsncmVtb3ZlJ30gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1SZW1vdmUjdHlwZQogKi8KCi8qKgogKiBUaGUgbmFtZSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50IG9yIGAnJHRleHQnYCBmb3IgYSB0ZXh0IG5vZGUuCiAqCiAqIEBtZW1iZXIge1N0cmluZ30gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1SZW1vdmUjbmFtZQogKi8KCi8qKgogKiBUaGUgcG9zaXRpb24gd2hlcmUgdGhlIG5vZGUgd2FzIHJlbW92ZWQuCiAqCiAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IG1vZHVsZTplbmdpbmUvbW9kZWwvZGlmZmVyfkRpZmZJdGVtUmVtb3ZlI3Bvc2l0aW9uCiAqLwoKLyoqCiAqIFRoZSBsZW5ndGggb2YgYSByZW1vdmVkIHRleHQgbm9kZS4gRm9yIGVsZW1lbnRzIGl0IGlzIGFsd2F5cyAxIGFzIGVhY2ggcmVtb3ZlZCBlbGVtZW50IGlzIGNvdW50ZWQgYXMgYSBvbmUuCiAqCiAqIEBtZW1iZXIge051bWJlcn0gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1SZW1vdmUjbGVuZ3RoCiAqLwoKLyoqCiAqIFRoZSBzaW5nbGUgZGlmZiBpdGVtIGZvciBhdHRyaWJ1dGUgY2hhbmdlLgogKgogKiBAY2xhc3MgRGlmZkl0ZW1BdHRyaWJ1dGUKICogQGltcGxlbWVudHMgbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW0KICovCgovKioKICogVGhlIHR5cGUgb2YgZGlmZiBpdGVtLgogKgogKiBAbWVtYmVyIHsnYXR0cmlidXRlJ30gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1BdHRyaWJ1dGUjdHlwZQogKi8KCi8qKgogKiBUaGUgbmFtZSBvZiB0aGUgY2hhbmdlZCBhdHRyaWJ1dGUuCiAqCiAqIEBtZW1iZXIge1N0cmluZ30gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1BdHRyaWJ1dGUjYXR0cmlidXRlS2V5CiAqLwoKLyoqCiAqIEFuIGF0dHJpYnV0ZSBwcmV2aW91cyB2YWx1ZSAoYmVmb3JlIGNoYW5nZSkuCiAqCiAqIEBtZW1iZXIge1N0cmluZ30gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1BdHRyaWJ1dGUjYXR0cmlidXRlT2xkVmFsdWUKICovCgovKioKICogQW4gYXR0cmlidXRlIG5ldyB2YWx1ZSAoYWZ0ZXIgY2hhbmdlKS4KICoKICogQG1lbWJlciB7U3RyaW5nfSBtb2R1bGU6ZW5naW5lL21vZGVsL2RpZmZlcn5EaWZmSXRlbUF0dHJpYnV0ZSNhdHRyaWJ1dGVOZXdWYWx1ZQogKi8KCi8qKgogKiBUaGUgcmFuZ2Ugd2hlcmUgdGhlIGNoYW5nZSBoYXBwZW5lZC4KICoKICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gbW9kdWxlOmVuZ2luZS9tb2RlbC9kaWZmZXJ+RGlmZkl0ZW1BdHRyaWJ1dGUjcmFuZ2UKICov"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js"],"names":["Position","Range","Differ","markerCollection","_markerCollection","_changesInElement","Map","_elementSnapshots","_changedMarkers","_changeCount","_cachedChanges","_cachedChangesWithGraveyard","size","item","_isInInsertedElement","parent","_markRemove","startOffset","offsetSize","_markInsert","range","_createOn","getMarkersIntersectingRange","marker","markerRange","getRange","bufferMarkerChange","name","affectsData","operation","type","position","offset","nodes","maxOffset","getItems","shallow","_markAttribute","sourcePosition","isEqual","targetPosition","getShiftedBy","howMany","sourceParentInserted","targetParentInserted","getMovedRangeStart","_createFromPositionAndShift","splitElement","splitPosition","insertionPosition","graveyardPosition","mergedElement","graveyardParent","mergedIntoElement","markerName","oldRange","newRange","buffered","get","set","delete","result","change","push","Array","from","map","data","options","includeChangesInGraveyard","slice","diffSet","keys","element","changes","sort","a","b","snapshotChildren","elementChildren","_getChildrenSnapshot","getChildren","actions","_generateActionsFromChanges","length","i","j","action","_getInsertDiff","_getRemoveDiff","elementAttributes","attributes","snapshotAttributes","_createAt","index","offsetToIndex","getChild","_getAttributesDiff","root","rootName","changeCount","isBefore","prevIndex","prevDiff","thisDiff","isConsecutiveTextRemove","isConsecutiveTextAdd","isConsecutiveAttributeChange","isFlat","attributeKey","attributeOldValue","attributeNewValue","end","filter","v","_changesInGraveyardFilter","clear","changeItem","count","_markChange","_removeAllNestedChanges","_makeSnapshot","_getChangesForElement","_handleChange","splice","has","inc","nodesToHandle","old","incEnd","oldEnd","unshift","intersectionLength","howManyAfter","attributePart","oldAttributes","newAttributes","diffs","key","oldValue","newValue","start","clone","is","children","snapshot","child","getAttributes","oldChildrenLength","oldChildrenHandled","repeat","split","entry","posInGy","rangeInGy"],"mappings":"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,GAAGD,iBAA1B,EAA8C;AAC7C,SAAM,IAAI/D,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG+D,iBAAiB,GAAGC,kBAApB,GAAyCrH,MAA9D,EAAsEqD,CAAC,EAAvE,EAA4E;AAC3EH,MAAAA,OAAO,CAACnB,IAAR,CAAc,GAAd;AACA;AACD;;AAED,SAAOmB,OAAP;AACA,C,CAED;;;AACA,SAASiC,yBAAT,CAAoCqC,KAApC,EAA4C;AAC3C,MAAMC,OAAO,GAAGD,KAAK,CAACzH,QAAN,IAAkByH,KAAK,CAACzH,QAAN,CAAemE,IAAf,CAAoBC,QAApB,IAAgC,YAAlE;AACA,MAAMuD,SAAS,GAAGF,KAAK,CAACpI,KAAN,IAAeoI,KAAK,CAACpI,KAAN,CAAY8E,IAAZ,CAAiBC,QAAjB,IAA6B,YAA9D;AAEA,SAAO,CAACsD,OAAD,IAAY,CAACC,SAApB;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\n\nimport Position from './position';\nimport Range from './range';\n\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\nexport default class Differ {\n\t/**\n\t * Creates a `Differ` instance.\n\t *\n\t * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n\t */\n\tconstructor( markerCollection ) {\n\t\t/**\n\t\t * Reference to the model's marker collection.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis._markerCollection = markerCollection;\n\n\t\t/**\n\t\t * A map that stores changes that happened in a given element.\n\t\t *\n\t\t * The keys of the map are references to the model elements.\n\t\t * The values of the map are arrays with changes that were done on this element.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changesInElement = new Map();\n\n\t\t/**\n\t\t * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n\t\t * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n\t\t * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._elementSnapshots = new Map();\n\n\t\t/**\n\t\t * A map that stores all changed markers.\n\t\t *\n\t\t * The keys of the map are marker names.\n\t\t * The values of the map are objects with the `oldRange` and `newRange` properties. They store the marker range\n\t\t * state before and after the change.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changedMarkers = new Map();\n\n\t\t/**\n\t\t * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n\t\t * when changes are sorted.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._changeCount = 0;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n\t\t * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores those changes that did not take place in graveyard root.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChanges = null;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n\t\t * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChangesWithGraveyard = null;\n\t}\n\n\t/**\n\t * Informs whether there are any changes buffered in `Differ`.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n\t}\n\n\t/**\n\t * Marks given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted in the differ changes\n\t * set, so it will be effectively re-converted when differ changes will be handled by a dispatcher.\n\t *\n\t * @param {module:engine/model/item~Item} item Item to refresh.\n\t */\n\trefreshItem( item ) {\n\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._markRemove( item.parent, item.startOffset, item.offsetSize );\n\t\tthis._markInsert( item.parent, item.startOffset, item.offsetSize );\n\n\t\tconst range = Range._createOn( item );\n\n\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers the given operation. An operation has to be buffered before it is executed.\n\t *\n\t * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n\t * in the state before the operation is executed.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n\t */\n\tbufferOperation( operation ) {\n\t\t// Below we take an operation, check its type, then use its parameters in marking (private) methods.\n\t\t// The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n\t\t// Marking changes in them would cause a \"double\" changing then.\n\t\t//\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, operation.nodes.maxOffset );\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'addAttribute':\n\t\t\tcase 'removeAttribute':\n\t\t\tcase 'changeAttribute': {\n\t\t\t\tfor ( const item of operation.range.getItems( { shallow: true } ) ) {\n\t\t\t\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._markAttribute( item );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'remove':\n\t\t\tcase 'move':\n\t\t\tcase 'reinsert': {\n\t\t\t\t// When range is moved to the same position then not mark it as a change.\n\t\t\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n\t\t\t\tif (\n\t\t\t\t\toperation.sourcePosition.isEqual( operation.targetPosition ) ||\n\t\t\t\t\toperation.sourcePosition.getShiftedBy( operation.howMany ).isEqual( operation.targetPosition )\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceParentInserted = this._isInInsertedElement( operation.sourcePosition.parent );\n\t\t\t\tconst targetParentInserted = this._isInInsertedElement( operation.targetPosition.parent );\n\n\t\t\t\tif ( !sourceParentInserted ) {\n\t\t\t\t\tthis._markRemove( operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tif ( !targetParentInserted ) {\n\t\t\t\t\tthis._markInsert( operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'rename': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markRemove( operation.position.parent, operation.position.offset, 1 );\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, 1 );\n\n\t\t\t\tconst range = Range._createFromPositionAndShift( operation.position, 1 );\n\n\t\t\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\t\t\tconst markerRange = marker.getRange();\n\n\t\t\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'split': {\n\t\t\t\tconst splitElement = operation.splitPosition.parent;\n\n\t\t\t\t// Mark that children of the split element were removed.\n\t\t\t\tif ( !this._isInInsertedElement( splitElement ) ) {\n\t\t\t\t\tthis._markRemove( splitElement, operation.splitPosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the new element (split copy) was inserted.\n\t\t\t\tif ( !this._isInInsertedElement( operation.insertionPosition.parent ) ) {\n\t\t\t\t\tthis._markInsert( operation.insertionPosition.parent, operation.insertionPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\t\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\t\tthis._markRemove( operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'merge': {\n\t\t\t\t// Mark that the merged element was removed.\n\t\t\t\tconst mergedElement = operation.sourcePosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedElement.parent ) ) {\n\t\t\t\t\tthis._markRemove( mergedElement.parent, mergedElement.startOffset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the merged element was inserted into graveyard.\n\t\t\t\tconst graveyardParent = operation.graveyardPosition.parent;\n\n\t\t\t\tthis._markInsert( graveyardParent, operation.graveyardPosition.offset, 1 );\n\n\t\t\t\t// Mark that children of merged element were inserted at new parent.\n\t\t\t\tconst mergedIntoElement = operation.targetPosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedIntoElement ) ) {\n\t\t\t\t\tthis._markInsert( mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers a marker change.\n\t *\n\t * @param {String} markerName The name of the marker that changed.\n\t * @param {module:engine/model/range~Range|null} oldRange Marker range before the change or `null` if the marker has just\n\t * been created.\n\t * @param {module:engine/model/range~Range|null} newRange Marker range after the change or `null` if the marker was removed.\n\t * @param {Boolean} affectsData Flag indicating whether marker affects the editor data.\n\t */\n\tbufferMarkerChange( markerName, oldRange, newRange, affectsData ) {\n\t\tconst buffered = this._changedMarkers.get( markerName );\n\n\t\tif ( !buffered ) {\n\t\t\tthis._changedMarkers.set( markerName, {\n\t\t\t\toldRange,\n\t\t\t\tnewRange,\n\t\t\t\taffectsData\n\t\t\t} );\n\t\t} else {\n\t\t\tbuffered.newRange = newRange;\n\t\t\tbuffered.affectsData = affectsData;\n\n\t\t\tif ( buffered.oldRange == null && buffered.newRange == null ) {\n\t\t\t\t// The marker is going to be removed (`newRange == null`) but it did not exist before the first buffered change\n\t\t\t\t// (`buffered.oldRange == null`). In this case, do not keep the marker in buffer at all.\n\t\t\t\tthis._changedMarkers.delete( markerName );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all markers that should be removed as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToRemove() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.oldRange != null ) {\n\t\t\t\tresult.push( { name, range: change.oldRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which should be added as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToAdd() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.newRange != null ) {\n\t\t\t\tresult.push( { name, range: change.newRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which changed.\n\t *\n\t * @returns {Array.<Object>}\n\t */\n\tgetChangedMarkers() {\n\t\treturn Array.from( this._changedMarkers ).map( item => (\n\t\t\t{\n\t\t\t\tname: item[ 0 ],\n\t\t\t\tdata: {\n\t\t\t\t\toldRange: item[ 1 ].oldRange,\n\t\t\t\t\tnewRange: item[ 1 ].newRange\n\t\t\t\t}\n\t\t\t}\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether some of the buffered changes affect the editor data.\n\t *\n\t * Types of changes which affect the editor data:\n\t *\n\t * * model structure changes,\n\t * * attribute changes,\n\t * * changes of markers which were defined as `affectingData`.\n\t *\n\t * @returns {Boolean}\n\t */\n\thasDataChanges() {\n\t\tfor ( const [ , change ] of this._changedMarkers ) {\n\t\t\tif ( change.affectsData ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// If markers do not affect the data, check whether there are some changes in elements.\n\t\treturn this._changesInElement.size > 0;\n\t}\n\n\t/**\n\t * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n\t * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n\t *\n\t * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done\n\t * on the model. The items are sorted by the position on which the change happened. If a position\n\t * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.\n\t *\n\t * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.\n\t *\n\t * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n\t * previous {@link #getChanges} call, the next call will return the cached value.\n\t *\n\t * @param {Object} options Additional options.\n\t * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n\t * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n\t * @returns {Array.<module:engine/model/differ~DiffItem>} Diff between the old and the new model tree state.\n\t */\n\tgetChanges( options = { includeChangesInGraveyard: false } ) {\n\t\t// If there are cached changes, just return them instead of calculating changes again.\n\t\tif ( this._cachedChanges ) {\n\t\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\t\treturn this._cachedChangesWithGraveyard.slice();\n\t\t\t} else {\n\t\t\t\treturn this._cachedChanges.slice();\n\t\t\t}\n\t\t}\n\n\t\t// Will contain returned results.\n\t\tlet diffSet = [];\n\n\t\t// Check all changed elements.\n\t\tfor ( const element of this._changesInElement.keys() ) {\n\t\t\t// Get changes for this element and sort them.\n\t\t\tconst changes = this._changesInElement.get( element ).sort( ( a, b ) => {\n\t\t\t\tif ( a.offset === b.offset ) {\n\t\t\t\t\tif ( a.type != b.type ) {\n\t\t\t\t\t\t// If there are multiple changes at the same position, \"remove\" change should be first.\n\t\t\t\t\t\t// If the order is different, for example, we would first add some nodes and then removed them\n\t\t\t\t\t\t// (instead of the nodes that we should remove).\n\t\t\t\t\t\treturn a.type == 'remove' ? -1 : 1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn a.offset < b.offset ? -1 : 1;\n\t\t\t} );\n\n\t\t\t// Get children of this element before any change was applied on it.\n\t\t\tconst snapshotChildren = this._elementSnapshots.get( element );\n\t\t\t// Get snapshot of current element's children.\n\t\t\tconst elementChildren = _getChildrenSnapshot( element.getChildren() );\n\n\t\t\t// Generate actions basing on changes done on element.\n\t\t\tconst actions = _generateActionsFromChanges( snapshotChildren.length, changes );\n\n\t\t\tlet i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\t\t\tlet j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n\n\t\t\t// Process every action.\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'i' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getInsertDiff( element, i, elementChildren[ i ].name ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t} else if ( action === 'r' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getRemoveDiff( element, i, snapshotChildren[ j ].name ) );\n\n\t\t\t\t\tj++;\n\t\t\t\t} else if ( action === 'a' ) {\n\t\t\t\t\t// Take attributes from saved and current children.\n\t\t\t\t\tconst elementAttributes = elementChildren[ i ].attributes;\n\t\t\t\t\tconst snapshotAttributes = snapshotChildren[ j ].attributes;\n\t\t\t\t\tlet range;\n\n\t\t\t\t\tif ( elementChildren[ i ].name == '$text' ) {\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element, i + 1 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index = element.offsetToIndex( i );\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element.getChild( index ), 0 ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Generate diff items for this change (there might be multiple attributes changed and\n\t\t\t\t\t// there is a single diff for each of them) and insert them into the diff set.\n\t\t\t\t\tdiffSet.push( ...this._getAttributesDiff( range, snapshotAttributes, elementAttributes ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\t// `action` is 'equal'. Child not changed.\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Then, sort the changes by the position (change at position before other changes is first).\n\t\tdiffSet.sort( ( a, b ) => {\n\t\t\t// If the change is in different root, we don't care much, but we'd like to have all changes in given\n\t\t\t// root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n\t\t\t// will be processed first.\n\t\t\tif ( a.position.root != b.position.root ) {\n\t\t\t\treturn a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n\t\t\t}\n\n\t\t\t// If change happens at the same position...\n\t\t\tif ( a.position.isEqual( b.position ) ) {\n\t\t\t\t// Keep chronological order of operations.\n\t\t\t\treturn a.changeCount - b.changeCount;\n\t\t\t}\n\n\t\t\t// If positions differ, position \"on the left\" should be earlier in the result.\n\t\t\treturn a.position.isBefore( b.position ) ? -1 : 1;\n\t\t} );\n\n\t\t// Glue together multiple changes (mostly on text nodes).\n\t\tfor ( let i = 1, prevIndex = 0; i < diffSet.length; i++ ) {\n\t\t\tconst prevDiff = diffSet[ prevIndex ];\n\t\t\tconst thisDiff = diffSet[ i ];\n\n\t\t\t// Glue remove changes if they happen on text on same position.\n\t\t\tconst isConsecutiveTextRemove =\n\t\t\t\tprevDiff.type == 'remove' && thisDiff.type == 'remove' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.isEqual( thisDiff.position );\n\n\t\t\t// Glue insert changes if they happen on text on consecutive fragments.\n\t\t\tconst isConsecutiveTextAdd =\n\t\t\t\tprevDiff.type == 'insert' && thisDiff.type == 'insert' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset;\n\n\t\t\t// Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\t\t\tconst isConsecutiveAttributeChange =\n\t\t\t\tprevDiff.type == 'attribute' && thisDiff.type == 'attribute' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.range.isFlat && thisDiff.range.isFlat &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset &&\n\t\t\t\tprevDiff.attributeKey == thisDiff.attributeKey &&\n\t\t\t\tprevDiff.attributeOldValue == thisDiff.attributeOldValue &&\n\t\t\t\tprevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n\t\t\tif ( isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange ) {\n\t\t\t\tprevDiff.length++;\n\n\t\t\t\tif ( isConsecutiveAttributeChange ) {\n\t\t\t\t\tprevDiff.range.end = prevDiff.range.end.getShiftedBy( 1 );\n\t\t\t\t}\n\n\t\t\t\tdiffSet[ i ] = null;\n\t\t\t} else {\n\t\t\t\tprevIndex = i;\n\t\t\t}\n\t\t}\n\n\t\tdiffSet = diffSet.filter( v => v );\n\n\t\t// Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\t\tfor ( const item of diffSet ) {\n\t\t\tdelete item.changeCount;\n\n\t\t\tif ( item.type == 'attribute' ) {\n\t\t\t\tdelete item.position;\n\t\t\t\tdelete item.length;\n\t\t\t}\n\t\t}\n\n\t\tthis._changeCount = 0;\n\n\t\t// Cache changes.\n\t\tthis._cachedChangesWithGraveyard = diffSet.slice();\n\t\tthis._cachedChanges = diffSet.filter( _changesInGraveyardFilter );\n\n\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\treturn this._cachedChangesWithGraveyard;\n\t\t} else {\n\t\t\treturn this._cachedChanges;\n\t\t}\n\t}\n\n\t/**\n\t * Resets `Differ`. Removes all buffered changes.\n\t */\n\treset() {\n\t\tthis._changesInElement.clear();\n\t\tthis._elementSnapshots.clear();\n\t\tthis._changedMarkers.clear();\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Saves and handles an insert change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markInsert( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'insert', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a remove change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markRemove( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'remove', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\n\t\tthis._removeAllNestedChanges( parent, offset, howMany );\n\t}\n\n\t/**\n\t * Saves and handles an attribute change.\n\t *\n\t * @private\n\t * @param {module:engine/model/item~Item} item\n\t */\n\t_markAttribute( item ) {\n\t\tconst changeItem = { type: 'attribute', offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++ };\n\n\t\tthis._markChange( item.parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a model change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Object} changeItem\n\t */\n\t_markChange( parent, changeItem ) {\n\t\t// First, make a snapshot of this parent's children (it will be made only if it was not made before).\n\t\tthis._makeSnapshot( parent );\n\n\t\t// Then, get all changes that already were done on the element (empty array if this is the first change).\n\t\tconst changes = this._getChangesForElement( parent );\n\n\t\t// Then, look through all the changes, and transform them or the new change.\n\t\tthis._handleChange( changeItem, changes );\n\n\t\t// Add the new change.\n\t\tchanges.push( changeItem );\n\n\t\t// Remove incorrect changes. During transformation some change might be, for example, included in another.\n\t\t// In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\t\tfor ( let i = 0; i < changes.length; i++ ) {\n\t\t\tif ( changes[ i ].howMany < 1 ) {\n\t\t\t\tchanges.splice( i, 1 );\n\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets an array of changes that have already been saved for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t * @returns {Array.<Object>}\n\t */\n\t_getChangesForElement( element ) {\n\t\tlet changes;\n\n\t\tif ( this._changesInElement.has( element ) ) {\n\t\t\tchanges = this._changesInElement.get( element );\n\t\t} else {\n\t\t\tchanges = [];\n\n\t\t\tthis._changesInElement.set( element, changes );\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\t/**\n\t * Saves a children snapshot for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_makeSnapshot( element ) {\n\t\tif ( !this._elementSnapshots.has( element ) ) {\n\t\t\tthis._elementSnapshots.set( element, _getChildrenSnapshot( element.getChildren() ) );\n\t\t}\n\t}\n\n\t/**\n\t * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n\t * change and/or the old change.\n\t *\n\t * @private\n\t * @param {Object} inc Incoming (new) change.\n\t * @param {Array.<Object>} changes An array containing all the changes done on that element.\n\t */\n\t_handleChange( inc, changes ) {\n\t\t// We need a helper variable that will store how many nodes are to be still handled for this change item.\n\t\t// `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n\t\t// needs to be differentiated.\n\t\t//\n\t\t// This comes up when there are multiple changes that are affected by `inc` change item.\n\t\t//\n\t\t// For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n\t\t// Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n\t\t//\n\t\t// Then, we:\n\t\t// - \"forget\" about first insert change (it is \"eaten\" by remove),\n\t\t// - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n\t\t// - but still we have to change offset of the second insert change from `5` to `3`!\n\t\t//\n\t\t// So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n\t\t// while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n\t\tinc.nodesToHandle = inc.howMany;\n\n\t\tfor ( const old of changes ) {\n\t\t\tconst incEnd = inc.offset + inc.howMany;\n\t\t\tconst oldEnd = old.offset + old.howMany;\n\n\t\t\tif ( inc.type == 'insert' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\told.howMany += inc.nodesToHandle;\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t// This case is more complicated, because attribute change has to be split into two.\n\t\t\t\t\t\t// Example (assume that uppercase and lowercase letters mean different attributes):\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// initial state:\t\tabcxyz\n\t\t\t\t\t\t// attribute change:\taBCXYz\n\t\t\t\t\t\t// incoming insert:\t\taBCfooXYz\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Change ranges cannot intersect because each item has to be described exactly (it was either\n\t\t\t\t\t\t// not changed, inserted, removed, or its attribute was changed). That's why old attribute\n\t\t\t\t\t\t// change has to be split and both parts has to be handled separately from now on.\n\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: incEnd,\n\t\t\t\t\t\t\thowMany: howMany - old.howMany,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'remove' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( incEnd <= oldEnd ) {\n\t\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\t\told.offset = inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= inc.nodesToHandle;\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\t\tinc.nodesToHandle -= old.howMany;\n\t\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t\tconst intersectionLength = oldEnd - inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tinc.nodesToHandle += old.howMany;\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\told.offset = inc.offset;\n\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd <= oldEnd ) {\n\t\t\t\t\t\t\t// On first sight in this case we don't need to split attribute operation into two.\n\t\t\t\t\t\t\t// However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n\t\t\t\t\t\t\t// For that reason, no two changes may intersect.\n\t\t\t\t\t\t\t// So we cannot have an attribute change that \"contains\" remove change.\n\t\t\t\t\t\t\t// Attribute change needs to be split.\n\t\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t\tconst howManyAfter = howMany - old.howMany - inc.nodesToHandle;\n\n\t\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: inc.offset,\n\t\t\t\t\t\t\t\thowMany: howManyAfter,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= oldEnd - inc.offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'attribute' ) {\n\t\t\t\t// In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\t// This case is similar to a case described when incoming change was insert and old change was attribute.\n\t\t\t\t\t\t\t// See comment above.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// This time incoming change is attribute. We need to split incoming change in this case too.\n\t\t\t\t\t\t\t// However this time, the second part of the attribute change needs to be processed further\n\t\t\t\t\t\t\t// because there might be other changes that it collides with.\n\t\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: oldEnd,\n\t\t\t\t\t\t\t\thowMany: incEnd - oldEnd,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\t\tchanges.push( attributePart );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t} else if ( inc.offset >= old.offset && inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\tinc.nodesToHandle = incEnd - oldEnd;\n\t\t\t\t\t\t\tinc.offset = oldEnd;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\t// This is a case when attribute change \"contains\" remove change.\n\t\t\t\t\t// The attribute change needs to be split into two because changes cannot intersect.\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: old.offset,\n\t\t\t\t\t\t\thowMany: incEnd - old.offset,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\tchanges.push( attributePart );\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\t// There are only two conflicting scenarios possible here:\n\t\t\t\t\tif ( inc.offset >= old.offset && incEnd <= oldEnd ) {\n\t\t\t\t\t\t// `old` change includes `inc` change, or they are the same.\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\tinc.howMany = 0;\n\t\t\t\t\t\tinc.offset = 0;\n\t\t\t\t\t} else if ( inc.offset <= old.offset && incEnd >= oldEnd ) {\n\t\t\t\t\t\t// `inc` change includes `old` change.\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinc.howMany = inc.nodesToHandle;\n\t\tdelete inc.nodesToHandle;\n\t}\n\n\t/**\n\t * Returns an object with a single insert change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which the change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getInsertDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'insert',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an object with a single remove change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getRemoveDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'remove',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an array of objects where each one is a single attribute change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range where the change happened.\n\t * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n\t * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n\t * @returns {Array.<Object>} An array containing one or more diff items.\n\t */\n\t_getAttributesDiff( range, oldAttributes, newAttributes ) {\n\t\t// Results holder.\n\t\tconst diffs = [];\n\n\t\t// Clone new attributes as we will be performing changes on this object.\n\t\tnewAttributes = new Map( newAttributes );\n\n\t\t// Look through old attributes.\n\t\tfor ( const [ key, oldValue ] of oldAttributes ) {\n\t\t\t// Check what is the new value of the attribute (or if it was removed).\n\t\t\tconst newValue = newAttributes.has( key ) ? newAttributes.get( key ) : null;\n\n\t\t\t// If values are different (or attribute was removed)...\n\t\t\tif ( newValue !== oldValue ) {\n\t\t\t\t// Add diff item.\n\t\t\t\tdiffs.push( {\n\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\tposition: range.start,\n\t\t\t\t\trange: range.clone(),\n\t\t\t\t\tlength: 1,\n\t\t\t\t\tattributeKey: key,\n\t\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\t\tattributeNewValue: newValue,\n\t\t\t\t\tchangeCount: this._changeCount++\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Prevent returning two diff items for the same change.\n\t\t\tnewAttributes.delete( key );\n\t\t}\n\n\t\t// Look through new attributes that weren't handled above.\n\t\tfor ( const [ key, newValue ] of newAttributes ) {\n\t\t\t// Each of them is a new attribute. Add diff item.\n\t\t\tdiffs.push( {\n\t\t\t\ttype: 'attribute',\n\t\t\t\tposition: range.start,\n\t\t\t\trange: range.clone(),\n\t\t\t\tlength: 1,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: newValue,\n\t\t\t\tchangeCount: this._changeCount++\n\t\t\t} );\n\t\t}\n\n\t\treturn diffs;\n\t}\n\n\t/**\n\t * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element Element to check.\n\t * @returns {Boolean}\n\t */\n\t_isInInsertedElement( element ) {\n\t\tconst parent = element.parent;\n\n\t\tif ( !parent ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst changes = this._changesInElement.get( parent );\n\t\tconst offset = element.startOffset;\n\n\t\tif ( changes ) {\n\t\t\tfor ( const change of changes ) {\n\t\t\t\tif ( change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._isInInsertedElement( parent );\n\t}\n\n\t/**\n\t * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n\t * and `howMany`.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_removeAllNestedChanges( parent, offset, howMany ) {\n\t\tconst range = new Range( Position._createAt( parent, offset ), Position._createAt( parent, offset + howMany ) );\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tthis._elementSnapshots.delete( item );\n\t\t\t\tthis._changesInElement.delete( item );\n\n\t\t\t\tthis._removeAllNestedChanges( item, 0, item.maxOffset );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\nfunction _getChildrenSnapshot( children ) {\n\tconst snapshot = [];\n\n\tfor ( const child of children ) {\n\t\tif ( child.is( '$text' ) ) {\n\t\t\tfor ( let i = 0; i < child.data.length; i++ ) {\n\t\t\t\tsnapshot.push( {\n\t\t\t\t\tname: '$text',\n\t\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\tsnapshot.push( {\n\t\t\t\tname: child.name,\n\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn snapshot;\n}\n\n// Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\nfunction _generateActionsFromChanges( oldChildrenLength, changes ) {\n\tconst actions = [];\n\n\tlet offset = 0;\n\tlet oldChildrenHandled = 0;\n\n\t// Go through all buffered changes.\n\tfor ( const change of changes ) {\n\t\t// First, fill \"holes\" between changes with \"equal\" actions.\n\t\tif ( change.offset > offset ) {\n\t\t\tfor ( let i = 0; i < change.offset - offset; i++ ) {\n\t\t\t\tactions.push( 'e' );\n\t\t\t}\n\n\t\t\toldChildrenHandled += change.offset - offset;\n\t\t}\n\n\t\t// Then, fill up actions accordingly to change type.\n\t\tif ( change.type == 'insert' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'i' );\n\t\t\t}\n\n\t\t\t// The last handled offset is after inserted range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t} else if ( change.type == 'remove' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'r' );\n\t\t\t}\n\n\t\t\t// The last handled offset is at the position where the nodes were removed.\n\t\t\toffset = change.offset;\n\t\t\t// We removed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t} else {\n\t\t\tactions.push( ...'a'.repeat( change.howMany ).split( '' ) );\n\n\t\t\t// The last handled offset is at the position after the changed range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t\t// We changed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t}\n\t}\n\n\t// Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n\t// has not been changed / removed at the end of their parent.\n\tif ( oldChildrenHandled < oldChildrenLength ) {\n\t\tfor ( let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++ ) {\n\t\t\tactions.push( 'e' );\n\t\t}\n\t}\n\n\treturn actions;\n}\n\n// Filter callback for Array.filter that filters out change entries that are in graveyard.\nfunction _changesInGraveyardFilter( entry ) {\n\tconst posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n\tconst rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n\n\treturn !posInGy && !rangeInGy;\n}\n\n/**\n * The single diff item.\n *\n * Could be one of:\n *\n * * {@link module:engine/model/differ~DiffItemInsert `DiffItemInsert`},\n * * {@link module:engine/model/differ~DiffItemRemove `DiffItemRemove`},\n * * {@link module:engine/model/differ~DiffItemAttribute `DiffItemAttribute`}.\n *\n * @interface DiffItem\n */\n\n/**\n * The single diff item for inserted nodes.\n *\n * @class DiffItemInsert\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'insert'} module:engine/model/differ~DiffItemInsert#type\n */\n\n/**\n * The name of the inserted elements or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemInsert#name\n */\n\n/**\n * The position where the node was inserted.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemInsert#position\n */\n\n/**\n * The length of an inserted text node. For elements it is always 1 as each inserted element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemInsert#length\n */\n\n/**\n * The single diff item for removed nodes.\n *\n * @class DiffItemRemove\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'remove'} module:engine/model/differ~DiffItemRemove#type\n */\n\n/**\n * The name of the removed element or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemRemove#name\n */\n\n/**\n * The position where the node was removed.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemRemove#position\n */\n\n/**\n * The length of a removed text node. For elements it is always 1 as each removed element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemRemove#length\n */\n\n/**\n * The single diff item for attribute change.\n *\n * @class DiffItemAttribute\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'attribute'} module:engine/model/differ~DiffItemAttribute#type\n */\n\n/**\n * The name of the changed attribute.\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeKey\n */\n\n/**\n * An attribute previous value (before change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeOldValue\n */\n\n/**\n * An attribute new value (after change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeNewValue\n */\n\n/**\n * The range where the change happened.\n *\n * @member {module:engine/model/range~Range} module:engine/model/differ~DiffItemAttribute#range\n */\n"]}]}