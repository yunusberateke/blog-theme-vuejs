{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKdmFyIF9tYXJrZWQgPSAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoY29tYmluZVdhbGtlcnMpLAogICAgX21hcmtlZDIgPSAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoY29udmVydFRvTWluaW1hbEZsYXRSYW5nZXMpOwoKaW1wb3J0ICJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbmQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuZW5kcy13aXRoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdGFydHMtd2l0aC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zZXQuanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9zY2hlbWEKICovCmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgT2JzZXJ2YWJsZU1peGluIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL29ic2VydmFibGVtaXhpbic7CmltcG9ydCBtaXggZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvbWl4JzsKaW1wb3J0IFJhbmdlIGZyb20gJy4vcmFuZ2UnOwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBFbGVtZW50IGZyb20gJy4vZWxlbWVudCc7CmltcG9ydCBUZXh0IGZyb20gJy4vdGV4dCc7CmltcG9ydCBUcmVlV2Fsa2VyIGZyb20gJy4vdHJlZXdhbGtlcic7Ci8qKgogKiBUaGUgbW9kZWwncyBzY2hlbWEuIEl0IGRlZmluZXMgYWxsb3dlZCBhbmQgZGlzYWxsb3dlZCBzdHJ1Y3R1cmVzIG9mIG5vZGVzIGFzIHdlbGwgYXMgbm9kZXMnIGF0dHJpYnV0ZXMuCiAqIFRoZSBzY2hlbWEgaXMgdXN1YWxseSBkZWZpbmVkIGJ5IGZlYXR1cmVzIGFuZCBiYXNlZCBvbiB0aGVtIHRoZSBlZGl0aW5nIGZyYW1ld29yayBhbmQgZmVhdHVyZXMKICogbWFrZSBkZWNpc2lvbnMgaG93IHRvIGNoYW5nZSBhbmQgcHJvY2VzcyB0aGUgbW9kZWwuCiAqCiAqIFRoZSBpbnN0YW5jZSBvZiBzY2hlbWEgaXMgYXZhaWxhYmxlIGluIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI3NjaGVtYSBgZWRpdG9yLm1vZGVsLnNjaGVtYWB9LgogKgogKiBSZWFkIG1vcmUgYWJvdXQgdGhlIHNjaGVtYSBpbjoKICoKICogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI3NjaGVtYSBTY2hlbWF9IHNlY3Rpb24gb2YgdGhlCiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUgSW50cm9kdWN0aW9uIHRvIHRoZSBFZGl0aW5nIGVuZ2luZSBhcmNoaXRlY3R1cmV9LgogKiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hIFNjaGVtYSBkZWVwIGRpdmV9IGd1aWRlLgogKgogKiBAbWl4ZXMgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4KICovCgp2YXIgU2NoZW1hID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIHNjaGVtYSBpbnN0YW5jZS4KICAgKi8KICBmdW5jdGlvbiBTY2hlbWEoKSB7CiAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2hlbWEpOwoKICAgIHRoaXMuX3NvdXJjZURlZmluaXRpb25zID0ge307CiAgICAvKioKICAgICAqIEEgZGljdGlvbmFyeSBjb250YWluaW5nIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtPYmplY3QuPFN0cmluZyxTdHJpbmc+fQogICAgICovCgogICAgdGhpcy5fYXR0cmlidXRlUHJvcGVydGllcyA9IHt9OwogICAgdGhpcy5kZWNvcmF0ZSgnY2hlY2tDaGlsZCcpOwogICAgdGhpcy5kZWNvcmF0ZSgnY2hlY2tBdHRyaWJ1dGUnKTsKICAgIHRoaXMub24oJ2NoZWNrQXR0cmlidXRlJywgZnVuY3Rpb24gKGV2dCwgYXJncykgewogICAgICBhcmdzWzBdID0gbmV3IFNjaGVtYUNvbnRleHQoYXJnc1swXSk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnaGlnaGVzdCcKICAgIH0pOwogICAgdGhpcy5vbignY2hlY2tDaGlsZCcsIGZ1bmN0aW9uIChldnQsIGFyZ3MpIHsKICAgICAgYXJnc1swXSA9IG5ldyBTY2hlbWFDb250ZXh0KGFyZ3NbMF0pOwogICAgICBhcmdzWzFdID0gX3RoaXMuZ2V0RGVmaW5pdGlvbihhcmdzWzFdKTsKICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdoaWdoZXN0JwogICAgfSk7CiAgfQogIC8qKgogICAqIFJlZ2lzdGVycyBzY2hlbWEgaXRlbS4gQ2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UgZm9yIGV2ZXJ5IGl0ZW0gbmFtZS4KICAgKgogICAqCQlzY2hlbWEucmVnaXN0ZXIoICdwYXJhZ3JhcGgnLCB7CiAgICoJCQlpbmhlcml0QWxsRnJvbTogJyRibG9jaycKICAgKgkJfSApOwogICAqCiAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1OYW1lCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0gZGVmaW5pdGlvbgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFNjaGVtYSwgW3sKICAgIGtleTogInJlZ2lzdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihpdGVtTmFtZSwgZGVmaW5pdGlvbikgewogICAgICBpZiAodGhpcy5fc291cmNlRGVmaW5pdGlvbnNbaXRlbU5hbWVdKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQSBzaW5nbGUgaXRlbSBjYW5ub3QgYmUgcmVnaXN0ZXJlZCB0d2ljZSBpbiB0aGUgc2NoZW1hLgogICAgICAgICAqCiAgICAgICAgICogVGhpcyBzaXR1YXRpb24gbWF5IGhhcHBlbiB3aGVuOgogICAgICAgICAqCiAgICAgICAgICogKiBUd28gb3IgbW9yZSBwbHVnaW5zIGNhbGxlZCB7QGxpbmsgI3JlZ2lzdGVyIGByZWdpc3RlcigpYH0gd2l0aCB0aGUgc2FtZSBuYW1lLiBUaGlzIHdpbGwgdXN1YWxseSBtZWFuIHRoYXQKICAgICAgICAgKiB0aGVyZSBpcyBhIGNvbGxpc2lvbiBiZXR3ZWVuIHBsdWdpbnMgd2hpY2ggdHJ5IHRvIHVzZSB0aGUgc2FtZSBlbGVtZW50IGluIHRoZSBtb2RlbC4gVW5mb3J0dW5hdGVseSwKICAgICAgICAgKiB0aGUgb25seSB3YXkgdG8gc29sdmUgdGhpcyBpcyBieSBtb2RpZnlpbmcgb25lIG9mIHRoZXNlIHBsdWdpbnMgdG8gdXNlIGEgdW5pcXVlIG1vZGVsIGVsZW1lbnQgbmFtZS4KICAgICAgICAgKiAqIEEgc2luZ2xlIHBsdWdpbiB3YXMgbG9hZGVkIHR3aWNlLiBUaGlzIGhhcHBlbnMgd2hlbiBpdCBpcyBpbnN0YWxsZWQgYnkgbnBtL3lhcm4gaW4gdHdvIHZlcnNpb25zCiAgICAgICAgICogYW5kIHVzdWFsbHkgbWVhbnMgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBpc3N1ZXM6CiAgICAgICAgICogICAgICogYSB2ZXJzaW9uIG1pc21hdGNoICh0d28gb2YgeW91ciBkZXBlbmRlbmNpZXMgcmVxdWlyZSB0d28gZGlmZmVyZW50IHZlcnNpb25zIG9mIHRoaXMgcGx1Z2luKSwKICAgICAgICAgKiAgICAgKiBpbmNvcnJlY3QgaW1wb3J0cyAodGhpcyBwbHVnaW4gaXMgc29tZWhvdyBpbXBvcnRlZCB0d2ljZSBpbiBhIHdheSB3aGljaCBjb25mdXNlcyB3ZWJwYWNrKSwKICAgICAgICAgKiAgICAgKiBtZXNzIGluIGBub2RlX21vZHVsZXMvYCAoYHJtIC1yZiBub2RlX21vZHVsZXMvYCBtYXkgaGVscCkuCiAgICAgICAgICoKICAgICAgICAgKiAqKk5vdGU6KiogQ2hlY2sgdGhlIGxvZ2dlZCBgaXRlbU5hbWVgIHRvIGJldHRlciB1bmRlcnN0YW5kIHdoaWNoIHBsdWdpbiB3YXMgZHVwbGljYXRlZC9jb25mbGljdGluZy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZSBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHJlZ2lzdGVyZWQgdHdpY2UuCiAgICAgICAgICogQGVycm9yIHNjaGVtYS1jYW5ub3QtcmVnaXN0ZXItaXRlbS10d2ljZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdzY2hlbWEtY2Fubm90LXJlZ2lzdGVyLWl0ZW0tdHdpY2UnLCB0aGlzLCB7CiAgICAgICAgICBpdGVtTmFtZTogaXRlbU5hbWUKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgdGhpcy5fc291cmNlRGVmaW5pdGlvbnNbaXRlbU5hbWVdID0gW09iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pXTsKCiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTsKICAgIH0KICAgIC8qKgogICAgICogRXh0ZW5kcyBhIHtAbGluayAjcmVnaXN0ZXIgcmVnaXN0ZXJlZH0gaXRlbSdzIGRlZmluaXRpb24uCiAgICAgKgogICAgICogRXh0ZW5kaW5nIHByb3BlcnRpZXMgc3VjaCBhcyBgYWxsb3dJbmAgd2lsbCBhZGQgbW9yZSBpdGVtcyB0byB0aGUgZXhpc3RpbmcgcHJvcGVydGllcywKICAgICAqIHdoaWxlIHJlZGVmaW5pbmcgcHJvcGVydGllcyBzdWNoIGFzIGBpc0Jsb2NrYCB3aWxsIG92ZXJyaWRlIHRoZSBwcmV2aW91c2x5IGRlZmluZWQgb25lcy4KICAgICAqCiAgICAgKgkJc2NoZW1hLnJlZ2lzdGVyKCAnZm9vJywgewogICAgICoJCQlhbGxvd0luOiAnJHJvb3QnLAogICAgICoJCQlpc0Jsb2NrOiB0cnVlOwogICAgICoJCX0gKTsKICAgICAqCQlzY2hlbWEuZXh0ZW5kKCAnZm9vJywgewogICAgICoJCQlhbGxvd0luOiAnYmxvY2tRdW90ZScsCiAgICAgKgkJCWlzQmxvY2s6IGZhbHNlCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQlzY2hlbWEuZ2V0RGVmaW5pdGlvbiggJ2ZvbycgKTsKICAgICAqCQkvLwl7CiAgICAgKgkJLy8JCWFsbG93SW46IFsgJyRyb290JywgJ2Jsb2NrUXVvdGUnIF0sCiAgICAgKgkJLy8gCQlpc0Jsb2NrOiBmYWxzZQogICAgICoJCS8vCX0KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbU5hbWUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGRlZmluaXRpb24KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJleHRlbmQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZChpdGVtTmFtZSwgZGVmaW5pdGlvbikgewogICAgICBpZiAoIXRoaXMuX3NvdXJjZURlZmluaXRpb25zW2l0ZW1OYW1lXSkgewogICAgICAgIC8qKgogICAgICAgICAqIENhbm5vdCBleHRlbmQgYW4gaXRlbSB3aGljaCB3YXMgbm90IHJlZ2lzdGVyZWQgeWV0LgogICAgICAgICAqCiAgICAgICAgICogVGhpcyBlcnJvciBoYXBwZW5zIHdoZW4gYSBwbHVnaW4gdHJpZXMgdG8gZXh0ZW5kIHRoZSBzY2hlbWEgZGVmaW5pdGlvbiBvZiBhbiBpdGVtIHdoaWNoIHdhcyBub3QKICAgICAgICAgKiB7QGxpbmsgI3JlZ2lzdGVyIHJlZ2lzdGVyZWR9IHlldC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZSBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgZWxlbWVudCB3aGljaCBpcyBiZWluZyBleHRlbmRlZC4KICAgICAgICAgKiBAZXJyb3Igc2NoZW1hLWNhbm5vdC1leHRlbmQtbWlzc2luZy1pdGVtCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3NjaGVtYS1jYW5ub3QtZXh0ZW5kLW1pc3NpbmctaXRlbScsIHRoaXMsIHsKICAgICAgICAgIGl0ZW1OYW1lOiBpdGVtTmFtZQogICAgICAgIH0pOwogICAgICB9CgogICAgICB0aGlzLl9zb3VyY2VEZWZpbml0aW9uc1tpdGVtTmFtZV0ucHVzaChPYmplY3QuYXNzaWduKHt9LCBkZWZpbml0aW9uKSk7CgogICAgICB0aGlzLl9jbGVhckNhY2hlKCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgZGF0YSBvZiBhbGwgcmVnaXN0ZXJlZCBpdGVtcy4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgbm9ybWFsbHkgYmUgdXNlZCBmb3IgcmVmbGVjdGlvbiBwdXJwb3NlcyAoZS5nLiBkZWZpbmluZyBhIGNsb25lIG9mIGEgY2VydGFpbiBlbGVtZW50LAogICAgICogY2hlY2tpbmcgYSBsaXN0IG9mIGFsbCBibG9jayBlbGVtZW50cywgZXRjKS4KICAgICAqIFVzZSBzcGVjaWZpYyBtZXRob2RzIChzdWNoIGFzIHtAbGluayAjY2hlY2tDaGlsZCBgY2hlY2tDaGlsZCgpYH0gb3Ige0BsaW5rICNpc0xpbWl0IGBpc0xpbWl0KClgfSkKICAgICAqIGluIG90aGVyIGNhc2VzLgogICAgICoKICAgICAqIEByZXR1cm5zIHtPYmplY3QuPFN0cmluZyxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb21waWxlZEl0ZW1EZWZpbml0aW9uPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXREZWZpbml0aW9ucyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbnMoKSB7CiAgICAgIGlmICghdGhpcy5fY29tcGlsZWREZWZpbml0aW9ucykgewogICAgICAgIHRoaXMuX2NvbXBpbGUoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVkRGVmaW5pdGlvbnM7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBkZWZpbml0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIG9yIGB1bmRlZmluZWRgIGlmIGFuIGl0ZW0gaXMgbm90IHJlZ2lzdGVyZWQuCiAgICAgKgogICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vcm1hbGx5IGJlIHVzZWQgZm9yIHJlZmxlY3Rpb24gcHVycG9zZXMgKGUuZy4gZGVmaW5pbmcgYSBjbG9uZSBvZiBhIGNlcnRhaW4gZWxlbWVudCwKICAgICAqIGNoZWNraW5nIGEgbGlzdCBvZiBhbGwgYmxvY2sgZWxlbWVudHMsIGV0YykuCiAgICAgKiBVc2Ugc3BlY2lmaWMgbWV0aG9kcyAoc3VjaCBhcyB7QGxpbmsgI2NoZWNrQ2hpbGQgYGNoZWNrQ2hpbGQoKWB9IG9yIHtAbGluayAjaXNMaW1pdCBgaXNMaW1pdCgpYH0pCiAgICAgKiBpbiBvdGhlciBjYXNlcy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfFN0cmluZ30gaXRlbQogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbXBpbGVkSXRlbURlZmluaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0RGVmaW5pdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbihpdGVtKSB7CiAgICAgIHZhciBpdGVtTmFtZTsKCiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnc3RyaW5nJykgewogICAgICAgIGl0ZW1OYW1lID0gaXRlbTsKICAgICAgfSBlbHNlIGlmIChpdGVtLmlzICYmIChpdGVtLmlzKCckdGV4dCcpIHx8IGl0ZW0uaXMoJyR0ZXh0UHJveHknKSkpIHsKICAgICAgICBpdGVtTmFtZSA9ICckdGV4dCc7CiAgICAgIH0gLy8gRWxlbWVudCBvciBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbS4KICAgICAgZWxzZSB7CiAgICAgICAgICBpdGVtTmFtZSA9IGl0ZW0ubmFtZTsKICAgICAgICB9CgogICAgICByZXR1cm4gdGhpcy5nZXREZWZpbml0aW9ucygpW2l0ZW1OYW1lXTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGl0ZW0gaXMgcmVnaXN0ZXJlZCBpbiB0aGUgc2NoZW1hLgogICAgICoKICAgICAqCQlzY2hlbWEuaXNSZWdpc3RlcmVkKCAncGFyYWdyYXBoJyApOyAvLyAtPiB0cnVlCiAgICAgKgkJc2NoZW1hLmlzUmVnaXN0ZXJlZCggZWRpdG9yLm1vZGVsLmRvY3VtZW50LmdldFJvb3QoKSApOyAvLyAtPiB0cnVlCiAgICAgKgkJc2NoZW1hLmlzUmVnaXN0ZXJlZCggJ2ZvbycgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfFN0cmluZ30gaXRlbQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzUmVnaXN0ZXJlZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZWdpc3RlcmVkKGl0ZW0pIHsKICAgICAgcmV0dXJuICEhdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaXRlbSBpcyBkZWZpbmVkIHRvIGJlCiAgICAgKiBhIGJsb2NrIGJ5IHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259J3MgYGlzQmxvY2tgIHByb3BlcnR5LgogICAgICoKICAgICAqCQlzY2hlbWEuaXNCbG9jayggJ3BhcmFncmFwaCcgKTsgLy8gLT4gdHJ1ZQogICAgICoJCXNjaGVtYS5pc0Jsb2NrKCAnJHJvb3QnICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICoJCWNvbnN0IHBhcmFncmFwaEVsZW1lbnQgPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgICAqCQlzY2hlbWEuaXNCbG9jayggcGFyYWdyYXBoRWxlbWVudCApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICogU2VlIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvZGVlcC1kaXZlL3NjaGVtYSNibG9jay1lbGVtZW50cyBCbG9jayBlbGVtZW50c30gc2VjdGlvbiBvZiB0aGUgU2NoZW1hIGRlZXAgZGl2ZQogICAgICogZ3VpZGUgZm9yIG1vcmUgZGV0YWlscy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfFN0cmluZ30gaXRlbQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQmxvY2siLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzQmxvY2soaXRlbSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwogICAgICByZXR1cm4gISEoZGVmICYmIGRlZi5pc0Jsb2NrKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGl0ZW0gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBsaW1pdCBlbGVtZW50LgogICAgICoKICAgICAqIEl0IGNvbnNpZGVycyBhbiBpdGVtIHRvIGJlIGEgbGltaXQgZWxlbWVudCBpZiBpdHMKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9uI2lzTGltaXQgYGlzTGltaXRgfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9uI2lzT2JqZWN0IGBpc09iamVjdGB9IHByb3BlcnR5CiAgICAgKiB3YXMgc2V0IHRvIGB0cnVlYC4KICAgICAqCiAgICAgKgkJc2NoZW1hLmlzTGltaXQoICdwYXJhZ3JhcGgnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJc2NoZW1hLmlzTGltaXQoICckcm9vdCcgKTsgLy8gLT4gdHJ1ZQogICAgICoJCXNjaGVtYS5pc0xpbWl0KCBlZGl0b3IubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdCgpICk7IC8vIC0+IHRydWUKICAgICAqCQlzY2hlbWEuaXNMaW1pdCggJ2ltYWdlJyApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICogU2VlIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvZGVlcC1kaXZlL3NjaGVtYSNsaW1pdC1lbGVtZW50cyBMaW1pdCBlbGVtZW50c30gc2VjdGlvbiBvZiB0aGUgU2NoZW1hIGRlZXAgZGl2ZQogICAgICogZ3VpZGUgZm9yIG1vcmUgZGV0YWlscy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfFN0cmluZ30gaXRlbQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzTGltaXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzTGltaXQoaXRlbSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwoKICAgICAgaWYgKCFkZWYpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiAhIShkZWYuaXNMaW1pdCB8fCBkZWYuaXNPYmplY3QpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaXRlbSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhbiBvYmplY3QgZWxlbWVudC4KICAgICAqCiAgICAgKiBJdCBjb25zaWRlcnMgYW4gaXRlbSB0byBiZSBhbiBvYmplY3QgZWxlbWVudCBpZiBpdHMKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9uI2lzT2JqZWN0IGBpc09iamVjdGB9IHByb3BlcnR5CiAgICAgKiB3YXMgc2V0IHRvIGB0cnVlYC4KICAgICAqCiAgICAgKgkJc2NoZW1hLmlzT2JqZWN0KCAncGFyYWdyYXBoJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXNjaGVtYS5pc09iamVjdCggJ2ltYWdlJyApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICoJCWNvbnN0IGltYWdlRWxlbWVudCA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAnaW1hZ2UnICk7CiAgICAgKgkJc2NoZW1hLmlzT2JqZWN0KCBpbWFnZUVsZW1lbnQgKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqIFNlZSB0aGUge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2RlZXAtZGl2ZS9zY2hlbWEjb2JqZWN0LWVsZW1lbnRzIE9iamVjdCBlbGVtZW50c30gc2VjdGlvbiBvZiB0aGUgU2NoZW1hIGRlZXAgZGl2ZQogICAgICogZ3VpZGUgZm9yIG1vcmUgZGV0YWlscy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfFN0cmluZ30gaXRlbQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzT2JqZWN0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc09iamVjdChpdGVtKSB7CiAgICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oaXRlbSk7CgogICAgICBpZiAoIWRlZikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBOb3RlOiBDaGVjayBvdXQgdGhlIGltcGxlbWVudGF0aW9uIG9mICNpc0xpbWl0KCksICNpc1NlbGVjdGFibGUoKSwgYW5kICNpc0NvbnRlbnQoKQogICAgICAvLyB0byB1bmRlcnN0YW5kIHdoeSB0aGVzZSB0aHJlZSBjb25zdGl0dXRlIGFuIG9iamVjdC4KCgogICAgICByZXR1cm4gISEoZGVmLmlzT2JqZWN0IHx8IGRlZi5pc0xpbWl0ICYmIGRlZi5pc1NlbGVjdGFibGUgJiYgZGVmLmlzQ29udGVudCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpdGVtIGlzIGRlZmluZWQgdG8gYmUKICAgICAqIGFuIGlubGluZSBlbGVtZW50IGJ5IHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259J3MgYGlzSW5saW5lYCBwcm9wZXJ0eS4KICAgICAqCiAgICAgKgkJc2NoZW1hLmlzSW5saW5lKCAncGFyYWdyYXBoJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXNjaGVtYS5pc0lubGluZSggJ3NvZnRCcmVhaycgKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqCQljb25zdCB0ZXh0ID0gd3JpdGVyLmNyZWF0ZVRleHQoICdmb28nICk7CiAgICAgKgkJc2NoZW1hLmlzSW5saW5lKCB0ZXh0ICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKiBTZWUgdGhlIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hI2lubGluZS1lbGVtZW50cyBJbmxpbmUgZWxlbWVudHN9IHNlY3Rpb24gb2YgdGhlIFNjaGVtYSBkZWVwIGRpdmUKICAgICAqIGd1aWRlIGZvciBtb3JlIGRldGFpbHMuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbXxTdHJpbmd9IGl0ZW0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0lubGluZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbmxpbmUoaXRlbSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwogICAgICByZXR1cm4gISEoZGVmICYmIGRlZi5pc0lubGluZSk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpdGVtIGlzIGRlZmluZWQgdG8gYmUKICAgICAqIGEgc2VsZWN0YWJsZSBlbGVtZW50IGJ5IHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259J3MgYGlzU2VsZWN0YWJsZWAgcHJvcGVydHkuCiAgICAgKgogICAgICoJCXNjaGVtYS5pc1NlbGVjdGFibGUoICdwYXJhZ3JhcGgnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJc2NoZW1hLmlzU2VsZWN0YWJsZSggJ2hlYWRpbmcxJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXNjaGVtYS5pc1NlbGVjdGFibGUoICdpbWFnZScgKTsgLy8gLT4gdHJ1ZQogICAgICoJCXNjaGVtYS5pc1NlbGVjdGFibGUoICd0YWJsZUNlbGwnICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJY29uc3QgdGV4dCA9IHdyaXRlci5jcmVhdGVUZXh0KCAnZm9vJyApOwogICAgICoJCXNjaGVtYS5pc1NlbGVjdGFibGUoIHRleHQgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKiBTZWUgdGhlIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hI3NlbGVjdGFibGUtZWxlbWVudHMgU2VsZWN0YWJsZSBlbGVtZW50c30gc2VjdGlvbiBvZiB0aGUgU2NoZW1hIGRlZXAgZGl2ZX0KICAgICAqIGd1aWRlIGZvciBtb3JlIGRldGFpbHMuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbXxTdHJpbmd9IGl0ZW0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc1NlbGVjdGFibGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2VsZWN0YWJsZShpdGVtKSB7CiAgICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oaXRlbSk7CgogICAgICBpZiAoIWRlZikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuICEhKGRlZi5pc1NlbGVjdGFibGUgfHwgZGVmLmlzT2JqZWN0KTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGl0ZW0gaXMgZGVmaW5lZCB0byBiZQogICAgICogYSBjb250ZW50IGJ5IHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259J3MgYGlzQ29udGVudGAgcHJvcGVydHkuCiAgICAgKgogICAgICoJCXNjaGVtYS5pc0NvbnRlbnQoICdwYXJhZ3JhcGgnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJc2NoZW1hLmlzQ29udGVudCggJ2hlYWRpbmcxJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXNjaGVtYS5pc0NvbnRlbnQoICdpbWFnZScgKTsgLy8gLT4gdHJ1ZQogICAgICoJCXNjaGVtYS5pc0NvbnRlbnQoICdob3Jpem9udGFsTGluZScgKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqCQljb25zdCB0ZXh0ID0gd3JpdGVyLmNyZWF0ZVRleHQoICdmb28nICk7CiAgICAgKgkJc2NoZW1hLmlzQ29udGVudCggdGV4dCApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICogU2VlIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvZGVlcC1kaXZlL3NjaGVtYSNjb250ZW50LWVsZW1lbnRzIENvbnRlbnQgZWxlbWVudHN9IHNlY3Rpb24gb2YgdGhlIFNjaGVtYSBkZWVwIGRpdmV9CiAgICAgKiBndWlkZSBmb3IgbW9yZSBkZXRhaWxzLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW18U3RyaW5nfSBpdGVtCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNDb250ZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NvbnRlbnQoaXRlbSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwoKICAgICAgaWYgKCFkZWYpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiAhIShkZWYuaXNDb250ZW50IHx8IGRlZi5pc09iamVjdCk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIChgY2hpbGRgKSBjYW4gYmUgYSBjaGlsZCBvZiB0aGUgZ2l2ZW4gY29udGV4dC4KICAgICAqCiAgICAgKgkJc2NoZW1hLmNoZWNrQ2hpbGQoIG1vZGVsLmRvY3VtZW50LmdldFJvb3QoKSwgcGFyYWdyYXBoICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICoJCXNjaGVtYS5yZWdpc3RlciggJ3BhcmFncmFwaCcsIHsKICAgICAqCQkJYWxsb3dJbjogJyRyb290JwogICAgICoJCX0gKTsKICAgICAqCQlzY2hlbWEuY2hlY2tDaGlsZCggbW9kZWwuZG9jdW1lbnQuZ2V0Um9vdCgpLCBwYXJhZ3JhcGggKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqIE5vdGU6IFdoZW4gdmVyaWZ5aW5nIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgY2FuIGJlIGEgY2hpbGQgb2YgdGhlIGdpdmVuIGNvbnRleHQsIHRoZQogICAgICogc2NoZW1hIGFsc28gdmVyaWZpZXMgdGhlIGVudGlyZSBjb250ZXh0ICZtZGFzaDsgZnJvbSBpdHMgcm9vdCB0byBpdHMgbGFzdCBlbGVtZW50LiBUaGVyZWZvcmUsIGl0IGlzIHBvc3NpYmxlCiAgICAgKiBmb3IgYGNoZWNrQ2hpbGQoKWAgdG8gcmV0dXJuIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGhlIGNvbnRleHQncyBsYXN0IGVsZW1lbnQgY2FuIGNvbnRhaW4gdGhlIGNoZWNrZWQgY2hpbGQuCiAgICAgKiBJdCBoYXBwZW5zIGlmIG9uZSBvZiB0aGUgY29udGV4dCdzIGVsZW1lbnRzIGRvZXMgbm90IGFsbG93IGl0cyBjaGlsZC4KICAgICAqCiAgICAgKiBAZmlyZXMgY2hlY2tDaGlsZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0RGVmaW5pdGlvbn0gY29udGV4dCBUaGUgY29udGV4dCBpbiB3aGljaCB0aGUgY2hpbGQgd2lsbCBiZSBjaGVja2VkLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxTdHJpbmd9IGRlZiBUaGUgY2hpbGQgdG8gY2hlY2suCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2hlY2tDaGlsZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tDaGlsZChjb250ZXh0LCBkZWYpIHsKICAgICAgLy8gTm90ZTogY29udGV4dCBhbmQgY2hpbGQgYXJlIGFscmVhZHkgbm9ybWFsaXplZCBoZXJlIHRvIGEgU2NoZW1hQ29udGV4dCBhbmQgU2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbi4KICAgICAgaWYgKCFkZWYpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLl9jaGVja0NvbnRleHRNYXRjaChkZWYsIGNvbnRleHQpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gYXR0cmlidXRlIGNhbiBiZSBhcHBsaWVkIGluIHRoZSBnaXZlbiBjb250ZXh0IChvbiB0aGUgbGFzdAogICAgICogaXRlbSBvZiB0aGUgY29udGV4dCkuCiAgICAgKgogICAgICoJCXNjaGVtYS5jaGVja0F0dHJpYnV0ZSggdGV4dE5vZGUsICdib2xkJyApOyAvLyAtPiBmYWxzZQogICAgICoKICAgICAqCQlzY2hlbWEuZXh0ZW5kKCAnJHRleHQnLCB7CiAgICAgKgkJCWFsbG93QXR0cmlidXRlczogJ2JvbGQnCiAgICAgKgkJfSApOwogICAgICoJCXNjaGVtYS5jaGVja0F0dHJpYnV0ZSggdGV4dE5vZGUsICdib2xkJyApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICogQGZpcmVzIGNoZWNrQXR0cmlidXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBjb250ZXh0IFRoZSBjb250ZXh0IGluIHdoaWNoIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBjaGVja2VkLgogICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjaGVja0F0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGUoY29udGV4dCwgYXR0cmlidXRlTmFtZSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGNvbnRleHQubGFzdCk7CgogICAgICBpZiAoIWRlZikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuIGRlZi5hbGxvd0F0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IChgZWxlbWVudFRvTWVyZ2VgKSBjYW4gYmUgbWVyZ2VkIHdpdGggdGhlIHNwZWNpZmllZCBiYXNlIGVsZW1lbnQgKGBwb3NpdGlvbk9yQmFzZUVsZW1lbnRgKS4KICAgICAqCiAgICAgKiBJbiBvdGhlciB3b3JkcyAmbWRhc2g7IHdoZXRoZXIgYGVsZW1lbnRUb01lcmdlYCdzIGNoaWxkcmVuIHtAbGluayAjY2hlY2tDaGlsZCBhcmUgYWxsb3dlZH0gaW4gdGhlIGBwb3NpdGlvbk9yQmFzZUVsZW1lbnRgLgogICAgICoKICAgICAqIFRoaXMgY2hlY2sgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIG1lcmdlZCB3aXRoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjbWVyZ2UgYFdyaXRlciNtZXJnZSgpYH0KICAgICAqIHdpbGwgYmUgdmFsaWQuCiAgICAgKgogICAgICogSW5zdGVhZCBvZiBlbGVtZW50cywgeW91IGNhbiBwYXNzIHRoZSBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGNsYXNzIGFzIHRoZQogICAgICogYHBvc2l0aW9uT3JCYXNlRWxlbWVudGAuIEl0IG1lYW5zIHRoYXQgdGhlIGVsZW1lbnRzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCB3aGV0aGVyIHRoZXkgY2FuIGJlIG1lcmdlZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBvc2l0aW9uT3JCYXNlRWxlbWVudCBUaGUgcG9zaXRpb24gb3IgYmFzZQogICAgICogZWxlbWVudCB0byB3aGljaCB0aGUgYGVsZW1lbnRUb01lcmdlYCB3aWxsIGJlIG1lcmdlZC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnRUb01lcmdlIFRoZSBlbGVtZW50IHRvIG1lcmdlLiBSZXF1aXJlZCBpZiBgcG9zaXRpb25PckJhc2VFbGVtZW50YCBpcyBhbiBlbGVtZW50LgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2hlY2tNZXJnZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tNZXJnZShwb3NpdGlvbk9yQmFzZUVsZW1lbnQpIHsKICAgICAgdmFyIGVsZW1lbnRUb01lcmdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsOwoKICAgICAgaWYgKHBvc2l0aW9uT3JCYXNlRWxlbWVudCBpbnN0YW5jZW9mIFBvc2l0aW9uKSB7CiAgICAgICAgdmFyIG5vZGVCZWZvcmUgPSBwb3NpdGlvbk9yQmFzZUVsZW1lbnQubm9kZUJlZm9yZTsKICAgICAgICB2YXIgbm9kZUFmdGVyID0gcG9zaXRpb25PckJhc2VFbGVtZW50Lm5vZGVBZnRlcjsKCiAgICAgICAgaWYgKCEobm9kZUJlZm9yZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7CiAgICAgICAgICAvKioKICAgICAgICAgICAqIFRoZSBub2RlIGJlZm9yZSB0aGUgbWVyZ2UgcG9zaXRpb24gbXVzdCBiZSBhbiBlbGVtZW50LgogICAgICAgICAgICoKICAgICAgICAgICAqIEBlcnJvciBzY2hlbWEtY2hlY2stbWVyZ2Utbm8tZWxlbWVudC1iZWZvcmUKICAgICAgICAgICAqLwogICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3NjaGVtYS1jaGVjay1tZXJnZS1uby1lbGVtZW50LWJlZm9yZScsIHRoaXMpOwogICAgICAgIH0KCiAgICAgICAgaWYgKCEobm9kZUFmdGVyIGluc3RhbmNlb2YgRWxlbWVudCkpIHsKICAgICAgICAgIC8qKgogICAgICAgICAgICogVGhlIG5vZGUgYWZ0ZXIgdGhlIG1lcmdlIHBvc2l0aW9uIG11c3QgYmUgYW4gZWxlbWVudC4KICAgICAgICAgICAqCiAgICAgICAgICAgKiBAZXJyb3Igc2NoZW1hLWNoZWNrLW1lcmdlLW5vLWVsZW1lbnQtYWZ0ZXIKICAgICAgICAgICAqLwogICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3NjaGVtYS1jaGVjay1tZXJnZS1uby1lbGVtZW50LWFmdGVyJywgdGhpcyk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdGhpcy5jaGVja01lcmdlKG5vZGVCZWZvcmUsIG5vZGVBZnRlcik7CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlbGVtZW50VG9NZXJnZS5nZXRDaGlsZHJlbigpKSwKICAgICAgICAgIF9zdGVwOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7CgogICAgICAgICAgaWYgKCF0aGlzLmNoZWNrQ2hpbGQocG9zaXRpb25PckJhc2VFbGVtZW50LCBjaGlsZCkpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8qKgogICAgICogQWxsb3dzIHJlZ2lzdGVyaW5nIGEgY2FsbGJhY2sgdG8gdGhlIHtAbGluayAjY2hlY2tDaGlsZH0gbWV0aG9kIGNhbGxzLgogICAgICoKICAgICAqIENhbGxiYWNrcyBhbGxvdyB5b3UgdG8gaW1wbGVtZW50IHJ1bGVzIHdoaWNoIGFyZSBub3Qgb3RoZXJ3aXNlIHBvc3NpYmxlIHRvIGFjaGlldmUKICAgICAqIGJ5IHVzaW5nIHRoZSBkZWNsYXJhdGl2ZSBBUEkgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufS4KICAgICAqIEZvciBleGFtcGxlLCBieSB1c2luZyB0aGlzIG1ldGhvZCB5b3UgY2FuIGRpc2FsbG93IGVsZW1lbnRzIGluIHNwZWNpZmljIGNvbnRleHRzLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc2hvcnRoYW5kIGZvciB1c2luZyB0aGUge0BsaW5rICNldmVudDpjaGVja0NoaWxkfSBldmVudC4gRm9yIGV2ZW4gYmV0dGVyIGNvbnRyb2wsCiAgICAgKiB5b3UgY2FuIHVzZSB0aGF0IGV2ZW50IGluc3RlYWQuCiAgICAgKgogICAgICogRXhhbXBsZToKICAgICAqCiAgICAgKgkJLy8gRGlzYWxsb3cgaGVhZGluZzEgZGlyZWN0bHkgaW5zaWRlIGEgYmxvY2tRdW90ZS4KICAgICAqCQlzY2hlbWEuYWRkQ2hpbGRDaGVjayggKCBjb250ZXh0LCBjaGlsZERlZmluaXRpb24gKSA9PiB7CiAgICAgKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2Jsb2NrUXVvdGUnICkgJiYgY2hpbGREZWZpbml0aW9uLm5hbWUgPT0gJ2hlYWRpbmcxJyApIHsKICAgICAqCQkJCXJldHVybiBmYWxzZTsKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBXaGljaCB0cmFuc2xhdGVzIHRvOgogICAgICoKICAgICAqCQlzY2hlbWEub24oICdjaGVja0NoaWxkJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAgICAgKgkJCWNvbnN0IGNvbnRleHQgPSBhcmdzWyAwIF07CiAgICAgKgkJCWNvbnN0IGNoaWxkRGVmaW5pdGlvbiA9IGFyZ3NbIDEgXTsKICAgICAqCiAgICAgKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2Jsb2NrUXVvdGUnICkgJiYgY2hpbGREZWZpbml0aW9uICYmIGNoaWxkRGVmaW5pdGlvbi5uYW1lID09ICdoZWFkaW5nMScgKSB7CiAgICAgKgkJCQkvLyBQcmV2ZW50IG5leHQgbGlzdGVuZXJzIGZyb20gYmVpbmcgY2FsbGVkLgogICAgICoJCQkJZXZ0LnN0b3AoKTsKICAgICAqCQkJCS8vIFNldCB0aGUgY2hlY2tDaGlsZCgpJ3MgcmV0dXJuIHZhbHVlLgogICAgICoJCQkJZXZ0LnJldHVybiA9IGZhbHNlOwogICAgICoJCQl9CiAgICAgKgkJfSwgeyBwcmlvcml0eTogJ2hpZ2gnIH0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkLiBJdCBpcyBjYWxsZWQgd2l0aCB0d28gcGFyYW1ldGVyczoKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0fSAoY29udGV4dCkgaW5zdGFuY2UgYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbn0gKGNoaWxkLXRvLWNoZWNrIGRlZmluaXRpb24pLgogICAgICogVGhlIGNhbGxiYWNrIG1heSByZXR1cm4gYHRydWUvZmFsc2VgIHRvIG92ZXJyaWRlIGBjaGVja0NoaWxkKClgJ3MgcmV0dXJuIHZhbHVlLiBJZiBpdCBkb2VzIG5vdCByZXR1cm4KICAgICAqIGEgYm9vbGVhbiB2YWx1ZSwgdGhlIGRlZmF1bHQgYWxnb3JpdGhtIChvciBvdGhlciBjYWxsYmFja3MpIHdpbGwgZGVmaW5lIGBjaGVja0NoaWxkKClgJ3MgcmV0dXJuIHZhbHVlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImFkZENoaWxkQ2hlY2siLAogICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENoaWxkQ2hlY2soY2FsbGJhY2spIHsKICAgICAgdGhpcy5vbignY2hlY2tDaGlsZCcsIGZ1bmN0aW9uIChldnQsIF9yZWYpIHsKICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSwKICAgICAgICAgICAgY3R4ID0gX3JlZjJbMF0sCiAgICAgICAgICAgIGNoaWxkRGVmID0gX3JlZjJbMV07CgogICAgICAgIC8vIGNoZWNrQ2hpbGQoKSB3YXMgY2FsbGVkIHdpdGggYSBub24tcmVnaXN0ZXJlZCBjaGlsZC4KICAgICAgICAvLyBJbiA5OSUgY2FzZXMgc3VjaCBjaGVjayBzaG91bGQgcmV0dXJuIGZhbHNlLCBzbyBub3QgdG8gb3ZlcmNvbXBsaWNhdGUgYWxsIGNhbGxiYWNrcwogICAgICAgIC8vIGRvbid0IGV2ZW4gZXhlY3V0ZSB0aGVtLgogICAgICAgIGlmICghY2hpbGREZWYpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIHZhciByZXRWYWx1ZSA9IGNhbGxiYWNrKGN0eCwgY2hpbGREZWYpOwoKICAgICAgICBpZiAodHlwZW9mIHJldFZhbHVlID09ICdib29sZWFuJykgewogICAgICAgICAgZXZ0LnN0b3AoKTsKICAgICAgICAgIGV2dC5yZXR1cm4gPSByZXRWYWx1ZTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBwcmlvcml0eTogJ2hpZ2gnCiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBBbGxvd3MgcmVnaXN0ZXJpbmcgYSBjYWxsYmFjayB0byB0aGUge0BsaW5rICNjaGVja0F0dHJpYnV0ZX0gbWV0aG9kIGNhbGxzLgogICAgICoKICAgICAqIENhbGxiYWNrcyBhbGxvdyB5b3UgdG8gaW1wbGVtZW50IHJ1bGVzIHdoaWNoIGFyZSBub3Qgb3RoZXJ3aXNlIHBvc3NpYmxlIHRvIGFjaGlldmUKICAgICAqIGJ5IHVzaW5nIHRoZSBkZWNsYXJhdGl2ZSBBUEkgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufS4KICAgICAqIEZvciBleGFtcGxlLCBieSB1c2luZyB0aGlzIG1ldGhvZCB5b3UgY2FuIGRpc2FsbG93IGF0dHJpYnV0ZSBpZiBub2RlIHRvIHdoaWNoIGl0IGlzIGFwcGxpZWQKICAgICAqIGlzIGNvbnRhaW5lZCB3aXRoaW4gc29tZSBvdGhlciBlbGVtZW50IChlLmcuIHlvdSB3YW50IHRvIGRpc2FsbG93IGBib2xkYCBvbiBgJHRleHRgIHdpdGhpbiBgaGVhZGluZzFgKS4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlIHtAbGluayAjZXZlbnQ6Y2hlY2tBdHRyaWJ1dGV9IGV2ZW50LiBGb3IgZXZlbiBiZXR0ZXIgY29udHJvbCwKICAgICAqIHlvdSBjYW4gdXNlIHRoYXQgZXZlbnQgaW5zdGVhZC4KICAgICAqCiAgICAgKiBFeGFtcGxlOgogICAgICoKICAgICAqCQkvLyBEaXNhbGxvdyBib2xkIG9uICR0ZXh0IGluc2lkZSBoZWFkaW5nMS4KICAgICAqCQlzY2hlbWEuYWRkQXR0cmlidXRlQ2hlY2soICggY29udGV4dCwgYXR0cmlidXRlTmFtZSApID0+IHsKICAgICAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnaGVhZGluZzEgJHRleHQnICkgJiYgYXR0cmlidXRlTmFtZSA9PSAnYm9sZCcgKSB7CiAgICAgKgkJCQlyZXR1cm4gZmFsc2U7CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogV2hpY2ggdHJhbnNsYXRlcyB0bzoKICAgICAqCiAgICAgKgkJc2NoZW1hLm9uKCAnY2hlY2tBdHRyaWJ1dGUnLCAoIGV2dCwgYXJncyApID0+IHsKICAgICAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICAgICAqCQkJY29uc3QgYXR0cmlidXRlTmFtZSA9IGFyZ3NbIDEgXTsKICAgICAqCiAgICAgKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2hlYWRpbmcxICR0ZXh0JyApICYmIGF0dHJpYnV0ZU5hbWUgPT0gJ2JvbGQnICkgewogICAgICoJCQkJLy8gUHJldmVudCBuZXh0IGxpc3RlbmVycyBmcm9tIGJlaW5nIGNhbGxlZC4KICAgICAqCQkJCWV2dC5zdG9wKCk7CiAgICAgKgkJCQkvLyBTZXQgdGhlIGNoZWNrQXR0cmlidXRlKCkncyByZXR1cm4gdmFsdWUuCiAgICAgKgkJCQlldnQucmV0dXJuID0gZmFsc2U7CiAgICAgKgkJCX0KICAgICAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQuIEl0IGlzIGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IChjb250ZXh0KSBpbnN0YW5jZSBhbmQgYXR0cmlidXRlIG5hbWUuCiAgICAgKiBUaGUgY2FsbGJhY2sgbWF5IHJldHVybiBgdHJ1ZS9mYWxzZWAgdG8gb3ZlcnJpZGUgYGNoZWNrQXR0cmlidXRlKClgJ3MgcmV0dXJuIHZhbHVlLiBJZiBpdCBkb2VzIG5vdCByZXR1cm4KICAgICAqIGEgYm9vbGVhbiB2YWx1ZSwgdGhlIGRlZmF1bHQgYWxnb3JpdGhtIChvciBvdGhlciBjYWxsYmFja3MpIHdpbGwgZGVmaW5lIGBjaGVja0F0dHJpYnV0ZSgpYCdzIHJldHVybiB2YWx1ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJhZGRBdHRyaWJ1dGVDaGVjayIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXR0cmlidXRlQ2hlY2soY2FsbGJhY2spIHsKICAgICAgdGhpcy5vbignY2hlY2tBdHRyaWJ1dGUnLCBmdW5jdGlvbiAoZXZ0LCBfcmVmMykgewogICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSwKICAgICAgICAgICAgY3R4ID0gX3JlZjRbMF0sCiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBfcmVmNFsxXTsKCiAgICAgICAgdmFyIHJldFZhbHVlID0gY2FsbGJhY2soY3R4LCBhdHRyaWJ1dGVOYW1lKTsKCiAgICAgICAgaWYgKHR5cGVvZiByZXRWYWx1ZSA9PSAnYm9vbGVhbicpIHsKICAgICAgICAgIGV2dC5zdG9wKCk7CiAgICAgICAgICBldnQucmV0dXJuID0gcmV0VmFsdWU7CiAgICAgICAgfQogICAgICB9LCB7CiAgICAgICAgcHJpb3JpdHk6ICdoaWdoJwogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGFzc2lnbmluZyBhZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHRoZSBtb2RlbCBhdHRyaWJ1dGVzLiBGb3IgZXhhbXBsZSwKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5BdHRyaWJ1dGVQcm9wZXJ0aWVzIGBBdHRyaWJ1dGVQcm9wZXJ0aWVzI2lzRm9ybWF0dGluZ2AgcHJvcGVydHl9IGlzCiAgICAgKiB1c2VkIHRvIG1hcmsgZm9ybWF0dGluZyBhdHRyaWJ1dGVzIChsaWtlIGBib2xkYCBvciBgaXRhbGljYCkuCiAgICAgKgogICAgICoJCS8vIE1hcmsgYm9sZCBhcyBhIGZvcm1hdHRpbmcgYXR0cmlidXRlLgogICAgICoJCXNjaGVtYS5zZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKCAnYm9sZCcsIHsKICAgICAqCQkJaXNGb3JtYXR0aW5nOiB0cnVlCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBPdmVycmlkZSBjb2RlIG5vdCB0byBiZSBjb25zaWRlcmVkIGEgZm9ybWF0dGluZyBtYXJrdXAuCiAgICAgKgkJc2NoZW1hLnNldEF0dHJpYnV0ZVByb3BlcnRpZXMoICdjb2RlJywgewogICAgICoJCQlpc0Zvcm1hdHRpbmc6IGZhbHNlCiAgICAgKgkJfSApOwogICAgICoKICAgICAqIFByb3BlcnRpZXMgYXJlIG5vdCBsaW1pdGVkIHRvIG1lbWJlcnMgZGVmaW5lZCBpbiB0aGUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5BdHRyaWJ1dGVQcm9wZXJ0aWVzIGBBdHRyaWJ1dGVQcm9wZXJ0aWVzYCB0eXBlfSBhbmQgeW91IGNhbiBhbHNvIHVzZSBjdXN0b20gcHJvcGVydGllczoKICAgICAqCiAgICAgKgkJc2NoZW1hLnNldEF0dHJpYnV0ZVByb3BlcnRpZXMoICdibG9ja1F1b3RlJywgewogICAgICoJCQljdXN0b21Qcm9wZXJ0eTogJ3ZhbHVlJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIHdpdGggdGhlIHNhbWUgYXR0cmlidXRlIHdpbGwgZXh0ZW5kIGl0cyBjdXN0b20gcHJvcGVydGllczoKICAgICAqCiAgICAgKgkJc2NoZW1hLnNldEF0dHJpYnV0ZVByb3BlcnRpZXMoICdibG9ja1F1b3RlJywgewogICAgICoJCQlvbmU6IDEKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCXNjaGVtYS5zZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKCAnYmxvY2tRdW90ZScsIHsKICAgICAqCQkJdHdvOiAyCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQljb25zb2xlLmxvZyggc2NoZW1hLmdldEF0dHJpYnV0ZVByb3BlcnRpZXMoICdibG9ja1F1b3RlJyApICk7CiAgICAgKgkJLy8gTG9nczogeyBvbmU6IDEsIHR3bzogMiB9CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgQSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gcmVjZWl2ZSB0aGUgcHJvcGVydGllcy4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+QXR0cmlidXRlUHJvcGVydGllc30gcHJvcGVydGllcyBBIGRpY3Rpb25hcnkgb2YgcHJvcGVydGllcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKGF0dHJpYnV0ZU5hbWUsIHByb3BlcnRpZXMpIHsKICAgICAgdGhpcy5fYXR0cmlidXRlUHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IE9iamVjdC5hc3NpZ24odGhpcy5nZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKGF0dHJpYnV0ZU5hbWUpLCBwcm9wZXJ0aWVzKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIG1vZGVsIGF0dHJpYnV0ZS4gU2VlIHtAbGluayAjc2V0QXR0cmlidXRlUHJvcGVydGllcyBgc2V0QXR0cmlidXRlUHJvcGVydGllcygpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgQSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+QXR0cmlidXRlUHJvcGVydGllc30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKGF0dHJpYnV0ZU5hbWUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZVByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gfHwge307CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIGxvd2VzdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzTGltaXQgbGltaXQgZWxlbWVudH0gY29udGFpbmluZyB0aGUgZW50aXJlCiAgICAgKiBzZWxlY3Rpb24vcmFuZ2UvcG9zaXRpb24gb3IgdGhlIHJvb3Qgb3RoZXJ3aXNlLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb258CiAgICAgKiBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHNlbGVjdGlvbk9yUmFuZ2VPclBvc2l0aW9uCiAgICAgKiBUaGUgc2VsZWN0aW9uL3JhbmdlL3Bvc2l0aW9uIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBUaGUgbG93ZXN0IGxpbWl0IGVsZW1lbnQgY29udGFpbmluZwogICAgICogdGhlIGVudGlyZSBgc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb25gLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldExpbWl0RWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGltaXRFbGVtZW50KHNlbGVjdGlvbk9yUmFuZ2VPclBvc2l0aW9uKSB7CiAgICAgIHZhciBlbGVtZW50OwoKICAgICAgaWYgKHNlbGVjdGlvbk9yUmFuZ2VPclBvc2l0aW9uIGluc3RhbmNlb2YgUG9zaXRpb24pIHsKICAgICAgICBlbGVtZW50ID0gc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb24ucGFyZW50OwogICAgICB9IGVsc2UgewogICAgICAgIHZhciByYW5nZXMgPSBzZWxlY3Rpb25PclJhbmdlT3JQb3NpdGlvbiBpbnN0YW5jZW9mIFJhbmdlID8gW3NlbGVjdGlvbk9yUmFuZ2VPclBvc2l0aW9uXSA6IEFycmF5LmZyb20oc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb24uZ2V0UmFuZ2VzKCkpOyAvLyBGaW5kIHRoZSBjb21tb24gYW5jZXN0b3IgZm9yIGFsbCBzZWxlY3Rpb24ncyByYW5nZXMuCgogICAgICAgIGVsZW1lbnQgPSByYW5nZXMucmVkdWNlKGZ1bmN0aW9uIChlbGVtZW50LCByYW5nZSkgewogICAgICAgICAgdmFyIHJhbmdlQ29tbW9uQW5jZXN0b3IgPSByYW5nZS5nZXRDb21tb25BbmNlc3RvcigpOwoKICAgICAgICAgIGlmICghZWxlbWVudCkgewogICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21tb25BbmNlc3RvcjsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRDb21tb25BbmNlc3RvcihyYW5nZUNvbW1vbkFuY2VzdG9yLCB7CiAgICAgICAgICAgIGluY2x1ZGVTZWxmOiB0cnVlCiAgICAgICAgICB9KTsKICAgICAgICB9LCBudWxsKTsKICAgICAgfQoKICAgICAgd2hpbGUgKCF0aGlzLmlzTGltaXQoZWxlbWVudCkpIHsKICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnQpIHsKICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gZWxlbWVudDsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBpcyBhbGxvd2VkIGluIHNlbGVjdGlvbjoKICAgICAqCiAgICAgKiAqIGlmIHRoZSBzZWxlY3Rpb24gaXMgbm90IGNvbGxhcHNlZCwgdGhlbiBjaGVja3MgaWYgdGhlIGF0dHJpYnV0ZSBpcyBhbGxvd2VkIG9uIGFueSBvZiBub2RlcyBpbiB0aGF0IHJhbmdlLAogICAgICogKiBpZiB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZCwgdGhlbiBjaGVja3MgaWYgb24gdGhlIHNlbGVjdGlvbiBwb3NpdGlvbiB0aGVyZSdzIGEgdGV4dCB3aXRoIHRoZQogICAgICogc3BlY2lmaWVkIGF0dHJpYnV0ZSBhbGxvd2VkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb259IHNlbGVjdGlvbgogICAgICogU2VsZWN0aW9uIHdoaWNoIHdpbGwgYmUgY2hlY2tlZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImNoZWNrQXR0cmlidXRlSW5TZWxlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQXR0cmlidXRlSW5TZWxlY3Rpb24oc2VsZWN0aW9uLCBhdHRyaWJ1dGUpIHsKICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkgewogICAgICAgIHZhciBmaXJzdFBvc2l0aW9uID0gc2VsZWN0aW9uLmdldEZpcnN0UG9zaXRpb24oKTsKICAgICAgICB2YXIgY29udGV4dCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZmlyc3RQb3NpdGlvbi5nZXRBbmNlc3RvcnMoKSksIFtuZXcgVGV4dCgnJywgc2VsZWN0aW9uLmdldEF0dHJpYnV0ZXMoKSldKTsgLy8gQ2hlY2sgd2hldGhlciBzY2hlbWEgYWxsb3dzIGZvciBhIHRleHQgd2l0aCB0aGUgYXR0cmlidXRlIGluIHRoZSBzZWxlY3Rpb24uCgogICAgICAgIHJldHVybiB0aGlzLmNoZWNrQXR0cmlidXRlKGNvbnRleHQsIGF0dHJpYnV0ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIHJhbmdlcyA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKTsgLy8gRm9yIGFsbCByYW5nZXMsIGNoZWNrIG5vZGVzIGluIHRoZW0gdW50aWwgeW91IGZpbmQgYSBub2RlIHRoYXQgaXMgYWxsb3dlZCB0byBoYXZlIHRoZSBhdHRyaWJ1dGUuCgogICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocmFuZ2VzKSwKICAgICAgICAgICAgX3N0ZXAyOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIHJhbmdlID0gX3N0ZXAyLnZhbHVlOwoKICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyYW5nZSksCiAgICAgICAgICAgICAgICBfc3RlcDM7CgogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDMudmFsdWU7CgogICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tBdHRyaWJ1dGUodmFsdWUuaXRlbSwgYXR0cmlidXRlKSkgewogICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIG5vZGUgdGhhdCBpcyBhbGxvd2VkIHRvIGhhdmUgdGhlIGF0dHJpYnV0ZSwgcmV0dXJuIHRydWUuCiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTsKICAgICAgICB9CiAgICAgIH0gLy8gSWYgd2UgaGF2ZW4ndCBmb3VuZCBzdWNoIG5vZGUsIHJldHVybiBmYWxzZS4KCgogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHNldCBvZiByYW5nZXMgaW50byBhIHNldCBvZiByYW5nZXMgd2hlcmUgdGhlIGdpdmVuIGF0dHJpYnV0ZSBpcyBhbGxvd2VkIChhbmQgY2FuIGJlIGFwcGxpZWQpLgogICAgICoKICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSByYW5nZXMgUmFuZ2VzIHRvIGJlIHZhbGlkYXRlZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFJhbmdlcyBpbiB3aGljaCB0aGUgYXR0cmlidXRlIGlzIGFsbG93ZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0VmFsaWRSYW5nZXMiLAogICAgdmFsdWU6CiAgICAvKiNfX1BVUkVfXyovCiAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBnZXRWYWxpZFJhbmdlcyhyYW5nZXMsIGF0dHJpYnV0ZSkgewogICAgICB2YXIgX2l0ZXJhdG9yNCwgX3N0ZXA0LCByYW5nZTsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRWYWxpZFJhbmdlcyQoX2NvbnRleHQpIHsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgcmFuZ2VzID0gY29udmVydFRvTWluaW1hbEZsYXRSYW5nZXMocmFuZ2VzKTsKICAgICAgICAgICAgICBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocmFuZ2VzKTsKICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjsKCiAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5zKCk7CgogICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgaWYgKChfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHJhbmdlID0gX3N0ZXA0LnZhbHVlOwogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKHRoaXMuX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UocmFuZ2UsIGF0dHJpYnV0ZSksICJ0MCIsIDcpOwoKICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSA5OgogICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExOwogICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbImNhdGNoIl0oMik7CgogICAgICAgICAgICAgIF9pdGVyYXRvcjQuZShfY29udGV4dC50MSk7CgogICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNDsKCiAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7CgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMTQpOwoKICAgICAgICAgICAgY2FzZSAxNzoKICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZ2V0VmFsaWRSYW5nZXMsIHRoaXMsIFtbMiwgMTEsIDE0LCAxN11dKTsKICAgIH0pCiAgICAvKioKICAgICAqIEJhc2luZyBvbiBnaXZlbiBgcG9zaXRpb25gLCBmaW5kcyBhbmQgcmV0dXJucyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfSB3aGljaCBpcwogICAgICogbmVhcmVzdCB0byB0aGF0IGBwb3NpdGlvbmAgYW5kIGlzIGEgY29ycmVjdCByYW5nZSBmb3Igc2VsZWN0aW9uLgogICAgICoKICAgICAqIFRoZSBjb3JyZWN0IHNlbGVjdGlvbiByYW5nZSBtaWdodCBiZSBjb2xsYXBzZWQgd2hlbiBpdCBpcyBsb2NhdGVkIGluIGEgcG9zaXRpb24gd2hlcmUgdGhlIHRleHQgbm9kZSBjYW4gYmUgcGxhY2VkLgogICAgICogTm9uLWNvbGxhcHNlZCByYW5nZSBpcyByZXR1cm5lZCB3aGVuIHNlbGVjdGlvbiBjYW4gYmUgcGxhY2VkIGFyb3VuZCBlbGVtZW50IG1hcmtlZCBhcyBhbiAib2JqZWN0IiBpbgogICAgICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfS4KICAgICAqCiAgICAgKiBEaXJlY3Rpb24gb2Ygc2VhcmNoaW5nIGZvciB0aGUgbmVhcmVzdCBjb3JyZWN0IHNlbGVjdGlvbiByYW5nZSBjYW4gYmUgc3BlY2lmaWVkIGFzOgogICAgICoKICAgICAqICogYGJvdGhgIC0gc2VhcmNoaW5nIHdpbGwgYmUgcGVyZm9ybWVkIGluIGJvdGggd2F5cywKICAgICAqICogYGZvcndhcmRgIC0gc2VhcmNoaW5nIHdpbGwgYmUgcGVyZm9ybWVkIG9ubHkgZm9yd2FyZCwKICAgICAqICogYGJhY2t3YXJkYCAtIHNlYXJjaGluZyB3aWxsIGJlIHBlcmZvcm1lZCBvbmx5IGJhY2t3YXJkLgogICAgICoKICAgICAqIFdoZW4gdmFsaWQgc2VsZWN0aW9uIHJhbmdlIGNhbm5vdCBiZSBmb3VuZCwgYG51bGxgIGlzIHJldHVybmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUmVmZXJlbmNlIHBvc2l0aW9uIHdoZXJlIG5ldyBzZWxlY3Rpb24gcmFuZ2Ugc2hvdWxkIGJlIGxvb2tlZCBmb3IuCiAgICAgKiBAcGFyYW0geydib3RoJ3wnZm9yd2FyZCd8J2JhY2t3YXJkJ30gW2RpcmVjdGlvbj0nYm90aCddIFNlYXJjaCBkaXJlY3Rpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxudWxsfSBOZWFyZXN0IHNlbGVjdGlvbiByYW5nZSBvciBgbnVsbGAgaWYgb25lIGNhbm5vdCBiZSBmb3VuZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXROZWFyZXN0U2VsZWN0aW9uUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5lYXJlc3RTZWxlY3Rpb25SYW5nZShwb3NpdGlvbikgewogICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgIHZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdib3RoJzsKCiAgICAgIC8vIFJldHVybiBjb2xsYXBzZWQgcmFuZ2UgaWYgcHJvdmlkZWQgcG9zaXRpb24gaXMgdmFsaWQuCiAgICAgIGlmICh0aGlzLmNoZWNrQ2hpbGQocG9zaXRpb24sICckdGV4dCcpKSB7CiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHZhciBiYWNrd2FyZFdhbGtlciwgZm9yd2FyZFdhbGtlcjsgLy8gTmV2ZXIgbGVhdmUgYSBsaW1pdCBlbGVtZW50LgoKICAgICAgdmFyIGxpbWl0RWxlbWVudCA9IHBvc2l0aW9uLmdldEFuY2VzdG9ycygpLnJldmVyc2UoKS5maW5kKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgcmV0dXJuIF90aGlzMi5pc0xpbWl0KGl0ZW0pOwogICAgICB9KSB8fCBwb3NpdGlvbi5yb290OwoKICAgICAgaWYgKGRpcmVjdGlvbiA9PSAnYm90aCcgfHwgZGlyZWN0aW9uID09ICdiYWNrd2FyZCcpIHsKICAgICAgICBiYWNrd2FyZFdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKHsKICAgICAgICAgIGJvdW5kYXJpZXM6IFJhbmdlLl9jcmVhdGVJbihsaW1pdEVsZW1lbnQpLAogICAgICAgICAgc3RhcnRQb3NpdGlvbjogcG9zaXRpb24sCiAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCcKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgaWYgKGRpcmVjdGlvbiA9PSAnYm90aCcgfHwgZGlyZWN0aW9uID09ICdmb3J3YXJkJykgewogICAgICAgIGZvcndhcmRXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcih7CiAgICAgICAgICBib3VuZGFyaWVzOiBSYW5nZS5fY3JlYXRlSW4obGltaXRFbGVtZW50KSwKICAgICAgICAgIHN0YXJ0UG9zaXRpb246IHBvc2l0aW9uCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY29tYmluZVdhbGtlcnMoYmFja3dhcmRXYWxrZXIsIGZvcndhcmRXYWxrZXIpKSwKICAgICAgICAgIF9zdGVwNTsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBkYXRhID0gX3N0ZXA1LnZhbHVlOwogICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLndhbGtlciA9PSBiYWNrd2FyZFdhbGtlciA/ICdlbGVtZW50RW5kJyA6ICdlbGVtZW50U3RhcnQnOwogICAgICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZTsKCiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSB0eXBlICYmIHRoaXMuaXNPYmplY3QodmFsdWUuaXRlbSkpIHsKICAgICAgICAgICAgcmV0dXJuIFJhbmdlLl9jcmVhdGVPbih2YWx1ZS5pdGVtKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAodGhpcy5jaGVja0NoaWxkKHZhbHVlLm5leHRQb3NpdGlvbiwgJyR0ZXh0JykpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh2YWx1ZS5uZXh0UG9zaXRpb24pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBUcmllcyB0byBmaW5kIHBvc2l0aW9uIGFuY2VzdG9ycyB0aGF0IGFsbG93IHRvIGluc2VydCBhIGdpdmVuIG5vZGUuCiAgICAgKiBJdCBzdGFydHMgc2VhcmNoaW5nIGZyb20gdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBnb2VzIG5vZGUgYnkgbm9kZSB0byB0aGUgdG9wIG9mIHRoZSBtb2RlbCB0cmVlCiAgICAgKiBhcyBsb25nIGFzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc0xpbWl0IGxpbWl0IGVsZW1lbnR9LCBhbgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc09iamVjdCBvYmplY3QgZWxlbWVudH0gb3IgYSB0b3Btb3N0IGFuY2VzdG9yIGlzIG5vdCByZWFjaGVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRoYXQgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IGZyb20uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfFN0cmluZ30gbm9kZSBUaGUgbm9kZSBmb3Igd2hpY2ggYW4gYWxsb3dlZCBwYXJlbnQgc2hvdWxkIGJlIGZvdW5kIG9yIGl0cyBuYW1lLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG51bGx9IGVsZW1lbnQgQWxsb3dlZCBwYXJlbnQgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmaW5kQWxsb3dlZFBhcmVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFsbG93ZWRQYXJlbnQocG9zaXRpb24sIG5vZGUpIHsKICAgICAgdmFyIHBhcmVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgICAgIHdoaWxlIChwYXJlbnQpIHsKICAgICAgICBpZiAodGhpcy5jaGVja0NoaWxkKHBhcmVudCwgbm9kZSkpIHsKICAgICAgICAgIHJldHVybiBwYXJlbnQ7CiAgICAgICAgfSAvLyBEbyBub3Qgc3BsaXQgbGltaXQgZWxlbWVudHMuCgoKICAgICAgICBpZiAodGhpcy5pc0xpbWl0KHBhcmVudCkpIHsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDsKICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYXR0cmlidXRlcyBkaXNhbGxvd2VkIGJ5IHRoZSBzY2hlbWEuCiAgICAgKgogICAgICogQHBhcmFtIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fSBub2RlcyBOb2RlcyB0aGF0IHdpbGwgYmUgZmlsdGVyZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlRGlzYWxsb3dlZEF0dHJpYnV0ZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZURpc2FsbG93ZWRBdHRyaWJ1dGVzKG5vZGVzLCB3cml0ZXIpIHsKICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihub2RlcyksCiAgICAgICAgICBfc3RlcDY7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwNi52YWx1ZTsKCiAgICAgICAgICAvLyBXaGVuIG5vZGUgaXMgYSBgVGV4dGAgaXQgaGFzIG5vIGNoaWxkcmVuLCBzbyBqdXN0IGZpbHRlciBpdCBvdXQuCiAgICAgICAgICBpZiAobm9kZS5pcygnJHRleHQnKSkgewogICAgICAgICAgICByZW1vdmVEaXNhbGxvd2VkQXR0cmlidXRlRnJvbU5vZGUodGhpcywgbm9kZSwgd3JpdGVyKTsKICAgICAgICAgIH0gLy8gSW4gYSBjYXNlIG9mIGBFbGVtZW50YCBpdGVyYXRlcyB0aHJvdWdoIHBvc2l0aW9ucyBiZXR3ZWVuIG5vZGVzIGluc2lkZSB0aGlzIGVsZW1lbnQKICAgICAgICAgIC8vIGFuZCBmaWx0ZXIgb3V0IG5vZGUgYmVmb3JlIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBvciBwb3NpdGlvbiBwYXJlbnQgd2hlbiBwb3NpdGlvbgogICAgICAgICAgLy8gaXMgYXQgc3RhcnQgb2YgYW4gZWxlbWVudC4gVXNpbmcgcG9zaXRpb25zIHByZXZlbnQgZnJvbSBvbWl0dGluZyBtZXJnZWQgbm9kZXMKICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9pc3N1ZXMvMTc4OS4KICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHZhciByYW5nZUluTm9kZSA9IFJhbmdlLl9jcmVhdGVJbihub2RlKTsKCiAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uc0luUmFuZ2UgPSByYW5nZUluTm9kZS5nZXRQb3NpdGlvbnMoKTsKCiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwb3NpdGlvbnNJblJhbmdlKSwKICAgICAgICAgICAgICAgICAgX3N0ZXA3OwoKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gX3N0ZXA3LnZhbHVlOwogICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHBvc2l0aW9uLm5vZGVCZWZvcmUgfHwgcG9zaXRpb24ucGFyZW50OwogICAgICAgICAgICAgICAgICByZW1vdmVEaXNhbGxvd2VkQXR0cmlidXRlRnJvbU5vZGUodGhpcywgaXRlbSwgd3JpdGVyKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcuZShlcnIpOwogICAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LmYoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjYuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjYuZigpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHNjaGVtYSBjb250ZXh0LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb259IGNvbnRleHQKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0fQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZUNvbnRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoY29udGV4dCkgewogICAgICByZXR1cm4gbmV3IFNjaGVtYUNvbnRleHQoY29udGV4dCk7CiAgICB9CiAgICAvKioKICAgICAqIEBwcml2YXRlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NsZWFyQ2FjaGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhckNhY2hlKCkgewogICAgICB0aGlzLl9jb21waWxlZERlZmluaXRpb25zID0gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQHByaXZhdGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY29tcGlsZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7CiAgICAgIHZhciBjb21waWxlZERlZmluaXRpb25zID0ge307CiAgICAgIHZhciBzb3VyY2VSdWxlcyA9IHRoaXMuX3NvdXJjZURlZmluaXRpb25zOwogICAgICB2YXIgaXRlbU5hbWVzID0gT2JqZWN0LmtleXMoc291cmNlUnVsZXMpOwoKICAgICAgZm9yICh2YXIgX2kgPSAwLCBfaXRlbU5hbWVzID0gaXRlbU5hbWVzOyBfaSA8IF9pdGVtTmFtZXMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgdmFyIGl0ZW1OYW1lID0gX2l0ZW1OYW1lc1tfaV07CiAgICAgICAgY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0gPSBjb21waWxlQmFzZUl0ZW1SdWxlKHNvdXJjZVJ1bGVzW2l0ZW1OYW1lXSwgaXRlbU5hbWUpOwogICAgICB9CgogICAgICBmb3IgKHZhciBfaTIgPSAwLCBfaXRlbU5hbWVzMiA9IGl0ZW1OYW1lczsgX2kyIDwgX2l0ZW1OYW1lczIubGVuZ3RoOyBfaTIrKykgewogICAgICAgIHZhciBfaXRlbU5hbWUgPSBfaXRlbU5hbWVzMltfaTJdOwogICAgICAgIGNvbXBpbGVBbGxvd0NvbnRlbnRPZihjb21waWxlZERlZmluaXRpb25zLCBfaXRlbU5hbWUpOwogICAgICB9CgogICAgICBmb3IgKHZhciBfaTMgPSAwLCBfaXRlbU5hbWVzMyA9IGl0ZW1OYW1lczsgX2kzIDwgX2l0ZW1OYW1lczMubGVuZ3RoOyBfaTMrKykgewogICAgICAgIHZhciBfaXRlbU5hbWUyID0gX2l0ZW1OYW1lczNbX2kzXTsKICAgICAgICBjb21waWxlQWxsb3dXaGVyZShjb21waWxlZERlZmluaXRpb25zLCBfaXRlbU5hbWUyKTsKICAgICAgfQoKICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX2l0ZW1OYW1lczQgPSBpdGVtTmFtZXM7IF9pNCA8IF9pdGVtTmFtZXM0Lmxlbmd0aDsgX2k0KyspIHsKICAgICAgICB2YXIgX2l0ZW1OYW1lMyA9IF9pdGVtTmFtZXM0W19pNF07CiAgICAgICAgY29tcGlsZUFsbG93QXR0cmlidXRlc09mKGNvbXBpbGVkRGVmaW5pdGlvbnMsIF9pdGVtTmFtZTMpOwogICAgICAgIGNvbXBpbGVJbmhlcml0UHJvcGVydGllc0Zyb20oY29tcGlsZWREZWZpbml0aW9ucywgX2l0ZW1OYW1lMyk7CiAgICAgIH0KCiAgICAgIGZvciAodmFyIF9pNSA9IDAsIF9pdGVtTmFtZXM1ID0gaXRlbU5hbWVzOyBfaTUgPCBfaXRlbU5hbWVzNS5sZW5ndGg7IF9pNSsrKSB7CiAgICAgICAgdmFyIF9pdGVtTmFtZTQgPSBfaXRlbU5hbWVzNVtfaTVdOwogICAgICAgIGNsZWFuVXBBbGxvd0luKGNvbXBpbGVkRGVmaW5pdGlvbnMsIF9pdGVtTmFtZTQpOwogICAgICAgIGNsZWFuVXBBbGxvd0F0dHJpYnV0ZXMoY29tcGlsZWREZWZpbml0aW9ucywgX2l0ZW1OYW1lNCk7CiAgICAgIH0KCiAgICAgIHRoaXMuX2NvbXBpbGVkRGVmaW5pdGlvbnMgPSBjb21waWxlZERlZmluaXRpb25zOwogICAgfQogICAgLyoqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb21waWxlZEl0ZW1EZWZpbml0aW9ufSBkZWYKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0gY29udGV4dAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRleHRJdGVtSW5kZXgKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY2hlY2tDb250ZXh0TWF0Y2giLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0NvbnRleHRNYXRjaChkZWYsIGNvbnRleHQpIHsKICAgICAgdmFyIGNvbnRleHRJdGVtSW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGNvbnRleHQubGVuZ3RoIC0gMTsKICAgICAgdmFyIGNvbnRleHRJdGVtID0gY29udGV4dC5nZXRJdGVtKGNvbnRleHRJdGVtSW5kZXgpOwoKICAgICAgaWYgKGRlZi5hbGxvd0luLmluY2x1ZGVzKGNvbnRleHRJdGVtLm5hbWUpKSB7CiAgICAgICAgaWYgKGNvbnRleHRJdGVtSW5kZXggPT0gMCkgewogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBwYXJlbnRSdWxlID0gdGhpcy5nZXREZWZpbml0aW9uKGNvbnRleHRJdGVtKTsKICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0NvbnRleHRNYXRjaChwYXJlbnRSdWxlLCBjb250ZXh0LCBjb250ZXh0SXRlbUluZGV4IC0gMSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBUYWtlcyBhIGZsYXQgcmFuZ2UgYW5kIGFuIGF0dHJpYnV0ZSBuYW1lLiBUcmF2ZXJzZXMgdGhlIHJhbmdlIHJlY3Vyc2l2ZWx5IGFuZCBkZWVwbHkgdG8gZmluZCBhbmQgcmV0dXJuIGFsbCByYW5nZXMKICAgICAqIGluc2lkZSB0aGUgZ2l2ZW4gcmFuZ2Ugb24gd2hpY2ggdGhlIGF0dHJpYnV0ZSBjYW4gYmUgYXBwbGllZC4KICAgICAqCiAgICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB7QGxpbmsgflNjaGVtYSNnZXRWYWxpZFJhbmdlc30uCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UgVGhlIHJhbmdlIHRvIHByb2Nlc3MuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBSYW5nZXMgaW4gd2hpY2ggdGhlIGF0dHJpYnV0ZSBpcyBhbGxvd2VkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRWYWxpZFJhbmdlc0ZvclJhbmdlIiwKICAgIHZhbHVlOgogICAgLyojX19QVVJFX18qLwogICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UocmFuZ2UsIGF0dHJpYnV0ZSkgewogICAgICB2YXIgc3RhcnQsIGVuZCwgX2l0ZXJhdG9yOCwgX3N0ZXA4LCBpdGVtOwoKICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9nZXRWYWxpZFJhbmdlc0ZvclJhbmdlJChfY29udGV4dDIpIHsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7CiAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICBzdGFydCA9IHJhbmdlLnN0YXJ0OwogICAgICAgICAgICAgIGVuZCA9IHJhbmdlLnN0YXJ0OwogICAgICAgICAgICAgIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyYW5nZS5nZXRJdGVtcyh7CiAgICAgICAgICAgICAgICBzaGFsbG93OiB0cnVlCiAgICAgICAgICAgICAgfSkpOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMzsKCiAgICAgICAgICAgICAgX2l0ZXJhdG9yOC5zKCk7CgogICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgaWYgKChfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNzsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgaXRlbSA9IF9zdGVwOC52YWx1ZTsKCiAgICAgICAgICAgICAgaWYgKCFpdGVtLmlzKCdlbGVtZW50JykpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5kZWxlZ2F0ZVlpZWxkKHRoaXMuX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UoUmFuZ2UuX2NyZWF0ZUluKGl0ZW0pLCBhdHRyaWJ1dGUpLCAidDAiLCA5KTsKCiAgICAgICAgICAgIGNhc2UgOToKICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0F0dHJpYnV0ZShpdGVtLCBhdHRyaWJ1dGUpKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBpZiAoc3RhcnQuaXNFcXVhbChlbmQpKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzOwogICAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CgogICAgICAgICAgICBjYXNlIDEzOgogICAgICAgICAgICAgIHN0YXJ0ID0gUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGl0ZW0pOwoKICAgICAgICAgICAgY2FzZSAxNDoKICAgICAgICAgICAgICBlbmQgPSBQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIoaXRlbSk7CgogICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTc6CiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMjsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxOTsKICAgICAgICAgICAgICBfY29udGV4dDIudDEgPSBfY29udGV4dDJbImNhdGNoIl0oMyk7CgogICAgICAgICAgICAgIF9pdGVyYXRvcjguZShfY29udGV4dDIudDEpOwoKICAgICAgICAgICAgY2FzZSAyMjoKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDIyOwoKICAgICAgICAgICAgICBfaXRlcmF0b3I4LmYoKTsKCiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjIpOwoKICAgICAgICAgICAgY2FzZSAyNToKICAgICAgICAgICAgICBpZiAoc3RhcnQuaXNFcXVhbChlbmQpKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI4OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI4OwogICAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CgogICAgICAgICAgICBjYXNlIDI4OgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UsIHRoaXMsIFtbMywgMTksIDIyLCAyNV1dKTsKICAgIH0pCiAgfV0pOwoKICByZXR1cm4gU2NoZW1hOwp9KCk7CgpleHBvcnQgeyBTY2hlbWEgYXMgZGVmYXVsdCB9OwptaXgoU2NoZW1hLCBPYnNlcnZhYmxlTWl4aW4pOwovKioKICogRXZlbnQgZmlyZWQgd2hlbiB0aGUge0BsaW5rICNjaGVja0NoaWxkfSBtZXRob2QgaXMgY2FsbGVkLiBJdCBhbGxvd3MgcGx1Z2dpbmcgaW4KICogYWRkaXRpb25hbCBiZWhhdmlvciwgZm9yIGV4YW1wbGUgaW1wbGVtZW50aW5nIHJ1bGVzIHdoaWNoIGNhbm5vdCBiZSBkZWZpbmVkIHVzaW5nIHRoZSBkZWNsYXJhdGl2ZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGludGVyZmFjZS4KICoKICogKipOb3RlOioqIFRoZSB7QGxpbmsgI2FkZENoaWxkQ2hlY2t9IG1ldGhvZCBpcyBhIG1vcmUgaGFuZHkgd2F5IHRvIHJlZ2lzdGVyIGNhbGxiYWNrcy4gSW50ZXJuYWxseSwKICogaXQgcmVnaXN0ZXJzIGEgbGlzdGVuZXIgdG8gdGhpcyBldmVudCBidXQgY29tZXMgd2l0aCBhIHNpbXBsZXIgQVBJIGFuZCBpdCBpcyB0aGUgcmVjb21tZW5kZWQgY2hvaWNlCiAqIGluIG1vc3Qgb2YgdGhlIGNhc2VzLgogKgogKiBUaGUge0BsaW5rICNjaGVja0NoaWxkfSBtZXRob2QgZmlyZXMgYW4gZXZlbnQgYmVjYXVzZSBpdCBpcwogKiB7QGxpbmsgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4jZGVjb3JhdGUgZGVjb3JhdGVkfSB3aXRoIGl0LiBUaGFua3MgdG8gdGhhdCB5b3UgY2FuCiAqIHVzZSB0aGlzIGV2ZW50IGluIHZhcmlvdXMgd2F5cywgYnV0IHRoZSBtb3N0IGltcG9ydGFudCB1c2UgY2FzZSBpcyBvdmVycmlkaW5nIHN0YW5kYXJkIGJlaGF2aW9yIG9mIHRoZQogKiBgY2hlY2tDaGlsZCgpYCBtZXRob2QuIExldCdzIHNlZSBhIHR5cGljYWwgbGlzdGVuZXIgdGVtcGxhdGU6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0NoaWxkJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICoJCQljb25zdCBjaGlsZERlZmluaXRpb24gPSBhcmdzWyAxIF07CiAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogKgogKiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCBhIGBoaWdoYCBwcmlvcml0eSB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIGRlZmF1bHQgbWV0aG9kIGlzIHJlYWxseSBjYWxsZWQuIFRoZSBgYXJnc2AgY2FsbGJhY2sKICogcGFyYW1ldGVyIGNvbnRhaW5zIGFyZ3VtZW50cyBwYXNzZWQgdG8gYGNoZWNrQ2hpbGQoIGNvbnRleHQsIGNoaWxkIClgLiBIb3dldmVyLCB0aGUgYGNvbnRleHRgIHBhcmFtZXRlciBpcyBhbHJlYWR5CiAqIG5vcm1hbGl6ZWQgdG8gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0gaW5zdGFuY2UgYW5kIGBjaGlsZGAgdG8gYQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbn0gaW5zdGFuY2UsIHNvIHlvdSBkbyBub3QgaGF2ZSB0byB3b3JyeSBhYm91dAogKiB0aGUgdmFyaW91cyB3YXlzIGhvdyBgY29udGV4dGAgYW5kIGBjaGlsZGAgbWF5IGJlIHBhc3NlZCB0byBgY2hlY2tDaGlsZCgpYC4KICoKICogKipOb3RlOioqIGBjaGlsZERlZmluaXRpb25gIG1heSBiZSBgdW5kZWZpbmVkYCBpZiBgY2hlY2tDaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggYSBub24tcmVnaXN0ZXJlZCBlbGVtZW50LgogKgogKiBTbywgaW4gb3JkZXIgdG8gaW1wbGVtZW50IGEgcnVsZSAiZGlzYWxsb3cgYGhlYWRpbmcxYCBpbiBgYmxvY2tRdW90ZWAiLCB5b3UgY2FuIGFkZCBzdWNoIGEgbGlzdGVuZXI6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0NoaWxkJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICoJCQljb25zdCBjaGlsZERlZmluaXRpb24gPSBhcmdzWyAxIF07CiAqCiAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnYmxvY2tRdW90ZScgKSAmJiBjaGlsZERlZmluaXRpb24gJiYgY2hpbGREZWZpbml0aW9uLm5hbWUgPT0gJ2hlYWRpbmcxJyApIHsKICoJCQkJLy8gUHJldmVudCBuZXh0IGxpc3RlbmVycyBmcm9tIGJlaW5nIGNhbGxlZC4KICoJCQkJZXZ0LnN0b3AoKTsKICoJCQkJLy8gU2V0IHRoZSBjaGVja0NoaWxkKCkncyByZXR1cm4gdmFsdWUuCiAqCQkJCWV2dC5yZXR1cm4gPSBmYWxzZTsKICoJCQl9CiAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogKgogKiBBbGxvd2luZyBlbGVtZW50cyBpbiBzcGVjaWZpYyBjb250ZXh0cyB3aWxsIGJlIGEgZmFyIGxlc3MgY29tbW9uIHVzZSBjYXNlLCBiZWNhdXNlIGl0IGlzIG5vcm1hbGx5IGhhbmRsZWQgYnkgdGhlCiAqIGBhbGxvd0luYCBydWxlIGZyb20ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufS4gQnV0IGlmIHlvdSBoYXZlIGEgY29tcGxleCBzY2VuYXJpbwogKiB3aGVyZSBgbGlzdEl0ZW1gIHNob3VsZCBiZSBhbGxvd2VkIG9ubHkgaW4gZWxlbWVudCBgZm9vYCB3aGljaCBtdXN0IGJlIGluIGVsZW1lbnQgYGJhcmAsIHRoZW4gdGhpcyB3b3VsZCBiZSB0aGUgd2F5OgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tDaGlsZCcsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGNvbnRleHQgPSBhcmdzWyAwIF07CiAqCQkJY29uc3QgY2hpbGREZWZpbml0aW9uID0gYXJnc1sgMSBdOwogKgogKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2JhciBmb28nICkgJiYgY2hpbGREZWZpbml0aW9uLm5hbWUgPT0gJ2xpc3RJdGVtJyApIHsKICoJCQkJLy8gUHJldmVudCBuZXh0IGxpc3RlbmVycyBmcm9tIGJlaW5nIGNhbGxlZC4KICoJCQkJZXZ0LnN0b3AoKTsKICoJCQkJLy8gU2V0IHRoZSBjaGVja0NoaWxkKCkncyByZXR1cm4gdmFsdWUuCiAqCQkJCWV2dC5yZXR1cm4gPSB0cnVlOwogKgkJCX0KICoJCX0sIHsgcHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAqCiAqIEBldmVudCBjaGVja0NoaWxkCiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGBjaGVja0NoaWxkKClgJ3MgYXJndW1lbnRzLgogKi8KCi8qKgogKiBFdmVudCBmaXJlZCB3aGVuIHRoZSB7QGxpbmsgI2NoZWNrQXR0cmlidXRlfSBtZXRob2QgaXMgY2FsbGVkLiBJdCBhbGxvd3MgcGx1Z2dpbmcgaW4KICogYWRkaXRpb25hbCBiZWhhdmlvciwgZm9yIGV4YW1wbGUgaW1wbGVtZW50aW5nIHJ1bGVzIHdoaWNoIGNhbm5vdCBiZSBkZWZpbmVkIHVzaW5nIHRoZSBkZWNsYXJhdGl2ZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGludGVyZmFjZS4KICoKICogKipOb3RlOioqIFRoZSB7QGxpbmsgI2FkZEF0dHJpYnV0ZUNoZWNrfSBtZXRob2QgaXMgYSBtb3JlIGhhbmR5IHdheSB0byByZWdpc3RlciBjYWxsYmFja3MuIEludGVybmFsbHksCiAqIGl0IHJlZ2lzdGVycyBhIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgYnV0IGNvbWVzIHdpdGggYSBzaW1wbGVyIEFQSSBhbmQgaXQgaXMgdGhlIHJlY29tbWVuZGVkIGNob2ljZQogKiBpbiBtb3N0IG9mIHRoZSBjYXNlcy4KICoKICogVGhlIHtAbGluayAjY2hlY2tBdHRyaWJ1dGV9IG1ldGhvZCBmaXJlcyBhbiBldmVudCBiZWNhdXNlIGl0IGlzCiAqIHtAbGluayBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbiNkZWNvcmF0ZSBkZWNvcmF0ZWR9IHdpdGggaXQuIFRoYW5rcyB0byB0aGF0IHlvdSBjYW4KICogdXNlIHRoaXMgZXZlbnQgaW4gdmFyaW91cyB3YXlzLCBidXQgdGhlIG1vc3QgaW1wb3J0YW50IHVzZSBjYXNlIGlzIG92ZXJyaWRpbmcgdGhlIHN0YW5kYXJkIGJlaGF2aW9yIG9mIHRoZQogKiBgY2hlY2tBdHRyaWJ1dGUoKWAgbWV0aG9kLiBMZXQncyBzZWUgYSB0eXBpY2FsIGxpc3RlbmVyIHRlbXBsYXRlOgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tBdHRyaWJ1dGUnLCAoIGV2dCwgYXJncyApID0+IHsKICoJCQljb25zdCBjb250ZXh0ID0gYXJnc1sgMCBdOwogKgkJCWNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhcmdzWyAxIF07CiAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogKgogKiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCBhIGBoaWdoYCBwcmlvcml0eSB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIGRlZmF1bHQgbWV0aG9kIGlzIHJlYWxseSBjYWxsZWQuIFRoZSBgYXJnc2AgY2FsbGJhY2sKICogcGFyYW1ldGVyIGNvbnRhaW5zIGFyZ3VtZW50cyBwYXNzZWQgdG8gYGNoZWNrQXR0cmlidXRlKCBjb250ZXh0LCBhdHRyaWJ1dGVOYW1lIClgLiBIb3dldmVyLCB0aGUgYGNvbnRleHRgIHBhcmFtZXRlciBpcyBhbHJlYWR5CiAqIG5vcm1hbGl6ZWQgdG8gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0gaW5zdGFuY2UsIHNvIHlvdSBkbyBub3QgaGF2ZSB0byB3b3JyeSBhYm91dAogKiB0aGUgdmFyaW91cyB3YXlzIGhvdyBgY29udGV4dGAgbWF5IGJlIHBhc3NlZCB0byBgY2hlY2tBdHRyaWJ1dGUoKWAuCiAqCiAqIFNvLCBpbiBvcmRlciB0byBpbXBsZW1lbnQgYSBydWxlICJkaXNhbGxvdyBgYm9sZGAgaW4gYSB0ZXh0IHdoaWNoIGlzIGluIGEgYGhlYWRpbmcxYCwgeW91IGNhbiBhZGQgc3VjaCBhIGxpc3RlbmVyOgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tBdHRyaWJ1dGUnLCAoIGV2dCwgYXJncyApID0+IHsKICoJCQljb25zdCBjb250ZXh0ID0gYXJnc1sgMCBdOwogKgkJCWNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhcmdzWyAxIF07CiAqCiAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnaGVhZGluZzEgJHRleHQnICkgJiYgYXR0cmlidXRlTmFtZSA9PSAnYm9sZCcgKSB7CiAqCQkJCS8vIFByZXZlbnQgbmV4dCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWQuCiAqCQkJCWV2dC5zdG9wKCk7CiAqCQkJCS8vIFNldCB0aGUgY2hlY2tBdHRyaWJ1dGUoKSdzIHJldHVybiB2YWx1ZS4KICoJCQkJZXZ0LnJldHVybiA9IGZhbHNlOwogKgkJCX0KICoJCX0sIHsgcHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAqCiAqIEFsbG93aW5nIGF0dHJpYnV0ZXMgaW4gc3BlY2lmaWMgY29udGV4dHMgd2lsbCBiZSBhIGZhciBsZXNzIGNvbW1vbiB1c2UgY2FzZSwgYmVjYXVzZSBpdCBpcyBub3JtYWxseSBoYW5kbGVkIGJ5IHRoZQogKiBgYWxsb3dBdHRyaWJ1dGVzYCBydWxlIGZyb20ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufS4gQnV0IGlmIHlvdSBoYXZlIGEgY29tcGxleCBzY2VuYXJpbwogKiB3aGVyZSBgYm9sZGAgc2hvdWxkIGJlIGFsbG93ZWQgb25seSBpbiBlbGVtZW50IGBmb29gIHdoaWNoIG11c3QgYmUgaW4gZWxlbWVudCBgYmFyYCwgdGhlbiB0aGlzIHdvdWxkIGJlIHRoZSB3YXk6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0F0dHJpYnV0ZScsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGNvbnRleHQgPSBhcmdzWyAwIF07CiAqCQkJY29uc3QgYXR0cmlidXRlTmFtZSA9IGFyZ3NbIDEgXTsKICoKICoJCQlpZiAoIGNvbnRleHQuZW5kc1dpdGgoICdiYXIgZm9vICR0ZXh0JyApICYmIGF0dHJpYnV0ZU5hbWUgPT0gJ2JvbGQnICkgewogKgkJCQkvLyBQcmV2ZW50IG5leHQgbGlzdGVuZXJzIGZyb20gYmVpbmcgY2FsbGVkLgogKgkJCQlldnQuc3RvcCgpOwogKgkJCQkvLyBTZXQgdGhlIGNoZWNrQXR0cmlidXRlKCkncyByZXR1cm4gdmFsdWUuCiAqCQkJCWV2dC5yZXR1cm4gPSB0cnVlOwogKgkJCX0KICoJCX0sIHsgcHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAqCiAqIEBldmVudCBjaGVja0F0dHJpYnV0ZQogKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBgY2hlY2tBdHRyaWJ1dGUoKWAncyBhcmd1bWVudHMuCiAqLwoKLyoqCiAqIEEgZGVmaW5pdGlvbiBvZiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfSBpdGVtLgogKgogKiBZb3UgY2FuIGRlZmluZSB0aGUgZm9sbG93aW5nIHJ1bGVzOgogKgogKiAqIHtAbGluayB+U2NoZW1hSXRlbURlZmluaXRpb24jYWxsb3dJbiBgYWxsb3dJbmB9ICZuZGFzaDsgRGVmaW5lcyBpbiB3aGljaCBvdGhlciBpdGVtcyB0aGlzIGl0ZW0gd2lsbCBiZSBhbGxvd2VkLgogKiAqIHtAbGluayB+U2NoZW1hSXRlbURlZmluaXRpb24jYWxsb3dBdHRyaWJ1dGVzIGBhbGxvd0F0dHJpYnV0ZXNgfSAmbmRhc2g7IERlZmluZXMgYWxsb3dlZCBhdHRyaWJ1dGVzIG9mIHRoZSBnaXZlbiBpdGVtLgogKiAqIHtAbGluayB+U2NoZW1hSXRlbURlZmluaXRpb24jYWxsb3dDb250ZW50T2YgYGFsbG93Q29udGVudE9mYH0gJm5kYXNoOyBJbmhlcml0cyAiYWxsb3dlZCBjaGlsZHJlbiIgZnJvbSBvdGhlciBpdGVtcy4KICogKiB7QGxpbmsgflNjaGVtYUl0ZW1EZWZpbml0aW9uI2FsbG93V2hlcmUgYGFsbG93V2hlcmVgfSAmbmRhc2g7IEluaGVyaXRzICJhbGxvd2VkIGluIiBmcm9tIG90aGVyIGl0ZW1zLgogKiAqIHtAbGluayB+U2NoZW1hSXRlbURlZmluaXRpb24jYWxsb3dBdHRyaWJ1dGVzT2YgYGFsbG93QXR0cmlidXRlc09mYH0gJm5kYXNoOyBJbmhlcml0cyBhdHRyaWJ1dGVzIGZyb20gb3RoZXIgaXRlbXMuCiAqICoge0BsaW5rIH5TY2hlbWFJdGVtRGVmaW5pdGlvbiNpbmhlcml0VHlwZXNGcm9tIGBpbmhlcml0VHlwZXNGcm9tYH0gJm5kYXNoOyBJbmhlcml0cyBgaXMqYCBwcm9wZXJ0aWVzIG9mIG90aGVyIGl0ZW1zLgogKiAqIHtAbGluayB+U2NoZW1hSXRlbURlZmluaXRpb24jaW5oZXJpdEFsbEZyb20gYGluaGVyaXRBbGxGcm9tYH0gJm5kYXNoOwogKiBBIHNob3J0aGFuZCBmb3IgYGFsbG93Q29udGVudE9mYCwgYGFsbG93V2hlcmVgLCBgYWxsb3dBdHRyaWJ1dGVzT2ZgLCBgaW5oZXJpdFR5cGVzRnJvbWAuCiAqCiAqICMgVGhlIGBpcypgIHByb3BlcnRpZXMKICoKICogVGhlcmUgYXJlIGEgY291cGxlIGNvbW1vbmx5IHVzZWQgYGlzKmAgcHJvcGVydGllcy4gVGhlaXIgcm9sZSBpcyB0byBhc3NpZ24gYWRkaXRpb25hbCBzZW1hbnRpY3MgdG8gc2NoZW1hIGl0ZW1zLgogKiBZb3UgY2FuIGRlZmluZSBtb3JlIHByb3BlcnRpZXMgYnV0IHlvdSB3aWxsIGFsc28gbmVlZCB0byBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgdGhlbSBpbiB0aGUgZXhpc3RpbmcgZWRpdG9yIGZlYXR1cmVzLgogKgogKiAqIHtAbGluayB+U2NoZW1hSXRlbURlZmluaXRpb24jaXNCbG9jayBgaXNCbG9ja2B9ICZuZGFzaDsgV2hldGhlciB0aGlzIGl0ZW0gaXMgcGFyYWdyYXBoLWxpa2UuCiAqIEdlbmVyYWxseSBzcGVha2luZywgY29udGVudCBpcyB1c3VhbGx5IG1hZGUgb3V0IG9mIGJsb2NrcyBsaWtlIHBhcmFncmFwaHMsIGxpc3QgaXRlbXMsIGltYWdlcywgaGVhZGluZ3MsIGV0Yy4KICogKiB7QGxpbmsgflNjaGVtYUl0ZW1EZWZpbml0aW9uI2lzSW5saW5lIGBpc0lubGluZWB9ICZuZGFzaDsgV2hldGhlciBhbiBpdGVtIGlzICJ0ZXh0LWxpa2UiIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhbiBpbmxpbmUgbm9kZS4KICogRXhhbXBsZXMgb2YgaW5saW5lIGVsZW1lbnRzOiBgJHRleHRgLCBgc29mdEJyZWFrYCAoYDxicj5gKSwgZXRjLgogKiAqIHtAbGluayB+U2NoZW1hSXRlbURlZmluaXRpb24jaXNMaW1pdCBgaXNMaW1pdGB9ICZuZGFzaDsgSXQgY2FuIGJlIHVuZGVyc3Rvb2QgYXMgd2hldGhlciB0aGlzIGVsZW1lbnQKICogc2hvdWxkIG5vdCBiZSBzcGxpdCBieSA8a2JkPkVudGVyPC9rYmQ+LiBFeGFtcGxlcyBvZiBsaW1pdCBlbGVtZW50czogYCRyb290YCwgdGFibGUgY2VsbCwgaW1hZ2UgY2FwdGlvbiwgZXRjLgogKiBJbiBvdGhlciB3b3JkcywgYWxsIGFjdGlvbnMgdGhhdCBoYXBwZW4gaW5zaWRlIGEgbGltaXQgZWxlbWVudCBhcmUgbGltaXRlZCB0byBpdHMgY29udGVudC4KICogQWxsIG9iamVjdHMgYXJlIHRyZWF0ZWQgYXMgbGltaXQgZWxlbWVudHMsIHRvby4KICogKiB7QGxpbmsgflNjaGVtYUl0ZW1EZWZpbml0aW9uI2lzT2JqZWN0IGBpc09iamVjdGB9ICZuZGFzaDsgV2hldGhlciBhbiBpdGVtIGlzICJzZWxmLWNvbnRhaW5lZCIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgd2hvbGUuCiAqIEV4YW1wbGVzIG9mIG9iamVjdCBlbGVtZW50czogYGltYWdlYCwgYHRhYmxlYCwgYHZpZGVvYCwgZXRjLiBBbiBvYmplY3QgaXMgYWxzbyBhIGxpbWl0LCBzbwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzTGltaXQgYGlzTGltaXQoKWB9IHJldHVybnMgYHRydWVgIGZvciBvYmplY3QgZWxlbWVudHMgYXV0b21hdGljYWxseS4KICoKICogUmVhZCBtb3JlIGFib3V0IHRoZSBtZWFuaW5nIG9mIHRoZXNlIHR5cGVzIGluIHRoZQogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvZGVlcC1kaXZlL3NjaGVtYSNkZWZpbmluZy1hZGRpdGlvbmFsLXNlbWFudGljcyBkZWRpY2F0ZWQgc2VjdGlvbiBvZiB0aGUgU2NoZW1hIGRlZXAgZGl2ZX0gZ3VpZGUuCiAqCiAqICMgR2VuZXJpYyBpdGVtcwogKgogKiBUaGVyZSBhcmUgdGhyZWUgYmFzaWMgZ2VuZXJpYyBpdGVtczogYCRyb290YCwgYCRibG9ja2AgYW5kIGAkdGV4dGAuCiAqIFRoZXkgYXJlIGRlZmluZWQgYXMgZm9sbG93czoKICoKICoJCXRoaXMuc2NoZW1hLnJlZ2lzdGVyKCAnJHJvb3QnLCB7CiAqCQkJaXNMaW1pdDogdHJ1ZQogKgkJfSApOwogKgkJdGhpcy5zY2hlbWEucmVnaXN0ZXIoICckYmxvY2snLCB7CiAqCQkJYWxsb3dJbjogJyRyb290JywKICoJCQlpc0Jsb2NrOiB0cnVlCiAqCQl9ICk7CiAqCQl0aGlzLnNjaGVtYS5yZWdpc3RlciggJyR0ZXh0JywgewogKgkJCWFsbG93SW46ICckYmxvY2snLAogKgkJCWlzSW5saW5lOiB0cnVlCiAqCQl9ICk7CiAqCiAqIFRoZXkgcmVmbGVjdCB0eXBpY2FsIGVkaXRvciBjb250ZW50IHRoYXQgaXMgY29udGFpbmVkIHdpdGhpbiBvbmUgcm9vdCwgY29uc2lzdHMgb2Ygc2V2ZXJhbCBibG9ja3MKICogKHBhcmFncmFwaHMsIGxpc3RzIGl0ZW1zLCBoZWFkaW5ncywgaW1hZ2VzKSB3aGljaCwgaW4gdHVybiwgbWF5IGNvbnRhaW4gdGV4dCBpbnNpZGUuCiAqCiAqIEJ5IGluaGVyaXRpbmcgZnJvbSB0aGUgZ2VuZXJpYyBpdGVtcyB5b3UgY2FuIGRlZmluZSBuZXcgaXRlbXMgd2hpY2ggd2lsbCBnZXQgZXh0ZW5kZWQgYnkgb3RoZXIgZWRpdG9yIGZlYXR1cmVzLgogKiBSZWFkIG1vcmUgYWJvdXQgZ2VuZXJpYyB0eXBlcyBpbiB0aGUge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2RlZXAtZGl2ZS9zY2hlbWEgU2NoZW1hIGRlZXAgZGl2ZX0gZ3VpZGUuCiAqCiAqICMgRXhhbXBsZSBkZWZpbml0aW9ucwogKgogKiBBbGxvdyBgcGFyYWdyYXBoYCBpbiByb290cyBhbmQgYmxvY2sgcXVvdGVzOgogKgogKgkJc2NoZW1hLnJlZ2lzdGVyKCAncGFyYWdyYXBoJywgewogKgkJCWFsbG93SW46IFsgJyRyb290JywgJ2Jsb2NrUXVvdGUnIF0sCiAqCQkJaXNCbG9jazogdHJ1ZQogKgkJfSApOwogKgogKiBBbGxvdyBgcGFyYWdyYXBoYCBldmVyeXdoZXJlIHdoZXJlIGAkYmxvY2tgIGlzIGFsbG93ZWQgKGkuZS4gaW4gYCRyb290YCk6CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdwYXJhZ3JhcGgnLCB7CiAqCQkJYWxsb3dXaGVyZTogJyRibG9jaycsCiAqCQkJaXNCbG9jazogdHJ1ZQogKgkJfSApOwogKgogKiBNYWtlIGBpbWFnZWAgYSBibG9jayBvYmplY3QsIHdoaWNoIGlzIGFsbG93ZWQgZXZlcnl3aGVyZSB3aGVyZSBgJGJsb2NrYCBpcy4KICogQWxzbywgYWxsb3cgYHNyY2AgYW5kIGBhbHRgIGF0dHJpYnV0ZXMgaW4gaXQ6CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdpbWFnZScsIHsKICoJCQlhbGxvd1doZXJlOiAnJGJsb2NrJywKICoJCQlhbGxvd0F0dHJpYnV0ZXM6IFsgJ3NyYycsICdhbHQnIF0sCiAqCQkJaXNCbG9jazogdHJ1ZSwKICoJCQlpc09iamVjdDogdHJ1ZQogKgkJfSApOwogKgogKiBNYWtlIGBjYXB0aW9uYCBhbGxvd2VkIGluIGBpbWFnZWAgYW5kIG1ha2UgaXQgYWxsb3cgYWxsIHRoZSBjb250ZW50IG9mIGAkYmxvY2tgcyAodXN1YWxseSwgYCR0ZXh0YCkuCiAqIEFsc28sIG1hcmsgaXQgYXMgYSBsaW1pdCBlbGVtZW50IHNvIGl0IGNhbm5vdCBiZSBzcGxpdDoKICoKICoJCXNjaGVtYS5yZWdpc3RlciggJ2NhcHRpb24nLCB7CiAqCQkJYWxsb3dJbjogJ2ltYWdlJywKICoJCQlhbGxvd0NvbnRlbnRPZjogJyRibG9jaycsCiAqCQkJaXNMaW1pdDogdHJ1ZQogKgkJfSApOwogKgogKiBNYWtlIGBsaXN0SXRlbWAgaW5oZXJpdCBhbGwgZnJvbSBgJGJsb2NrYCBidXQgYWxzbyBhbGxvdyBhZGRpdGlvbmFsIGF0dHJpYnV0ZXM6CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdsaXN0SXRlbScsIHsKICoJCQlpbmhlcml0QWxsRnJvbTogJyRibG9jaycsCiAqCQkJYWxsb3dBdHRyaWJ1dGVzOiBbICdsaXN0VHlwZScsICdsaXN0SW5kZW50JyBdCiAqCQl9ICk7CiAqCiAqIFdoaWNoIHRyYW5zbGF0ZXMgdG86CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdsaXN0SXRlbScsIHsKICoJCQlhbGxvd1doZXJlOiAnJGJsb2NrJywKICoJCQlhbGxvd0NvbnRlbnRPZjogJyRibG9jaycsCiAqCQkJYWxsb3dBdHRyaWJ1dGVzT2Y6ICckYmxvY2snLAogKgkJCWluaGVyaXRUeXBlc0Zyb206ICckYmxvY2snLAogKgkJCWFsbG93QXR0cmlidXRlczogWyAnbGlzdFR5cGUnLCAnbGlzdEluZGVudCcgXQogKgkJfSApOwogKgogKiAjIFRpcHMKICoKICogKiBDaGVjayBzY2hlbWEgZGVmaW5pdGlvbnMgb2YgZXhpc3RpbmcgZmVhdHVyZXMgdG8gc2VlIGhvdyB0aGV5IGFyZSBkZWZpbmVkLgogKiAqIElmIHlvdSB3YW50IHRvIHB1Ymxpc2ggeW91ciBmZWF0dXJlIHNvIG90aGVyIGRldmVsb3BlcnMgY2FuIHVzZSBpdCwgdHJ5IHRvIHVzZQogKiBnZW5lcmljIGl0ZW1zIGFzIG11Y2ggYXMgcG9zc2libGUuCiAqICogS2VlcCB5b3VyIG1vZGVsIGNsZWFuLiBMaW1pdCBpdCB0byB0aGUgYWN0dWFsIGRhdGEgYW5kIHN0b3JlIGluZm9ybWF0aW9uIGluIGEgbm9ybWFsaXplZCB3YXkuCiAqICogUmVtZW1iZXIgYWJvdXQgZGVmaW5pbmcgdGhlIGBpcypgIHByb3BlcnRpZXMuIFRoZXkgZG8gbm90IGFmZmVjdCB0aGUgYWxsb3dlZCBzdHJ1Y3R1cmVzLCBidXQgdGhleSBjYW4KICogYWZmZWN0IGhvdyB0aGUgZWRpdG9yIGZlYXR1cmVzIHRyZWF0IHlvdXIgZWxlbWVudHMuCiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9uCiAqCiAqIEBwcm9wZXJ0eSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBhbGxvd0luIERlZmluZXMgaW4gd2hpY2ggb3RoZXIgaXRlbXMgdGhpcyBpdGVtIHdpbGwgYmUgYWxsb3dlZC4KICogQHByb3BlcnR5IHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGFsbG93QXR0cmlidXRlcyBEZWZpbmVzIGFsbG93ZWQgYXR0cmlidXRlcyBvZiB0aGUgZ2l2ZW4gaXRlbS4KICogQHByb3BlcnR5IHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGFsbG93Q29udGVudE9mIEluaGVyaXRzICJhbGxvd2VkIGNoaWxkcmVuIiBmcm9tIG90aGVyIGl0ZW1zLgogKiBAcHJvcGVydHkge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gYWxsb3dXaGVyZSBJbmhlcml0cyAiYWxsb3dlZCBpbiIgZnJvbSBvdGhlciBpdGVtcy4KICogQHByb3BlcnR5IHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGFsbG93QXR0cmlidXRlc09mIEluaGVyaXRzIGF0dHJpYnV0ZXMgZnJvbSBvdGhlciBpdGVtcy4KICogQHByb3BlcnR5IHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGluaGVyaXRUeXBlc0Zyb20gSW5oZXJpdHMgYGlzKmAgcHJvcGVydGllcyBvZiBvdGhlciBpdGVtcy4KICogQHByb3BlcnR5IHtTdHJpbmd9IGluaGVyaXRBbGxGcm9tIEEgc2hvcnRoYW5kIGZvciBgYWxsb3dDb250ZW50T2ZgLCBgYWxsb3dXaGVyZWAsIGBhbGxvd0F0dHJpYnV0ZXNPZmAsIGBpbmhlcml0VHlwZXNGcm9tYC4KICoKICogQHByb3BlcnR5IHtCb29sZWFufSBpc0Jsb2NrCiAqIFdoZXRoZXIgdGhpcyBpdGVtIGlzIHBhcmFncmFwaC1saWtlLiBHZW5lcmFsbHkgc3BlYWtpbmcsIGNvbnRlbnQgaXMgdXN1YWxseSBtYWRlIG91dCBvZiBibG9ja3MKICogbGlrZSBwYXJhZ3JhcGhzLCBsaXN0IGl0ZW1zLCBpbWFnZXMsIGhlYWRpbmdzLCBldGMuIEFsbCB0aGVzZSBlbGVtZW50cyBhcmUgbWFya2VkIGFzIGJsb2Nrcy4gQSBibG9jawogKiBzaG91bGQgbm90IGFsbG93IGFub3RoZXIgYmxvY2sgaW5zaWRlLiBOb3RlOiBUaGVyZSBpcyBhbHNvIHRoZSBgJGJsb2NrYCBnZW5lcmljIGl0ZW0gd2hpY2ggaGFzIGBpc0Jsb2NrYCBzZXQgdG8gYHRydWVgLgogKiBNb3N0IGJsb2NrIHR5cGUgaXRlbXMgd2lsbCBpbmhlcml0IGZyb20gYCRibG9ja2AgKHRocm91Z2ggYGluaGVyaXRBbGxGcm9tYCkuCiAqCiAqIFJlYWQgbW9yZSBhYm91dCB0aGUgYmxvY2sgZWxlbWVudHMgaW4gdGhlCiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hI2Jsb2NrLWVsZW1lbnRzIEJsb2NrIGVsZW1lbnRzfSBzZWN0aW9uIG9mIHRoZSBTY2hlbWEgZGVlcCBkaXZlfSBndWlkZS4KICoKICogQHByb3BlcnR5IHtCb29sZWFufSBpc0lubGluZQogKiBXaGV0aGVyIGFuIGl0ZW0gaXMgInRleHQtbGlrZSIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFuIGlubGluZSBub2RlLiBFeGFtcGxlcyBvZiBpbmxpbmUgZWxlbWVudHM6CiAqIGAkdGV4dGAsIGBzb2Z0QnJlYWtgIChgPGJyPmApLCBldGMuCiAqCiAqIFJlYWQgbW9yZSBhYm91dCB0aGUgaW5saW5lIGVsZW1lbnRzIGluIHRoZQogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvZGVlcC1kaXZlL3NjaGVtYSNpbmxpbmUtZWxlbWVudHMgSW5saW5lIGVsZW1lbnRzfSBzZWN0aW9uIG9mIHRoZSBTY2hlbWEgZGVlcCBkaXZlfSBndWlkZS4KICoKICogQHByb3BlcnR5IHtCb29sZWFufSBpc0xpbWl0CiAqIEl0IGNhbiBiZSB1bmRlcnN0b29kIGFzIHdoZXRoZXIgdGhpcyBlbGVtZW50IHNob3VsZCBub3QgYmUgc3BsaXQgYnkgPGtiZD5FbnRlcjwva2JkPi4KICogRXhhbXBsZXMgb2YgbGltaXQgZWxlbWVudHM6IGAkcm9vdGAsIHRhYmxlIGNlbGwsIGltYWdlIGNhcHRpb24sIGV0Yy4gSW4gb3RoZXIgd29yZHMsIGFsbCBhY3Rpb25zIHRoYXQgaGFwcGVuIGluc2lkZQogKiBhIGxpbWl0IGVsZW1lbnQgYXJlIGxpbWl0ZWQgdG8gaXRzIGNvbnRlbnQuCiAqCiAqIFJlYWQgbW9yZSBhYm91dCB0aGUgbGltaXQgZWxlbWVudHMgaW4gdGhlCiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hI2xpbWl0LWVsZW1lbnRzIExpbWl0IGVsZW1lbnRzfSBzZWN0aW9uIG9mIHRoZSBTY2hlbWEgZGVlcCBkaXZlfSBndWlkZS4KICoKICogQHByb3BlcnR5IHtCb29sZWFufSBpc09iamVjdAogKiBXaGV0aGVyIGFuIGl0ZW0gaXMgInNlbGYtY29udGFpbmVkIiBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB3aG9sZS4gRXhhbXBsZXMgb2Ygb2JqZWN0IGVsZW1lbnRzOgogKiBgaW1hZ2VgLCBgdGFibGVgLCBgdmlkZW9gLCBldGMuCiAqCiAqICoqTm90ZToqKiBBbiBvYmplY3QgaXMgYWxzbyBhIGxpbWl0LCBzbwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzTGltaXQgYGlzTGltaXQoKWB9IHJldHVybnMgYHRydWVgIGZvciBvYmplY3QgZWxlbWVudHMgYXV0b21hdGljYWxseS4KICoKICogUmVhZCBtb3JlIGFib3V0IHRoZSBvYmplY3QgZWxlbWVudHMgaW4gdGhlCiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hI29iamVjdC1lbGVtZW50cyBPYmplY3QgZWxlbWVudHN9IHNlY3Rpb24gb2YgdGhlIFNjaGVtYSBkZWVwIGRpdmV9IGd1aWRlLgogKgogKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzU2VsZWN0YWJsZQogKiBgdHJ1ZWAgd2hlbiBhbiBlbGVtZW50IHNob3VsZCBiZSBzZWxlY3RhYmxlIGFzIGEgd2hvbGUgYnkgdGhlIHVzZXIuIEV4YW1wbGVzIG9mIHNlbGVjdGFibGUgZWxlbWVudHM6IGBpbWFnZWAsIGB0YWJsZWAsIGB0YWJsZUNlbGxgLCBldGMuCiAqCiAqICoqTm90ZToqKiBBbiBvYmplY3QgaXMgYWxzbyBhIHNlbGVjdGFibGUgZWxlbWVudCwgc28KICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc1NlbGVjdGFibGUgYGlzU2VsZWN0YWJsZSgpYH0gcmV0dXJucyBgdHJ1ZWAgZm9yIG9iamVjdCBlbGVtZW50cyBhdXRvbWF0aWNhbGx5LgogKgogKiBSZWFkIG1vcmUgYWJvdXQgc2VsZWN0YWJsZSBlbGVtZW50cyBpbiB0aGUKICoge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2RlZXAtZGl2ZS9zY2hlbWEjc2VsZWN0YWJsZS1lbGVtZW50cyBTZWxlY3RhYmxlIGVsZW1lbnRzfSBzZWN0aW9uIG9mIHRoZSBTY2hlbWEgZGVlcCBkaXZlfSBndWlkZS4KICoKICogQHByb3BlcnR5IHtCb29sZWFufSBpc0NvbnRlbnQKICogQW4gaXRlbSBpcyBhIGNvbnRlbnQgd2hlbiBpdCBhbHdheXMgZmluZHMgaXRzIHdheSB0byB0aGUgZWRpdG9yIGRhdGEgb3V0cHV0IHJlZ2FyZGxlc3Mgb2YgdGhlIG51bWJlciBhbmQgdHlwZSBvZiBpdHMgZGVzY2VuZGFudHMuCiAqIEV4YW1wbGVzIG9mIGNvbnRlbnQgZWxlbWVudHM6IGAkdGV4dGAsIGBpbWFnZWAsIGB0YWJsZWAsIGV0Yy4gKGJ1dCBub3QgYHBhcmFncmFwaGAsIGBoZWFkaW5nMWAgb3IgYHRhYmxlQ2VsbGApLgogKgogKiAqKk5vdGU6KiogQW4gb2JqZWN0IGlzIGFsc28gYSBjb250ZW50IGVsZW1lbnQsIHNvCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjaXNDb250ZW50IGBpc0NvbnRlbnQoKWB9IHJldHVybnMgYHRydWVgIGZvciBvYmplY3QgZWxlbWVudHMgYXV0b21hdGljYWxseS4KICoKICogUmVhZCBtb3JlIGFib3V0IGNvbnRlbnQgZWxlbWVudHMgaW4gdGhlCiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hI2NvbnRlbnQtZWxlbWVudHMgQ29udGVudCBlbGVtZW50c30gc2VjdGlvbiBvZiB0aGUgU2NoZW1hIGRlZXAgZGl2ZX0gZ3VpZGUuCiAqLwoKLyoqCiAqIEEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0gYWZ0ZXIKICogY29tcGlsYXRpb24gYnkgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfS4KICogUnVsZXMgZmVkIHRvIHRoZSBzY2hlbWEgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNyZWdpc3Rlcn0KICogYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjZXh0ZW5kfSBtZXRob2RzIGFyZSBkZWZpbmVkIGluIHRoZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGZvcm1hdC4KICogTGF0ZXIgb24sIHRoZXkgYXJlIGNvbXBpbGVkIHRvIGBTY2hlbWFDb21waWxlZEl0ZW1EZWZpbml0aW9uYCBzbyB3aGVuIHlvdSB1c2UgZS5nLgogKiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNnZXREZWZpbml0aW9ufSBtZXRob2QgeW91IGdldCB0aGUgY29tcGlsZWQgdmVyc2lvbi4KICoKICogVGhlIGNvbXBpbGVkIHZlcnNpb24gY29udGFpbnMgb25seSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAqCiAqICogVGhlIGBuYW1lYCBwcm9wZXJ0eSwKICogKiBUaGUgYGlzKmAgcHJvcGVydGllcywKICogKiBUaGUgYGFsbG93SW5gIGFycmF5LAogKiAqIFRoZSBgYWxsb3dBdHRyaWJ1dGVzYCBhcnJheS4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbgogKi8KCi8qKgogKiBBIHNjaGVtYSBjb250ZXh0ICZtZGFzaDsgYSBsaXN0IG9mIGFuY2VzdG9ycyBvZiBhIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC4KICoKICogQ29uc2lkZXJpbmcgc3VjaCBwb3NpdGlvbjoKICoKICoJCTwkcm9vdD4KICoJCQk8YmxvY2tRdW90ZT4KICoJCQkJPHBhcmFncmFwaD4KICoJCQkJCV4KICoJCQkJPC9wYXJhZ3JhcGg+CiAqCQkJPC9ibG9ja1F1b3RlPgogKgkJPC8kcm9vdD4KICoKICogVGhlIGNvbnRleHQgb2YgdGhpcyBwb3NpdGlvbiBpcyBpdHMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jZ2V0QW5jZXN0b3JzIGxpc3RzIG9mIGFuY2VzdG9yc306CiAqCiAqCQlbIHJvb3RFbGVtZW50LCBibG9ja1F1b3RlRWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCBdCiAqCiAqIENvbnRleHRzIGFyZSB1c2VkIGluIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2V2ZW50OmNoZWNrQ2hpbGQgYFNjaGVtYSNjaGVja0NoaWxkYH0gYW5kCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjZXZlbnQ6Y2hlY2tBdHRyaWJ1dGUgYFNjaGVtYSNjaGVja0F0dHJpYnV0ZWB9IGV2ZW50cyBhcyBhIGRlZmluaXRpb24KICogb2YgYSBwbGFjZSBpbiB0aGUgZG9jdW1lbnQgd2hlcmUgdGhlIGNoZWNrIG9jY3Vycy4gVGhlIGNvbnRleHQgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIGJhc2VkIG9uIHRoZSBmaXJzdCBhcmd1bWVudHMKICogb2YgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjY2hlY2tDaGlsZCBgU2NoZW1hI2NoZWNrQ2hpbGQoKWB9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2NoZWNrQXR0cmlidXRlIGBTY2hlbWEjY2hlY2tBdHRyaWJ1dGUoKWB9IG1ldGhvZHMgc28gd2hlbgogKiB1c2luZyB0aGVzZSBtZXRob2RzIHlvdSBuZWVkIHRvIHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb259cy4KICovCgpleHBvcnQgdmFyIFNjaGVtYUNvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGNvbnRleHQuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBjb250ZXh0CiAgICovCiAgZnVuY3Rpb24gU2NoZW1hQ29udGV4dChjb250ZXh0KSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NoZW1hQ29udGV4dCk7CgogICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBTY2hlbWFDb250ZXh0KSB7CiAgICAgIHJldHVybiBjb250ZXh0OwogICAgfQoKICAgIGlmICh0eXBlb2YgY29udGV4dCA9PSAnc3RyaW5nJykgewogICAgICBjb250ZXh0ID0gW2NvbnRleHRdOwogICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShjb250ZXh0KSkgewogICAgICAvLyBgY29udGV4dGAgaXMgaXRlbSBvciBwb3NpdGlvbi4KICAgICAgLy8gUG9zaXRpb24jZ2V0QW5jZXN0b3JzKCkgZG9lc24ndCBhY2NlcHQgYW55IHBhcmFtZXRlcnMgYnV0IGl0IHdvcmtzIGp1c3QgZmluZSBoZXJlLgogICAgICBjb250ZXh0ID0gY29udGV4dC5nZXRBbmNlc3RvcnMoewogICAgICAgIGluY2x1ZGVTZWxmOiB0cnVlCiAgICAgIH0pOwogICAgfQoKICAgIHRoaXMuX2l0ZW1zID0gY29udGV4dC5tYXAobWFwQ29udGV4dEl0ZW0pOwogIH0KICAvKioKICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zLgogICAqCiAgICogQHR5cGUge051bWJlcn0KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhTY2hlbWFDb250ZXh0LCBbewogICAga2V5OiAibGVuZ3RoIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoOwogICAgfQogICAgLyoqCiAgICAgKiBUaGUgbGFzdCBpdGVtICh0aGUgbG93ZXN0IG5vZGUpLgogICAgICoKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJsYXN0IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV07CiAgICB9CiAgICAvKioKICAgICAqIEl0ZXJhYmxlIGludGVyZmFjZS4KICAgICAqCiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjb250ZXh0IGl0ZW1zLgogICAgICoKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW0+fQogICAgICovCgogIH0sIHsKICAgIGtleTogU3ltYm9sLml0ZXJhdG9yLAogICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkgewogICAgICByZXR1cm4gdGhpcy5faXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbmV3IHNjaGVtYSBjb250ZXh0IGluc3RhbmNlIHdpdGggYW4gYWRkaXRpb25hbCBpdGVtLgogICAgICoKICAgICAqIEl0ZW0gY2FuIGJlIGFkZGVkIGFzOgogICAgICoKICAgICAqIAkJY29uc3QgY29udGV4dCA9IG5ldyBTY2hlbWFDb250ZXh0KCBbICckcm9vdCcgXSApOwogICAgICoKICAgICAqIAkJLy8gQW4gZWxlbWVudC4KICAgICAqIAkJY29uc3QgZm9vRWxlbWVudCA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAnZm9vRWxlbWVudCcgKTsKICAgICAqIAkJY29uc3QgbmV3Q29udGV4dCA9IGNvbnRleHQucHVzaCggZm9vRWxlbWVudCApOyAvLyBbICckcm9vdCcsICdmb29FbGVtZW50JyBdCiAgICAgKgogICAgICogCQkvLyBBIHRleHQgbm9kZS4KICAgICAqIAkJY29uc3QgdGV4dCA9IHdyaXRlci5jcmVhdGVUZXh0KCAnZm9vYmFyJyApOwogICAgICogCQljb25zdCBuZXdDb250ZXh0ID0gY29udGV4dC5wdXNoKCB0ZXh0ICk7IC8vIFsgJyRyb290JywgJyR0ZXh0JyBdCiAgICAgKgogICAgICogCQkvLyBBIHN0cmluZyAoZWxlbWVudCBuYW1lKS4KICAgICAqIAkJY29uc3QgbmV3Q29udGV4dCA9IGNvbnRleHQucHVzaCggJ2JhckVsZW1lbnQnICk7IC8vIFsgJyRyb290JywgJ2JhckVsZW1lbnQnIF0KICAgICAqCiAgICAgKiAqKk5vdGUqKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IHRoYXQgaXMgYWxyZWFkeSBpbiB0aGUgbW9kZWwgdHJlZSB3aWxsIGJlIGFkZGVkIGFzIHRoZSBvbmx5IGl0ZW0KICAgICAqICh3aXRob3V0IGFuY2VzdG9ycykuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd8bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8QXJyYXk8U3RyaW5nfG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlPn0gaXRlbSBBbiBpdGVtIHRoYXQgd2lsbCBiZSBhZGRlZAogICAgICogdG8gdGhlIGN1cnJlbnQgY29udGV4dC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0fSBBIG5ldyBzY2hlbWEgY29udGV4dCBpbnN0YW5jZSB3aXRoIGFuIGFkZGl0aW9uYWwgaXRlbS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJwdXNoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHsKICAgICAgdmFyIGN0eCA9IG5ldyBTY2hlbWFDb250ZXh0KFtpdGVtXSk7CiAgICAgIGN0eC5faXRlbXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX2l0ZW1zKSwgX3RvQ29uc3VtYWJsZUFycmF5KGN0eC5faXRlbXMpKTsKICAgICAgcmV0dXJuIGN0eDsKICAgIH0KICAgIC8qKgogICAgICogR2V0cyBhbiBpdGVtIG9uIHRoZSBnaXZlbiBpbmRleC4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW19CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0SXRlbSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbShpbmRleCkgewogICAgICByZXR1cm4gdGhpcy5faXRlbXNbaW5kZXhdOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiBpdGVtcy4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPFN0cmluZz59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0TmFtZXMiLAogICAgdmFsdWU6CiAgICAvKiNfX1BVUkVfXyovCiAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBnZXROYW1lcygpIHsKICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIGdldE5hbWVzJChfY29udGV4dDMpIHsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7CiAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmRlbGVnYXRlWWllbGQodGhpcy5faXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5uYW1lOwogICAgICAgICAgICAgIH0pLCAidDAiLCAxKTsKCiAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sIGdldE5hbWVzLCB0aGlzKTsKICAgIH0pCiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBjb250ZXh0IGVuZHMgd2l0aCB0aGUgZ2l2ZW4gbm9kZXMuCiAgICAgKgogICAgICoJCWNvbnN0IGN0eCA9IG5ldyBTY2hlbWFDb250ZXh0KCBbIHJvb3RFbGVtZW50LCBwYXJhZ3JhcGhFbGVtZW50LCB0ZXh0Tm9kZSBdICk7CiAgICAgKgogICAgICoJCWN0eC5lbmRzV2l0aCggJyR0ZXh0JyApOyAvLyAtPiB0cnVlCiAgICAgKgkJY3R4LmVuZHNXaXRoKCAncGFyYWdyYXBoICR0ZXh0JyApOyAvLyAtPiB0cnVlCiAgICAgKgkJY3R4LmVuZHNXaXRoKCAnJHJvb3QnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJY3R4LmVuZHNXaXRoKCAncGFyYWdyYXBoJyApOyAvLyAtPiBmYWxzZQogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeQogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZW5kc1dpdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGVuZHNXaXRoKHF1ZXJ5KSB7CiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZ2V0TmFtZXMoKSkuam9pbignICcpLmVuZHNXaXRoKHF1ZXJ5KTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNvbnRleHQgc3RhcnRzIHdpdGggdGhlIGdpdmVuIG5vZGVzLgogICAgICoKICAgICAqCQljb25zdCBjdHggPSBuZXcgU2NoZW1hQ29udGV4dCggWyByb290RWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCwgdGV4dE5vZGUgXSApOwogICAgICoKICAgICAqCQljdHguZW5kc1dpdGgoICckcm9vdCcgKTsgLy8gLT4gdHJ1ZQogICAgICoJCWN0eC5lbmRzV2l0aCggJyRyb290IHBhcmFncmFwaCcgKTsgLy8gLT4gdHJ1ZQogICAgICoJCWN0eC5lbmRzV2l0aCggJyR0ZXh0JyApOyAvLyAtPiBmYWxzZQogICAgICoJCWN0eC5lbmRzV2l0aCggJ3BhcmFncmFwaCcgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkKICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogInN0YXJ0c1dpdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgocXVlcnkpIHsKICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5nZXROYW1lcygpKS5qb2luKCcgJykuc3RhcnRzV2l0aChxdWVyeSk7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gU2NoZW1hQ29udGV4dDsKfSgpOwovKioKICogVGhlIGRlZmluaXRpb24gb2YgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dCBzY2hlbWEgY29udGV4dH0uCiAqCiAqIENvbnRleHRzIGNhbiBiZSBjcmVhdGVkIGluIG11bHRpcGxlIHdheXM6CiAqCiAqICogQnkgZGVmaW5pbmcgYSAqKm5vZGUqKiDigJMgaW4gdGhpcyBjYXNlcyB0aGlzIG5vZGUgYW5kIGFsbCBpdHMgYW5jZXN0b3JzIHdpbGwgYmUgdXNlZC4KICogKiBCeSBkZWZpbmluZyBhICoqcG9zaXRpb24qKiBpbiB0aGUgZG9jdW1lbnQg4oCTIGluIHRoaXMgY2FzZSBhbGwgaXRzIGFuY2VzdG9ycyB3aWxsIGJlIHVzZWQuCiAqICogQnkgZGVmaW5pbmcgYW4gKiphcnJheSBvZiBub2RlcyoqIOKAkyBpbiB0aGlzIGNhc2UgdGhpcyBhcnJheSBkZWZpbmVzIHRoZSBlbnRpcmUgY29udGV4dC4KICogKiBCeSBkZWZpbmluZyBhICoqbmFtZSBvZiBub2RlKiogLSBpbiB0aGlzIGNhc2Ugbm9kZSB3aWxsIGJlICJtb2NrZWQiLiBJdCBpcyBub3QgcmVjb21tZW5kZWQgYmVjYXVzZSBjb250ZXh0CiAqIHdpbGwgYmUgdW5yZWFsaXN0aWMgKGUuZy4gYXR0cmlidXRlcyBvZiB0aGVzZSBub2RlcyBhcmUgbm90IHNwZWNpZmllZCkuIEhvd2V2ZXIsIGF0IHRpbWVzIHRoaXMgbWF5IGJlIHRoZSBvbmx5CiAqIHdheSB0byBkZWZpbmUgdGhlIGNvbnRleHQgKGUuZy4gd2hlbiBjaGVja2luZyBzb21lIGh5cG90aGV0aWNhbCBzaXR1YXRpb24pLgogKiAqIEJ5IGRlZmluaW5nIGFuICoqYXJyYXkgb2Ygbm9kZSBuYW1lcyoqIChwb3RlbnRpYWxseSwgbWl4ZWQgd2l0aCByZWFsIG5vZGVzKSDigJMgVGhlIHNhbWUgYXMgKipuYW1lIG9mIG5vZGUqKgogKiBidXQgaXQgaXMgcG9zc2libGUgdG8gY3JlYXRlIGEgcGF0aC4KICogKiBCeSBkZWZpbmluZyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0fSBpbnN0YW5jZSAtIGluIHRoaXMgY2FzZSB0aGUgc2FtZSBpbnN0YW5jZSBhcyBwcm92aWRlZAogKiB3aWxsIGJlIHJldHVybi4KICoKICogRXhhbXBsZXMgb2YgY29udGV4dCBkZWZpbml0aW9ucyBwYXNzZWQgdG8gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjY2hlY2tDaGlsZCBgU2NoZW1hI2NoZWNrQ2hpbGQoKWB9CiAqIG1ldGhvZDoKICoKICoJCS8vIEFzc3VtaW5nIHRoYXQgd2UgaGF2ZSBhICRyb290ID4gYmxvY2tRdW90ZSA+IHBhcmFncmFwaCBzdHJ1Y3R1cmUsIHRoZSBmb2xsb3dpbmcgY29kZQogKgkJLy8gd2lsbCBjaGVjayBub2RlICdmb28nIGluIHRoZSBmb2xsb3dpbmcgY29udGV4dDoKICoJCS8vIFsgcm9vdEVsZW1lbnQsIGJsb2NrUXVvdGVFbGVtZW50LCBwYXJhZ3JhcGhFbGVtZW50IF0KICoJCWNvbnN0IGNvbnRleHREZWZpbml0aW9uID0gcGFyYWdyYXBoRWxlbWVudDsKICogCQljb25zdCBjaGlsZFRvQ2hlY2sgPSAnZm9vJzsKICoJCXNjaGVtYS5jaGVja0NoaWxkKCBjb250ZXh0RGVmaW5pdGlvbiwgY2hpbGRUb0NoZWNrICk7CiAqCiAqCQkvLyBBbHNvIGNoZWNrIGluIFsgcm9vdEVsZW1lbnQsIGJsb2NrUXVvdGVFbGVtZW50LCBwYXJhZ3JhcGhFbGVtZW50IF0uCiAqCQlzY2hlbWEuY2hlY2tDaGlsZCggbW9kZWwuY3JlYXRlUG9zaXRpb25BdCggcGFyYWdyYXBoRWxlbWVudCwgMCApLCAnZm9vJyApOwogKgogKgkJLy8gQ2hlY2sgaW4gWyByb290RWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCBdLgogKgkJc2NoZW1hLmNoZWNrQ2hpbGQoIFsgcm9vdEVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQgXSwgJ2ZvbycgKTsKICoKICoJCS8vIENoZWNrIG9ubHkgZmFrZVBhcmFncmFwaEVsZW1lbnQuCiAqCQlzY2hlbWEuY2hlY2tDaGlsZCggJ3BhcmFncmFwaCcsICdmb28nICk7CiAqCiAqCQkvLyBDaGVjayBpbiBbIGZha2VSb290RWxlbWVudCwgZmFrZUJhckVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQgXS4KICoJCXNjaGVtYS5jaGVja0NoaWxkKCBbICckcm9vdCcsICdiYXInLCBwYXJhZ3JhcGhFbGVtZW50IF0sICdmb28nICk7CiAqCiAqIEFsbCB0aGVzZSBgY2hlY2tDaGlsZCgpYCBjYWxscyB3aWxsIGZpcmUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNldmVudDpjaGVja0NoaWxkIGBTY2hlbWEjY2hlY2tDaGlsZGB9CiAqIGV2ZW50cyBpbiB3aGljaCBgYXJnc1sgMCBdYCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgY29udGV4dC4gVGhlcmVmb3JlLCB5b3UgY2FuIHdyaXRlIGEgbGlzdGVuZXIgbGlrZSB0aGlzOgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tDaGlsZCcsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGN0eCA9IGFyZ3NbIDAgXTsKICoKICoJCQljb25zb2xlLmxvZyggQXJyYXkuZnJvbSggY3R4LmdldE5hbWVzKCkgKSApOwogKgkJfSApOwogKgogKiBXaGljaCB3aWxsIGxvZyB0aGUgZm9sbG93aW5nOgogKgogKgkJWyAnJHJvb3QnLCAnYmxvY2tRdW90ZScsICdwYXJhZ3JhcGgnIF0KICoJCVsgJyRyb290JywgJ3BhcmFncmFwaCcgXQogKgkJWyAnJHJvb3QnLCAnYmFyJywgJ3BhcmFncmFwaCcgXQogKgogKiBOb3RlOiBXaGVuIHVzaW5nIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2NoZWNrQXR0cmlidXRlIGBTY2hlbWEjY2hlY2tBdHRyaWJ1dGUoKWB9IG1ldGhvZAogKiB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgd2hldGhlciBhIHRleHQgbm9kZSBtYXkgaGF2ZSBhbiBhdHRyaWJ1dGUuIEEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0fSBpcyBhCiAqIGNvcnJlY3Qgd2F5IHRvIGRlZmluZSBhIGNvbnRleHQgc28geW91IGNhbiBkbyB0aGlzOgogKgogKgkJc2NoZW1hLmNoZWNrQXR0cmlidXRlKCB0ZXh0Tm9kZSwgJ2JvbGQnICk7CiAqCiAqIEJ1dCBzb21ldGltZXMgeW91IHdhbnQgdG8gY2hlY2sgd2hldGhlciBhIHRleHQgYXQgYSBnaXZlbiBwb3NpdGlvbiBtaWdodCd2ZSBoYWQgc29tZSBhdHRyaWJ1dGUsCiAqIGluIHdoaWNoIGNhc2UgeW91IGNhbiBjcmVhdGUgYSBjb250ZXh0IGJ5IG1peGluZyBpbiBhbiBhcnJheSBvZiBlbGVtZW50cyB3aXRoIGEgYCckdGV4dCdgIHN0cmluZzoKICoKICoJCS8vIENoZWNrIGluIFsgcm9vdEVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQsIHRleHROb2RlIF0uCiAqCQlzY2hlbWEuY2hlY2tDaGlsZCggWyAuLi5wb3NpdGlvbkluUGFyYWdyYXBoLmdldEFuY2VzdG9ycygpLCAnJHRleHQnIF0sICdib2xkJyApOwogKgogKiBAdHlwZWRlZiB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0fAogKiBTdHJpbmd8QXJyYXkuPFN0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59IG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9uCiAqLwoKLyoqCiAqIEFuIGl0ZW0gb2YgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0IHNjaGVtYSBjb250ZXh0fS4KICoKICogSXQgY29udGFpbnMgMyBwcm9wZXJ0aWVzOgogKgogKiAqIGBuYW1lYCDigJMgdGhlIG5hbWUgb2YgdGhpcyBpdGVtLAogKiAqIGAqIGdldEF0dHJpYnV0ZUtleXMoKWAg4oCTIGEgZ2VuZXJhdG9yIG9mIGtleXMgb2YgaXRlbSBhdHRyaWJ1dGVzLAogKiAqIGBnZXRBdHRyaWJ1dGUoIGtleU5hbWUgKWAg4oCTIGEgbWV0aG9kIHRvIGdldCBhdHRyaWJ1dGUgdmFsdWVzLgogKgogKiBUaGUgY29udGV4dCBpdGVtIGludGVyZmFjZSBpcyBhIGhpZ2hseSBzaW1wbGlmaWVkIHZlcnNpb24gb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBhbmQgaXRzIHJvbGUKICogaXMgdG8gZXhwb3NlIG9ubHkgdGhlIGluZm9ybWF0aW9uIHdoaWNoIHNjaGVtYSBjaGVja3MgYXJlIGFibGUgdG8gcHJvdmlkZSAod2hpY2ggaXMgdGhlIG5hbWUgb2YgdGhlIG5vZGUgYW5kCiAqIG5vZGUncyBhdHRyaWJ1dGVzKS4KICoKICoJCXNjaGVtYS5vbiggJ2NoZWNrQ2hpbGQnLCAoIGV2dCwgYXJncyApID0+IHsKICoJCQljb25zdCBjdHggPSBhcmdzWyAwIF07CiAqCQkJY29uc3QgZmlyc3RJdGVtID0gY3R4LmdldEl0ZW0oIDAgKTsKICoKICoJCQljb25zb2xlLmxvZyggZmlyc3RJdGVtLm5hbWUgKTsgLy8gLT4gJyRyb290JwogKgkJCWNvbnNvbGUubG9nKCBmaXJzdEl0ZW0uZ2V0QXR0cmlidXRlKCAnZm9vJyApICk7IC8vIC0+ICdiYXInCiAqCQkJY29uc29sZS5sb2coIEFycmF5LmZyb20oIGZpcnN0SXRlbS5nZXRBdHRyaWJ1dGVLZXlzKCkgKSApOyAvLyAtPiBbICdmb28nLCAnZmFhJyBdCiAqCQl9ICk7CiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtCiAqLwoKLyoqCiAqIEEgc3RydWN0dXJlIGNvbnRhaW5pbmcgYWRkaXRpb25hbCBtZXRhZGF0YSBkZXNjcmliaW5nIHRoZSBhdHRyaWJ1dGUuCiAqCiAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI3NldEF0dHJpYnV0ZVByb3BlcnRpZXMgYFNjaGVtYSNzZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKClgfSBmb3IgdXNhZ2UgZXhhbXBsZXMuCiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hfkF0dHJpYnV0ZVByb3BlcnRpZXMKICogQHByb3BlcnR5IHtCb29sZWFufSBbaXNGb3JtYXR0aW5nXSBJbmRpY2F0ZXMgdGhhdCB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIGEgdmlzdWFsIGZvcm1hdHRpbmcsIGxpa2UgYGJvbGRgLCBgaXRhbGljYCBvcgogKiBgZm9udFNpemVgIHJhdGhlciB0aGFuIHNlbWFudGljIGF0dHJpYnV0ZSAoc3VjaCBhcyBgc3JjYCwgYGxpc3RUeXBlYCwgZXRjLikuIEZvciBleGFtcGxlLCBpdCBpcyB1c2VkIGJ5IHRoZSAiUmVtb3ZlIGZvcm1hdCIgZmVhdHVyZS4KICogQHByb3BlcnR5IHtCb29sZWFufSBbY29weU9uRW50ZXJdIEluZGljYXRlcyB0aGF0IGdpdmVuIHRleHQgYXR0cmlidXRlIHNob3VsZCBiZSBjb3BpZWQgdG8gdGhlIG5leHQgYmxvY2sgd2hlbiBlbnRlciBpcyBwcmVzc2VkLgogKi8KCmZ1bmN0aW9uIGNvbXBpbGVCYXNlSXRlbVJ1bGUoc291cmNlSXRlbVJ1bGVzLCBpdGVtTmFtZSkgewogIHZhciBpdGVtUnVsZSA9IHsKICAgIG5hbWU6IGl0ZW1OYW1lLAogICAgYWxsb3dJbjogW10sCiAgICBhbGxvd0NvbnRlbnRPZjogW10sCiAgICBhbGxvd1doZXJlOiBbXSwKICAgIGFsbG93QXR0cmlidXRlczogW10sCiAgICBhbGxvd0F0dHJpYnV0ZXNPZjogW10sCiAgICBpbmhlcml0VHlwZXNGcm9tOiBbXQogIH07CiAgY29weVR5cGVzKHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUpOwogIGNvcHlQcm9wZXJ0eShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlLCAnYWxsb3dJbicpOwogIGNvcHlQcm9wZXJ0eShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlLCAnYWxsb3dDb250ZW50T2YnKTsKICBjb3B5UHJvcGVydHkoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSwgJ2FsbG93V2hlcmUnKTsKICBjb3B5UHJvcGVydHkoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSwgJ2FsbG93QXR0cmlidXRlcycpOwogIGNvcHlQcm9wZXJ0eShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlLCAnYWxsb3dBdHRyaWJ1dGVzT2YnKTsKICBjb3B5UHJvcGVydHkoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSwgJ2luaGVyaXRUeXBlc0Zyb20nKTsKICBtYWtlSW5oZXJpdEFsbFdvcmsoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSk7CiAgcmV0dXJuIGl0ZW1SdWxlOwp9CgpmdW5jdGlvbiBjb21waWxlQWxsb3dDb250ZW50T2YoY29tcGlsZWREZWZpbml0aW9ucywgaXRlbU5hbWUpIHsKICB2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdLmFsbG93Q29udGVudE9mKSwKICAgICAgX3N0ZXA5OwoKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3I5LnMoKTsgIShfc3RlcDkgPSBfaXRlcmF0b3I5Lm4oKSkuZG9uZTspIHsKICAgICAgdmFyIGFsbG93Q29udGVudE9mSXRlbU5hbWUgPSBfc3RlcDkudmFsdWU7CgogICAgICAvLyBUaGUgYWxsb3dDb250ZW50T2YgcHJvcGVydHkgbWF5IHBvaW50IHRvIGFuIHVucmVnaXN0ZXJlZCBlbGVtZW50LgogICAgICBpZiAoY29tcGlsZWREZWZpbml0aW9uc1thbGxvd0NvbnRlbnRPZkl0ZW1OYW1lXSkgewogICAgICAgIHZhciBhbGxvd2VkQ2hpbGRyZW4gPSBnZXRBbGxvd2VkQ2hpbGRyZW4oY29tcGlsZWREZWZpbml0aW9ucywgYWxsb3dDb250ZW50T2ZJdGVtTmFtZSk7CiAgICAgICAgYWxsb3dlZENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFsbG93ZWRJdGVtKSB7CiAgICAgICAgICBhbGxvd2VkSXRlbS5hbGxvd0luLnB1c2goaXRlbU5hbWUpOwogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3I5LmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yOS5mKCk7CiAgfQoKICBkZWxldGUgY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dDb250ZW50T2Y7Cn0KCmZ1bmN0aW9uIGNvbXBpbGVBbGxvd1doZXJlKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKSB7CiAgdmFyIF9pdGVyYXRvcjEwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dXaGVyZSksCiAgICAgIF9zdGVwMTA7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjEwLnMoKTsgIShfc3RlcDEwID0gX2l0ZXJhdG9yMTAubigpKS5kb25lOykgewogICAgICB2YXIgYWxsb3dXaGVyZUl0ZW1OYW1lID0gX3N0ZXAxMC52YWx1ZTsKICAgICAgdmFyIGluaGVyaXRGcm9tID0gY29tcGlsZWREZWZpbml0aW9uc1thbGxvd1doZXJlSXRlbU5hbWVdOyAvLyBUaGUgYWxsb3dXaGVyZSBwcm9wZXJ0eSBtYXkgcG9pbnQgdG8gYW4gdW5yZWdpc3RlcmVkIGVsZW1lbnQuCgogICAgICBpZiAoaW5oZXJpdEZyb20pIHsKICAgICAgICB2YXIgX2NvbXBpbGVkRGVmaW5pdGlvbnMkOwoKICAgICAgICB2YXIgYWxsb3dlZEluID0gaW5oZXJpdEZyb20uYWxsb3dJbjsKCiAgICAgICAgKF9jb21waWxlZERlZmluaXRpb25zJCA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdLmFsbG93SW4pLnB1c2guYXBwbHkoX2NvbXBpbGVkRGVmaW5pdGlvbnMkLCBfdG9Db25zdW1hYmxlQXJyYXkoYWxsb3dlZEluKSk7CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjEwLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yMTAuZigpOwogIH0KCiAgZGVsZXRlIGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdLmFsbG93V2hlcmU7Cn0KCmZ1bmN0aW9uIGNvbXBpbGVBbGxvd0F0dHJpYnV0ZXNPZihjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSkgewogIHZhciBfaXRlcmF0b3IxMSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdLmFsbG93QXR0cmlidXRlc09mKSwKICAgICAgX3N0ZXAxMTsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMTEucygpOyAhKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBhbGxvd0F0dHJpYnV0ZU9mSXRlbSA9IF9zdGVwMTEudmFsdWU7CiAgICAgIHZhciBpbmhlcml0RnJvbSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbYWxsb3dBdHRyaWJ1dGVPZkl0ZW1dOwoKICAgICAgaWYgKGluaGVyaXRGcm9tKSB7CiAgICAgICAgdmFyIF9jb21waWxlZERlZmluaXRpb25zJDI7CgogICAgICAgIHZhciBpbmhlcml0QXR0cmlidXRlcyA9IGluaGVyaXRGcm9tLmFsbG93QXR0cmlidXRlczsKCiAgICAgICAgKF9jb21waWxlZERlZmluaXRpb25zJDIgPSBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXS5hbGxvd0F0dHJpYnV0ZXMpLnB1c2guYXBwbHkoX2NvbXBpbGVkRGVmaW5pdGlvbnMkMiwgX3RvQ29uc3VtYWJsZUFycmF5KGluaGVyaXRBdHRyaWJ1dGVzKSk7CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjExLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yMTEuZigpOwogIH0KCiAgZGVsZXRlIGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdLmFsbG93QXR0cmlidXRlc09mOwp9CgpmdW5jdGlvbiBjb21waWxlSW5oZXJpdFByb3BlcnRpZXNGcm9tKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKSB7CiAgdmFyIGl0ZW0gPSBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXTsKCiAgdmFyIF9pdGVyYXRvcjEyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaXRlbS5pbmhlcml0VHlwZXNGcm9tKSwKICAgICAgX3N0ZXAxMjsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMTIucygpOyAhKF9zdGVwMTIgPSBfaXRlcmF0b3IxMi5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBpbmhlcml0UHJvcGVydGllc09mSXRlbSA9IF9zdGVwMTIudmFsdWU7CiAgICAgIHZhciBpbmhlcml0RnJvbSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaW5oZXJpdFByb3BlcnRpZXNPZkl0ZW1dOwoKICAgICAgaWYgKGluaGVyaXRGcm9tKSB7CiAgICAgICAgdmFyIHR5cGVOYW1lcyA9IE9iamVjdC5rZXlzKGluaGVyaXRGcm9tKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsKICAgICAgICAgIHJldHVybiBuYW1lLnN0YXJ0c1dpdGgoJ2lzJyk7CiAgICAgICAgfSk7CgogICAgICAgIHZhciBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHR5cGVOYW1lcyksCiAgICAgICAgICAgIF9zdGVwMTM7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjEzLnMoKTsgIShfc3RlcDEzID0gX2l0ZXJhdG9yMTMubigpKS5kb25lOykgewogICAgICAgICAgICB2YXIgbmFtZSA9IF9zdGVwMTMudmFsdWU7CgogICAgICAgICAgICBpZiAoIShuYW1lIGluIGl0ZW0pKSB7CiAgICAgICAgICAgICAgaXRlbVtuYW1lXSA9IGluaGVyaXRGcm9tW25hbWVdOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfaXRlcmF0b3IxMy5lKGVycik7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIF9pdGVyYXRvcjEzLmYoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjEyLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yMTIuZigpOwogIH0KCiAgZGVsZXRlIGl0ZW0uaW5oZXJpdFR5cGVzRnJvbTsKfSAvLyBSZW1vdmUgaXRlbXMgd2hpY2ggd2VyZW4ndCByZWdpc3RlcmVkIChiZWNhdXNlIGl0IG1heSBicmVhayBzb21lIGNoZWNrcyBvciB3ZSdkIG5lZWQgdG8gY29tcGxpY2F0ZSB0aGVtKS4KLy8gTWFrZSBzdXJlIGFsbG93SW4gZG9lc24ndCBjb250YWluIHJlcGVhdGVkIHZhbHVlcy4KCgpmdW5jdGlvbiBjbGVhblVwQWxsb3dJbihjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSkgewogIHZhciBpdGVtUnVsZSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdOwogIHZhciBleGlzdGluZ0l0ZW1zID0gaXRlbVJ1bGUuYWxsb3dJbi5maWx0ZXIoZnVuY3Rpb24gKGl0ZW1Ub0NoZWNrKSB7CiAgICByZXR1cm4gY29tcGlsZWREZWZpbml0aW9uc1tpdGVtVG9DaGVja107CiAgfSk7CiAgaXRlbVJ1bGUuYWxsb3dJbiA9IEFycmF5LmZyb20obmV3IFNldChleGlzdGluZ0l0ZW1zKSk7Cn0KCmZ1bmN0aW9uIGNsZWFuVXBBbGxvd0F0dHJpYnV0ZXMoY29tcGlsZWREZWZpbml0aW9ucywgaXRlbU5hbWUpIHsKICB2YXIgaXRlbVJ1bGUgPSBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXTsKICBpdGVtUnVsZS5hbGxvd0F0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoaXRlbVJ1bGUuYWxsb3dBdHRyaWJ1dGVzKSk7Cn0KCmZ1bmN0aW9uIGNvcHlUeXBlcyhzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlKSB7CiAgdmFyIF9pdGVyYXRvcjE0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc291cmNlSXRlbVJ1bGVzKSwKICAgICAgX3N0ZXAxNDsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMTQucygpOyAhKF9zdGVwMTQgPSBfaXRlcmF0b3IxNC5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBzb3VyY2VJdGVtUnVsZSA9IF9zdGVwMTQudmFsdWU7CiAgICAgIHZhciB0eXBlTmFtZXMgPSBPYmplY3Qua2V5cyhzb3VyY2VJdGVtUnVsZSkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7CiAgICAgICAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aCgnaXMnKTsKICAgICAgfSk7CgogICAgICB2YXIgX2l0ZXJhdG9yMTUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0eXBlTmFtZXMpLAogICAgICAgICAgX3N0ZXAxNTsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IxNS5zKCk7ICEoX3N0ZXAxNSA9IF9pdGVyYXRvcjE1Lm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBuYW1lID0gX3N0ZXAxNS52YWx1ZTsKICAgICAgICAgIGl0ZW1SdWxlW25hbWVdID0gc291cmNlSXRlbVJ1bGVbbmFtZV07CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IxNS5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMTUuZigpOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3IxNC5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjE0LmYoKTsKICB9Cn0KCmZ1bmN0aW9uIGNvcHlQcm9wZXJ0eShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlLCBwcm9wZXJ0eU5hbWUpIHsKICB2YXIgX2l0ZXJhdG9yMTYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzb3VyY2VJdGVtUnVsZXMpLAogICAgICBfc3RlcDE2OwoKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3IxNi5zKCk7ICEoX3N0ZXAxNiA9IF9pdGVyYXRvcjE2Lm4oKSkuZG9uZTspIHsKICAgICAgdmFyIHNvdXJjZUl0ZW1SdWxlID0gX3N0ZXAxNi52YWx1ZTsKCiAgICAgIGlmICh0eXBlb2Ygc291cmNlSXRlbVJ1bGVbcHJvcGVydHlOYW1lXSA9PSAnc3RyaW5nJykgewogICAgICAgIGl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0ucHVzaChzb3VyY2VJdGVtUnVsZVtwcm9wZXJ0eU5hbWVdKTsKICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZUl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0pKSB7CiAgICAgICAgdmFyIF9pdGVtUnVsZSRwcm9wZXJ0eU5hbTsKCiAgICAgICAgKF9pdGVtUnVsZSRwcm9wZXJ0eU5hbSA9IGl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0pLnB1c2guYXBwbHkoX2l0ZW1SdWxlJHByb3BlcnR5TmFtLCBfdG9Db25zdW1hYmxlQXJyYXkoc291cmNlSXRlbVJ1bGVbcHJvcGVydHlOYW1lXSkpOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3IxNi5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjE2LmYoKTsKICB9Cn0KCmZ1bmN0aW9uIG1ha2VJbmhlcml0QWxsV29yayhzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlKSB7CiAgdmFyIF9pdGVyYXRvcjE3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc291cmNlSXRlbVJ1bGVzKSwKICAgICAgX3N0ZXAxNzsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMTcucygpOyAhKF9zdGVwMTcgPSBfaXRlcmF0b3IxNy5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBzb3VyY2VJdGVtUnVsZSA9IF9zdGVwMTcudmFsdWU7CiAgICAgIHZhciBpbmhlcml0RnJvbSA9IHNvdXJjZUl0ZW1SdWxlLmluaGVyaXRBbGxGcm9tOwoKICAgICAgaWYgKGluaGVyaXRGcm9tKSB7CiAgICAgICAgaXRlbVJ1bGUuYWxsb3dDb250ZW50T2YucHVzaChpbmhlcml0RnJvbSk7CiAgICAgICAgaXRlbVJ1bGUuYWxsb3dXaGVyZS5wdXNoKGluaGVyaXRGcm9tKTsKICAgICAgICBpdGVtUnVsZS5hbGxvd0F0dHJpYnV0ZXNPZi5wdXNoKGluaGVyaXRGcm9tKTsKICAgICAgICBpdGVtUnVsZS5pbmhlcml0VHlwZXNGcm9tLnB1c2goaW5oZXJpdEZyb20pOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3IxNy5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjE3LmYoKTsKICB9Cn0KCmZ1bmN0aW9uIGdldEFsbG93ZWRDaGlsZHJlbihjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSkgewogIHZhciBpdGVtUnVsZSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdOwogIHJldHVybiBnZXRWYWx1ZXMoY29tcGlsZWREZWZpbml0aW9ucykuZmlsdGVyKGZ1bmN0aW9uIChkZWYpIHsKICAgIHJldHVybiBkZWYuYWxsb3dJbi5pbmNsdWRlcyhpdGVtUnVsZS5uYW1lKTsKICB9KTsKfQoKZnVuY3Rpb24gZ2V0VmFsdWVzKG9iaikgewogIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7CiAgICByZXR1cm4gb2JqW2tleV07CiAgfSk7Cn0KCmZ1bmN0aW9uIG1hcENvbnRleHRJdGVtKGN0eEl0ZW0pIHsKICBpZiAodHlwZW9mIGN0eEl0ZW0gPT0gJ3N0cmluZycgfHwgY3R4SXRlbS5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICByZXR1cm4gewogICAgICBuYW1lOiB0eXBlb2YgY3R4SXRlbSA9PSAnc3RyaW5nJyA/IGN0eEl0ZW0gOiAnJGRvY3VtZW50RnJhZ21lbnQnLAogICAgICBnZXRBdHRyaWJ1dGVLZXlzOiAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gZ2V0QXR0cmlidXRlS2V5cygpIHsKICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0QXR0cmlidXRlS2V5cyQoX2NvbnRleHQ0KSB7CiAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHsKICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwgZ2V0QXR0cmlidXRlS2V5cyk7CiAgICAgIH0pLAogICAgICBnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSgpIHt9CiAgICB9OwogIH0gZWxzZSB7CiAgICByZXR1cm4gewogICAgICAvLyAnJHRleHQnIG1lYW5zIHRleHQgbm9kZXMgYW5kIHRleHQgcHJveGllcy4KICAgICAgbmFtZTogY3R4SXRlbS5pcygnZWxlbWVudCcpID8gY3R4SXRlbS5uYW1lIDogJyR0ZXh0JywKICAgICAgZ2V0QXR0cmlidXRlS2V5czogLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUtleXMoKSB7CiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUtleXMkKF9jb250ZXh0NSkgewogICAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7CiAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5kZWxlZ2F0ZVlpZWxkKGN0eEl0ZW0uZ2V0QXR0cmlidXRlS2V5cygpLCAidDAiLCAxKTsKCiAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sIGdldEF0dHJpYnV0ZUtleXMpOwogICAgICB9KSwKICAgICAgZ2V0QXR0cmlidXRlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoa2V5KSB7CiAgICAgICAgcmV0dXJuIGN0eEl0ZW0uZ2V0QXR0cmlidXRlKGtleSk7CiAgICAgIH0KICAgIH07CiAgfQp9IC8vIEdlbmVyYXRvciBmdW5jdGlvbiByZXR1cm5pbmcgdmFsdWVzIGZyb20gcHJvdmlkZWQgd2Fsa2Vycywgc3dpdGNoaW5nIGJldHdlZW4gdGhlbSBhdCBlYWNoIGl0ZXJhdGlvbi4gSWYgb25seSBvbmUgd2Fsa2VyCi8vIGlzIHByb3ZpZGVkIGl0IHdpbGwgcmV0dXJuIGRhdGEgb25seSBmcm9tIHRoYXQgd2Fsa2VyLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kdWxlL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gW2JhY2t3YXJkXSBXYWxrZXIgaXRlcmF0aW5nIGluIGJhY2t3YXJkIGRpcmVjdGlvbi4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZHVsZS90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IFtmb3J3YXJkXSBXYWxrZXIgaXRlcmF0aW5nIGluIGZvcndhcmQgZGlyZWN0aW9uLgovLyBAcmV0dXJucyB7SXRlcmFibGUuPE9iamVjdD59IE9iamVjdCByZXR1cm5lZCBhdCBlYWNoIGl0ZXJhdGlvbiBjb250YWlucyBgdmFsdWVgIGFuZCBgd2Fsa2VyYCAoaW5mb3JtaW5nIHdoaWNoIHdhbGtlciByZXR1cm5lZAovLyBnaXZlbiB2YWx1ZSkgZmllbGRzLgoKCmZ1bmN0aW9uIGNvbWJpbmVXYWxrZXJzKGJhY2t3YXJkLCBmb3J3YXJkKSB7CiAgdmFyIGRvbmUsIHN0ZXAsIF9zdGVwMTg7CgogIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBjb21iaW5lV2Fsa2VycyQoX2NvbnRleHQ2KSB7CiAgICB3aGlsZSAoMSkgewogICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHsKICAgICAgICBjYXNlIDA6CiAgICAgICAgICBkb25lID0gZmFsc2U7CgogICAgICAgIGNhc2UgMToKICAgICAgICAgIGlmIChkb25lKSB7CiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTc7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGRvbmUgPSB0cnVlOwoKICAgICAgICAgIGlmICghYmFja3dhcmQpIHsKICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA5OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBzdGVwID0gYmFja3dhcmQubmV4dCgpOwoKICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHsKICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA5OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBkb25lID0gZmFsc2U7CiAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDk7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICB3YWxrZXI6IGJhY2t3YXJkLAogICAgICAgICAgICB2YWx1ZTogc3RlcC52YWx1ZQogICAgICAgICAgfTsKCiAgICAgICAgY2FzZSA5OgogICAgICAgICAgaWYgKCFmb3J3YXJkKSB7CiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTU7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIF9zdGVwMTggPSBmb3J3YXJkLm5leHQoKTsKCiAgICAgICAgICBpZiAoX3N0ZXAxOC5kb25lKSB7CiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTU7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGRvbmUgPSBmYWxzZTsKICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTU7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICB3YWxrZXI6IGZvcndhcmQsCiAgICAgICAgICAgIHZhbHVlOiBfc3RlcDE4LnZhbHVlCiAgICAgICAgICB9OwoKICAgICAgICBjYXNlIDE1OgogICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgMTc6CiAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpOwogICAgICB9CiAgICB9CiAgfSwgX21hcmtlZCk7Cn0gLy8gVGFrZXMgYW4gYXJyYXkgb2Ygbm9uLWludGVyc2VjdGluZyByYW5nZXMuIEZvciBlYWNoIG9mIHRoZW0gZ2V0cyBtaW5pbWFsIGZsYXQgcmFuZ2VzIGNvdmVyaW5nIHRoYXQgcmFuZ2UgYW5kIHJldHVybnMKLy8gYWxsIHRob3NlIG1pbmltYWwgZmxhdCByYW5nZXMuCi8vCi8vIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSByYW5nZXMgUmFuZ2VzIHRvIHByb2Nlc3MuCi8vIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IE1pbmltYWwgZmxhdCByYW5nZXMgb2YgZ2l2ZW4gYHJhbmdlc2AuCgoKZnVuY3Rpb24gY29udmVydFRvTWluaW1hbEZsYXRSYW5nZXMocmFuZ2VzKSB7CiAgdmFyIF9pdGVyYXRvcjE4LCBfc3RlcDE5LCByYW5nZTsKCiAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIGNvbnZlcnRUb01pbmltYWxGbGF0UmFuZ2VzJChfY29udGV4dDcpIHsKICAgIHdoaWxlICgxKSB7CiAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkgewogICAgICAgIGNhc2UgMDoKICAgICAgICAgIF9pdGVyYXRvcjE4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocmFuZ2VzKTsKICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTsKCiAgICAgICAgICBfaXRlcmF0b3IxOC5zKCk7CgogICAgICAgIGNhc2UgMzoKICAgICAgICAgIGlmICgoX3N0ZXAxOSA9IF9pdGVyYXRvcjE4Lm4oKSkuZG9uZSkgewogICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDg7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIHJhbmdlID0gX3N0ZXAxOS52YWx1ZTsKICAgICAgICAgIHJldHVybiBfY29udGV4dDcuZGVsZWdhdGVZaWVsZChyYW5nZS5nZXRNaW5pbWFsRmxhdFJhbmdlcygpLCAidDAiLCA2KTsKCiAgICAgICAgY2FzZSA2OgogICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAzOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgODoKICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTM7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAxMDoKICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMTA7CiAgICAgICAgICBfY29udGV4dDcudDEgPSBfY29udGV4dDdbImNhdGNoIl0oMSk7CgogICAgICAgICAgX2l0ZXJhdG9yMTguZShfY29udGV4dDcudDEpOwoKICAgICAgICBjYXNlIDEzOgogICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSAxMzsKCiAgICAgICAgICBfaXRlcmF0b3IxOC5mKCk7CgogICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5maW5pc2goMTMpOwoKICAgICAgICBjYXNlIDE2OgogICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTsKICAgICAgfQogICAgfQogIH0sIF9tYXJrZWQyLCBudWxsLCBbWzEsIDEwLCAxMywgMTZdXSk7Cn0KCmZ1bmN0aW9uIHJlbW92ZURpc2FsbG93ZWRBdHRyaWJ1dGVGcm9tTm9kZShzY2hlbWEsIG5vZGUsIHdyaXRlcikgewogIHZhciBfaXRlcmF0b3IxOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5vZGUuZ2V0QXR0cmlidXRlS2V5cygpKSwKICAgICAgX3N0ZXAyMDsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMTkucygpOyAhKF9zdGVwMjAgPSBfaXRlcmF0b3IxOS5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBhdHRyaWJ1dGUgPSBfc3RlcDIwLnZhbHVlOwoKICAgICAgaWYgKCFzY2hlbWEuY2hlY2tBdHRyaWJ1dGUobm9kZSwgYXR0cmlidXRlKSkgewogICAgICAgIHdyaXRlci5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlLCBub2RlKTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMTkuZShlcnIpOwogIH0gZmluYWxseSB7CiAgICBfaXRlcmF0b3IxOS5mKCk7CiAgfQp9"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js"],"names":["combineWalkers","convertToMinimalFlatRanges","CKEditorError","ObservableMixin","mix","Range","Position","Element","Text","TreeWalker","Schema","_sourceDefinitions","_attributeProperties","decorate","on","evt","args","SchemaContext","priority","getDefinition","itemName","definition","Object","assign","_clearCache","push","_compiledDefinitions","_compile","item","is","name","getDefinitions","def","isBlock","isLimit","isObject","isSelectable","isContent","isInline","context","_checkContextMatch","attributeName","last","allowAttributes","includes","positionOrBaseElement","elementToMerge","nodeBefore","nodeAfter","checkMerge","getChildren","child","checkChild","callback","ctx","childDef","retValue","stop","return","properties","getAttributeProperties","selectionOrRangeOrPosition","element","parent","ranges","Array","from","getRanges","reduce","range","rangeCommonAncestor","getCommonAncestor","includeSelf","selection","attribute","isCollapsed","firstPosition","getFirstPosition","getAncestors","getAttributes","checkAttribute","value","_getValidRangesForRange","position","direction","backwardWalker","forwardWalker","limitElement","reverse","find","root","boundaries","_createIn","startPosition","data","type","walker","_createOn","nextPosition","node","nodes","writer","removeDisallowedAttributeFromNode","rangeInNode","positionsInRange","getPositions","compiledDefinitions","sourceRules","itemNames","keys","compileBaseItemRule","compileAllowContentOf","compileAllowWhere","compileAllowAttributesOf","compileInheritPropertiesFrom","cleanUpAllowIn","cleanUpAllowAttributes","contextItemIndex","length","contextItem","getItem","allowIn","parentRule","start","end","getItems","shallow","isEqual","_createAfter","isArray","_items","map","mapContextItem","Symbol","iterator","index","query","getNames","join","endsWith","startsWith","sourceItemRules","itemRule","allowContentOf","allowWhere","allowAttributesOf","inheritTypesFrom","copyTypes","copyProperty","makeInheritAllWork","allowContentOfItemName","allowedChildren","getAllowedChildren","forEach","allowedItem","allowWhereItemName","inheritFrom","allowedIn","allowAttributeOfItem","inheritAttributes","inheritPropertiesOfItem","typeNames","filter","existingItems","itemToCheck","Set","sourceItemRule","propertyName","inheritAllFrom","getValues","obj","key","ctxItem","getAttributeKeys","getAttribute","backward","forward","done","step","next","getMinimalFlatRanges","schema","removeAttribute"],"mappings":";;;;;;mDAysDUA,c;oDAqCAC,0B;;;;;;;;;;;;;;;;;;;;;;;;;AA9uDV;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,eAAP,MAA4B,+CAA5B;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,M;AACpB;AACD;AACA;AACC,oBAAc;AAAA;;AAAA;;AACb,SAAKC,kBAAL,GAA0B,EAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,oBAAL,GAA4B,EAA5B;AAEA,SAAKC,QAAL,CAAe,YAAf;AACA,SAAKA,QAAL,CAAe,gBAAf;AAEA,SAAKC,EAAL,CAAS,gBAAT,EAA2B,UAAEC,GAAF,EAAOC,IAAP,EAAiB;AAC3CA,MAAAA,IAAI,CAAE,CAAF,CAAJ,GAAY,IAAIC,aAAJ,CAAmBD,IAAI,CAAE,CAAF,CAAvB,CAAZ;AACA,KAFD,EAEG;AAAEE,MAAAA,QAAQ,EAAE;AAAZ,KAFH;AAIA,SAAKJ,EAAL,CAAS,YAAT,EAAuB,UAAEC,GAAF,EAAOC,IAAP,EAAiB;AACvCA,MAAAA,IAAI,CAAE,CAAF,CAAJ,GAAY,IAAIC,aAAJ,CAAmBD,IAAI,CAAE,CAAF,CAAvB,CAAZ;AACAA,MAAAA,IAAI,CAAE,CAAF,CAAJ,GAAY,KAAI,CAACG,aAAL,CAAoBH,IAAI,CAAE,CAAF,CAAxB,CAAZ;AACA,KAHD,EAGG;AAAEE,MAAAA,QAAQ,EAAE;AAAZ,KAHH;AAIA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACC,kBAAUE,QAAV,EAAoBC,UAApB,EAAiC;AAChC,UAAK,KAAKV,kBAAL,CAAyBS,QAAzB,CAAL,EAA2C;AAC1C;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG,cAAM,IAAIlB,aAAJ,CACL,mCADK,EAEL,IAFK,EAGL;AACCkB,UAAAA,QAAQ,EAARA;AADD,SAHK,CAAN;AAOA;;AAED,WAAKT,kBAAL,CAAyBS,QAAzB,IAAsC,CACrCE,MAAM,CAACC,MAAP,CAAe,EAAf,EAAmBF,UAAnB,CADqC,CAAtC;;AAIA,WAAKG,WAAL;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gBAAQJ,QAAR,EAAkBC,UAAlB,EAA+B;AAC9B,UAAK,CAAC,KAAKV,kBAAL,CAAyBS,QAAzB,CAAN,EAA4C;AAC3C;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG,cAAM,IAAIlB,aAAJ,CAAmB,mCAAnB,EAAwD,IAAxD,EAA8D;AACnEkB,UAAAA,QAAQ,EAARA;AADmE,SAA9D,CAAN;AAGA;;AAED,WAAKT,kBAAL,CAAyBS,QAAzB,EAAoCK,IAApC,CAA0CH,MAAM,CAACC,MAAP,CAAe,EAAf,EAAmBF,UAAnB,CAA1C;;AAEA,WAAKG,WAAL;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,0BAAiB;AAChB,UAAK,CAAC,KAAKE,oBAAX,EAAkC;AACjC,aAAKC,QAAL;AACA;;AAED,aAAO,KAAKD,oBAAZ;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeE,IAAf,EAAsB;AACrB,UAAIR,QAAJ;;AAEA,UAAK,OAAOQ,IAAP,IAAe,QAApB,EAA+B;AAC9BR,QAAAA,QAAQ,GAAGQ,IAAX;AACA,OAFD,MAEO,IAAKA,IAAI,CAACC,EAAL,KAAaD,IAAI,CAACC,EAAL,CAAS,OAAT,KAAsBD,IAAI,CAACC,EAAL,CAAS,YAAT,CAAnC,CAAL,EAAoE;AAC1ET,QAAAA,QAAQ,GAAG,OAAX;AACA,OAFM,CAGP;AAHO,WAIF;AACJA,UAAAA,QAAQ,GAAGQ,IAAI,CAACE,IAAhB;AACA;;AAED,aAAO,KAAKC,cAAL,GAAuBX,QAAvB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sBAAcQ,IAAd,EAAqB;AACpB,aAAO,CAAC,CAAC,KAAKT,aAAL,CAAoBS,IAApB,CAAT;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAASA,IAAT,EAAgB;AACf,UAAMI,GAAG,GAAG,KAAKb,aAAL,CAAoBS,IAApB,CAAZ;AAEA,aAAO,CAAC,EAAGI,GAAG,IAAIA,GAAG,CAACC,OAAd,CAAR;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iBAASL,IAAT,EAAgB;AACf,UAAMI,GAAG,GAAG,KAAKb,aAAL,CAAoBS,IAApB,CAAZ;;AAEA,UAAK,CAACI,GAAN,EAAY;AACX,eAAO,KAAP;AACA;;AAED,aAAO,CAAC,EAAGA,GAAG,CAACE,OAAJ,IAAeF,GAAG,CAACG,QAAtB,CAAR;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,kBAAUP,IAAV,EAAiB;AAChB,UAAMI,GAAG,GAAG,KAAKb,aAAL,CAAoBS,IAApB,CAAZ;;AAEA,UAAK,CAACI,GAAN,EAAY;AACX,eAAO,KAAP;AACA,OALe,CAOhB;AACA;;;AACA,aAAO,CAAC,EAAGA,GAAG,CAACG,QAAJ,IAAkBH,GAAG,CAACE,OAAJ,IAAeF,GAAG,CAACI,YAAnB,IAAmCJ,GAAG,CAACK,SAA5D,CAAR;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,kBAAUT,IAAV,EAAiB;AAChB,UAAMI,GAAG,GAAG,KAAKb,aAAL,CAAoBS,IAApB,CAAZ;AAEA,aAAO,CAAC,EAAGI,GAAG,IAAIA,GAAG,CAACM,QAAd,CAAR;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sBAAcV,IAAd,EAAqB;AACpB,UAAMI,GAAG,GAAG,KAAKb,aAAL,CAAoBS,IAApB,CAAZ;;AAEA,UAAK,CAACI,GAAN,EAAY;AACX,eAAO,KAAP;AACA;;AAED,aAAO,CAAC,EAAGA,GAAG,CAACI,YAAJ,IAAoBJ,GAAG,CAACG,QAA3B,CAAR;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,mBAAWP,IAAX,EAAkB;AACjB,UAAMI,GAAG,GAAG,KAAKb,aAAL,CAAoBS,IAApB,CAAZ;;AAEA,UAAK,CAACI,GAAN,EAAY;AACX,eAAO,KAAP;AACA;;AAED,aAAO,CAAC,EAAGA,GAAG,CAACK,SAAJ,IAAiBL,GAAG,CAACG,QAAxB,CAAR;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,oBAAYI,OAAZ,EAAqBP,GAArB,EAA2B;AAC1B;AACA,UAAK,CAACA,GAAN,EAAY;AACX,eAAO,KAAP;AACA;;AAED,aAAO,KAAKQ,kBAAL,CAAyBR,GAAzB,EAA8BO,OAA9B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,wBAAgBA,OAAhB,EAAyBE,aAAzB,EAAyC;AACxC,UAAMT,GAAG,GAAG,KAAKb,aAAL,CAAoBoB,OAAO,CAACG,IAA5B,CAAZ;;AAEA,UAAK,CAACV,GAAN,EAAY;AACX,eAAO,KAAP;AACA;;AAED,aAAOA,GAAG,CAACW,eAAJ,CAAoBC,QAApB,CAA8BH,aAA9B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,oBAAYI,qBAAZ,EAA2D;AAAA,UAAxBC,cAAwB,uEAAP,IAAO;;AAC1D,UAAKD,qBAAqB,YAAYvC,QAAtC,EAAiD;AAChD,YAAMyC,UAAU,GAAGF,qBAAqB,CAACE,UAAzC;AACA,YAAMC,SAAS,GAAGH,qBAAqB,CAACG,SAAxC;;AAEA,YAAK,EAAGD,UAAU,YAAYxC,OAAzB,CAAL,EAA0C;AACzC;AACJ;AACA;AACA;AACA;AACI,gBAAM,IAAIL,aAAJ,CACL,sCADK,EAEL,IAFK,CAAN;AAIA;;AAED,YAAK,EAAG8C,SAAS,YAAYzC,OAAxB,CAAL,EAAyC;AACxC;AACJ;AACA;AACA;AACA;AACI,gBAAM,IAAIL,aAAJ,CACL,qCADK,EAEL,IAFK,CAAN;AAIA;;AAED,eAAO,KAAK+C,UAAL,CAAiBF,UAAjB,EAA6BC,SAA7B,CAAP;AACA;;AA9ByD,iDAgCrCF,cAAc,CAACI,WAAf,EAhCqC;AAAA;;AAAA;AAgC1D,4DAAoD;AAAA,cAAxCC,KAAwC;;AACnD,cAAK,CAAC,KAAKC,UAAL,CAAiBP,qBAAjB,EAAwCM,KAAxC,CAAN,EAAwD;AACvD,mBAAO,KAAP;AACA;AACD;AApCyD;AAAA;AAAA;AAAA;AAAA;;AAsC1D,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeE,QAAf,EAA0B;AACzB,WAAKvC,EAAL,CAAS,YAAT,EAAuB,UAAEC,GAAF,QAA8B;AAAA;AAAA,YAArBuC,GAAqB;AAAA,YAAhBC,QAAgB;;AACpD;AACA;AACA;AACA,YAAK,CAACA,QAAN,EAAiB;AAChB;AACA;;AAED,YAAMC,QAAQ,GAAGH,QAAQ,CAAEC,GAAF,EAAOC,QAAP,CAAzB;;AAEA,YAAK,OAAOC,QAAP,IAAmB,SAAxB,EAAoC;AACnCzC,UAAAA,GAAG,CAAC0C,IAAJ;AACA1C,UAAAA,GAAG,CAAC2C,MAAJ,GAAaF,QAAb;AACA;AACD,OAdD,EAcG;AAAEtC,QAAAA,QAAQ,EAAE;AAAZ,OAdH;AAeA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,2BAAmBmC,QAAnB,EAA8B;AAC7B,WAAKvC,EAAL,CAAS,gBAAT,EAA2B,UAAEC,GAAF,SAAmC;AAAA;AAAA,YAA1BuC,GAA0B;AAAA,YAArBb,aAAqB;;AAC7D,YAAMe,QAAQ,GAAGH,QAAQ,CAAEC,GAAF,EAAOb,aAAP,CAAzB;;AAEA,YAAK,OAAOe,QAAP,IAAmB,SAAxB,EAAoC;AACnCzC,UAAAA,GAAG,CAAC0C,IAAJ;AACA1C,UAAAA,GAAG,CAAC2C,MAAJ,GAAaF,QAAb;AACA;AACD,OAPD,EAOG;AAAEtC,QAAAA,QAAQ,EAAE;AAAZ,OAPH;AAQA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gCAAwBuB,aAAxB,EAAuCkB,UAAvC,EAAoD;AACnD,WAAK/C,oBAAL,CAA2B6B,aAA3B,IAA6CnB,MAAM,CAACC,MAAP,CAAe,KAAKqC,sBAAL,CAA6BnB,aAA7B,CAAf,EAA6DkB,UAA7D,CAA7C;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,gCAAwBlB,aAAxB,EAAwC;AACvC,aAAO,KAAK7B,oBAAL,CAA2B6B,aAA3B,KAA8C,EAArD;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAiBoB,0BAAjB,EAA8C;AAC7C,UAAIC,OAAJ;;AAEA,UAAKD,0BAA0B,YAAYvD,QAA3C,EAAsD;AACrDwD,QAAAA,OAAO,GAAGD,0BAA0B,CAACE,MAArC;AACA,OAFD,MAEO;AACN,YAAMC,MAAM,GAAGH,0BAA0B,YAAYxD,KAAtC,GACd,CAAEwD,0BAAF,CADc,GAEdI,KAAK,CAACC,IAAN,CAAYL,0BAA0B,CAACM,SAA3B,EAAZ,CAFD,CADM,CAKN;;AACAL,QAAAA,OAAO,GAAGE,MAAM,CACdI,MADQ,CACA,UAAEN,OAAF,EAAWO,KAAX,EAAsB;AAC9B,cAAMC,mBAAmB,GAAGD,KAAK,CAACE,iBAAN,EAA5B;;AAEA,cAAK,CAACT,OAAN,EAAgB;AACf,mBAAOQ,mBAAP;AACA;;AAED,iBAAOR,OAAO,CAACS,iBAAR,CAA2BD,mBAA3B,EAAgD;AAAEE,YAAAA,WAAW,EAAE;AAAf,WAAhD,CAAP;AACA,SATQ,EASN,IATM,CAAV;AAUA;;AAED,aAAQ,CAAC,KAAKtC,OAAL,CAAc4B,OAAd,CAAT,EAAmC;AAClC,YAAKA,OAAO,CAACC,MAAb,EAAsB;AACrBD,UAAAA,OAAO,GAAGA,OAAO,CAACC,MAAlB;AACA,SAFD,MAEO;AACN;AACA;AACD;;AAED,aAAOD,OAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,mCAA2BW,SAA3B,EAAsCC,SAAtC,EAAkD;AACjD,UAAKD,SAAS,CAACE,WAAf,EAA6B;AAC5B,YAAMC,aAAa,GAAGH,SAAS,CAACI,gBAAV,EAAtB;AACA,YAAMtC,OAAO,gCACTqC,aAAa,CAACE,YAAd,EADS,IAEZ,IAAItE,IAAJ,CAAU,EAAV,EAAciE,SAAS,CAACM,aAAV,EAAd,CAFY,EAAb,CAF4B,CAO5B;;AACA,eAAO,KAAKC,cAAL,CAAqBzC,OAArB,EAA8BmC,SAA9B,CAAP;AACA,OATD,MASO;AACN,YAAMV,MAAM,GAAGS,SAAS,CAACN,SAAV,EAAf,CADM,CAGN;;AAHM,oDAIeH,MAJf;AAAA;;AAAA;AAIN,iEAA8B;AAAA,gBAAlBK,KAAkB;;AAAA,wDACRA,KADQ;AAAA;;AAAA;AAC7B,qEAA6B;AAAA,oBAAjBY,KAAiB;;AAC5B,oBAAK,KAAKD,cAAL,CAAqBC,KAAK,CAACrD,IAA3B,EAAiC8C,SAAjC,CAAL,EAAoD;AACnD;AACA,yBAAO,IAAP;AACA;AACD;AAN4B;AAAA;AAAA;AAAA;AAAA;AAO7B;AAXK;AAAA;AAAA;AAAA;AAAA;AAYN,OAtBgD,CAwBjD;;;AACA,aAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;4BACC,wBAAkBV,MAAlB,EAA0BU,SAA1B;AAAA;;AAAA;AAAA;AAAA;AAAA;AACCV,cAAAA,MAAM,GAAG/D,0BAA0B,CAAE+D,MAAF,CAAnC;AADD,sDAGsBA,MAHtB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGaK,cAAAA,KAHb;AAIE,4CAAO,KAAKa,uBAAL,CAA8Bb,KAA9B,EAAqCK,SAArC,CAAP;;AAJF;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,K;AAQA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,kCAA0BS,QAA1B,EAAyD;AAAA;;AAAA,UAArBC,SAAqB,uEAAT,MAAS;;AACxD;AACA,UAAK,KAAKhC,UAAL,CAAiB+B,QAAjB,EAA2B,OAA3B,CAAL,EAA4C;AAC3C,eAAO,IAAI9E,KAAJ,CAAW8E,QAAX,CAAP;AACA;;AAED,UAAIE,cAAJ,EAAoBC,aAApB,CANwD,CAQxD;;AACA,UAAMC,YAAY,GAAGJ,QAAQ,CAACL,YAAT,GAAwBU,OAAxB,GAAkCC,IAAlC,CAAwC,UAAA7D,IAAI;AAAA,eAAI,MAAI,CAACM,OAAL,CAAcN,IAAd,CAAJ;AAAA,OAA5C,KAA0EuD,QAAQ,CAACO,IAAxG;;AAEA,UAAKN,SAAS,IAAI,MAAb,IAAuBA,SAAS,IAAI,UAAzC,EAAsD;AACrDC,QAAAA,cAAc,GAAG,IAAI5E,UAAJ,CAAgB;AAChCkF,UAAAA,UAAU,EAAEtF,KAAK,CAACuF,SAAN,CAAiBL,YAAjB,CADoB;AAEhCM,UAAAA,aAAa,EAAEV,QAFiB;AAGhCC,UAAAA,SAAS,EAAE;AAHqB,SAAhB,CAAjB;AAKA;;AAED,UAAKA,SAAS,IAAI,MAAb,IAAuBA,SAAS,IAAI,SAAzC,EAAqD;AACpDE,QAAAA,aAAa,GAAG,IAAI7E,UAAJ,CAAgB;AAC/BkF,UAAAA,UAAU,EAAEtF,KAAK,CAACuF,SAAN,CAAiBL,YAAjB,CADmB;AAE/BM,UAAAA,aAAa,EAAEV;AAFgB,SAAhB,CAAhB;AAIA;;AAxBuD,kDA0BpCnF,cAAc,CAAEqF,cAAF,EAAkBC,aAAlB,CA1BsB;AAAA;;AAAA;AA0BxD,+DAAsE;AAAA,cAA1DQ,IAA0D;AACrE,cAAMC,IAAI,GAAKD,IAAI,CAACE,MAAL,IAAeX,cAAf,GAAgC,YAAhC,GAA+C,cAA9D;AACA,cAAMJ,KAAK,GAAGa,IAAI,CAACb,KAAnB;;AAEA,cAAKA,KAAK,CAACc,IAAN,IAAcA,IAAd,IAAsB,KAAK5D,QAAL,CAAe8C,KAAK,CAACrD,IAArB,CAA3B,EAAyD;AACxD,mBAAOvB,KAAK,CAAC4F,SAAN,CAAiBhB,KAAK,CAACrD,IAAvB,CAAP;AACA;;AAED,cAAK,KAAKwB,UAAL,CAAiB6B,KAAK,CAACiB,YAAvB,EAAqC,OAArC,CAAL,EAAsD;AACrD,mBAAO,IAAI7F,KAAJ,CAAW4E,KAAK,CAACiB,YAAjB,CAAP;AACA;AACD;AArCuD;AAAA;AAAA;AAAA;AAAA;;AAuCxD,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,2BAAmBf,QAAnB,EAA6BgB,IAA7B,EAAoC;AACnC,UAAIpC,MAAM,GAAGoB,QAAQ,CAACpB,MAAtB;;AAEA,aAAQA,MAAR,EAAiB;AAChB,YAAK,KAAKX,UAAL,CAAiBW,MAAjB,EAAyBoC,IAAzB,CAAL,EAAuC;AACtC,iBAAOpC,MAAP;AACA,SAHe,CAKhB;;;AACA,YAAK,KAAK7B,OAAL,CAAc6B,MAAd,CAAL,EAA8B;AAC7B,iBAAO,IAAP;AACA;;AAEDA,QAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACA;;AAED,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,oCAA4BqC,KAA5B,EAAmCC,MAAnC,EAA4C;AAAA,kDACvBD,KADuB;AAAA;;AAAA;AAC3C,+DAA4B;AAAA,cAAhBD,IAAgB;;AAC3B;AACA,cAAKA,IAAI,CAACtE,EAAL,CAAS,OAAT,CAAL,EAA0B;AACzByE,YAAAA,iCAAiC,CAAE,IAAF,EAAQH,IAAR,EAAcE,MAAd,CAAjC;AACA,WAFD,CAGA;AACA;AACA;AACA;AANA,eAOK;AACJ,kBAAME,WAAW,GAAGlG,KAAK,CAACuF,SAAN,CAAiBO,IAAjB,CAApB;;AACA,kBAAMK,gBAAgB,GAAGD,WAAW,CAACE,YAAZ,EAAzB;;AAFI,0DAIoBD,gBAJpB;AAAA;;AAAA;AAIJ,uEAA2C;AAAA,sBAA/BrB,QAA+B;AAC1C,sBAAMvD,IAAI,GAAGuD,QAAQ,CAACpC,UAAT,IAAuBoC,QAAQ,CAACpB,MAA7C;AAEAuC,kBAAAA,iCAAiC,CAAE,IAAF,EAAQ1E,IAAR,EAAcyE,MAAd,CAAjC;AACA;AARG;AAAA;AAAA;AAAA;AAAA;AASJ;AACD;AApB0C;AAAA;AAAA;AAAA;AAAA;AAqB3C;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,uBAAe9D,OAAf,EAAyB;AACxB,aAAO,IAAItB,aAAJ,CAAmBsB,OAAnB,CAAP;AACA;AAED;AACD;AACA;;;;WACC,uBAAc;AACb,WAAKb,oBAAL,GAA4B,IAA5B;AACA;AAED;AACD;AACA;;;;WACC,oBAAW;AACV,UAAMgF,mBAAmB,GAAG,EAA5B;AACA,UAAMC,WAAW,GAAG,KAAKhG,kBAAzB;AACA,UAAMiG,SAAS,GAAGtF,MAAM,CAACuF,IAAP,CAAaF,WAAb,CAAlB;;AAEA,oCAAwBC,SAAxB,gCAAoC;AAA9B,YAAMxF,QAAQ,iBAAd;AACLsF,QAAAA,mBAAmB,CAAEtF,QAAF,CAAnB,GAAkC0F,mBAAmB,CAAEH,WAAW,CAAEvF,QAAF,CAAb,EAA2BA,QAA3B,CAArD;AACA;;AAED,sCAAwBwF,SAAxB,mCAAoC;AAA9B,YAAMxF,SAAQ,mBAAd;AACL2F,QAAAA,qBAAqB,CAAEL,mBAAF,EAAuBtF,SAAvB,CAArB;AACA;;AAED,sCAAwBwF,SAAxB,mCAAoC;AAA9B,YAAMxF,UAAQ,mBAAd;AACL4F,QAAAA,iBAAiB,CAAEN,mBAAF,EAAuBtF,UAAvB,CAAjB;AACA;;AAED,sCAAwBwF,SAAxB,mCAAoC;AAA9B,YAAMxF,UAAQ,mBAAd;AACL6F,QAAAA,wBAAwB,CAAEP,mBAAF,EAAuBtF,UAAvB,CAAxB;AACA8F,QAAAA,4BAA4B,CAAER,mBAAF,EAAuBtF,UAAvB,CAA5B;AACA;;AAED,sCAAwBwF,SAAxB,mCAAoC;AAA9B,YAAMxF,UAAQ,mBAAd;AACL+F,QAAAA,cAAc,CAAET,mBAAF,EAAuBtF,UAAvB,CAAd;AACAgG,QAAAA,sBAAsB,CAAEV,mBAAF,EAAuBtF,UAAvB,CAAtB;AACA;;AAED,WAAKM,oBAAL,GAA4BgF,mBAA5B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;WACC,4BAAoB1E,GAApB,EAAyBO,OAAzB,EAA0E;AAAA,UAAxC8E,gBAAwC,uEAArB9E,OAAO,CAAC+E,MAAR,GAAiB,CAAI;AACzE,UAAMC,WAAW,GAAGhF,OAAO,CAACiF,OAAR,CAAiBH,gBAAjB,CAApB;;AAEA,UAAKrF,GAAG,CAACyF,OAAJ,CAAY7E,QAAZ,CAAsB2E,WAAW,CAACzF,IAAlC,CAAL,EAAgD;AAC/C,YAAKuF,gBAAgB,IAAI,CAAzB,EAA6B;AAC5B,iBAAO,IAAP;AACA,SAFD,MAEO;AACN,cAAMK,UAAU,GAAG,KAAKvG,aAAL,CAAoBoG,WAApB,CAAnB;AAEA,iBAAO,KAAK/E,kBAAL,CAAyBkF,UAAzB,EAAqCnF,OAArC,EAA8C8E,gBAAgB,GAAG,CAAjE,CAAP;AACA;AACD,OARD,MAQO;AACN,eAAO,KAAP;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;4BACC,iCAA2BhD,KAA3B,EAAkCK,SAAlC;AAAA;;AAAA;AAAA;AAAA;AAAA;AACKiD,cAAAA,KADL,GACatD,KAAK,CAACsD,KADnB;AAEKC,cAAAA,GAFL,GAEWvD,KAAK,CAACsD,KAFjB;AAAA,sDAIqBtD,KAAK,CAACwD,QAAN,CAAgB;AAAEC,gBAAAA,OAAO,EAAE;AAAX,eAAhB,CAJrB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIalG,cAAAA,IAJb;;AAAA,mBAKOA,IAAI,CAACC,EAAL,CAAS,SAAT,CALP;AAAA;AAAA;AAAA;;AAMG,6CAAO,KAAKqD,uBAAL,CAA8B7E,KAAK,CAACuF,SAAN,CAAiBhE,IAAjB,CAA9B,EAAuD8C,SAAvD,CAAP;;AANH;AAAA,kBASQ,KAAKM,cAAL,CAAqBpD,IAArB,EAA2B8C,SAA3B,CATR;AAAA;AAAA;AAAA;;AAAA,kBAUSiD,KAAK,CAACI,OAAN,CAAeH,GAAf,CAVT;AAAA;AAAA;AAAA;;AAAA;AAWI,qBAAM,IAAIvH,KAAJ,CAAWsH,KAAX,EAAkBC,GAAlB,CAAN;;AAXJ;AAcGD,cAAAA,KAAK,GAAGrH,QAAQ,CAAC0H,YAAT,CAAuBpG,IAAvB,CAAR;;AAdH;AAiBEgG,cAAAA,GAAG,GAAGtH,QAAQ,CAAC0H,YAAT,CAAuBpG,IAAvB,CAAN;;AAjBF;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA,kBAoBO+F,KAAK,CAACI,OAAN,CAAeH,GAAf,CApBP;AAAA;AAAA;AAAA;;AAAA;AAqBE,qBAAM,IAAIvH,KAAJ,CAAWsH,KAAX,EAAkBC,GAAlB,CAAN;;AArBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,K;;;;;;SAz4BoBlH,M;AAm6BrBN,GAAG,CAAEM,MAAF,EAAUP,eAAV,CAAH;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAac,aAAb;AACC;AACD;AACA;AACA;AACA;AACC,yBAAasB,OAAb,EAAuB;AAAA;;AACtB,QAAKA,OAAO,YAAYtB,aAAxB,EAAwC;AACvC,aAAOsB,OAAP;AACA;;AAED,QAAK,OAAOA,OAAP,IAAkB,QAAvB,EAAkC;AACjCA,MAAAA,OAAO,GAAG,CAAEA,OAAF,CAAV;AACA,KAFD,MAEO,IAAK,CAAC0B,KAAK,CAACgE,OAAN,CAAe1F,OAAf,CAAN,EAAiC;AACvC;AACA;AACAA,MAAAA,OAAO,GAAGA,OAAO,CAACuC,YAAR,CAAsB;AAAEN,QAAAA,WAAW,EAAE;AAAf,OAAtB,CAAV;AACA;;AAED,SAAK0D,MAAL,GAAc3F,OAAO,CAAC4F,GAAR,CAAaC,cAAb,CAAd;AACA;AAED;AACD;AACA;AACA;AACA;;;AA1BA;AAAA;AAAA,SA2BC,eAAa;AACZ,aAAO,KAAKF,MAAL,CAAYZ,MAAnB;AACA;AAED;AACD;AACA;AACA;AACA;;AAnCA;AAAA;AAAA,SAoCC,eAAW;AACV,aAAO,KAAKY,MAAL,CAAa,KAAKA,MAAL,CAAYZ,MAAZ,GAAqB,CAAlC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;AA9CA;AAAA,SA+CGe,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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport Text from './text';\nimport TreeWalker from './treewalker';\n\n/**\n * The model's schema. It defines allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by features and based on them the editing framework and features\n * make decisions how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * {@glink framework/guides/architecture/editing-engine#schema Schema} section of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture}.\n * * {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Schema {\n\t/**\n\t * Creates schema instance.\n\t */\n\tconstructor() {\n\t\tthis._sourceDefinitions = {};\n\n\t\t/**\n\t\t * A dictionary containing attribute properties.\n\t\t *\n\t\t * @private\n\t\t * @member {Object.<String,String>}\n\t\t */\n\t\tthis._attributeProperties = {};\n\n\t\tthis.decorate( 'checkChild' );\n\t\tthis.decorate( 'checkAttribute' );\n\n\t\tthis.on( 'checkAttribute', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t}, { priority: 'highest' } );\n\n\t\tthis.on( 'checkChild', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t\targs[ 1 ] = this.getDefinition( args[ 1 ] );\n\t\t}, { priority: 'highest' } );\n\t}\n\n\t/**\n\t * Registers schema item. Can only be called once for every item name.\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tinheritAllFrom: '$block'\n\t *\t\t} );\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\tregister( itemName, definition ) {\n\t\tif ( this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * A single item cannot be registered twice in the schema.\n\t\t\t *\n\t\t\t * This situation may happen when:\n\t\t\t *\n\t\t\t * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n\t\t\t * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n\t\t\t * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n\t\t\t * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n\t\t\t * and usually means one or more of the following issues:\n\t\t\t *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n\t\t\t *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n\t\t\t *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n\t\t\t *\n\t\t\t * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element that is being registered twice.\n\t\t\t * @error schema-cannot-register-item-twice\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'schema-cannot-register-item-twice',\n\t\t\t\tthis,\n\t\t\t\t{\n\t\t\t\t\titemName\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ] = [\n\t\t\tObject.assign( {}, definition )\n\t\t];\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Extends a {@link #register registered} item's definition.\n\t *\n\t * Extending properties such as `allowIn` will add more items to the existing properties,\n\t * while redefining properties such as `isBlock` will override the previously defined ones.\n\t *\n\t *\t\tschema.register( 'foo', {\n\t *\t\t\tallowIn: '$root',\n\t *\t\t\tisBlock: true;\n\t *\t\t} );\n\t *\t\tschema.extend( 'foo', {\n\t *\t\t\tallowIn: 'blockQuote',\n\t *\t\t\tisBlock: false\n\t *\t\t} );\n\t *\n\t *\t\tschema.getDefinition( 'foo' );\n\t *\t\t//\t{\n\t *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n\t *\t\t// \t\tisBlock: false\n\t *\t\t//\t}\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\textend( itemName, definition ) {\n\t\tif ( !this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * Cannot extend an item which was not registered yet.\n\t\t\t *\n\t\t\t * This error happens when a plugin tries to extend the schema definition of an item which was not\n\t\t\t * {@link #register registered} yet.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element which is being extended.\n\t\t\t * @error schema-cannot-extend-missing-item\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'schema-cannot-extend-missing-item', this, {\n\t\t\t\titemName\n\t\t\t} );\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ].push( Object.assign( {}, definition ) );\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Returns data of all registered items.\n\t *\n\t * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n\t * checking a list of all block elements, etc).\n\t * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n\t * in other cases.\n\t *\n\t * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n\t */\n\tgetDefinitions() {\n\t\tif ( !this._compiledDefinitions ) {\n\t\t\tthis._compile();\n\t\t}\n\n\t\treturn this._compiledDefinitions;\n\t}\n\n\t/**\n\t * Returns a definition of the given item or `undefined` if an item is not registered.\n\t *\n\t * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n\t * checking a list of all block elements, etc).\n\t * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n\t * in other cases.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n\t */\n\tgetDefinition( item ) {\n\t\tlet itemName;\n\n\t\tif ( typeof item == 'string' ) {\n\t\t\titemName = item;\n\t\t} else if ( item.is && ( item.is( '$text' ) || item.is( '$textProxy' ) ) ) {\n\t\t\titemName = '$text';\n\t\t}\n\t\t// Element or module:engine/model/schema~SchemaContextItem.\n\t\telse {\n\t\t\titemName = item.name;\n\t\t}\n\n\t\treturn this.getDefinitions()[ itemName ];\n\t}\n\n\t/**\n\t * Returns `true` if the given item is registered in the schema.\n\t *\n\t *\t\tschema.isRegistered( 'paragraph' ); // -> true\n\t *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isRegistered( 'foo' ); // -> false\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisRegistered( item ) {\n\t\treturn !!this.getDefinition( item );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n\t *\n\t *\t\tschema.isBlock( 'paragraph' ); // -> true\n\t *\t\tschema.isBlock( '$root' ); // -> false\n\t *\n\t *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n\t *\t\tschema.isBlock( paragraphElement ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of the Schema deep dive\n\t * guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisBlock( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isBlock );\n\t}\n\n\t/**\n\t * Returns `true` if the given item should be treated as a limit element.\n\t *\n\t * It considers an item to be a limit element if its\n\t * {@link module:engine/model/schema~SchemaItemDefinition}'s\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n\t * was set to `true`.\n\t *\n\t *\t\tschema.isLimit( 'paragraph' ); // -> false\n\t *\t\tschema.isLimit( '$root' ); // -> true\n\t *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isLimit( 'image' ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of the Schema deep dive\n\t * guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisLimit( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isLimit || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item should be treated as an object element.\n\t *\n\t * It considers an item to be an object element if its\n\t * {@link module:engine/model/schema~SchemaItemDefinition}'s\n\t * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n\t * was set to `true`.\n\t *\n\t *\t\tschema.isObject( 'paragraph' ); // -> false\n\t *\t\tschema.isObject( 'image' ); // -> true\n\t *\n\t *\t\tconst imageElement = writer.createElement( 'image' );\n\t *\t\tschema.isObject( imageElement ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of the Schema deep dive\n\t * guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisObject( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Note: Check out the implementation of #isLimit(), #isSelectable(), and #isContent()\n\t\t// to understand why these three constitute an object.\n\t\treturn !!( def.isObject || ( def.isLimit && def.isSelectable && def.isContent ) );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n\t *\n\t *\t\tschema.isInline( 'paragraph' ); // -> false\n\t *\t\tschema.isInline( 'softBreak' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isInline( text ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of the Schema deep dive\n\t * guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisInline( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isInline );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.\n\t *\n\t *\t\tschema.isSelectable( 'paragraph' ); // -> false\n\t *\t\tschema.isSelectable( 'heading1' ); // -> false\n\t *\t\tschema.isSelectable( 'image' ); // -> true\n\t *\t\tschema.isSelectable( 'tableCell' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isSelectable( text ); // -> false\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements} section of the Schema deep dive}\n\t * guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisSelectable( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isSelectable || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.\n\t *\n\t *\t\tschema.isContent( 'paragraph' ); // -> false\n\t *\t\tschema.isContent( 'heading1' ); // -> false\n\t *\t\tschema.isContent( 'image' ); // -> true\n\t *\t\tschema.isContent( 'horizontalLine' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\tschema.isContent( text ); // -> true\n\t *\n\t * See the {@glink framework/guides/deep-dive/schema#content-elements Content elements} section of the Schema deep dive}\n\t * guide for more details.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisContent( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isContent || def.isObject );\n\t}\n\n\t/**\n\t * Checks whether the given node (`child`) can be a child of the given context.\n\t *\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tallowIn: '$root'\n\t *\t\t} );\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n\t *\n\t * Note: When verifying whether the given node can be a child of the given context, the\n\t * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n\t * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n\t * It happens if one of the context's elements does not allow its child.\n\t *\n\t * @fires checkChild\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n\t * @param {module:engine/model/node~Node|String} def The child to check.\n\t */\n\tcheckChild( context, def ) {\n\t\t// Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._checkContextMatch( def, context );\n\t}\n\n\t/**\n\t * Checks whether the given attribute can be applied in the given context (on the last\n\t * item of the context).\n\t *\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n\t *\n\t *\t\tschema.extend( '$text', {\n\t *\t\t\tallowAttributes: 'bold'\n\t *\t\t} );\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n\t *\n\t * @fires checkAttribute\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n\t * @param {String} attributeName\n\t */\n\tcheckAttribute( context, attributeName ) {\n\t\tconst def = this.getDefinition( context.last );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn def.allowAttributes.includes( attributeName );\n\t}\n\n\t/**\n\t * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n\t *\n\t * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n\t *\n\t * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n\t * will be valid.\n\t *\n\t * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n\t * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n\t *\n\t * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n\t * element to which the `elementToMerge` will be merged.\n\t * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n\t * @returns {Boolean}\n\t */\n\tcheckMerge( positionOrBaseElement, elementToMerge = null ) {\n\t\tif ( positionOrBaseElement instanceof Position ) {\n\t\t\tconst nodeBefore = positionOrBaseElement.nodeBefore;\n\t\t\tconst nodeAfter = positionOrBaseElement.nodeAfter;\n\n\t\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node before the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-before\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-before',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node after the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-after\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-after',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.checkMerge( nodeBefore, nodeAfter );\n\t\t}\n\n\t\tfor ( const child of elementToMerge.getChildren() ) {\n\t\t\tif ( !this.checkChild( positionOrBaseElement, child ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkChild} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow elements in specific contexts.\n\t *\n\t * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow heading1 directly inside a blockQuote.\n\t *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkChild', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst childDefinition = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkChild()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and\n\t * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n\t * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n\t */\n\taddChildCheck( callback ) {\n\t\tthis.on( 'checkChild', ( evt, [ ctx, childDef ] ) => {\n\t\t\t// checkChild() was called with a non-registered child.\n\t\t\t// In 99% cases such check should return false, so not to overcomplicate all callbacks\n\t\t\t// don't even execute them.\n\t\t\tif ( !childDef ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst retValue = callback( ctx, childDef );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkAttribute} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow attribute if node to which it is applied\n\t * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n\t *\n\t * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow bold on $text inside heading1.\n\t *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst attributeName = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkAttribute()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n\t * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n\t */\n\taddAttributeCheck( callback ) {\n\t\tthis.on( 'checkAttribute', ( evt, [ ctx, attributeName ] ) => {\n\t\t\tconst retValue = callback( ctx, attributeName );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * This method allows assigning additional metadata to the model attributes. For example,\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n\t * used to mark formatting attributes (like `bold` or `italic`).\n\t *\n\t *\t\t// Mark bold as a formatting attribute.\n\t *\t\tschema.setAttributeProperties( 'bold', {\n\t *\t\t\tisFormatting: true\n\t *\t\t} );\n\t *\n\t *\t\t// Override code not to be considered a formatting markup.\n\t *\t\tschema.setAttributeProperties( 'code', {\n\t *\t\t\tisFormatting: false\n\t *\t\t} );\n\t *\n\t * Properties are not limited to members defined in the\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tcustomProperty: 'value'\n\t *\t\t} );\n\t *\n\t * Subsequent calls with the same attribute will extend its custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tone: 1\n\t *\t\t} );\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\ttwo: 2\n\t *\t\t} );\n\t *\n\t *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n\t *\t\t// Logs: { one: 1, two: 2 }\n\t *\n\t * @param {String} attributeName A name of the attribute to receive the properties.\n\t * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n\t */\n\tsetAttributeProperties( attributeName, properties ) {\n\t\tthis._attributeProperties[ attributeName ] = Object.assign( this.getAttributeProperties( attributeName ), properties );\n\t}\n\n\t/**\n\t * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n\t *\n\t * @param {String} attributeName A name of the attribute.\n\t * @returns {module:engine/model/schema~AttributeProperties}\n\t */\n\tgetAttributeProperties( attributeName ) {\n\t\treturn this._attributeProperties[ attributeName ] || {};\n\t}\n\n\t/**\n\t * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n\t * selection/range/position or the root otherwise.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n\t * The selection/range/position to check.\n\t * @returns {module:engine/model/element~Element} The lowest limit element containing\n\t * the entire `selectionOrRangeOrPosition`.\n\t */\n\tgetLimitElement( selectionOrRangeOrPosition ) {\n\t\tlet element;\n\n\t\tif ( selectionOrRangeOrPosition instanceof Position ) {\n\t\t\telement = selectionOrRangeOrPosition.parent;\n\t\t} else {\n\t\t\tconst ranges = selectionOrRangeOrPosition instanceof Range ?\n\t\t\t\t[ selectionOrRangeOrPosition ] :\n\t\t\t\tArray.from( selectionOrRangeOrPosition.getRanges() );\n\n\t\t\t// Find the common ancestor for all selection's ranges.\n\t\t\telement = ranges\n\t\t\t\t.reduce( ( element, range ) => {\n\t\t\t\t\tconst rangeCommonAncestor = range.getCommonAncestor();\n\n\t\t\t\t\tif ( !element ) {\n\t\t\t\t\t\treturn rangeCommonAncestor;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn element.getCommonAncestor( rangeCommonAncestor, { includeSelf: true } );\n\t\t\t\t}, null );\n\t\t}\n\n\t\twhile ( !this.isLimit( element ) ) {\n\t\t\tif ( element.parent ) {\n\t\t\t\telement = element.parent;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n\n\t/**\n\t * Checks whether the attribute is allowed in selection:\n\t *\n\t * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n\t * * if the selection is collapsed, then checks if on the selection position there's a text with the\n\t * specified attribute allowed.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection which will be checked.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Boolean}\n\t */\n\tcheckAttributeInSelection( selection, attribute ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\tconst firstPosition = selection.getFirstPosition();\n\t\t\tconst context = [\n\t\t\t\t...firstPosition.getAncestors(),\n\t\t\t\tnew Text( '', selection.getAttributes() )\n\t\t\t];\n\n\t\t\t// Check whether schema allows for a text with the attribute in the selection.\n\t\t\treturn this.checkAttribute( context, attribute );\n\t\t} else {\n\t\t\tconst ranges = selection.getRanges();\n\n\t\t\t// For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tif ( this.checkAttribute( value.item, attribute ) ) {\n\t\t\t\t\t\t// If we found a node that is allowed to have the attribute, return true.\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't found such node, return false.\n\t\treturn false;\n\t}\n\n\t/**\n\t * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* getValidRanges( ranges, attribute ) {\n\t\tranges = convertToMinimalFlatRanges( ranges );\n\n\t\tfor ( const range of ranges ) {\n\t\t\tyield* this._getValidRangesForRange( range, attribute );\n\t\t}\n\t}\n\n\t/**\n\t * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n\t * nearest to that `position` and is a correct range for selection.\n\t *\n\t * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n\t * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n\t * the {@link module:engine/model/schema~Schema schema}.\n\t *\n\t * Direction of searching for the nearest correct selection range can be specified as:\n\t *\n\t * * `both` - searching will be performed in both ways,\n\t * * `forward` - searching will be performed only forward,\n\t * * `backward` - searching will be performed only backward.\n\t *\n\t * When valid selection range cannot be found, `null` is returned.\n\t *\n\t * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n\t * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n\t * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n\t */\n\tgetNearestSelectionRange( position, direction = 'both' ) {\n\t\t// Return collapsed range if provided position is valid.\n\t\tif ( this.checkChild( position, '$text' ) ) {\n\t\t\treturn new Range( position );\n\t\t}\n\n\t\tlet backwardWalker, forwardWalker;\n\n\t\t// Never leave a limit element.\n\t\tconst limitElement = position.getAncestors().reverse().find( item => this.isLimit( item ) ) || position.root;\n\n\t\tif ( direction == 'both' || direction == 'backward' ) {\n\t\t\tbackwardWalker = new TreeWalker( {\n\t\t\t\tboundaries: Range._createIn( limitElement ),\n\t\t\t\tstartPosition: position,\n\t\t\t\tdirection: 'backward'\n\t\t\t} );\n\t\t}\n\n\t\tif ( direction == 'both' || direction == 'forward' ) {\n\t\t\tforwardWalker = new TreeWalker( {\n\t\t\t\tboundaries: Range._createIn( limitElement ),\n\t\t\t\tstartPosition: position\n\t\t\t} );\n\t\t}\n\n\t\tfor ( const data of combineWalkers( backwardWalker, forwardWalker ) ) {\n\t\t\tconst type = ( data.walker == backwardWalker ? 'elementEnd' : 'elementStart' );\n\t\t\tconst value = data.value;\n\n\t\t\tif ( value.type == type && this.isObject( value.item ) ) {\n\t\t\t\treturn Range._createOn( value.item );\n\t\t\t}\n\n\t\t\tif ( this.checkChild( value.nextPosition, '$text' ) ) {\n\t\t\t\treturn new Range( value.nextPosition );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Tries to find position ancestors that allow to insert a given node.\n\t * It starts searching from the given position and goes node by node to the top of the model tree\n\t * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an\n\t * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.\n\t *\n\t * @param {module:engine/model/position~Position} position The position that the search will start from.\n\t * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.\n\t * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n\t */\n\tfindAllowedParent( position, node ) {\n\t\tlet parent = position.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( this.checkChild( parent, node ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\t// Do not split limit elements.\n\t\t\tif ( this.isLimit( parent ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes attributes disallowed by the schema.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n\t * @param {module:engine/model/writer~Writer} writer\n\t */\n\tremoveDisallowedAttributes( nodes, writer ) {\n\t\tfor ( const node of nodes ) {\n\t\t\t// When node is a `Text` it has no children, so just filter it out.\n\t\t\tif ( node.is( '$text' ) ) {\n\t\t\t\tremoveDisallowedAttributeFromNode( this, node, writer );\n\t\t\t}\n\t\t\t// In a case of `Element` iterates through positions between nodes inside this element\n\t\t\t// and filter out node before the current position, or position parent when position\n\t\t\t// is at start of an element. Using positions prevent from omitting merged nodes\n\t\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n\t\t\telse {\n\t\t\t\tconst rangeInNode = Range._createIn( node );\n\t\t\t\tconst positionsInRange = rangeInNode.getPositions();\n\n\t\t\t\tfor ( const position of positionsInRange ) {\n\t\t\t\t\tconst item = position.nodeBefore || position.parent;\n\n\t\t\t\t\tremoveDisallowedAttributeFromNode( this, item, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an instance of the schema context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t * @returns {module:engine/model/schema~SchemaContext}\n\t */\n\tcreateContext( context ) {\n\t\treturn new SchemaContext( context );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_clearCache() {\n\t\tthis._compiledDefinitions = null;\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_compile() {\n\t\tconst compiledDefinitions = {};\n\t\tconst sourceRules = this._sourceDefinitions;\n\t\tconst itemNames = Object.keys( sourceRules );\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompiledDefinitions[ itemName ] = compileBaseItemRule( sourceRules[ itemName ], itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowContentOf( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowWhere( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowAttributesOf( compiledDefinitions, itemName );\n\t\t\tcompileInheritPropertiesFrom( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcleanUpAllowIn( compiledDefinitions, itemName );\n\t\t\tcleanUpAllowAttributes( compiledDefinitions, itemName );\n\t\t}\n\n\t\tthis._compiledDefinitions = compiledDefinitions;\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n\t * @param {module:engine/model/schema~SchemaContext} context\n\t * @param {Number} contextItemIndex\n\t */\n\t_checkContextMatch( def, context, contextItemIndex = context.length - 1 ) {\n\t\tconst contextItem = context.getItem( contextItemIndex );\n\n\t\tif ( def.allowIn.includes( contextItem.name ) ) {\n\t\t\tif ( contextItemIndex == 0 ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst parentRule = this.getDefinition( contextItem );\n\n\t\t\t\treturn this._checkContextMatch( parentRule, context, contextItemIndex - 1 );\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n\t * inside the given range on which the attribute can be applied.\n\t *\n\t * This is a helper function for {@link ~Schema#getValidRanges}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range to process.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* _getValidRangesForRange( range, attribute ) {\n\t\tlet start = range.start;\n\t\tlet end = range.start;\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tyield* this._getValidRangesForRange( Range._createIn( item ), attribute );\n\t\t\t}\n\n\t\t\tif ( !this.checkAttribute( item, attribute ) ) {\n\t\t\t\tif ( !start.isEqual( end ) ) {\n\t\t\t\t\tyield new Range( start, end );\n\t\t\t\t}\n\n\t\t\t\tstart = Position._createAfter( item );\n\t\t\t}\n\n\t\t\tend = Position._createAfter( item );\n\t\t}\n\n\t\tif ( !start.isEqual( end ) ) {\n\t\t\tyield new Range( start, end );\n\t\t}\n\t}\n}\n\nmix( Schema, ObservableMixin );\n\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding standard behavior of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you do not have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\", you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding the standard behavior of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you do not have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1`, you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * {@link ~SchemaItemDefinition#allowIn `allowIn`} &ndash; Defines in which other items this item will be allowed.\n * * {@link ~SchemaItemDefinition#allowAttributes `allowAttributes`} &ndash; Defines allowed attributes of the given item.\n * * {@link ~SchemaItemDefinition#allowContentOf `allowContentOf`} &ndash; Inherits \"allowed children\" from other items.\n * * {@link ~SchemaItemDefinition#allowWhere `allowWhere`} &ndash; Inherits \"allowed in\" from other items.\n * * {@link ~SchemaItemDefinition#allowAttributesOf `allowAttributesOf`} &ndash; Inherits attributes from other items.\n * * {@link ~SchemaItemDefinition#inheritTypesFrom `inheritTypesFrom`} &ndash; Inherits `is*` properties of other items.\n * * {@link ~SchemaItemDefinition#inheritAllFrom `inheritAllFrom`} &ndash;\n * A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * # The `is*` properties\n *\n * There are a couple commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * {@link ~SchemaItemDefinition#isBlock `isBlock`} &ndash; Whether this item is paragraph-like.\n * Generally speaking, content is usually made out of blocks like paragraphs, list items, images, headings, etc.\n * * {@link ~SchemaItemDefinition#isInline `isInline`} &ndash; Whether an item is \"text-like\" and should be treated as an inline node.\n * Examples of inline elements: `$text`, `softBreak` (`<br>`), etc.\n * * {@link ~SchemaItemDefinition#isLimit `isLimit`} &ndash; It can be understood as whether this element\n * should not be split by <kbd>Enter</kbd>. Examples of limit elements: `$root`, table cell, image caption, etc.\n * In other words, all actions that happen inside a limit element are limited to its content.\n * All objects are treated as limit elements, too.\n * * {@link ~SchemaItemDefinition#isObject `isObject`} &ndash; Whether an item is \"self-contained\" and should be treated as a whole.\n * Examples of object elements: `image`, `table`, `video`, etc. An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the meaning of these types in the\n * {@glink framework/guides/deep-dive/schema#defining-additional-semantics dedicated section of the Schema deep dive} guide.\n *\n * # Generic items\n *\n * There are three basic generic items: `$root`, `$block` and `$text`.\n * They are defined as follows:\n *\n *\t\tthis.schema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\t\tthis.schema.register( '$block', {\n *\t\t\tallowIn: '$root',\n *\t\t\tisBlock: true\n *\t\t} );\n *\t\tthis.schema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Make `image` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'image', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n * Make `caption` allowed in `image` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'image',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about defining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n *\n * @property {String|Array.<String>} allowIn Defines in which other items this item will be allowed.\n * @property {String|Array.<String>} allowAttributes Defines allowed attributes of the given item.\n * @property {String|Array.<String>} allowContentOf Inherits \"allowed children\" from other items.\n * @property {String|Array.<String>} allowWhere Inherits \"allowed in\" from other items.\n * @property {String|Array.<String>} allowAttributesOf Inherits attributes from other items.\n * @property {String|Array.<String>} inheritTypesFrom Inherits `is*` properties of other items.\n * @property {String} inheritAllFrom A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * @property {Boolean} isBlock\n * Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n *\n * Read more about the block elements in the\n * {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of the Schema deep dive} guide.\n *\n * @property {Boolean} isInline\n * Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * Read more about the inline elements in the\n * {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of the Schema deep dive} guide.\n *\n * @property {Boolean} isLimit\n * It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content.\n *\n * Read more about the limit elements in the\n * {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of the Schema deep dive} guide.\n *\n * @property {Boolean} isObject\n * Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `image`, `table`, `video`, etc.\n *\n * **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the object elements in the\n * {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of the Schema deep dive} guide.\n *\n * @property {Boolean} isSelectable\n * `true` when an element should be selectable as a whole by the user. Examples of selectable elements: `image`, `table`, `tableCell`, etc.\n *\n * **Note:** An object is also a selectable element, so\n * {@link module:engine/model/schema~Schema#isSelectable `isSelectable()`} returns `true` for object elements automatically.\n *\n * Read more about selectable elements in the\n * {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements} section of the Schema deep dive} guide.\n *\n * @property {Boolean} isContent\n * An item is a content when it always finds its way to the editor data output regardless of the number and type of its descendants.\n * Examples of content elements: `$text`, `image`, `table`, etc. (but not `paragraph`, `heading1` or `tableCell`).\n *\n * **Note:** An object is also a content element, so\n * {@link module:engine/model/schema~Schema#isContent `isContent()`} returns `true` for object elements automatically.\n *\n * Read more about content elements in the\n * {@glink framework/guides/deep-dive/schema#content-elements Content elements} section of the Schema deep dive} guide.\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefinition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\nexport class SchemaContext {\n\t/**\n\t * Creates an instance of the context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t */\n\tconstructor( context ) {\n\t\tif ( context instanceof SchemaContext ) {\n\t\t\treturn context;\n\t\t}\n\n\t\tif ( typeof context == 'string' ) {\n\t\t\tcontext = [ context ];\n\t\t} else if ( !Array.isArray( context ) ) {\n\t\t\t// `context` is item or position.\n\t\t\t// Position#getAncestors() doesn't accept any parameters but it works just fine here.\n\t\t\tcontext = context.getAncestors( { includeSelf: true } );\n\t\t}\n\n\t\tthis._items = context.map( mapContextItem );\n\t}\n\n\t/**\n\t * The number of items.\n\t *\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * The last item (the lowest node).\n\t *\n\t * @type {module:engine/model/schema~SchemaContextItem}\n\t */\n\tget last() {\n\t\treturn this._items[ this._items.length - 1 ];\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all context items.\n\t *\n\t * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns a new schema context instance with an additional item.\n\t *\n\t * Item can be added as:\n\t *\n\t * \t\tconst context = new SchemaContext( [ '$root' ] );\n\t *\n\t * \t\t// An element.\n\t * \t\tconst fooElement = writer.createElement( 'fooElement' );\n\t * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n\t *\n\t * \t\t// A text node.\n\t * \t\tconst text = writer.createText( 'foobar' );\n\t * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n\t *\n\t * \t\t// A string (element name).\n\t * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n\t *\n\t * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n\t * (without ancestors).\n\t *\n\t * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n\t * to the current context.\n\t * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n\t */\n\tpush( item ) {\n\t\tconst ctx = new SchemaContext( [ item ] );\n\n\t\tctx._items = [ ...this._items, ...ctx._items ];\n\n\t\treturn ctx;\n\t}\n\n\t/**\n\t * Gets an item on the given index.\n\t *\n\t * @returns {module:engine/model/schema~SchemaContextItem}\n\t */\n\tgetItem( index ) {\n\t\treturn this._items[ index ];\n\t}\n\n\t/**\n\t * Returns the names of items.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* getNames() {\n\t\tyield* this._items.map( item => item.name );\n\t}\n\n\t/**\n\t * Checks whether the context ends with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$text' ); // -> true\n\t *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n\t *\t\tctx.endsWith( '$root' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tendsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).endsWith( query );\n\t}\n\n\t/**\n\t * Checks whether the context starts with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$root' ); // -> true\n\t *\t\tctx.endsWith( '$root paragraph' ); // -> true\n\t *\t\tctx.endsWith( '$text' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tstartsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).startsWith( query );\n\t}\n}\n\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node**  in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document  in this case all its ancestors will be used.\n * * By defining an **array of nodes**  in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes)  The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mixing in an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name`  the name of this item,\n * * `* getAttributeKeys()`  a generator of keys of item attributes,\n * * `getAttribute( keyName )`  a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.\n */\n\nfunction compileBaseItemRule( sourceItemRules, itemName ) {\n\tconst itemRule = {\n\t\tname: itemName,\n\n\t\tallowIn: [],\n\t\tallowContentOf: [],\n\t\tallowWhere: [],\n\n\t\tallowAttributes: [],\n\t\tallowAttributesOf: [],\n\n\t\tinheritTypesFrom: []\n\t};\n\n\tcopyTypes( sourceItemRules, itemRule );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowIn' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowContentOf' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowWhere' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributes' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributesOf' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'inheritTypesFrom' );\n\n\tmakeInheritAllWork( sourceItemRules, itemRule );\n\n\treturn itemRule;\n}\n\nfunction compileAllowContentOf( compiledDefinitions, itemName ) {\n\tfor ( const allowContentOfItemName of compiledDefinitions[ itemName ].allowContentOf ) {\n\t\t// The allowContentOf property may point to an unregistered element.\n\t\tif ( compiledDefinitions[ allowContentOfItemName ] ) {\n\t\t\tconst allowedChildren = getAllowedChildren( compiledDefinitions, allowContentOfItemName );\n\n\t\t\tallowedChildren.forEach( allowedItem => {\n\t\t\t\tallowedItem.allowIn.push( itemName );\n\t\t\t} );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowContentOf;\n}\n\nfunction compileAllowWhere( compiledDefinitions, itemName ) {\n\tfor ( const allowWhereItemName of compiledDefinitions[ itemName ].allowWhere ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowWhereItemName ];\n\n\t\t// The allowWhere property may point to an unregistered element.\n\t\tif ( inheritFrom ) {\n\t\t\tconst allowedIn = inheritFrom.allowIn;\n\n\t\t\tcompiledDefinitions[ itemName ].allowIn.push( ...allowedIn );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowWhere;\n}\n\nfunction compileAllowAttributesOf( compiledDefinitions, itemName ) {\n\tfor ( const allowAttributeOfItem of compiledDefinitions[ itemName ].allowAttributesOf ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowAttributeOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst inheritAttributes = inheritFrom.allowAttributes;\n\n\t\t\tcompiledDefinitions[ itemName ].allowAttributes.push( ...inheritAttributes );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom( compiledDefinitions, itemName ) {\n\tconst item = compiledDefinitions[ itemName ];\n\n\tfor ( const inheritPropertiesOfItem of item.inheritTypesFrom ) {\n\t\tconst inheritFrom = compiledDefinitions[ inheritPropertiesOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst typeNames = Object.keys( inheritFrom ).filter( name => name.startsWith( 'is' ) );\n\n\t\t\tfor ( const name of typeNames ) {\n\t\t\t\tif ( !( name in item ) ) {\n\t\t\t\t\titem[ name ] = inheritFrom[ name ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete item.inheritTypesFrom;\n}\n\n// Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\nfunction cleanUpAllowIn( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\tconst existingItems = itemRule.allowIn.filter( itemToCheck => compiledDefinitions[ itemToCheck ] );\n\n\titemRule.allowIn = Array.from( new Set( existingItems ) );\n}\n\nfunction cleanUpAllowAttributes( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\titemRule.allowAttributes = Array.from( new Set( itemRule.allowAttributes ) );\n}\n\nfunction copyTypes( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst typeNames = Object.keys( sourceItemRule ).filter( name => name.startsWith( 'is' ) );\n\n\t\tfor ( const name of typeNames ) {\n\t\t\titemRule[ name ] = sourceItemRule[ name ];\n\t\t}\n\t}\n}\n\nfunction copyProperty( sourceItemRules, itemRule, propertyName ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tif ( typeof sourceItemRule[ propertyName ] == 'string' ) {\n\t\t\titemRule[ propertyName ].push( sourceItemRule[ propertyName ] );\n\t\t} else if ( Array.isArray( sourceItemRule[ propertyName ] ) ) {\n\t\t\titemRule[ propertyName ].push( ...sourceItemRule[ propertyName ] );\n\t\t}\n\t}\n}\n\nfunction makeInheritAllWork( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst inheritFrom = sourceItemRule.inheritAllFrom;\n\n\t\tif ( inheritFrom ) {\n\t\t\titemRule.allowContentOf.push( inheritFrom );\n\t\t\titemRule.allowWhere.push( inheritFrom );\n\t\t\titemRule.allowAttributesOf.push( inheritFrom );\n\t\t\titemRule.inheritTypesFrom.push( inheritFrom );\n\t\t}\n\t}\n}\n\nfunction getAllowedChildren( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\treturn getValues( compiledDefinitions ).filter( def => def.allowIn.includes( itemRule.name ) );\n}\n\nfunction getValues( obj ) {\n\treturn Object.keys( obj ).map( key => obj[ key ] );\n}\n\nfunction mapContextItem( ctxItem ) {\n\tif ( typeof ctxItem == 'string' || ctxItem.is( 'documentFragment' ) ) {\n\t\treturn {\n\t\t\tname: typeof ctxItem == 'string' ? ctxItem : '$documentFragment',\n\n\t\t\t* getAttributeKeys() {},\n\n\t\t\tgetAttribute() {}\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\t// '$text' means text nodes and text proxies.\n\t\t\tname: ctxItem.is( 'element' ) ? ctxItem.name : '$text',\n\n\t\t\t* getAttributeKeys() {\n\t\t\t\tyield* ctxItem.getAttributeKeys();\n\t\t\t},\n\n\t\t\tgetAttribute( key ) {\n\t\t\t\treturn ctxItem.getAttribute( key );\n\t\t\t}\n\t\t};\n\t}\n}\n\n// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\nfunction* combineWalkers( backward, forward ) {\n\tlet done = false;\n\n\twhile ( !done ) {\n\t\tdone = true;\n\n\t\tif ( backward ) {\n\t\t\tconst step = backward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: backward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( forward ) {\n\t\t\tconst step = forward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: forward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\nfunction* convertToMinimalFlatRanges( ranges ) {\n\tfor ( const range of ranges ) {\n\t\tyield* range.getMinimalFlatRanges();\n\t}\n}\n\nfunction removeDisallowedAttributeFromNode( schema, node, writer ) {\n\tfor ( const attribute of node.getAttributeKeys() ) {\n\t\tif ( !schema.checkAttribute( node, attribute ) ) {\n\t\t\twriter.removeAttribute( attribute, node );\n\t\t}\n\t}\n}\n"]}]}