{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KaW1wb3J0IEluc2VydE9wZXJhdGlvbiBmcm9tICcuL2luc2VydG9wZXJhdGlvbic7CmltcG9ydCBBdHRyaWJ1dGVPcGVyYXRpb24gZnJvbSAnLi9hdHRyaWJ1dGVvcGVyYXRpb24nOwppbXBvcnQgUmVuYW1lT3BlcmF0aW9uIGZyb20gJy4vcmVuYW1lb3BlcmF0aW9uJzsKaW1wb3J0IE1hcmtlck9wZXJhdGlvbiBmcm9tICcuL21hcmtlcm9wZXJhdGlvbic7CmltcG9ydCBNb3ZlT3BlcmF0aW9uIGZyb20gJy4vbW92ZW9wZXJhdGlvbic7CmltcG9ydCBSb290QXR0cmlidXRlT3BlcmF0aW9uIGZyb20gJy4vcm9vdGF0dHJpYnV0ZW9wZXJhdGlvbic7CmltcG9ydCBNZXJnZU9wZXJhdGlvbiBmcm9tICcuL21lcmdlb3BlcmF0aW9uJzsKaW1wb3J0IFNwbGl0T3BlcmF0aW9uIGZyb20gJy4vc3BsaXRvcGVyYXRpb24nOwppbXBvcnQgTm9PcGVyYXRpb24gZnJvbSAnLi9ub29wZXJhdGlvbic7CmltcG9ydCBSYW5nZSBmcm9tICcuLi9yYW5nZSc7CmltcG9ydCBQb3NpdGlvbiBmcm9tICcuLi9wb3NpdGlvbic7CmltcG9ydCBjb21wYXJlQXJyYXlzIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NvbXBhcmVhcnJheXMnOwp2YXIgdHJhbnNmb3JtYXRpb25zID0gbmV3IE1hcCgpOwovKioKICogQG1vZHVsZSBlbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3RyYW5zZm9ybQogKi8KCi8qKgogKiBTZXRzIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdG8gYmUgYmUgdXNlZCB0byB0cmFuc2Zvcm0gaW5zdGFuY2VzIG9mIGNsYXNzIGBPcGVyYXRpb25BYCBieSBpbnN0YW5jZXMgb2YgY2xhc3MgYE9wZXJhdGlvbkJgLgogKgogKiBUaGUgYHRyYW5zZm9ybWF0aW9uRnVuY3Rpb25gIGlzIHBhc3NlZCB0aHJlZSBwYXJhbWV0ZXJzOgogKgogKiAqIGBhYCAtIG9wZXJhdGlvbiB0byBiZSB0cmFuc2Zvcm1lZCwgYW4gaW5zdGFuY2Ugb2YgYE9wZXJhdGlvbkFgLAogKiAqIGBiYCAtIG9wZXJhdGlvbiB0byBiZSB0cmFuc2Zvcm1lZCBieSwgYW4gaW5zdGFuY2Ugb2YgYE9wZXJhdGlvbkJgLAogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi90cmFuc2Zvcm1+VHJhbnNmb3JtYXRpb25Db250ZXh0IGBjb250ZXh0YH0gLSBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0CiAqIHRyYW5zZm9ybWF0aW9uIGNvbnRleHQuCiAqCiAqIFRoZSBgdHJhbnNmb3JtYXRpb25GdW5jdGlvbmAgc2hvdWxkIHJldHVybiB0cmFuc2Zvcm1hdGlvbiByZXN1bHQsIHdoaWNoIGlzIGFuIGFycmF5IHdpdGggb25lIG9yIG11bHRpcGxlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uIG9wZXJhdGlvbn0gaW5zdGFuY2VzLgogKgogKiBAcHJvdGVjdGVkCiAqIEBwYXJhbSB7RnVuY3Rpb259IE9wZXJhdGlvbkEKICogQHBhcmFtIHtGdW5jdGlvbn0gT3BlcmF0aW9uQgogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm1hdGlvbkZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHVzZSBmb3IgdHJhbnNmb3JtaW5nLgogKi8KCmZ1bmN0aW9uIHNldFRyYW5zZm9ybWF0aW9uKE9wZXJhdGlvbkEsIE9wZXJhdGlvbkIsIHRyYW5zZm9ybWF0aW9uRnVuY3Rpb24pIHsKICB2YXIgYUdyb3VwID0gdHJhbnNmb3JtYXRpb25zLmdldChPcGVyYXRpb25BKTsKCiAgaWYgKCFhR3JvdXApIHsKICAgIGFHcm91cCA9IG5ldyBNYXAoKTsKICAgIHRyYW5zZm9ybWF0aW9ucy5zZXQoT3BlcmF0aW9uQSwgYUdyb3VwKTsKICB9CgogIGFHcm91cC5zZXQoT3BlcmF0aW9uQiwgdHJhbnNmb3JtYXRpb25GdW5jdGlvbik7Cn0KLyoqCiAqIFJldHVybnMgYSBwcmV2aW91c2x5IHNldCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiBmb3IgdHJhbnNmb3JtaW5nIGFuIGluc3RhbmNlIG9mIGBPcGVyYXRpb25BYCBieSBhbiBpbnN0YW5jZSBvZiBgT3BlcmF0aW9uQmAuCiAqCiAqIElmIG5vIHRyYW5zZm9ybWF0aW9uIHdhcyBzZXQgZm9yIGdpdmVuIHBhaXIgb2Ygb3BlcmF0aW9ucywge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3RyYW5zZm9ybX5ub1VwZGF0ZVRyYW5zZm9ybWF0aW9ufQogKiBpcyByZXR1cm5lZC4gVGhpcyBtZWFucyB0aGF0IGlmIG5vIHRyYW5zZm9ybWF0aW9uIHdhcyBzZXQsIHRoZSBgT3BlcmF0aW9uQWAgaW5zdGFuY2Ugd2lsbCBub3QgY2hhbmdlIHdoZW4gdHJhbnNmb3JtZWQKICogYnkgdGhlIGBPcGVyYXRpb25CYCBpbnN0YW5jZS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtGdW5jdGlvbn0gT3BlcmF0aW9uQQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBPcGVyYXRpb25CCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gRnVuY3Rpb24gc2V0IHRvIHRyYW5zZm9ybSBhbiBpbnN0YW5jZSBvZiBgT3BlcmF0aW9uQWAgYnkgYW4gaW5zdGFuY2Ugb2YgYE9wZXJhdGlvbkJgLgogKi8KCgpmdW5jdGlvbiBnZXRUcmFuc2Zvcm1hdGlvbihPcGVyYXRpb25BLCBPcGVyYXRpb25CKSB7CiAgdmFyIGFHcm91cCA9IHRyYW5zZm9ybWF0aW9ucy5nZXQoT3BlcmF0aW9uQSk7CgogIGlmIChhR3JvdXAgJiYgYUdyb3VwLmhhcyhPcGVyYXRpb25CKSkgewogICAgcmV0dXJuIGFHcm91cC5nZXQoT3BlcmF0aW9uQik7CiAgfQoKICByZXR1cm4gbm9VcGRhdGVUcmFuc2Zvcm1hdGlvbjsKfQovKioKICogQSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0aGF0IG9ubHkgY2xvbmVzIG9wZXJhdGlvbiB0byB0cmFuc2Zvcm0sIHdpdGhvdXQgY2hhbmdpbmcgaXQuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gYSBPcGVyYXRpb24gdG8gdHJhbnNmb3JtLgogKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fQogKi8KCgpmdW5jdGlvbiBub1VwZGF0ZVRyYW5zZm9ybWF0aW9uKGEpIHsKICByZXR1cm4gW2FdOwp9Ci8qKgogKiBUcmFuc2Zvcm1zIG9wZXJhdGlvbiBgYWAgYnkgb3BlcmF0aW9uIGBiYC4KICoKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBhIE9wZXJhdGlvbiB0byBiZSB0cmFuc2Zvcm1lZC4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBiIE9wZXJhdGlvbiB0byB0cmFuc2Zvcm0gYnkuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3JtflRyYW5zZm9ybWF0aW9uQ29udGV4dH0gY29udGV4dCBUcmFuc2Zvcm1hdGlvbiBjb250ZXh0IGZvciB0aGlzIHRyYW5zZm9ybWF0aW9uLgogKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSBUcmFuc2Zvcm1hdGlvbiByZXN1bHQuCiAqLwoKCmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oYSwgYikgewogIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTsKICB2YXIgdHJhbnNmb3JtYXRpb25GdW5jdGlvbiA9IGdldFRyYW5zZm9ybWF0aW9uKGEuY29uc3RydWN0b3IsIGIuY29uc3RydWN0b3IpOwogIC8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtY2F0Y2ggKi8KCiAgdHJ5IHsKICAgIGEgPSBhLmNsb25lKCk7CiAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25GdW5jdGlvbihhLCBiLCBjb250ZXh0KTsKICB9IGNhdGNoIChlKSB7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnRXJyb3IgZHVyaW5nIG9wZXJhdGlvbiB0cmFuc2Zvcm1hdGlvbiEnLCBlLm1lc3NhZ2UgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdUcmFuc2Zvcm1lZCBvcGVyYXRpb24nLCBhICk7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnT3BlcmF0aW9uIHRyYW5zZm9ybWVkIGJ5JywgYiApOwogICAgLy8gQGlmIENLX0RFQlVHIC8vIGNvbnNvbGUud2FybiggJ2NvbnRleHQuYUlzU3Ryb25nJywgY29udGV4dC5hSXNTdHJvbmcgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmFXYXNVbmRvbmUnLCBjb250ZXh0LmFXYXNVbmRvbmUgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmJXYXNVbmRvbmUnLCBjb250ZXh0LmJXYXNVbmRvbmUgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmFiUmVsYXRpb24nLCBjb250ZXh0LmFiUmVsYXRpb24gKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmJhUmVsYXRpb24nLCBjb250ZXh0LmJhUmVsYXRpb24gKTsKICAgIHRocm93IGU7CiAgfQogIC8qIGVzbGludC1lbmFibGUgbm8tdXNlbGVzcy1jYXRjaCAqLwoKfQovKioKICogUGVyZm9ybXMgYSB0cmFuc2Zvcm1hdGlvbiBvZiB0d28gc2V0cyBvZiBvcGVyYXRpb25zIC0gYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYC4gVGhlIHRyYW5zZm9ybWF0aW9uIGlzIHR3by13YXkgLQogKiBib3RoIHRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQWAgYW5kIHRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQmAgYXJlIHJldHVybmVkLgogKgogKiBOb3RlLCB0aGF0IHRoZSBmaXJzdCBvcGVyYXRpb24gaW4gZWFjaCBzZXQgc2hvdWxkIGJhc2Ugb24gdGhlIHNhbWUgZG9jdW1lbnQgc3RhdGUgKAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCN2ZXJzaW9uIGRvY3VtZW50IHZlcnNpb259KS4KICoKICogSXQgaXMgYXNzdW1lZCB0aGF0IGBvcGVyYXRpb25zQWAgYXJlICJtb3JlIGltcG9ydGFudCIgZHVyaW5nIGNvbmZsaWN0IHJlc29sdXRpb24gYmV0d2VlbiB0d28gb3BlcmF0aW9ucy4KICoKICogTmV3IGNvcGllcyBvZiBib3RoIHBhc3NlZCBhcnJheXMgYW5kIG9wZXJhdGlvbnMgaW5zaWRlIHRoZW0gYXJlIHJldHVybmVkLiBQYXNzZWQgYXJndW1lbnRzIGFyZSBub3QgYWx0ZXJlZC4KICoKICogQmFzZSB2ZXJzaW9ucyBvZiB0aGUgdHJhbnNmb3JtZWQgb3BlcmF0aW9ucyBzZXRzIGFyZSB1cGRhdGVkIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgYXNzdW1lIHRoYXQgYmFzZSB2ZXJzaW9ucyBhcmUgYDRgCiAqIGFuZCB0aGVyZSBhcmUgYDNgIG9wZXJhdGlvbnMgaW4gYG9wZXJhdGlvbnNBYCBhbmQgYDVgIG9wZXJhdGlvbnMgaW4gYG9wZXJhdGlvbnNCYC4gVGhlbjoKICoKICogKiB0cmFuc2Zvcm1lZCBgb3BlcmF0aW9uc0FgIHdpbGwgc3RhcnQgZnJvbSBiYXNlIHZlcnNpb24gYDlgIChgNGAgYmFzZSB2ZXJzaW9uICsgYDVgIG9wZXJhdGlvbnMgQiksCiAqICogdHJhbnNmb3JtZWQgYG9wZXJhdGlvbnNCYCB3aWxsIHN0YXJ0IGZyb20gYmFzZSB2ZXJzaW9uIGA3YCAoYDRgIGJhc2UgdmVyc2lvbiArIGAzYCBvcGVyYXRpb25zIEEpLgogKgogKiBJZiBubyBvcGVyYXRpb24gd2FzIGJyb2tlbiBpbnRvIHR3byBkdXJpbmcgdHJhbnNmb3JtYXRpb24sIHRoZW4gYm90aCBzZXRzIHdpbGwgZW5kIHVwIHdpdGggYW4gb3BlcmF0aW9uIHRoYXQgYmFzZXMgb24gdmVyc2lvbiBgMTFgOgogKgogKiAqIHRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQWAgc3RhcnQgZnJvbSBgOWAgYW5kIHRoZXJlIGFyZSBgM2Agb2YgdGhlbSwgc28gdGhlIGxhc3Qgd2lsbCBoYXZlIGBiYXNlVmVyc2lvbmAgZXF1YWwgdG8gYDExYCwKICogKiB0cmFuc2Zvcm1lZCBgb3BlcmF0aW9uc0JgIHN0YXJ0IGZyb20gYDdgIGFuZCB0aGVyZSBhcmUgYDVgIG9mIHRoZW0sIHNvIHRoZSBsYXN0IHdpbGwgaGF2ZSBgYmFzZVZlcnNpb25gIGVxdWFsIHRvIGAxMWAuCiAqCiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSBvcGVyYXRpb25zQQogKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0gb3BlcmF0aW9uc0IKICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR8bnVsbH0gb3B0aW9ucy5kb2N1bWVudCBEb2N1bWVudCB3aGljaCB0aGUgb3BlcmF0aW9ucyBjaGFuZ2UuCiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlUmVsYXRpb25zPWZhbHNlXSBXaGV0aGVyIGR1cmluZyB0cmFuc2Zvcm1hdGlvbiByZWxhdGlvbnMgc2hvdWxkIGJlIHVzZWQgKHVzZWQgZHVyaW5nIHVuZG8gZm9yCiAqIGJldHRlciBjb25mbGljdCByZXNvbHV0aW9uKS4KICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wYWRXaXRoTm9PcHM9ZmFsc2VdIFdoZXRoZXIgYWRkaXRpb25hbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbm9vcGVyYXRpb25+Tm9PcGVyYXRpb259cwogKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHRyYW5zZm9ybWF0aW9uIHJlc3VsdHMgdG8gZm9yY2UgdGhlIHNhbWUgbGFzdCBiYXNlIHZlcnNpb24gZm9yIGJvdGggdHJhbnNmb3JtZWQgc2V0cyAoaW4gY2FzZQogKiBpZiBzb21lIG9wZXJhdGlvbnMgZ290IGJyb2tlbiBpbnRvIG11bHRpcGxlIG9wZXJhdGlvbnMgZHVyaW5nIHRyYW5zZm9ybWF0aW9uKS4KICogQHJldHVybnMge09iamVjdH0gVHJhbnNmb3JtYXRpb24gcmVzdWx0LgogKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSByZXR1cm4ub3BlcmF0aW9uc0EgVHJhbnNmb3JtZWQgYG9wZXJhdGlvbnNBYC4KICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0gcmV0dXJuLm9wZXJhdGlvbnNCIFRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQmAuCiAqIEByZXR1cm5zIHtNYXB9IHJldHVybi5vcmlnaW5hbE9wZXJhdGlvbnMgQSBtYXAgdGhhdCBsaW5rcyB0cmFuc2Zvcm1lZCBvcGVyYXRpb25zIHRvIG9yaWdpbmFsIG9wZXJhdGlvbnMuIFRoZSBrZXlzIGFyZSB0aGUgdHJhbnNmb3JtZWQKICogb3BlcmF0aW9ucyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIG9wZXJhdGlvbnMgZnJvbSB0aGUgaW5wdXQgKGBvcGVyYXRpb25zQWAgYW5kIGBvcGVyYXRpb25zQmApLgogKi8KCmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1TZXRzKG9wZXJhdGlvbnNBLCBvcGVyYXRpb25zQiwgb3B0aW9ucykgewogIC8vIENyZWF0ZSBuZXcgYXJyYXlzIHNvIHRoZSBvcmlnaW5hbGx5IHBhc3NlZCBhcmd1bWVudHMgYXJlIG5vdCBjaGFuZ2VkLgogIC8vIE5vIG5lZWQgdG8gY2xvbmUgb3BlcmF0aW9ucywgdGhleSBhcmUgY2xvbmVkIGFzIHRoZXkgYXJlIHRyYW5zZm9ybWVkLgogIG9wZXJhdGlvbnNBID0gb3BlcmF0aW9uc0Euc2xpY2UoKTsKICBvcGVyYXRpb25zQiA9IG9wZXJhdGlvbnNCLnNsaWNlKCk7CiAgdmFyIGNvbnRleHRGYWN0b3J5ID0gbmV3IENvbnRleHRGYWN0b3J5KG9wdGlvbnMuZG9jdW1lbnQsIG9wdGlvbnMudXNlUmVsYXRpb25zLCBvcHRpb25zLmZvcmNlV2Vha1JlbW92ZSk7CiAgY29udGV4dEZhY3Rvcnkuc2V0T3JpZ2luYWxPcGVyYXRpb25zKG9wZXJhdGlvbnNBKTsKICBjb250ZXh0RmFjdG9yeS5zZXRPcmlnaW5hbE9wZXJhdGlvbnMob3BlcmF0aW9uc0IpOwogIHZhciBvcmlnaW5hbE9wZXJhdGlvbnMgPSBjb250ZXh0RmFjdG9yeS5vcmlnaW5hbE9wZXJhdGlvbnM7IC8vIElmIG9uZSBvZiBzZXRzIGlzIGVtcHR5IHRoZXJlIGlzIHNpbXBseSBub3RoaW5nIHRvIHRyYW5zZm9ybSwgc28gcmV0dXJuIHNldHMgYXMgdGhleSBhcmUuCgogIGlmIChvcGVyYXRpb25zQS5sZW5ndGggPT0gMCB8fCBvcGVyYXRpb25zQi5sZW5ndGggPT0gMCkgewogICAgcmV0dXJuIHsKICAgICAgb3BlcmF0aW9uc0E6IG9wZXJhdGlvbnNBLAogICAgICBvcGVyYXRpb25zQjogb3BlcmF0aW9uc0IsCiAgICAgIG9yaWdpbmFsT3BlcmF0aW9uczogb3JpZ2luYWxPcGVyYXRpb25zCiAgICB9OwogIH0gLy8KICAvLyBGb2xsb3dpbmcgaXMgYSBkZXNjcmlwdGlvbiBvZiB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzOgogIC8vCiAgLy8gVGhlcmUgYXJlIGBvcGVyYXRpb25zQWAgYW5kIGBvcGVyYXRpb25zQmAgdG8gYmUgdHJhbnNmb3JtZWQsIGJvdGggYnkgYm90aC4KICAvLwogIC8vIFNvLCBzdXBwb3NlIHdlIGhhdmUgc2V0cyBvZiB0d28gb3BlcmF0aW9ucyBlYWNoOiBgb3BlcmF0aW9uc0FgID0gYFsgYTEsIGEyIF1gLCBgb3BlcmF0aW9uc0JgID0gYFsgYjEsIGIyIF1gLgogIC8vCiAgLy8gUmVtZW1iZXIsIHRoYXQgd2UgY2FuIG9ubHkgdHJhbnNmb3JtIG9wZXJhdGlvbnMgdGhhdCBiYXNlIG9uIHRoZSBzYW1lIGNvbnRleHQuIFdlIGFzc2VydCB0aGF0IGBhMWAgYW5kIGBiMWAgYmFzZSBvbgogIC8vIHRoZSBzYW1lIGNvbnRleHQgYW5kIHdlIHRyYW5zZm9ybSB0aGVtLiBUaGVuLCB3ZSBnZXQgYGExJ2AgYW5kIGBiMSdgLiBgYTJgIGJhc2VzIG9uIGEgY29udGV4dCB3aXRoIGBhMWAgLS0gYGEyYAogIC8vIGlzIGFuIG9wZXJhdGlvbiB0aGF0IGZvbGxvd2VkIGBhMWAuIFNpbWlsYXJseSwgYGIyYCBiYXNlcyBvbiBhIGNvbnRleHQgd2l0aCBgYjFgLgogIC8vCiAgLy8gSG93ZXZlciwgc2luY2UgYGExJ2AgaXMgYSByZXN1bHQgb2YgdHJhbnNmb3JtYXRpb24gYnkgYGIxYCwgYGExJ2Agbm93IGFsc28gaGFzIGEgY29udGV4dCB3aXRoIGBiMWAuIFRoaXMgbWVhbnMgdGhhdAogIC8vIHdlIGNhbiBzYWZlbHkgdHJhbnNmb3JtIGBhMSdgIGJ5IGBiMmAuIEFzIHdlIGZpbmlzaCB0cmFuc2Zvcm1pbmcgYGExYCwgd2UgYWxzbyB0cmFuc2Zvcm1lZCBhbGwgYG9wZXJhdGlvbnNCYC4KICAvLyBBbGwgYG9wZXJhdGlvbnNCYCBhbHNvIGhhdmUgY29udGV4dCBpbmNsdWRpbmcgYGExYC4gTm93LCB3ZSBjYW4gcHJvcGVybHkgdHJhbnNmb3JtIGBhMmAgYnkgdGhvc2Ugb3BlcmF0aW9ucy4KICAvLwogIC8vIFRoZSB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzIGNhbiBiZSB2aXN1YWxpemVkIG9uIGEgdHJhbnNmb3JtYXRpb24gZGlhZ3JhbSAoImRpYW1vbmQgZGlhZ3JhbSIpOgogIC8vCiAgLy8gICAgICAgICAgW3RoZSBpbml0aWFsIHN0YXRlXQogIC8vICAgICAgICAgW2NvbW1vbiBmb3IgYTEgYW5kIGIxXQogIC8vCiAgLy8gICAgICAgICAgICAgICAgICAgKgogIC8vICAgICAgICAgICAgICAgICAgLyBcCiAgLy8gICAgICAgICAgICAgICAgIC8gICBcCiAgLy8gICAgICAgICAgICAgICBiMSAgICAgYTEKICAvLyAgICAgICAgICAgICAgIC8gICAgICAgXAogIC8vICAgICAgICAgICAgICAvICAgICAgICAgXAogIC8vICAgICAgICAgICAgICogICAgICAgICAgICoKICAvLyAgICAgICAgICAgIC8gXCAgICAgICAgIC8gXAogIC8vICAgICAgICAgICAvICAgXCAgICAgICAvICAgXAogIC8vICAgICAgICAgYjIgICAgYTEnICAgYjEnICAgIGEyCiAgLy8gICAgICAgICAvICAgICAgIFwgICAvICAgICAgIFwKICAvLyAgICAgICAgLyAgICAgICAgIFwgLyAgICAgICAgIFwKICAvLyAgICAgICAqICAgICAgICAgICAqICAgICAgICAgICAqCiAgLy8gICAgICAgIFwgICAgICAgICAvIFwgICAgICAgICAvCiAgLy8gICAgICAgICBcICAgICAgIC8gICBcICAgICAgIC8KICAvLyAgICAgICAgYTEnJyAgIGIyJyAgIGEyJyAgIGIxJycKICAvLyAgICAgICAgICAgXCAgIC8gICAgICAgXCAgIC8KICAvLyAgICAgICAgICAgIFwgLyAgICAgICAgIFwgLwogIC8vICAgICAgICAgICAgICogICAgICAgICAgICoKICAvLyAgICAgICAgICAgICAgXCAgICAgICAgIC8KICAvLyAgICAgICAgICAgICAgIFwgICAgICAgLwogIC8vICAgICAgICAgICAgICBhMicnICAgYjInJwogIC8vICAgICAgICAgICAgICAgICBcICAgLwogIC8vICAgICAgICAgICAgICAgICAgXCAvCiAgLy8gICAgICAgICAgICAgICAgICAgKgogIC8vCiAgLy8gICAgICAgICAgIFt0aGUgZmluYWwgc3RhdGVdCiAgLy8KICAvLyBUaGUgZmluYWwgc3RhdGUgY2FuIGJlIHJlYWNoZWQgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZSBieSBhcHBseWluZyBgYTFgLCBgYTJgLCBgYjEnJ2AgYW5kIGBiMicnYCwgYXMgd2VsbCBhcyBieQogIC8vIGFwcGx5aW5nIGBiMWAsIGBiMmAsIGBhMScnYCwgYGEyJydgLiBOb3RlIGhvdyB0aGUgb3BlcmF0aW9ucyBnZXQgdG8gYSBwcm9wZXIgY29tbW9uIHN0YXRlIGJlZm9yZSBlYWNoIHBhaXIgaXMKICAvLyB0cmFuc2Zvcm1lZC4KICAvLwogIC8vIEFub3RoZXIgdGhpbmcgdG8gY29uc2lkZXIgaXMgdGhhdCBhbiBvcGVyYXRpb24gZHVyaW5nIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBicm9rZW4gaW50byBtdWx0aXBsZSBvcGVyYXRpb25zLgogIC8vIFN1cHBvc2UgdGhhdCBgYTFgICogYGIxYCA9IGBbIGExMScsIGExMicgXWAgKGluc3RlYWQgb2YgYGExJ2AgdGhhdCB3ZSBjb25zaWRlcmVkIHByZXZpb3VzbHkpLgogIC8vCiAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBsZWF2ZSBgYTEyJ2AgZm9yIGxhdGVyIGFuZCB3ZSBjb250aW51ZSB0cmFuc2Zvcm1pbmcgYGExMSdgIHVudGlsIGl0IGlzIHRyYW5zZm9ybWVkIGJ5IGFsbCBgb3BlcmF0aW9uc0JgCiAgLy8gKGluIG91ciBjYXNlIGl0IGlzIGp1c3QgYGIyYCkuIEF0IHRoaXMgcG9pbnQsIGBiMWAgaXMgdHJhbnNmb3JtZWQgYnkgIndob2xlIiBgYTFgLCB3aGlsZSBgYjJgIGlzIG9ubHkgdHJhbnNmb3JtZWQKICAvLyBieSBgYTExJ2AuIFNpbWlsYXJseSwgYGExMidgIGlzIG9ubHkgdHJhbnNmb3JtZWQgYnkgYGIxYC4gVGhpcyBsZWFkcyB0byBhIGNvbmNsdXNpb24gdGhhdCB3ZSBuZWVkIHRvIHN0YXJ0IHRyYW5zZm9ybWluZyBgYTEyJ2AKICAvLyBmcm9tIHRoZSBtb21lbnQganVzdCBhZnRlciBpdCB3YXMgYnJva2VuLiBTbywgYGExMidgIGlzIHRyYW5zZm9ybWVkIGJ5IGBiMmAuIE5vdywgInRoZSB3aG9sZSIgYGExYCBpcyB0cmFuc2Zvcm1lZAogIC8vIGJ5IGBvcGVyYXRpb25zQmAsIHdoaWxlIGFsbCBgb3BlcmF0aW9uc0JgIGFyZSB0cmFuc2Zvcm1lZCBieSAidGhlIHdob2xlIiBgYTFgLiBUaGlzIG1lYW5zIHRoYXQgd2UgY2FuIGNvbnRpbnVlIHdpdGgKICAvLyBmb2xsb3dpbmcgYG9wZXJhdGlvbnNBYCAoaW4gb3VyIGNhc2UgaXQgaXMganVzdCBgYTJgKS4KICAvLwogIC8vIE9mIGNvdXJzZSwgYWxzbyBgb3BlcmF0aW9uc0JgIGNhbiBiZSBicm9rZW4uIEhvd2V2ZXIsIHNpbmNlIHdlIGZvY3VzIG9uIHRyYW5zZm9ybWluZyBvcGVyYXRpb24gYGFgIHRvIHRoZSBlbmQsCiAgLy8gdGhlIG9ubHkgdGhpbmcgdG8gZG8gaXMgdG8gc3RvcmUgYm90aCBwaWVjZXMgb2Ygb3BlcmF0aW9uIGBiYCwgc28gdGhhdCB0aGUgbmV4dCB0cmFuc2Zvcm1lZCBvcGVyYXRpb24gYGFgIHdpbGwKICAvLyBiZSB0cmFuc2Zvcm1lZCBieSBib3RoIG9mIHRoZW0uCiAgLy8KICAvLyAgICAgICAgICAgICAgICAgICAgICAgKgogIC8vICAgICAgICAgICAgICAgICAgICAgIC8gXAogIC8vICAgICAgICAgICAgICAgICAgICAgLyAgIFwKICAvLyAgICAgICAgICAgICAgICAgICAgLyAgICAgXAogIC8vICAgICAgICAgICAgICAgICAgYjEgICAgICAgYTEKICAvLyAgICAgICAgICAgICAgICAgIC8gICAgICAgICBcCiAgLy8gICAgICAgICAgICAgICAgIC8gICAgICAgICAgIFwKICAvLyAgICAgICAgICAgICAgICAvICAgICAgICAgICAgIFwKICAvLyAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAqCiAgLy8gICAgICAgICAgICAgIC8gXCAgICAgICAgICAgICAvIFwKICAvLyAgICAgICAgICAgICAvICBhMTEnICAgICAgICAgLyAgIFwKICAvLyAgICAgICAgICAgIC8gICAgIFwgICAgICAgICAvICAgICBcCiAgLy8gICAgICAgICAgYjIgICAgICAgKiAgICAgIGIxJyAgICAgIGEyCiAgLy8gICAgICAgICAgLyAgICAgICAvIFwgICAgIC8gICAgICAgICBcCiAgLy8gICAgICAgICAvICAgICAgIC8gIGExMicgLyAgICAgICAgICAgXAogIC8vICAgICAgICAvICAgICAgIC8gICAgIFwgLyAgICAgICAgICAgICBcCiAgLy8gICAgICAgKiAgICAgICBiMicgICAgICogICAgICAgICAgICAgICAqCiAgLy8gICAgICAgIFwgICAgIC8gICAgICAgLyBcICAgICAgICAgICAgIC8KICAvLyAgICAgICBhMTEnJyAvICAgICBiMjEnJyBcICAgICAgICAgICAvCiAgLy8gICAgICAgICAgXCAvICAgICAgIC8gICAgIFwgICAgICAgICAvCiAgLy8gICAgICAgICAgICogICAgICAgKiAgICAgIGEyJyAgICAgYjEnJwogIC8vICAgICAgICAgICAgXCAgICAgLyBcICAgICAgIFwgICAgIC8KICAvLyAgICAgICAgICBhMTInJyBiMjInJ1wgICAgICAgXCAgIC8KICAvLyAgICAgICAgICAgICAgXCAvICAgICBcICAgICAgIFwgLwogIC8vICAgICAgICAgICAgICAgKiAgICAgIGEyJycgICAgICoKICAvLyAgICAgICAgICAgICAgICBcICAgICAgIFwgICAgIC8KICAvLyAgICAgICAgICAgICAgICAgXCAgICAgICBcICBiMjEnJycKICAvLyAgICAgICAgICAgICAgICAgIFwgICAgICAgXCAvCiAgLy8gICAgICAgICAgICAgICAgYTInJycgICAgICAqCiAgLy8gICAgICAgICAgICAgICAgICAgIFwgICAgIC8KICAvLyAgICAgICAgICAgICAgICAgICAgIFwgIGIyMicnJwogIC8vICAgICAgICAgICAgICAgICAgICAgIFwgLwogIC8vICAgICAgICAgICAgICAgICAgICAgICAqCiAgLy8KICAvLyBOb3RlLCBob3cgYGExYCBpcyBicm9rZW4gYW5kIHRyYW5zZm9ybWVkIGludG8gYGExMSdgIGFuZCBgYTEyJ2AsIHdoaWxlIGBiMidgIGdvdCBicm9rZW4gYW5kIHRyYW5zZm9ybWVkIGludG8gYGIyMScnYCBhbmQgYGIyMicnYC4KICAvLwogIC8vIEhhdmluZyBhbGwgdGhhdCBvbiBtaW5kLCBoZXJlIGlzIGFuIG91dGxpbmUgZm9yIHRoZSB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzIGFsZ29yaXRobToKICAvLwogIC8vIDEuIFdlIGhhdmUgYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYCBhcnJheSwgd2hpY2ggd2UgZHluYW1pY2FsbHkgdXBkYXRlIGFzIHRoZSB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzIGdvZXMuCiAgLy8KICAvLyAyLiBXZSB0YWtlIG5leHQgKG9yIGZpcnN0KSBvcGVyYXRpb24gZnJvbSBgb3BlcmF0aW9uc0FgIGFuZCBjaGVjayBmcm9tIHdoaWNoIG9wZXJhdGlvbiBgYmAgd2UgbmVlZCB0byBzdGFydCB0cmFuc2Zvcm1pbmcgaXQuCiAgLy8gQWxsIG9yaWdpbmFsIGBvcGVyYXRpb25zQWAgYXJlIHNldCB0byBiZSB0cmFuc2Zvcm1lZCBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBvcGVyYXRpb24gYGJgLgogIC8vCiAgLy8gMy4gV2UgdGFrZSBvcGVyYXRpb25zIGZyb20gYG9wZXJhdGlvbnNCYCwgb25lIGJ5IG9uZSwgc3RhcnRpbmcgZnJvbSB0aGUgY29ycmVjdCBvbmUsIGFuZCB0cmFuc2Zvcm0gb3BlcmF0aW9uIGBhYAogIC8vIGJ5IG9wZXJhdGlvbiBgYmAgKGFuZCB2aWNlIHZlcnNhKS4gV2UgdXBkYXRlIGBvcGVyYXRpb25zQWAgYW5kIGBvcGVyYXRpb25zQmAgYnkgcmVwbGFjaW5nIHRoZSBvcmlnaW5hbCBvcGVyYXRpb25zCiAgLy8gd2l0aCB0aGUgdHJhbnNmb3JtYXRpb24gcmVzdWx0cy4KICAvLwogIC8vIDQuIElmIG9wZXJhdGlvbiBpcyBicm9rZW4gaW50byBtdWx0aXBsZSBvcGVyYXRpb25zLCB3ZSBzYXZlIGFsbCB0aGUgbmV3IG9wZXJhdGlvbnMgaW4gdGhlIHBsYWNlIG9mIHRoZQogIC8vIG9yaWdpbmFsIG9wZXJhdGlvbi4KICAvLwogIC8vIDUuIEFkZGl0aW9uYWxseSwgaWYgb3BlcmF0aW9uIGBhYCB3YXMgYnJva2VuLCBmb3IgdGhlICJuZXciIG9wZXJhdGlvbiwgd2UgcmVtZW1iZXIgZnJvbSB3aGljaCBvcGVyYXRpb24gYGJgIGl0IHNob3VsZAogIC8vIGJlIHRyYW5zZm9ybWVkIGJ5LgogIC8vCiAgLy8gNi4gV2UgY29udGludWUgdHJhbnNmb3JtaW5nICJjdXJyZW50IiBvcGVyYXRpb24gYGFgIHVudGlsIGl0IGlzIHRyYW5zZm9ybWVkIGJ5IGFsbCBgb3BlcmF0aW9uc0JgLiBUaGVuLCBnbyB0byAyLgogIC8vIHVubGVzcyB0aGUgbGFzdCBvcGVyYXRpb24gYGFgIHdhcyB0cmFuc2Zvcm1lZC4KICAvLwogIC8vIFRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFib3ZlIGFsZ29yaXRobSBpcyBzbGlnaHRseSBkaWZmZXJlbnQsIGFzIG9ubHkgb25lIGxvb3AgKHdoaWxlKSBpcyB1c2VkLgogIC8vIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgd2UgaGF2ZSAiY3VycmVudCIgYGFgIG9wZXJhdGlvbiB0byB0cmFuc2Zvcm0gYW5kIHdlIHN0b3JlIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBgYmAgb3BlcmF0aW9uCiAgLy8gdG8gdHJhbnNmb3JtIGJ5LiBFYWNoIGxvb3Agb3BlcmF0ZXMgb24gdHdvIGluZGV4ZXMgdGhlbjogaW5kZXggcG9pbnRpbmcgdG8gY3VycmVudGx5IHByb2Nlc3NlZCBgYWAgb3BlcmF0aW9uIGFuZAogIC8vIGluZGV4IHBvaW50aW5nIHRvIG5leHQgYGJgIG9wZXJhdGlvbi4gRWFjaCBsb29wIGlzIGp1c3Qgb25lIGBhICogYmAgKyBgYiAqIGFgIHRyYW5zZm9ybWF0aW9uLiBBZnRlciBlYWNoIGxvb3AKICAvLyBvcGVyYXRpb24gYGJgIGluZGV4IGlzIHVwZGF0ZWQuIElmIGFsbCBgYmAgb3BlcmF0aW9ucyB3ZXJlIHZpc2l0ZWQgZm9yIHRoZSBjdXJyZW50IGBhYCBvcGVyYXRpb24sIHdlIGNoYW5nZQogIC8vIGN1cnJlbnQgYGFgIG9wZXJhdGlvbiBpbmRleCB0byB0aGUgbmV4dCBvbmUuCiAgLy8KICAvLyBGb3IgZWFjaCBvcGVyYXRpb24gYGFgLCBrZWVwcyBpbmZvcm1hdGlvbiB3aGF0IGlzIHRoZSBpbmRleCBpbiBgb3BlcmF0aW9uc0JgIGZyb20gd2hpY2ggdGhlIHRyYW5zZm9ybWF0aW9uIHNob3VsZCBzdGFydC4KCgogIHZhciBuZXh0VHJhbnNmb3JtSW5kZXggPSBuZXcgV2Vha01hcCgpOyAvLyBGb3IgYWxsIHRoZSBvcmlnaW5hbCBgb3BlcmF0aW9uc0FgLCBzZXQgdGhhdCB0aGV5IHNob3VsZCBiZSB0cmFuc2Zvcm1lZCBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBvZiBgb3BlcmF0aW9uc0JgLgoKICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3BlcmF0aW9uc0EpLAogICAgICBfc3RlcDsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBvcCA9IF9zdGVwLnZhbHVlOwogICAgICBuZXh0VHJhbnNmb3JtSW5kZXguc2V0KG9wLCAwKTsKICAgIH0gLy8gQWRkaXRpb25hbCBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29tZSBwb3N0cHJvY2Vzc2luZyBhZnRlciB0aGUgbWFpbiB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzIGlzIGRvbmUuCgogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yLmYoKTsKICB9CgogIHZhciBkYXRhID0gewogICAgbmV4dEJhc2VWZXJzaW9uQTogb3BlcmF0aW9uc0Fbb3BlcmF0aW9uc0EubGVuZ3RoIC0gMV0uYmFzZVZlcnNpb24gKyAxLAogICAgbmV4dEJhc2VWZXJzaW9uQjogb3BlcmF0aW9uc0Jbb3BlcmF0aW9uc0IubGVuZ3RoIC0gMV0uYmFzZVZlcnNpb24gKyAxLAogICAgb3JpZ2luYWxPcGVyYXRpb25zQUNvdW50OiBvcGVyYXRpb25zQS5sZW5ndGgsCiAgICBvcmlnaW5hbE9wZXJhdGlvbnNCQ291bnQ6IG9wZXJhdGlvbnNCLmxlbmd0aAogIH07IC8vIEluZGV4IG9mIGN1cnJlbnRseSB0cmFuc2Zvcm1lZCBvcGVyYXRpb24gYGFgLgoKICB2YXIgaSA9IDA7IC8vIFdoaWxlIG5vdCBhbGwgYG9wZXJhdGlvbnNBYCBhcmUgdHJhbnNmb3JtZWQuLi4KCiAgd2hpbGUgKGkgPCBvcGVyYXRpb25zQS5sZW5ndGgpIHsKICAgIHZhciBfb3BlcmF0aW9uc0EsIF9vcGVyYXRpb25zQjsKCiAgICAvLyBHZXQgImN1cnJlbnQiIG9wZXJhdGlvbiBgYWAuCiAgICB2YXIgb3BBID0gb3BlcmF0aW9uc0FbaV07IC8vIEZvciB0aGUgImN1cnJlbnQiIG9wZXJhdGlvbiBgYWAsIGdldCB0aGUgaW5kZXggb2YgdGhlIG5leHQgb3BlcmF0aW9uIGBiYCB0byB0cmFuc2Zvcm0gYnkuCgogICAgdmFyIGluZGV4QiA9IG5leHRUcmFuc2Zvcm1JbmRleC5nZXQob3BBKTsgLy8gSWYgb3BlcmF0aW9uIGBhYCB3YXMgYWxyZWFkeSB0cmFuc2Zvcm1lZCBieSBldmVyeSBvcGVyYXRpb24gYGJgLCBjaGFuZ2UgImN1cnJlbnQiIG9wZXJhdGlvbiBgYWAgdG8gdGhlIG5leHQgb25lLgoKICAgIGlmIChpbmRleEIgPT0gb3BlcmF0aW9uc0IubGVuZ3RoKSB7CiAgICAgIGkrKzsKICAgICAgY29udGludWU7CiAgICB9CgogICAgdmFyIG9wQiA9IG9wZXJhdGlvbnNCW2luZGV4Ql07IC8vIFRyYW5zZm9ybSBgYWAgYnkgYGJgIGFuZCBgYmAgYnkgYGFgLgoKICAgIHZhciBuZXdPcHNBID0gdHJhbnNmb3JtKG9wQSwgb3BCLCBjb250ZXh0RmFjdG9yeS5nZXRDb250ZXh0KG9wQSwgb3BCLCB0cnVlKSk7CiAgICB2YXIgbmV3T3BzQiA9IHRyYW5zZm9ybShvcEIsIG9wQSwgY29udGV4dEZhY3RvcnkuZ2V0Q29udGV4dChvcEIsIG9wQSwgZmFsc2UpKTsgLy8gQXMgYSByZXN1bHQgd2UgZ2V0IG9uZSBvciBtb3JlIGBuZXdPcHNBYCBhbmQgb25lIG9yIG1vcmUgYG5ld09wc0JgIG9wZXJhdGlvbnMuCiAgICAvLyBVcGRhdGUgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCBvcGVyYXRpb25zLgoKICAgIGNvbnRleHRGYWN0b3J5LnVwZGF0ZVJlbGF0aW9uKG9wQSwgb3BCKTsKICAgIGNvbnRleHRGYWN0b3J5LnNldE9yaWdpbmFsT3BlcmF0aW9ucyhuZXdPcHNBLCBvcEEpOwogICAgY29udGV4dEZhY3Rvcnkuc2V0T3JpZ2luYWxPcGVyYXRpb25zKG5ld09wc0IsIG9wQik7IC8vIEZvciBuZXcgYGFgIG9wZXJhdGlvbnMsIHVwZGF0ZSB0aGVpciBpbmRleCBvZiB0aGUgbmV4dCBvcGVyYXRpb24gYGJgIHRvIHRyYW5zZm9ybSB0aGVtIGJ5LgogICAgLy8KICAgIC8vIFRoaXMgaXMgbmVlZGVkIGV2ZW4gaWYgdGhlcmUgd2FzIG9ubHkgb25lIHJlc3VsdCAoYGFgIHdhcyBub3QgYnJva2VuKSBiZWNhdXNlIHRoYXQgaW5mb3JtYXRpb24gaXMgdXNlZAogICAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIGxvb3AgZXZlcnkgdGltZS4KCiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5ld09wc0EpLAogICAgICAgIF9zdGVwMjsKCiAgICB0cnkgewogICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykgewogICAgICAgIHZhciBuZXdPcEEgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgLy8gQWNrbm93bGVkZ2UsIHRoYXQgb3BlcmF0aW9uIGBiYCBhbHNvIG1pZ2h0IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIG9wZXJhdGlvbnMuCiAgICAgICAgLy8KICAgICAgICAvLyBUaGlzIGlzIHdoeSB3ZSByYWlzZSBgaW5kZXhCYCBub3QganVzdCBieSAxLiBJZiBgbmV3T3BzQmAgYXJlIG11bHRpcGxlIG9wZXJhdGlvbnMsIHRoZXkgd2lsbCBiZQogICAgICAgIC8vIHNwbGljZWQgaW4gdGhlIHBsYWNlIG9mIGBvcEJgLiBTbyB3ZSBuZWVkIHRvIGNoYW5nZSBgdHJhbnNmb3JtQnlgIGFjY29yZGluZ2x5LCBzbyB0aGF0IGFuIG9wZXJhdGlvbiB3b24ndAogICAgICAgIC8vIGJlIHRyYW5zZm9ybWVkIGJ5IHRoZSBzYW1lIG9wZXJhdGlvbiAocGFydCBvZiBpdCkgYWdhaW4uCiAgICAgICAgbmV4dFRyYW5zZm9ybUluZGV4LnNldChuZXdPcEEsIGluZGV4QiArIG5ld09wc0IubGVuZ3RoKTsKICAgICAgfSAvLyBVcGRhdGUgYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYCB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2ZXJzaW9ucy4KCiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICB9IGZpbmFsbHkgewogICAgICBfaXRlcmF0b3IyLmYoKTsKICAgIH0KCiAgICAoX29wZXJhdGlvbnNBID0gb3BlcmF0aW9uc0EpLnNwbGljZS5hcHBseShfb3BlcmF0aW9uc0EsIFtpLCAxXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5ld09wc0EpKSk7CgogICAgKF9vcGVyYXRpb25zQiA9IG9wZXJhdGlvbnNCKS5zcGxpY2UuYXBwbHkoX29wZXJhdGlvbnNCLCBbaW5kZXhCLCAxXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5ld09wc0IpKSk7CiAgfQoKICBpZiAob3B0aW9ucy5wYWRXaXRoTm9PcHMpIHsKICAgIC8vIElmIG5vLW9wZXJhdGlvbnMgcGFkZGluZyBpcyBlbmFibGVkLCBjb3VudCBob3cgbWFueSBleHRyYSBgYWAgYW5kIGBiYCBvcGVyYXRpb25zIHdlcmUgZ2VuZXJhdGVkLgogICAgdmFyIGJyb2tlbk9wZXJhdGlvbnNBQ291bnQgPSBvcGVyYXRpb25zQS5sZW5ndGggLSBkYXRhLm9yaWdpbmFsT3BlcmF0aW9uc0FDb3VudDsKICAgIHZhciBicm9rZW5PcGVyYXRpb25zQkNvdW50ID0gb3BlcmF0aW9uc0IubGVuZ3RoIC0gZGF0YS5vcmlnaW5hbE9wZXJhdGlvbnNCQ291bnQ7IC8vIFRoZW4sIGlmIHRoYXQgbnVtYmVyIGlzIG5vdCB0aGUgc2FtZSwgcGFkIGBvcGVyYXRpb25zQWAgb3IgYG9wZXJhdGlvbnNCYCB3aXRoIGNvcnJlY3QgbnVtYmVyIG9mIG5vLW9wcyBzbwogICAgLy8gdGhhdCB0aGUgYmFzZSB2ZXJzaW9ucyBhcmUgZXF1YWxsZWQuCiAgICAvLwogICAgLy8gTm90ZSB0aGF0IG9ubHkgb25lIGFycmF5IHdpbGwgYmUgdXBkYXRlZCwgYXMgb25seSBvbmUgb2YgdGhvc2Ugc3VidHJhY3Rpb25zIGNhbiBiZSBncmVhdGVyIHRoYW4gemVyby4KCiAgICBwYWRXaXRoTm9PcHMob3BlcmF0aW9uc0EsIGJyb2tlbk9wZXJhdGlvbnNCQ291bnQgLSBicm9rZW5PcGVyYXRpb25zQUNvdW50KTsKICAgIHBhZFdpdGhOb09wcyhvcGVyYXRpb25zQiwgYnJva2VuT3BlcmF0aW9uc0FDb3VudCAtIGJyb2tlbk9wZXJhdGlvbnNCQ291bnQpOwogIH0gLy8gRmluYWxseSwgdXBkYXRlIGJhc2UgdmVyc2lvbnMgb2YgdHJhbnNmb3JtZWQgb3BlcmF0aW9ucy4KCgogIHVwZGF0ZUJhc2VWZXJzaW9ucyhvcGVyYXRpb25zQSwgZGF0YS5uZXh0QmFzZVZlcnNpb25CKTsKICB1cGRhdGVCYXNlVmVyc2lvbnMob3BlcmF0aW9uc0IsIGRhdGEubmV4dEJhc2VWZXJzaW9uQSk7CiAgcmV0dXJuIHsKICAgIG9wZXJhdGlvbnNBOiBvcGVyYXRpb25zQSwKICAgIG9wZXJhdGlvbnNCOiBvcGVyYXRpb25zQiwKICAgIG9yaWdpbmFsT3BlcmF0aW9uczogb3JpZ2luYWxPcGVyYXRpb25zCiAgfTsKfSAvLyBHYXRoZXJzIGFkZGl0aW9uYWwgZGF0YSBhYm91dCBvcGVyYXRpb25zIHByb2Nlc3NlZCBkdXJpbmcgdHJhbnNmb3JtYXRpb24uIENhbiBiZSB1c2VkIHRvIG9idGFpbiBjb250ZXh0dWFsIGluZm9ybWF0aW9uCi8vIGFib3V0IHR3byBvcGVyYXRpb25zIHRoYXQgYXJlIGFib3V0IHRvIGJlIHRyYW5zZm9ybWVkLiBUaGlzIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gY2FuIGJlIHVzZWQgZm9yIGJldHRlciBjb25mbGljdCByZXNvbHV0aW9uLgoKdmFyIENvbnRleHRGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvLyBDcmVhdGVzIGBDb250ZXh0RmFjdG9yeWAgaW5zdGFuY2UuCiAgLy8KICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9IGRvY3VtZW50IERvY3VtZW50IHdoaWNoIHRoZSBvcGVyYXRpb25zIGNoYW5nZS4KICAvLyBAcGFyYW0ge0Jvb2xlYW59IHVzZVJlbGF0aW9ucyBXaGV0aGVyIGR1cmluZyB0cmFuc2Zvcm1hdGlvbiByZWxhdGlvbnMgc2hvdWxkIGJlIHVzZWQgKHVzZWQgZHVyaW5nIHVuZG8gZm9yCiAgLy8gYmV0dGVyIGNvbmZsaWN0IHJlc29sdXRpb24pLgogIC8vIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlV2Vha1JlbW92ZT1mYWxzZV0gSWYgc2V0IHRvIGBmYWxzZWAsIHJlbW92ZSBvcGVyYXRpb24gd2lsbCBiZSBhbHdheXMgc3Ryb25nZXIgdGhhbiBtb3ZlIG9wZXJhdGlvbiwKICAvLyBzbyB0aGUgcmVtb3ZlZCBub2RlcyB3b24ndCBlbmQgdXAgYmFjayBpbiB0aGUgZG9jdW1lbnQgcm9vdC4gV2hlbiBzZXQgdG8gYHRydWVgLCBjb250ZXh0IGRhdGEgd2lsbCBiZSB1c2VkLgogIGZ1bmN0aW9uIENvbnRleHRGYWN0b3J5KGRvY3VtZW50LCB1c2VSZWxhdGlvbnMpIHsKICAgIHZhciBmb3JjZVdlYWtSZW1vdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250ZXh0RmFjdG9yeSk7CgogICAgLy8gRm9yIGVhY2ggb3BlcmF0aW9uIHRoYXQgaXMgY3JlYXRlZCBkdXJpbmcgdHJhbnNmb3JtYXRpb24gcHJvY2Vzcywgd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgb3BlcmF0aW9uCiAgICAvLyB3aGljaCBpdCBjb21lcyBmcm9tLiBUaGUgb3JpZ2luYWwgb3BlcmF0aW9uIHdvcmtzIGFzIGEga2luZCBvZiAiaWRlbnRpZmllciIuIEV2ZXJ5IGNvbnRleHR1YWwgaW5mb3JtYXRpb24KICAgIC8vIGdhdGhlcmVkIGR1cmluZyB0cmFuc2Zvcm1hdGlvbiB0aGF0IHdlIHdhbnQgdG8gc2F2ZSBmb3IgZ2l2ZW4gb3BlcmF0aW9uLCBpcyBhY3R1YWxseSBzYXZlZCBmb3IgdGhlIG9yaWdpbmFsIG9wZXJhdGlvbi4KICAgIC8vIFRoaXMgd2F5IG5vIG1hdHRlciBpZiBvcGVyYXRpb24gYGFgIGlzIGNsb25lZCwgdGhlbiB0cmFuc2Zvcm1lZCwgZXZlbiBicmVha3MsIHdlIHN0aWxsIGhhdmUgYWNjZXNzIHRvIHRoZSBwcmV2aW91c2x5CiAgICAvLyBnYXRoZXJlZCBkYXRhIHRocm91Z2ggb3JpZ2luYWwgb3BlcmF0aW9uIHJlZmVyZW5jZS4KICAgIHRoaXMub3JpZ2luYWxPcGVyYXRpb25zID0gbmV3IE1hcCgpOyAvLyBgbW9kZWwuSGlzdG9yeWAgaW5zdGFuY2Ugd2hpY2ggaW5mb3JtYXRpb24gYWJvdXQgdW5kb25lIG9wZXJhdGlvbnMgd2lsbCBiZSB0YWtlbiBmcm9tLgoKICAgIHRoaXMuX2hpc3RvcnkgPSBkb2N1bWVudC5oaXN0b3J5OyAvLyBXaGV0aGVyIGFkZGl0aW9uYWwgY29udGV4dCBzaG91bGQgYmUgdXNlZC4KCiAgICB0aGlzLl91c2VSZWxhdGlvbnMgPSB1c2VSZWxhdGlvbnM7CiAgICB0aGlzLl9mb3JjZVdlYWtSZW1vdmUgPSAhIWZvcmNlV2Vha1JlbW92ZTsgLy8gUmVsYXRpb25zIGlzIGEgZG91YmxlLW1hcCBzdHJ1Y3R1cmUgKG1hcHMgaW4gbWFwKSB3aGVyZSBmb3IgdHdvIG9wZXJhdGlvbnMgd2Ugc3RvcmUgaG93IHRob3NlIG9wZXJhdGlvbnMgd2VyZSByZWxhdGVkCiAgICAvLyB0byBlYWNoIG90aGVyLiBUaG9zZSByZWxhdGlvbnMgYXJlIGV2YWx1YXRlZCBkdXJpbmcgdHJhbnNmb3JtYXRpb24gcHJvY2Vzcy4gRm9yIGV2ZXJ5IHRyYW5zZm9ybWF0ZWQgcGFpciBvZiBvcGVyYXRpb25zCiAgICAvLyB3ZSBrZWVwIHJlbGF0aW9ucyBiZXR3ZWVuIHRoZW0uCgogICAgdGhpcy5fcmVsYXRpb25zID0gbmV3IE1hcCgpOwogIH0gLy8gU2V0cyAib3JpZ2luYWwgb3BlcmF0aW9uIiBmb3IgZ2l2ZW4gb3BlcmF0aW9ucy4KICAvLwogIC8vIER1cmluZyB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzLCBvcGVyYXRpb25zIGFyZSBjbG9uZWQsIHRoZW4gY2hhbmdlZCwgdGhlbiBwcm9jZXNzZWQgYWdhaW4sIHNvbWV0aW1lcyBicm9rZW4gaW50byB0d28KICAvLyBvciBtdWx0aXBsZSBvcGVyYXRpb25zLiBXaGVuIGdhdGhlcmluZyBhZGRpdGlvbmFsIGRhdGEgaXQgaXMgaW1wb3J0YW50IHRoYXQgYWxsIG9wZXJhdGlvbnMgY2FuIGJlIHNvbWVob3cgbGlua2VkCiAgLy8gc28gYSBjbG9uZWQgYW5kIHRyYW5zZm9ybWVkICJ2ZXJzaW9uIiBzdGlsbCBrZXB0IHRyYWNrIG9mIHRoZSBkYXRhIGFzc2lnbmVkIGVhcmxpZXIgdG8gaXQuCiAgLy8KICAvLyBUaGUgb3JpZ2luYWwgb3BlcmF0aW9uIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgc3VjaCBhbiB1bml2ZXJzYWwgbGlua2luZyBpZC4gVGhyb3VnaG91dCB0aGUgdHJhbnNmb3JtYXRpb24gcHJvY2VzcwogIC8vIGFsbCBjbG9uZWQgb3BlcmF0aW9ucyB3aWxsIHJlZmVyIHRvICJ0aGUgb3JpZ2luYWwgb3BlcmF0aW9uIiB3aGVuIHN0b3JpbmcgYW5kIHJlYWRpbmcgYWRkaXRpb25hbCBkYXRhLgogIC8vCiAgLy8gSWYgYHRha2VGcm9tYCBpcyBub3Qgc2V0LCBlYWNoIG9wZXJhdGlvbiBmcm9tIGBvcGVyYXRpb25zYCBhcnJheSB3aWxsIGJlIGFzc2lnbmVkIGl0c2VsZiBhcyAidGhlIG9yaWdpbmFsIG9wZXJhdGlvbiIuCiAgLy8gVGhpcyBzaG91bGQgYmUgdXNlZCBhcyBhbiBpbml0aWFsaXphdGlvbiBzdGVwLgogIC8vCiAgLy8gSWYgYHRha2VGcm9tYCBpcyBzZXQsIGVhY2ggb3BlcmF0aW9uIGZyb20gYG9wZXJhdGlvbnNgIHdpbGwgYmUgYXNzaWduZWQgdGhlIHNhbWUgb3JpZ2luYWwgb3BlcmF0aW9uIGFzIGFzc2lnbmVkCiAgLy8gZm9yIGB0YWtlRnJvbWAgb3BlcmF0aW9uLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIHVwZGF0ZSBvcmlnaW5hbCBvcGVyYXRpb25zLiBJdCBzaG91bGQgYmUgdXNlZCBpbiBhIHdheSB0aGF0CiAgLy8gYG9wZXJhdGlvbnNgIGFyZSB0aGUgcmVzdWx0IG9mIGB0YWtlRnJvbWAgdHJhbnNmb3JtYXRpb24gdG8gZW5zdXJlIHByb3BlciAib3JpZ2luYWwgb3BlcmF0aW9uIHByb3BhZ2F0aW9uIi4KICAvLwogIC8vIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSBvcGVyYXRpb25zCiAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufG51bGx9IFt0YWtlRnJvbT1udWxsXQoKCiAgX2NyZWF0ZUNsYXNzKENvbnRleHRGYWN0b3J5LCBbewogICAga2V5OiAic2V0T3JpZ2luYWxPcGVyYXRpb25zIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnaW5hbE9wZXJhdGlvbnMob3BlcmF0aW9ucykgewogICAgICB2YXIgdGFrZUZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7CiAgICAgIHZhciBvcmlnaW5hbE9wZXJhdGlvbiA9IHRha2VGcm9tID8gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KHRha2VGcm9tKSA6IG51bGw7CgogICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9wZXJhdGlvbnMpLAogICAgICAgICAgX3N0ZXAzOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykgewogICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IF9zdGVwMy52YWx1ZTsKICAgICAgICAgIHRoaXMub3JpZ2luYWxPcGVyYXRpb25zLnNldChvcGVyYXRpb24sIG9yaWdpbmFsT3BlcmF0aW9uIHx8IG9wZXJhdGlvbik7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IzLmYoKTsKICAgICAgfQogICAgfSAvLyBTYXZlcyBhIHJlbGF0aW9uIGJldHdlZW4gb3BlcmF0aW9ucyBgb3BBYCBhbmQgYG9wQmAuCiAgICAvLwogICAgLy8gUmVsYXRpb25zIGFyZSB0aGVuIGxhdGVyIHVzZWQgdG8gaGVscCBzb2x2ZSBjb25mbGljdHMgd2hlbiBvcGVyYXRpb25zIGFyZSB0cmFuc2Zvcm1lZC4KICAgIC8vCiAgICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQQogICAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEIKCiAgfSwgewogICAga2V5OiAidXBkYXRlUmVsYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVJlbGF0aW9uKG9wQSwgb3BCKSB7CiAgICAgIC8vIFRoZSB1c2Ugb2YgcmVsYXRpb25zIGlzIGRlc2NyaWJlZCBpbiBhIGJpZ2dlciBkZXRhaWwgaW4gdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zLgogICAgICAvLwogICAgICAvLyBJbiBicmllZiwgdGhpcyBmdW5jdGlvbiwgZm9yIHNwZWNpZmllZCBwYWlycyBvZiBvcGVyYXRpb24gdHlwZXMsIGNoZWNrcyBob3cgcG9zaXRpb25zIGRlZmluZWQgaW4gdGhvc2Ugb3BlcmF0aW9ucyByZWxhdGUuCiAgICAgIC8vIFRoZW4gdGhvc2UgcmVsYXRpb25zIGFyZSBzYXZlZC4gRm9yIGV4YW1wbGUsIGZvciB0d28gbW92ZSBvcGVyYXRpb25zLCBpdCBpcyBzYXZlZCBpZiBvbmUgb2YgdGhvc2Ugb3BlcmF0aW9ucyB0YXJnZXQKICAgICAgLy8gcG9zaXRpb24gaXMgYmVmb3JlIHRoZSBvdGhlciBvcGVyYXRpb24gc291cmNlIHBvc2l0aW9uLiBUaGlzIGtpbmQgb2YgaW5mb3JtYXRpb24gZ2l2ZXMgY29udGV4dHVhbCBpbmZvcm1hdGlvbiB3aGVuCiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uIGlzIHVzZWQgZHVyaW5nIHVuZG8uIFNpbWlsYXIgY2hlY2tzIGFyZSBkb25lIGZvciBvdGhlciBwYWlycyBvZiBvcGVyYXRpb25zLgogICAgICAvLwogICAgICBzd2l0Y2ggKG9wQS5jb25zdHJ1Y3RvcikgewogICAgICAgIGNhc2UgTW92ZU9wZXJhdGlvbjoKICAgICAgICAgIHsKICAgICAgICAgICAgc3dpdGNoIChvcEIuY29uc3RydWN0b3IpIHsKICAgICAgICAgICAgICBjYXNlIE1lcmdlT3BlcmF0aW9uOgogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICBpZiAob3BBLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwob3BCLnNvdXJjZVBvc2l0aW9uKSB8fCBvcEIubW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKG9wQS50YXJnZXRQb3NpdGlvbikpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGlvbihvcEEsIG9wQiwgJ2luc2VydEF0U291cmNlJyk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BBLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwob3BCLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdpbnNlcnRCZXR3ZWVuJyk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BBLnRhcmdldFBvc2l0aW9uLmlzQWZ0ZXIob3BCLnNvdXJjZVBvc2l0aW9uKSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnbW92ZVRhcmdldEFmdGVyJyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBjYXNlIE1vdmVPcGVyYXRpb246CiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgIGlmIChvcEEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChvcEIuc291cmNlUG9zaXRpb24pIHx8IG9wQS50YXJnZXRQb3NpdGlvbi5pc0JlZm9yZShvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdpbnNlcnRCZWZvcmUnKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGlvbihvcEEsIG9wQiwgJ2luc2VydEFmdGVyJyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgY2FzZSBTcGxpdE9wZXJhdGlvbjoKICAgICAgICAgIHsKICAgICAgICAgICAgc3dpdGNoIChvcEIuY29uc3RydWN0b3IpIHsKICAgICAgICAgICAgICBjYXNlIE1lcmdlT3BlcmF0aW9uOgogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICBpZiAob3BBLnNwbGl0UG9zaXRpb24uaXNCZWZvcmUob3BCLnNvdXJjZVBvc2l0aW9uKSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnc3BsaXRCZWZvcmUnKTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNhc2UgTW92ZU9wZXJhdGlvbjoKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgaWYgKG9wQS5zcGxpdFBvc2l0aW9uLmlzRXF1YWwob3BCLnNvdXJjZVBvc2l0aW9uKSB8fCBvcEEuc3BsaXRQb3NpdGlvbi5pc0JlZm9yZShvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdzcGxpdEJlZm9yZScpOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChvcEIuc291cmNlUG9zaXRpb24sIG9wQi5ob3dNYW55KTsKCiAgICAgICAgICAgICAgICAgICAgaWYgKG9wQS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhvcEIuc291cmNlUG9zaXRpb24pICYmIHJhbmdlLmNvbnRhaW5zUG9zaXRpb24ob3BBLnNwbGl0UG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgaG93TWFueSA9IHJhbmdlLmVuZC5vZmZzZXQgLSBvcEEuc3BsaXRQb3NpdGlvbi5vZmZzZXQ7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb3BBLnNwbGl0UG9zaXRpb24ub2Zmc2V0IC0gcmFuZ2Uuc3RhcnQub2Zmc2V0OwoKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhvd01hbnk6IGhvd01hbnksCiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0CiAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgIGNhc2UgTWVyZ2VPcGVyYXRpb246CiAgICAgICAgICB7CiAgICAgICAgICAgIHN3aXRjaCAob3BCLmNvbnN0cnVjdG9yKSB7CiAgICAgICAgICAgICAgY2FzZSBNZXJnZU9wZXJhdGlvbjoKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgaWYgKCFvcEEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVRhcmdldE5vdE1vdmVkJyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGlmIChvcEEuc291cmNlUG9zaXRpb24uaXNFcXVhbChvcEIudGFyZ2V0UG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVNvdXJjZU5vdE1vdmVkJyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGlmIChvcEEuc291cmNlUG9zaXRpb24uaXNFcXVhbChvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVNhbWVFbGVtZW50Jyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBjYXNlIFNwbGl0T3BlcmF0aW9uOgogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICBpZiAob3BBLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwob3BCLnNwbGl0UG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdzcGxpdEF0U291cmNlJyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgIGNhc2UgTWFya2VyT3BlcmF0aW9uOgogICAgICAgICAgewogICAgICAgICAgICB2YXIgbWFya2VyUmFuZ2UgPSBvcEEubmV3UmFuZ2U7CgogICAgICAgICAgICBpZiAoIW1hcmtlclJhbmdlKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBzd2l0Y2ggKG9wQi5jb25zdHJ1Y3RvcikgewogICAgICAgICAgICAgIGNhc2UgTW92ZU9wZXJhdGlvbjoKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQob3BCLnNvdXJjZVBvc2l0aW9uLCBvcEIuaG93TWFueSk7CgogICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRMZWZ0ID0gbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKG1hcmtlclJhbmdlLnN0YXJ0KSB8fCBtb3ZlZFJhbmdlLnN0YXJ0LmlzRXF1YWwobWFya2VyUmFuZ2Uuc3RhcnQpOwogICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRSaWdodCA9IG1vdmVkUmFuZ2UuY29udGFpbnNQb3NpdGlvbihtYXJrZXJSYW5nZS5lbmQpIHx8IG1vdmVkUmFuZ2UuZW5kLmlzRXF1YWwobWFya2VyUmFuZ2UuZW5kKTsKCiAgICAgICAgICAgICAgICAgIGlmICgoYWZmZWN0ZWRMZWZ0IHx8IGFmZmVjdGVkUmlnaHQpICYmICFtb3ZlZFJhbmdlLmNvbnRhaW5zUmFuZ2UobWFya2VyUmFuZ2UpKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsIHsKICAgICAgICAgICAgICAgICAgICAgIHNpZGU6IGFmZmVjdGVkTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcsCiAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBhZmZlY3RlZExlZnQgPyBtYXJrZXJSYW5nZS5zdGFydC5wYXRoLnNsaWNlKCkgOiBtYXJrZXJSYW5nZS5lbmQucGF0aC5zbGljZSgpCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBjYXNlIE1lcmdlT3BlcmF0aW9uOgogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICB2YXIgd2FzSW5MZWZ0RWxlbWVudCA9IG1hcmtlclJhbmdlLnN0YXJ0LmlzRXF1YWwob3BCLnRhcmdldFBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgdmFyIHdhc1N0YXJ0QmVmb3JlTWVyZ2VkRWxlbWVudCA9IG1hcmtlclJhbmdlLnN0YXJ0LmlzRXF1YWwob3BCLmRlbGV0aW9uUG9zaXRpb24pOwogICAgICAgICAgICAgICAgICB2YXIgd2FzRW5kQmVmb3JlTWVyZ2VkRWxlbWVudCA9IG1hcmtlclJhbmdlLmVuZC5pc0VxdWFsKG9wQi5kZWxldGlvblBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgdmFyIHdhc0luUmlnaHRFbGVtZW50ID0gbWFya2VyUmFuZ2UuZW5kLmlzRXF1YWwob3BCLnNvdXJjZVBvc2l0aW9uKTsKCiAgICAgICAgICAgICAgICAgIGlmICh3YXNJbkxlZnRFbGVtZW50IHx8IHdhc1N0YXJ0QmVmb3JlTWVyZ2VkRWxlbWVudCB8fCB3YXNFbmRCZWZvcmVNZXJnZWRFbGVtZW50IHx8IHdhc0luUmlnaHRFbGVtZW50KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsIHsKICAgICAgICAgICAgICAgICAgICAgIHdhc0luTGVmdEVsZW1lbnQ6IHdhc0luTGVmdEVsZW1lbnQsCiAgICAgICAgICAgICAgICAgICAgICB3YXNTdGFydEJlZm9yZU1lcmdlZEVsZW1lbnQ6IHdhc1N0YXJ0QmVmb3JlTWVyZ2VkRWxlbWVudCwKICAgICAgICAgICAgICAgICAgICAgIHdhc0VuZEJlZm9yZU1lcmdlZEVsZW1lbnQ6IHdhc0VuZEJlZm9yZU1lcmdlZEVsZW1lbnQsCiAgICAgICAgICAgICAgICAgICAgICB3YXNJblJpZ2h0RWxlbWVudDogd2FzSW5SaWdodEVsZW1lbnQKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICB9CiAgICB9IC8vIEV2YWx1YXRlcyBhbmQgcmV0dXJucyBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGFib3V0IHR3byBnaXZlbiBvcGVyYXRpb25zIGBvcEFgIGFuZCBgb3BCYCB3aGljaCBhcmUgYWJvdXQgdG8gYmUgdHJhbnNmb3JtZWQuCiAgICAvLwogICAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEEKICAgIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BCCiAgICAvLyBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3JtflRyYW5zZm9ybWF0aW9uQ29udGV4dH0KCiAgfSwgewogICAga2V5OiAiZ2V0Q29udGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dChvcEEsIG9wQiwgYUlzU3Ryb25nKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgYUlzU3Ryb25nOiBhSXNTdHJvbmcsCiAgICAgICAgYVdhc1VuZG9uZTogdGhpcy5fd2FzVW5kb25lKG9wQSksCiAgICAgICAgYldhc1VuZG9uZTogdGhpcy5fd2FzVW5kb25lKG9wQiksCiAgICAgICAgYWJSZWxhdGlvbjogdGhpcy5fdXNlUmVsYXRpb25zID8gdGhpcy5fZ2V0UmVsYXRpb24ob3BBLCBvcEIpIDogbnVsbCwKICAgICAgICBiYVJlbGF0aW9uOiB0aGlzLl91c2VSZWxhdGlvbnMgPyB0aGlzLl9nZXRSZWxhdGlvbihvcEIsIG9wQSkgOiBudWxsLAogICAgICAgIGZvcmNlV2Vha1JlbW92ZTogdGhpcy5fZm9yY2VXZWFrUmVtb3ZlCiAgICAgIH07CiAgICB9IC8vIFJldHVybnMgd2hldGhlciBnaXZlbiBvcGVyYXRpb24gYG9wYCBoYXMgYWxyZWFkeSBiZWVuIHVuZG9uZS4KICAgIC8vCiAgICAvLyBJbmZvcm1hdGlvbiB3aGV0aGVyIGFuIG9wZXJhdGlvbiB3YXMgdW5kb25lIGdpdmVzIG1vcmUgY29udGV4dCB3aGVuIG1ha2luZyBhIGRlY2lzaW9uIHdoZW4gdHdvIG9wZXJhdGlvbnMgYXJlIGluIGNvbmZsaWN0LgogICAgLy8KICAgIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3AKICAgIC8vIEByZXR1cm5zIHtCb29sZWFufQoKICB9LCB7CiAgICBrZXk6ICJfd2FzVW5kb25lIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfd2FzVW5kb25lKG9wKSB7CiAgICAgIC8vIEZvciBgb3BgLCBnZXQgaXRzIG9yaWdpbmFsIG9wZXJhdGlvbi4gQWZ0ZXIgYWxsLCBpZiBgb3BgIGlzIGEgY2xvbmUgKG9yIGV2ZW4gdHJhbnNmb3JtZWQgY2xvbmUpIG9mIGFub3RoZXIKICAgICAgLy8gb3BlcmF0aW9uLCBsaXRlcmFsbHkgYG9wYCBjb3VsZG4ndCBiZSB1bmRvbmUuIEl0IHdhcyBqdXN0IGdlbmVyYXRlZC4gSWYgYW55dGhpbmcsIGl0IHdhcyB0aGUgb3BlcmF0aW9uIGl0IG9yaWdpbnMKICAgICAgLy8gZnJvbSB3aGljaCB3YXMgdW5kb25lLiBTbyBnZXQgdGhhdCBvcmlnaW5hbCBvcGVyYXRpb24uCiAgICAgIHZhciBvcmlnaW5hbE9wID0gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KG9wKTsgLy8gQW5kIGNoZWNrIHdpdGggdGhlIGRvY3VtZW50IGlmIHRoZSBvcmlnaW5hbCBvcGVyYXRpb24gd2FzIHVuZG9uZS4KCiAgICAgIHJldHVybiBvcmlnaW5hbE9wLndhc1VuZG9uZSB8fCB0aGlzLl9oaXN0b3J5LmlzVW5kb25lT3BlcmF0aW9uKG9yaWdpbmFsT3ApOwogICAgfSAvLyBSZXR1cm5zIGEgcmVsYXRpb24gYmV0d2VlbiBgb3BBYCBhbmQgYW4gb3BlcmF0aW9uIHdoaWNoIGlzIHVuZG9uZSBieSBgb3BCYC4gVGhpcyBjYW4gYmUgYFN0cmluZ2AgdmFsdWUgaWYgYSByZWxhdGlvbgogICAgLy8gd2FzIHNldCBlYXJsaWVyIG9yIGBudWxsYCBpZiB0aGVyZSB3YXMgbm8gcmVsYXRpb24gYmV0d2VlbiB0aG9zZSBvcGVyYXRpb25zLgogICAgLy8KICAgIC8vIFRoaXMgaXMgYSBsaXR0bGUgdHJpY2t5IHRvIHVuZGVyc3RhbmQsIHNvIGxldCdzIGNvbXBhcmUgaXQgdG8gYENvbnRleHRGYWN0b3J5I193YXNVbmRvbmVgLgogICAgLy8KICAgIC8vIFdoZW4gYHdhc1VuZG9uZSggb3BCIClgIGlzIHVzZWQsIHdlIGNoZWNrIGlmIHRoZSBgb3BCYCBoYXMgYWxyZWFkeSBiZWVuIHVuZG9uZS4gSXQgaXMgb2J2aW91cywgdGhhdCB0aGUKICAgIC8vIHVuZG9pbmcgb3BlcmF0aW9uIG11c3QgaGFwcGVuIGFmdGVyIHRoZSB1bmRvbmUgb3BlcmF0aW9uLiBTbywgZXNzZW50aWFsbHksIHdlIGhhdmUgYG9wQmAsIHdlIHRha2UgZG9jdW1lbnQgaGlzdG9yeSwKICAgIC8vIHdlIGxvb2sgZm9yd2FyZCBpbiB0aGUgZnV0dXJlIGFuZCBhc2sgaWYgaW4gdGhhdCBmdXR1cmUgYG9wQmAgd2FzIHVuZG9uZS4KICAgIC8vCiAgICAvLyBSZWxhdGlvbnMgaXMgYSBiYWNrd2FyZCBwcm9jZXNzIHRvIGB3YXNVbmRvbmUoKWAuCiAgICAvLwogICAgLy8gTG9uZyBzdG9yeSBzaG9ydCAtIHVzaW5nIHJlbGF0aW9ucyBpcyBhc2tpbmcgd2hhdCBoYXBwZW5lZCBpbiB0aGUgcGFzdC4gTG9va2luZyBiYWNrLiBUaGlzIHRpbWUgd2UgaGF2ZSBhbiB1bmRvaW5nCiAgICAvLyBvcGVyYXRpb24gYG9wQmAgd2hpY2ggaGFzIHVuZG9uZSBzb21lIG90aGVyIG9wZXJhdGlvbi4gV2hlbiB0aGVyZSBpcyBhIHRyYW5zZm9ybWF0aW9uIGBvcEFgIHggYG9wQmAgYW5kIHRoZXJlIGlzCiAgICAvLyBhIGNvbmZsaWN0IHRvIHNvbHZlIGFuZCBgb3BCYCBpcyBhbiB1bmRvaW5nIG9wZXJhdGlvbiwgd2UgY2FuIGxvb2sgYmFjayBpbiB0aGUgaGlzdG9yeSBhbmQgc2VlIHdoYXQgd2FzIGEgcmVsYXRpb24KICAgIC8vIGJldHdlZW4gYG9wQWAgYW5kIHRoZSBvcGVyYXRpb24gd2hpY2ggYG9wQmAgdW5kb25lLiBCYXNpbmcgb24gdGhhdCByZWxhdGlvbiBmcm9tIHRoZSBwYXN0LCB3ZSBjYW4gbm93IG1ha2UKICAgIC8vIGEgYmV0dGVyIGRlY2lzaW9uIHdoZW4gcmVzb2x2aW5nIGEgY29uZmxpY3QgYmV0d2VlbiB0d28gb3BlcmF0aW9ucywgYmVjYXVzZSB3ZSBrbm93IG1vcmUgYWJvdXQgdGhlIGNvbnRleHQgb2YKICAgIC8vIHRob3NlIHR3byBvcGVyYXRpb25zLgogICAgLy8KICAgIC8vIFRoaXMgaXMgd2h5IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgcmVsYXRpb24gZGlyZWN0bHkgYmV0d2VlbiBgb3BBYCBhbmQgYG9wQmAgYmVjYXVzZSB3ZSBuZWVkIHRvIGxvb2sKICAgIC8vIGJhY2sgdG8gc2VhcmNoIGZvciBhIG1lYW5pbmdmdWwgY29udGV4dHVhbCBpbmZvcm1hdGlvbi4KICAgIC8vCiAgICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQQogICAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEIKICAgIC8vIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0KCiAgfSwgewogICAga2V5OiAiX2dldFJlbGF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UmVsYXRpb24ob3BBLCBvcEIpIHsKICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBvcGVyYXRpb24uIFNpbWlsYXJseSBhcyBpbiBgd2FzVW5kb25lKClgIGl0IGlzIHVzZWQgYXMgYW4gdW5pdmVyc2FsIGlkZW50aWZpZXIgZm9yIHN0b3JlZCBkYXRhLgogICAgICB2YXIgb3JpZ0IgPSB0aGlzLm9yaWdpbmFsT3BlcmF0aW9ucy5nZXQob3BCKTsKCiAgICAgIHZhciB1bmRvbmVCID0gdGhpcy5faGlzdG9yeS5nZXRVbmRvbmVPcGVyYXRpb24ob3JpZ0IpOyAvLyBJZiBgb3BCYCBpcyBub3QgdW5kb2luZyBhbnkgb3BlcmF0aW9uLCB0aGVyZSBpcyBubyByZWxhdGlvbi4KCgogICAgICBpZiAoIXVuZG9uZUIpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgdmFyIG9yaWdBID0gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KG9wQSk7CgogICAgICB2YXIgcmVsYXRpb25zQSA9IHRoaXMuX3JlbGF0aW9ucy5nZXQob3JpZ0EpOyAvLyBHZXQgYWxsIHJlbGF0aW9ucyBmb3IgYG9wQWAsIGFuZCBjaGVjayBpZiB0aGVyZSBpcyBhIHJlbGF0aW9uIHdpdGggYG9wQmAtdW5kb25lLWNvdW50ZXJwYXJ0LiBJZiBzbywgcmV0dXJuIGl0LgoKCiAgICAgIGlmIChyZWxhdGlvbnNBKSB7CiAgICAgICAgcmV0dXJuIHJlbGF0aW9uc0EuZ2V0KHVuZG9uZUIpIHx8IG51bGw7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGBDb250ZXh0RmFjdG9yeSN1cGRhdGVSZWxhdGlvbnNgLgogICAgLy8KICAgIC8vIEBwcml2YXRlCiAgICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQQogICAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEIKICAgIC8vIEBwYXJhbSB7U3RyaW5nfSByZWxhdGlvbgoKICB9LCB7CiAgICBrZXk6ICJfc2V0UmVsYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRSZWxhdGlvbihvcEEsIG9wQiwgcmVsYXRpb24pIHsKICAgICAgLy8gQXMgYWx3YXlzLCBzZXR0aW5nIGlzIGZvciBvcmlnaW5hbCBvcGVyYXRpb25zLCBub3QgdGhlIGNsb25lcy90cmFuc2Zvcm1lZCBvcGVyYXRpb25zLgogICAgICB2YXIgb3JpZ0EgPSB0aGlzLm9yaWdpbmFsT3BlcmF0aW9ucy5nZXQob3BBKTsKICAgICAgdmFyIG9yaWdCID0gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KG9wQik7CgogICAgICB2YXIgcmVsYXRpb25zQSA9IHRoaXMuX3JlbGF0aW9ucy5nZXQob3JpZ0EpOwoKICAgICAgaWYgKCFyZWxhdGlvbnNBKSB7CiAgICAgICAgcmVsYXRpb25zQSA9IG5ldyBNYXAoKTsKCiAgICAgICAgdGhpcy5fcmVsYXRpb25zLnNldChvcmlnQSwgcmVsYXRpb25zQSk7CiAgICAgIH0KCiAgICAgIHJlbGF0aW9uc0Euc2V0KG9yaWdCLCByZWxhdGlvbik7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gQ29udGV4dEZhY3Rvcnk7Cn0oKTsKLyoqCiAqIEhvbGRzIGFkZGl0aW9uYWwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCBhIHRyYW5zZm9ybWVkIHBhaXIgb2Ygb3BlcmF0aW9ucyAoYGFgIGFuZCBgYmApLiBUaG9zZSBpbmZvcm1hdGlvbgogKiBjYW4gYmUgdXNlZCBmb3IgYmV0dGVyIGNvbmZsaWN0IHJlc29sdmluZy4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3JtflRyYW5zZm9ybWF0aW9uQ29udGV4dAogKgogKiBAcHJvcGVydHkge0Jvb2xlYW59IGFJc1N0cm9uZyBXaGV0aGVyIGBhYCBpcyBzdHJvbmcgb3BlcmF0aW9uIGluIHRoaXMgdHJhbnNmb3JtYXRpb24sIG9yIHdlYWsuCiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYVdhc1VuZG9uZSBXaGV0aGVyIGBhYCBvcGVyYXRpb24gd2FzIHVuZG9uZS4KICogQHByb3BlcnR5IHtCb29sZWFufSBiV2FzVW5kb25lIFdoZXRoZXIgYGJgIG9wZXJhdGlvbiB3YXMgdW5kb25lLgogKiBAcHJvcGVydHkge1N0cmluZ3xudWxsfSBhYlJlbGF0aW9uIFRoZSByZWxhdGlvbiBiZXR3ZWVuIGBhYCBvcGVyYXRpb24gYW5kIGFuIG9wZXJhdGlvbiB1bmRvbmUgYnkgYGJgIG9wZXJhdGlvbi4KICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gYmFSZWxhdGlvbiBUaGUgcmVsYXRpb24gYmV0d2VlbiBgYmAgb3BlcmF0aW9uIGFuZCBhbiBvcGVyYXRpb24gdW5kb25lIGJ5IGBhYCBvcGVyYXRpb24uCiAqLwoKLyoqCiAqIEFuIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uI2Jhc2VWZXJzaW9uIGJhc2UgdmVyc2lvbnN9CiAqIG9mIHBhc3NlZCBvcGVyYXRpb25zLgogKgogKiBUaGUgZnVuY3Rpb24gc2ltcGx5IHNldHMgYGJhc2VWZXJzaW9uYCBhcyBhIGJhc2UgdmVyc2lvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIG9wZXJhdGlvbiBhbmQgdGhlbiBpbmNyZW1lbnRzIGl0IGZvcgogKiBlYWNoIGZvbGxvd2luZyBvcGVyYXRpb24gaW4gYG9wZXJhdGlvbnNgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0gb3BlcmF0aW9ucyBPcGVyYXRpb25zIHRvIHVwZGF0ZS4KICogQHBhcmFtIHtOdW1iZXJ9IGJhc2VWZXJzaW9uIEJhc2UgdmVyc2lvbiB0byBzZXQgZm9yIHRoZSBmaXJzdCBvcGVyYXRpb24gaW4gYG9wZXJhdGlvbnNgLgogKi8KCgpmdW5jdGlvbiB1cGRhdGVCYXNlVmVyc2lvbnMob3BlcmF0aW9ucywgYmFzZVZlcnNpb24pIHsKICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9wZXJhdGlvbnMpLAogICAgICBfc3RlcDQ7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykgewogICAgICB2YXIgb3BlcmF0aW9uID0gX3N0ZXA0LnZhbHVlOwogICAgICBvcGVyYXRpb24uYmFzZVZlcnNpb24gPSBiYXNlVmVyc2lvbisrOwogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yNC5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjQuZigpOwogIH0KfQovKioKICogQWRkcyBgaG93TWFueWAgaW5zdGFuY2VzIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9ub29wZXJhdGlvbn5Ob09wZXJhdGlvbn0gdG8gYG9wZXJhdGlvbnNgIHNldC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59IG9wZXJhdGlvbnMKICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkKICovCgoKZnVuY3Rpb24gcGFkV2l0aE5vT3BzKG9wZXJhdGlvbnMsIGhvd01hbnkpIHsKICBmb3IgKHZhciBpID0gMDsgaSA8IGhvd01hbnk7IGkrKykgewogICAgb3BlcmF0aW9ucy5wdXNoKG5ldyBOb09wZXJhdGlvbigwKSk7CiAgfQp9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgoKc2V0VHJhbnNmb3JtYXRpb24oQXR0cmlidXRlT3BlcmF0aW9uLCBBdHRyaWJ1dGVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgLy8gSWYgb3BlcmF0aW9ucyBpbiBjb25mbGljdCwgY2hlY2sgaWYgdGhlaXIgcmFuZ2VzIGludGVyc2VjdCBhbmQgbWFuYWdlIHRoZW0gcHJvcGVybHkuCiAgLy8KICAvLyBPcGVyYXRpb25zIGNhbiBiZSBpbiBjb25mbGljdCBvbmx5IGlmOgogIC8vCiAgLy8gKiB0aGVpciBrZXkgaXMgdGhlIHNhbWUgKHRoZXkgY2hhbmdlIHRoZSBzYW1lIGF0dHJpYnV0ZSksIGFuZAogIC8vICogdGhleSBhcmUgaW4gdGhlIHNhbWUgcGFyZW50IChvcGVyYXRpb25zIGZvciByYW5nZXMgWyAxIF0gLSBbIDMgXSBhbmQgWyAyLCAwIF0gLSBbIDIsIDUgXSBjaGFuZ2UgZGlmZmVyZW50CiAgLy8gZWxlbWVudHMgYW5kIGNhbid0IGJlIGluIGNvbmZsaWN0KS4KICBpZiAoYS5rZXkgPT09IGIua2V5ICYmIGEucmFuZ2Uuc3RhcnQuaGFzU2FtZVBhcmVudEFzKGIucmFuZ2Uuc3RhcnQpKSB7CiAgICAvLyBGaXJzdCwgd2Ugd2FudCB0byBhcHBseSBjaGFuZ2UgdG8gdGhlIHBhcnQgb2YgYSByYW5nZSB0aGF0IGhhcyBub3QgYmVlbiBjaGFuZ2VkIGJ5IHRoZSBvdGhlciBvcGVyYXRpb24uCiAgICB2YXIgb3BlcmF0aW9ucyA9IGEucmFuZ2UuZ2V0RGlmZmVyZW5jZShiLnJhbmdlKS5tYXAoZnVuY3Rpb24gKHJhbmdlKSB7CiAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlT3BlcmF0aW9uKHJhbmdlLCBhLmtleSwgYS5vbGRWYWx1ZSwgYS5uZXdWYWx1ZSwgMCk7CiAgICB9KTsgLy8gVGhlbiB3ZSB0YWtlIGNhcmUgb2YgdGhlIGNvbW1vbiBwYXJ0IG9mIHJhbmdlcy4KCiAgICB2YXIgY29tbW9uID0gYS5yYW5nZS5nZXRJbnRlcnNlY3Rpb24oYi5yYW5nZSk7CgogICAgaWYgKGNvbW1vbikgewogICAgICAvLyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBtb3JlIGltcG9ydGFudCwgd2UgYWxzbyB3YW50IHRvIGFwcGx5IGNoYW5nZSB0byB0aGUgcGFydCBvZiB0aGUKICAgICAgLy8gb3JpZ2luYWwgcmFuZ2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNoYW5nZWQgYnkgdGhlIG90aGVyIG9wZXJhdGlvbi4gU2luY2UgdGhhdCByYW5nZQogICAgICAvLyBnb3QgY2hhbmdlZCB3ZSBhbHNvIGhhdmUgdG8gdXBkYXRlIGBvbGRWYWx1ZWAuCiAgICAgIGlmIChjb250ZXh0LmFJc1N0cm9uZykgewogICAgICAgIG9wZXJhdGlvbnMucHVzaChuZXcgQXR0cmlidXRlT3BlcmF0aW9uKGNvbW1vbiwgYi5rZXksIGIubmV3VmFsdWUsIGEubmV3VmFsdWUsIDApKTsKICAgICAgfQogICAgfQoKICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCA9PSAwKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KCiAgICByZXR1cm4gb3BlcmF0aW9uczsKICB9IGVsc2UgewogICAgLy8gSWYgb3BlcmF0aW9ucyBkb24ndCBjb25mbGljdCwgc2ltcGx5IHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGp1c3QgYSBjbG9uZSBvZiB0aGlzIG9wZXJhdGlvbi4KICAgIHJldHVybiBbYV07CiAgfQp9KTsKc2V0VHJhbnNmb3JtYXRpb24oQXR0cmlidXRlT3BlcmF0aW9uLCBJbnNlcnRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVGhlIGF0dHJpYnV0ZSBvcGVyYXRpb24gcmFuZ2UgaW5jbHVkZXMgdGhlIHBvc2l0aW9uIHdoZXJlIG5vZGVzIHdlcmUgaW5zZXJ0ZWQuCiAgLy8gVGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzY2VuYXJpb3M6IHRoZSBpbnNlcnRlZCBub2RlcyB3ZXJlIHRleHQgYW5kIHRoZXkgc2hvdWxkIHJlY2VpdmUgYXR0cmlidXRlcyBvcgogIC8vIHRoZSBpbnNlcnRlZCBub2RlcyB3ZXJlIGVsZW1lbnRzIGFuZCB0aGV5IHNob3VsZCBub3QgcmVjZWl2ZSBhdHRyaWJ1dGVzLgogIC8vCiAgaWYgKGEucmFuZ2Uuc3RhcnQuaGFzU2FtZVBhcmVudEFzKGIucG9zaXRpb24pICYmIGEucmFuZ2UuY29udGFpbnNQb3NpdGlvbihiLnBvc2l0aW9uKSkgewogICAgLy8gSWYgbmV3IG5vZGVzIHNob3VsZCBub3QgcmVjZWl2ZSBhdHRyaWJ1dGVzLCB0d28gc2VwYXJhdGVkIHJhbmdlcyB3aWxsIGJlIHJldHVybmVkLgogICAgLy8gT3RoZXJ3aXNlLCBvbmUgZXhwYW5kZWQgcmFuZ2Ugd2lsbCBiZSByZXR1cm5lZC4KICAgIHZhciByYW5nZSA9IGEucmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oYi5wb3NpdGlvbiwgYi5ob3dNYW55LCAhYi5zaG91bGRSZWNlaXZlQXR0cmlidXRlcyk7CgogICAgdmFyIHJlc3VsdCA9IHJhbmdlLm1hcChmdW5jdGlvbiAocikgewogICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyLCBhLmtleSwgYS5vbGRWYWx1ZSwgYS5uZXdWYWx1ZSwgYS5iYXNlVmVyc2lvbik7CiAgICB9KTsKCiAgICBpZiAoYi5zaG91bGRSZWNlaXZlQXR0cmlidXRlcykgewogICAgICAvLyBgQXR0cmlidXRlT3BlcmF0aW9uI3JhbmdlYCBpbmNsdWRlcyBzb21lIG5ld2x5IGluc2VydGVkIHRleHQuCiAgICAgIC8vIFRoZSBvcGVyYXRpb24gc2hvdWxkIGFsc28gY2hhbmdlIHRoZSBhdHRyaWJ1dGUgb2YgdGhhdCB0ZXh0LiBBbiBleGFtcGxlOgogICAgICAvLwogICAgICAvLyBCb2xkIHNob3VsZCBiZSBhcHBsaWVkIG9uIHRoZSBmb2xsb3dpbmcgcmFuZ2U6CiAgICAgIC8vIDxwPkZvW3piXWFyPC9wPgogICAgICAvLwogICAgICAvLyBJbiBtZWFudGltZSwgbmV3IHRleHQgaXMgdHlwZWQ6CiAgICAgIC8vIDxwPkZvenh4YmFyPC9wPgogICAgICAvLwogICAgICAvLyBCb2xkIHNob3VsZCBiZSBhcHBsaWVkIGFsc28gb24gdGhlIG5ldyB0ZXh0OgogICAgICAvLyA8cD5Gb1t6eHhiXWFyPC9wPgogICAgICAvLyA8cD5GbzwkdGV4dCBib2xkPSJ0cnVlIj56eHhiPC8kdGV4dD5hcjwvcD4KICAgICAgLy8KICAgICAgLy8gVGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdG8gY29uc2lkZXIgaGVyZSB0byBjb25zaWRlci4KICAgICAgLy8KICAgICAgLy8gQ29uc2lkZXIgc2V0dGluZyBhbiBhdHRyaWJ1dGUgd2l0aCBtdWx0aXBsZSBwb3NzaWJsZSB2YWx1ZXMsIGZvciBleGFtcGxlIGBoaWdobGlnaHRgLiBUaGUgaW5zZXJ0ZWQgdGV4dCBtaWdodAogICAgICAvLyBoYXZlIGFscmVhZHkgYW4gYXR0cmlidXRlIHZhbHVlIGFwcGxpZWQgYW5kIHRoZSBgb2xkVmFsdWVgIHByb3BlcnR5IG9mIHRoZSBhdHRyaWJ1dGUgb3BlcmF0aW9uIG1pZ2h0IGJlIHdyb25nOgogICAgICAvLwogICAgICAvLyBBdHRyaWJ1dGUgYGhpZ2hsaWdodD0ieWVsbG93ImAgc2hvdWxkIGJlIGFwcGxpZWQgb24gdGhlIGZvbGxvd2luZyByYW5nZToKICAgICAgLy8gPHA+Rm9bemJdYXI8cD4KICAgICAgLy8KICAgICAgLy8gSW4gbWVhbnRpbWUsIGNoYXJhY3RlciBgeGAgd2l0aCBgaGlnaGxpZ2h0PSJyZWQiYCBpcyB0eXBlZDoKICAgICAgLy8gPHA+Rm9bejwkdGV4dCBoaWdobGlnaHQ9InJlZCI+eDwvJHRleHQ+Yl1hcjwvcD4KICAgICAgLy8KICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIGNhbm5vdCBzaW1wbHkgYXBwbHkgb3BlcmF0aW9uIGNoYW5naW5nIHRoZSBhdHRyaWJ1dGUgdmFsdWUgZnJvbSBgbnVsbGAgdG8gYCJ5ZWxsb3ciYCBmb3IgdGhlIHdob2xlIHJhbmdlCiAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b3VsZCBsZWFkIHRvIGFuIGV4Y2VwdGlvbiAoYG9sZFZhbHVlYCBpcyBpbmNvcnJlY3QgZm9yIGB4YCkuCiAgICAgIC8vCiAgICAgIC8vIFdlIGFsc28gY2Fubm90IGJyZWFrIHRoZSBvcmlnaW5hbCByYW5nZSBhcyB0aGlzIHdvdWxkIG1lc3MgdXAgYSBzY2VuYXJpbyB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBmb2xsb3dpbmcKICAgICAgLy8gaW5zZXJ0IG9wZXJhdGlvbnMsIGJlY2F1c2UgdGhlbiBvbmx5IHRoZSBmaXJzdCBpbnNlcnRlZCBjaGFyYWN0ZXIgaXMgaW5jbHVkZWQgaW4gdGhvc2UgcmFuZ2VzOgogICAgICAvLyA8cD5Gb1t6XVt4XVtiXWFyPC9wPiAgIC0tPiAgIDxwPkZvW3pdW3hdeFtiXWFyPC9wPiAgIC0tPiAgIDxwPkZvW3pdW3hdeHhbYl1hcjwvcD4KICAgICAgLy8KICAgICAgLy8gU28sIHRoZSBhdHRyaWJ1dGUgcmFuZ2UgbmVlZHMgYmUgZXhwYW5kZWQsIG5vIG1hdHRlciB3aGF0IGF0dHJpYnV0ZXMgYXJlIHNldCBvbiB0aGUgaW5zZXJ0ZWQgbm9kZXM6CiAgICAgIC8vCiAgICAgIC8vIDxwPkZvW3o8JHRleHQgaGlnaGxpZ2h0PSJyZWQiPng8LyR0ZXh0PmJdYXI8L3A+ICAgICAgPC0tLSBDaGFuZ2UgZnJvbSBgbnVsbGAgdG8gYHllbGxvd2AsIHRocm93aW5nIGFuIGV4Y2VwdGlvbi4KICAgICAgLy8KICAgICAgLy8gQnV0IGJlZm9yZSB0aGF0IG9wZXJhdGlvbiB3b3VsZCBiZSBhcHBsaWVkLCB3ZSB3aWxsIGFkZCBhbiBhZGRpdGlvbmFsIGF0dHJpYnV0ZSBvcGVyYXRpb24gdGhhdCB3aWxsIGNoYW5nZQogICAgICAvLyBhdHRyaWJ1dGVzIG9uIHRoZSBpbnNlcnRlZCBub2RlcyBpbiBhIHdheSB3aGljaCB3b3VsZCBtYWtlIHRoZSBvcmlnaW5hbCBvcGVyYXRpb24gY29ycmVjdDoKICAgICAgLy8KICAgICAgLy8gPHA+Rm9bens8JHRleHQgaGlnaGxpZ2h0PSJyZWQiPn14PC8kdGV4dD5iXWFyPC9wPiAgICA8LS0tIENoYW5nZSByYW5nZSBge31gIGZyb20gYHJlZGAgdG8gYG51bGxgLgogICAgICAvLyA8cD5Gb1t6eGJdYXI8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0gTm93IGNoYW5nZSBmcm9tIGBudWxsYCB0byBgeWVsbG93YCBpcyBjb21wbGV0ZWx5IGZpbmUuCiAgICAgIC8vCiAgICAgIC8vIEdlbmVyYXRlIGNvbXBsZW1lbnRhcnkgYXR0cmlidXRlIG9wZXJhdGlvbi4gQmUgc3VyZSB0byBhZGQgaXQgYmVmb3JlIHRoZSBvcmlnaW5hbCBvcGVyYXRpb24uCiAgICAgIHZhciBvcCA9IF9nZXRDb21wbGVtZW50YXJ5QXR0cmlidXRlT3BlcmF0aW9ucyhiLCBhLmtleSwgYS5vbGRWYWx1ZSk7CgogICAgICBpZiAob3ApIHsKICAgICAgICByZXN1bHQudW5zaGlmdChvcCk7CiAgICAgIH0KICAgIH0gLy8gSWYgbm9kZXMgc2hvdWxkIG5vdCByZWNlaXZlIG5ldyBhdHRyaWJ1dGUsIHdlIGFyZSBkb25lIGhlcmUuCgoKICAgIHJldHVybiByZXN1bHQ7CiAgfSAvLyBJZiBpbnNlcnQgb3BlcmF0aW9uIGlzIG5vdCBleHBhbmRpbmcgdGhlIGF0dHJpYnV0ZSBvcGVyYXRpb24gcmFuZ2UsIHNpbXBseSB0cmFuc2Zvcm0gdGhlIHJhbmdlLgoKCiAgYS5yYW5nZSA9IGEucmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oYi5wb3NpdGlvbiwgYi5ob3dNYW55LCBmYWxzZSlbMF07CiAgcmV0dXJuIFthXTsKfSk7Ci8qKgogKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGBBdHRyaWJ1dGVPcGVyYXRpb25gIHggYEluc2VydE9wZXJhdGlvbmAgKGFuZCByZXZlcnNlKSB0cmFuc2Zvcm1hdGlvbi4KICoKICogRm9yIGdpdmVuIGBpbnNlcnRPcGVyYXRpb25gIGl0IGNoZWNrcyB0aGUgaW5zZXJ0ZWQgbm9kZSBpZiBpdCBoYXMgYW4gYXR0cmlidXRlIGBrZXlgIHNldCB0byBhIHZhbHVlIGRpZmZlcmVudAogKiB0aGFuIGBuZXdWYWx1ZWAuIElmIHNvLCBpdCBnZW5lcmF0ZXMgYW4gYEF0dHJpYnV0ZU9wZXJhdGlvbmAgd2hpY2ggY2hhbmdlcyB0aGUgdmFsdWUgb2YgYGtleWAgYXR0cmlidXRlIHRvIGBuZXdWYWx1ZWAuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vaW5zZXJ0b3BlcmF0aW9ufkluc2VydE9wZXJhdGlvbn0gaW5zZXJ0T3BlcmF0aW9uCiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkKICogQHBhcmFtIHsqfSBuZXdWYWx1ZQogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vYXR0cmlidXRlb3BlcmF0aW9ufkF0dHJpYnV0ZU9wZXJhdGlvbnxudWxsfQogKi8KCmZ1bmN0aW9uIF9nZXRDb21wbGVtZW50YXJ5QXR0cmlidXRlT3BlcmF0aW9ucyhpbnNlcnRPcGVyYXRpb24sIGtleSwgbmV3VmFsdWUpIHsKICB2YXIgbm9kZXMgPSBpbnNlcnRPcGVyYXRpb24ubm9kZXM7IC8vIEF0IHRoZSBiZWdpbm5pbmcgd2Ugc3RvcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBub2RlLgoKICB2YXIgaW5zZXJ0VmFsdWUgPSBub2Rlcy5nZXROb2RlKDApLmdldEF0dHJpYnV0ZShrZXkpOwoKICBpZiAoaW5zZXJ0VmFsdWUgPT0gbmV3VmFsdWUpIHsKICAgIHJldHVybiBudWxsOwogIH0KCiAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKGluc2VydE9wZXJhdGlvbi5wb3NpdGlvbiwgaW5zZXJ0T3BlcmF0aW9uLnBvc2l0aW9uLmdldFNoaWZ0ZWRCeShpbnNlcnRPcGVyYXRpb24uaG93TWFueSkpOwogIHJldHVybiBuZXcgQXR0cmlidXRlT3BlcmF0aW9uKHJhbmdlLCBrZXksIGluc2VydFZhbHVlLCBuZXdWYWx1ZSwgMCk7Cn0KCnNldFRyYW5zZm9ybWF0aW9uKEF0dHJpYnV0ZU9wZXJhdGlvbiwgTWVyZ2VPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgdmFyIHJhbmdlcyA9IFtdOyAvLyBDYXNlIDE6CiAgLy8KICAvLyBBdHRyaWJ1dGUgY2hhbmdlIG9uIHRoZSBtZXJnZWQgZWxlbWVudC4gSW4gdGhpcyBjYXNlLCB0aGUgbWVyZ2VkIGVsZW1lbnQgd2FzIG1vdmVkIHRvIHRoZSBncmF2ZXlhcmQuCiAgLy8gQW4gYWRkaXRpb25hbCBhdHRyaWJ1dGUgb3BlcmF0aW9uIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIChyZSltb3ZlZCBlbGVtZW50IG5lZWRzIHRvIGJlIGdlbmVyYXRlZC4KICAvLwoKICBpZiAoYS5yYW5nZS5zdGFydC5oYXNTYW1lUGFyZW50QXMoYi5kZWxldGlvblBvc2l0aW9uKSkgewogICAgaWYgKGEucmFuZ2UuY29udGFpbnNQb3NpdGlvbihiLmRlbGV0aW9uUG9zaXRpb24pIHx8IGEucmFuZ2Uuc3RhcnQuaXNFcXVhbChiLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICAgIHJhbmdlcy5wdXNoKFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChiLmdyYXZleWFyZFBvc2l0aW9uLCAxKSk7CiAgICB9CiAgfQoKICB2YXIgcmFuZ2UgPSBhLnJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7IC8vIERvIG5vdCBhZGQgZW1wdHkgKGNvbGxhcHNlZCkgcmFuZ2VzIHRvIHRoZSByZXN1bHQuIGByYW5nZWAgbWF5IGJlIGNvbGxhcHNlZCBpZiBpdCBjb250YWluZWQgb25seSB0aGUgbWVyZ2VkIGVsZW1lbnQuCgoKICBpZiAoIXJhbmdlLmlzQ29sbGFwc2VkKSB7CiAgICByYW5nZXMucHVzaChyYW5nZSk7CiAgfSAvLyBDcmVhdGUgYEF0dHJpYnV0ZU9wZXJhdGlvbmBzIG91dCBvZiB0aGUgcmFuZ2VzLgoKCiAgcmV0dXJuIHJhbmdlcy5tYXAoZnVuY3Rpb24gKHJhbmdlKSB7CiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwgYS5rZXksIGEub2xkVmFsdWUsIGEubmV3VmFsdWUsIGEuYmFzZVZlcnNpb24pOwogIH0pOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oQXR0cmlidXRlT3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIHZhciByYW5nZXMgPSBfYnJlYWtSYW5nZUJ5TW92ZU9wZXJhdGlvbihhLnJhbmdlLCBiKTsgLy8gQ3JlYXRlIGBBdHRyaWJ1dGVPcGVyYXRpb25gcyBvdXQgb2YgdGhlIHJhbmdlcy4KCgogIHJldHVybiByYW5nZXMubWFwKGZ1bmN0aW9uIChyYW5nZSkgewogICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVPcGVyYXRpb24ocmFuZ2UsIGEua2V5LCBhLm9sZFZhbHVlLCBhLm5ld1ZhbHVlLCBhLmJhc2VWZXJzaW9uKTsKICB9KTsKfSk7IC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgYEF0dHJpYnV0ZU9wZXJhdGlvbmAgeCBgTW92ZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uCi8vCi8vIFRha2VzIHRoZSBwYXNzZWQgYHJhbmdlYCBhbmQgdHJhbnNmb3JtcyBpdCBieSBtb3ZlIG9wZXJhdGlvbiBgbW92ZU9wYCBpbiBhIHNwZWNpZmljIHdheS4gT25seSB0b3AtbGV2ZWwgbm9kZXMgb2YgYHJhbmdlYAovLyBhcmUgY29uc2lkZXJlZCB0byBiZSBpbiB0aGUgcmFuZ2UuIElmIG1vdmUgb3BlcmF0aW9uIG1vdmVzIG5vZGVzIGRlZXAgZnJvbSBpbnNpZGUgb2YgdGhlIHJhbmdlLCB0aG9zZSBub2RlcyB3b24ndAovLyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0LiBJbiBvdGhlciB3b3JkcywgdG9wLWxldmVsIG5vZGVzIG9mIHRoZSByYW5nZXMgZnJvbSB0aGUgcmVzdWx0IGFyZSBleGFjdGx5IHRoZSBzYW1lIGFzCi8vIHRvcC1sZXZlbCBub2RlcyBvZiB0aGUgb3JpZ2luYWwgYHJhbmdlYC4KLy8KLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIGBBdHRyaWJ1dGVPcGVyYXRpb25gIGJlY2F1c2UsIGZvciBpdHMgcmFuZ2UsIGl0IGNoYW5nZXMgb25seSB0aGUgdG9wLWxldmVsIG5vZGVzLiBTbyB3ZSBuZWVkIHRvCi8vIHRyYWNrIG9ubHkgaG93IHRob3NlIG5vZGVzIGhhdmUgYmVlbiBhZmZlY3RlZCBieSBgTW92ZU9wZXJhdGlvbmAuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tb3Zlb3BlcmF0aW9ufk1vdmVPcGVyYXRpb259IG1vdmVPcAovLyBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fQoKZnVuY3Rpb24gX2JyZWFrUmFuZ2VCeU1vdmVPcGVyYXRpb24ocmFuZ2UsIG1vdmVPcCkgewogIHZhciBtb3ZlUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQobW92ZU9wLnNvdXJjZVBvc2l0aW9uLCBtb3ZlT3AuaG93TWFueSk7IC8vIFdlIGFyZSB0cmFuc2Zvcm1pbmcgYHJhbmdlYCAob3JpZ2luYWwgcmFuZ2UpIGJ5IGBtb3ZlUmFuZ2VgIChyYW5nZSBtb3ZlZCBieSBtb3ZlIG9wZXJhdGlvbikuIEFzIHVzdWFsIHdoZW4gaXQgY29tZXMgdG8KICAvLyB0cmFuc2Zvcm1pbmcgYSByYW5nZXMsIHdlIG1heSBoYXZlIGEgY29tbW9uIHBhcnQgb2YgdGhlIHJhbmdlcyBhbmQgd2UgbWF5IGhhdmUgYSBkaWZmZXJlbmNlIHBhcnQgKHplcm8gdG8gdHdvIHJhbmdlcykuCgoKICB2YXIgY29tbW9uID0gbnVsbDsKICB2YXIgZGlmZmVyZW5jZSA9IFtdOyAvLyBMZXQncyBjb21wYXJlIHRoZSByYW5nZXMuCgogIGlmIChtb3ZlUmFuZ2UuY29udGFpbnNSYW5nZShyYW5nZSwgdHJ1ZSkpIHsKICAgIC8vIElmIHRoZSB3aG9sZSBvcmlnaW5hbCByYW5nZSBpcyBtb3ZlZCwgdHJlYXQgaXQgd2hvbGUgYXMgYSBjb21tb24gcGFydC4gVGhlcmUncyBhbHNvIG5vIGRpZmZlcmVuY2UgcGFydC4KICAgIGNvbW1vbiA9IHJhbmdlOwogIH0gZWxzZSBpZiAocmFuZ2Uuc3RhcnQuaGFzU2FtZVBhcmVudEFzKG1vdmVSYW5nZS5zdGFydCkpIHsKICAgIC8vIElmIHRoZSByYW5nZXMgYXJlICJvbiB0aGUgc2FtZSBsZXZlbCIgKGluIHRoZSBzYW1lIHBhcmVudCkgdGhlbiBtb3ZlIG9wZXJhdGlvbiBtYXkgbW92ZSBleGFjdGx5IHRob3NlIG5vZGVzCiAgICAvLyB0aGF0IGFyZSBjaGFuZ2VkIGJ5IHRoZSBhdHRyaWJ1dGUgb3BlcmF0aW9uLiBJbiB0aGlzIGNhc2Ugd2UgZ2V0IGNvbW1vbiBwYXJ0IGFuZCBkaWZmZXJlbmNlIHBhcnQgaW4gdGhlIHVzdWFsIHdheS4KICAgIGRpZmZlcmVuY2UgPSByYW5nZS5nZXREaWZmZXJlbmNlKG1vdmVSYW5nZSk7CiAgICBjb21tb24gPSByYW5nZS5nZXRJbnRlcnNlY3Rpb24obW92ZVJhbmdlKTsKICB9IGVsc2UgewogICAgLy8gSW4gYW55IG90aGVyIHNpdHVhdGlvbiB3ZSBhc3N1bWUgdGhhdCBvcmlnaW5hbCByYW5nZSBpcyBkaWZmZXJlbnQgdGhhbiBtb3ZlIHJhbmdlLCB0aGF0IGlzIHRoYXQgbW92ZSBvcGVyYXRpb24KICAgIC8vIG1vdmVzIG90aGVyIG5vZGVzIHRoYXQgYXR0cmlidXRlIG9wZXJhdGlvbiBjaGFuZ2UuIEV2ZW4gaWYgdGhlIG1vdmVkIHJhbmdlIGlzIGRlZXAgaW5zaWRlIGluIHRoZSBvcmlnaW5hbCByYW5nZS4KICAgIC8vCiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBpbiBgLmdldEludGVyc2VjdGlvbmAgKHdlIHdvdWxkIGdldCBhIGNvbW1vbiBwYXJ0IGluIHRoYXQgY2FzZSkgYW5kIGRpZmZlcmVudAogICAgLy8gdGhhbiBgLmdldERpZmZlcmVuY2VgICh3ZSB3b3VsZCBnZXQgdHdvIHJhbmdlcykuCiAgICBkaWZmZXJlbmNlID0gW3JhbmdlXTsKICB9CgogIHZhciByZXN1bHQgPSBbXTsgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIGBfZ2V0VHJhbnNmb3JtZWRCeU1vdmVgIG1pZ2h0IGdldCB3cm9uZyByZXN1bHRzIGZvciBkaWZmZXJlbmNlIHBhcnQsIHRob3VnaCwgc28KICAvLyB3ZSBkbyBpdCBieSBoYW5kLgoKICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRpZmZlcmVuY2UpLAogICAgICBfc3RlcDU7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykgewogICAgICB2YXIgZGlmZiA9IF9zdGVwNS52YWx1ZTsKICAgICAgLy8gRmlyc3QsIHRyYW5zZm9ybSB0aGUgcmFuZ2UgYnkgcmVtb3ZpbmcgbW92ZWQgbm9kZXMuIFNpbmNlIHRoaXMgaXMgYSBkaWZmZXJlbmNlLCB0aGlzIGlzIHNhZmUsIGBudWxsYCB3b24ndCBiZSByZXR1cm5lZAogICAgICAvLyBhcyB0aGUgcmFuZ2UgaXMgZGlmZmVyZW50IHRoYW4gdGhlIG1vdmVkIHJhbmdlLgogICAgICBkaWZmID0gZGlmZi5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKG1vdmVPcC5zb3VyY2VQb3NpdGlvbiwgbW92ZU9wLmhvd01hbnkpOyAvLyBUcmFuc2Zvcm0gYWxzbyBgdGFyZ2V0UG9zaXRpb25gLgoKICAgICAgdmFyIHRhcmdldFBvc2l0aW9uID0gbW92ZU9wLmdldE1vdmVkUmFuZ2VTdGFydCgpOyAvLyBTcHJlYWQgdGhlIHJhbmdlIG9ubHkgaWYgbW92ZWQgbm9kZXMgYXJlIGluc2VydGVkIG9ubHkgYmV0d2VlbiB0aGUgdG9wLWxldmVsIG5vZGVzIG9mIHRoZSBgZGlmZmAgcmFuZ2UuCgogICAgICB2YXIgc3ByZWFkID0gZGlmZi5zdGFydC5oYXNTYW1lUGFyZW50QXModGFyZ2V0UG9zaXRpb24pOyAvLyBUcmFuc2Zvcm0gYnkgaW5zZXJ0aW9uIG9mIG1vdmVkIG5vZGVzLgoKICAgICAgZGlmZiA9IGRpZmYuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24odGFyZ2V0UG9zaXRpb24sIG1vdmVPcC5ob3dNYW55LCBzcHJlYWQpOwogICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF90b0NvbnN1bWFibGVBcnJheShkaWZmKSk7CiAgICB9IC8vIENvbW1vbiBwYXJ0IGNhbiBiZSBzaW1wbHkgdHJhbnNmb3JtZWQgYnkgdGhlIG1vdmUgb3BlcmF0aW9uLiBUaGlzIGlzIGJlY2F1c2UgbW92ZSBvcGVyYXRpb24gd2lsbCBub3QgdGFyZ2V0IHRvCiAgICAvLyB0aGF0IGNvbW1vbiBwYXJ0ICh0aGUgb3BlcmF0aW9uIHdvdWxkIGhhdmUgdG8gdGFyZ2V0IGluc2lkZSBpdHMgb3duIG1vdmVkIHJhbmdlKS4KCiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3I1LmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yNS5mKCk7CiAgfQoKICBpZiAoY29tbW9uKSB7CiAgICByZXN1bHQucHVzaChjb21tb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlKG1vdmVPcC5zb3VyY2VQb3NpdGlvbiwgbW92ZU9wLnRhcmdldFBvc2l0aW9uLCBtb3ZlT3AuaG93TWFueSwgZmFsc2UpWzBdKTsKICB9CgogIHJldHVybiByZXN1bHQ7Cn0KCnNldFRyYW5zZm9ybWF0aW9uKEF0dHJpYnV0ZU9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gU3BsaXQgbm9kZSBpcyB0aGUgbGFzdCBub2RlIGluIGBBdHRyaWJ1dGVPcGVyYXRpb24jcmFuZ2VgLgogIC8vIGBBdHRyaWJ1dGVPcGVyYXRpb24jcmFuZ2VgIG5lZWRzIHRvIGJlIGV4cGFuZGVkIHRvIGluY2x1ZGUgdGhlIG5ldyAoc3BsaXQpIG5vZGUuCiAgLy8KICAvLyBBdHRyaWJ1dGUgYHR5cGVgIHRvIGJlIGNoYW5nZWQgdG8gYG51bWJlcmVkYCBidXQgdGhlIGBsaXN0SXRlbWAgaXMgc3BsaXQuCiAgLy8gPGxpc3RJdGVtIHR5cGU9ImJ1bGxldGVkIj5mb29iYXI8L2xpc3RJdGVtPgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPGxpc3RJdGVtIHR5cGU9ImJ1bGxldGVkIj5mb288L2xpc3RJdGVtPjxsaXN0SXRlbSB0eXBlPSJidWxsZXRlZCI+YmFyPC9saXN0SXRlbT4KICAvLwogIC8vIEFmdGVyIGF0dHJpYnV0ZSBjaGFuZ2U6CiAgLy8gPGxpc3RJdGVtIHR5cGU9Im51bWJlcmVkIj5mb288L2xpc3RJdGVtPjxsaXN0SXRlbSB0eXBlPSJudW1iZXJlZCI+Zm9vPC9saXN0SXRlbT4KICAvLwogIGlmIChhLnJhbmdlLmVuZC5pc0VxdWFsKGIuaW5zZXJ0aW9uUG9zaXRpb24pKSB7CiAgICBpZiAoIWIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgICAgYS5yYW5nZS5lbmQub2Zmc2V0Kys7CiAgICB9CgogICAgcmV0dXJuIFthXTsKICB9IC8vIENhc2UgMjoKICAvLwogIC8vIFNwbGl0IHBvc2l0aW9uIGlzIGluc2lkZSBgQXR0cmlidXRlT3BlcmF0aW9uI3JhbmdlYCwgYXQgdGhlIHNhbWUgbGV2ZWwsIHNvIHRoZSBub2RlcyB0byBjaGFuZ2UgYXJlCiAgLy8gbm90IGdvaW5nIHRvIG1ha2UgYSBmbGF0IHJhbmdlLgogIC8vCiAgLy8gQ29udGVudCB3aXRoIHJhbmdlLXRvLWNoYW5nZSBhbmQgc3BsaXQgcG9zaXRpb246CiAgLy8gPHA+Rm9bemJeYV1yPC9wPgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPHA+Rm96YjwvcD48cD5hcjwvcD4KICAvLwogIC8vIE1ha2UgdHdvIHNlcGFyYXRlIHJhbmdlcyBjb250YWluaW5nIGFsbCBub2RlcyB0byBjaGFuZ2U6CiAgLy8gPHA+Rm9bemJdPC9wPjxwPlthXXI8L3A+CiAgLy8KCgogIGlmIChhLnJhbmdlLnN0YXJ0Lmhhc1NhbWVQYXJlbnRBcyhiLnNwbGl0UG9zaXRpb24pICYmIGEucmFuZ2UuY29udGFpbnNQb3NpdGlvbihiLnNwbGl0UG9zaXRpb24pKSB7CiAgICB2YXIgc2Vjb25kUGFydCA9IGEuY2xvbmUoKTsKICAgIHNlY29uZFBhcnQucmFuZ2UgPSBuZXcgUmFuZ2UoYi5tb3ZlVGFyZ2V0UG9zaXRpb24uY2xvbmUoKSwgYS5yYW5nZS5lbmQuX2dldENvbWJpbmVkKGIuc3BsaXRQb3NpdGlvbiwgYi5tb3ZlVGFyZ2V0UG9zaXRpb24pKTsKICAgIGEucmFuZ2UuZW5kID0gYi5zcGxpdFBvc2l0aW9uLmNsb25lKCk7CiAgICBhLnJhbmdlLmVuZC5zdGlja2luZXNzID0gJ3RvUHJldmlvdXMnOwogICAgcmV0dXJuIFthLCBzZWNvbmRQYXJ0XTsKICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGEucmFuZ2UgPSBhLnJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKEluc2VydE9wZXJhdGlvbiwgQXR0cmlidXRlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIHZhciByZXN1bHQgPSBbYV07IC8vIENhc2UgMToKICAvLwogIC8vIFRoZSBhdHRyaWJ1dGUgb3BlcmF0aW9uIHJhbmdlIGluY2x1ZGVzIHRoZSBwb3NpdGlvbiB3aGVyZSBub2RlcyB3ZXJlIGluc2VydGVkLgogIC8vIFRoZXJlIGFyZSB0d28gcG9zc2libGUgc2NlbmFyaW9zOiB0aGUgaW5zZXJ0ZWQgbm9kZXMgd2VyZSB0ZXh0IGFuZCB0aGV5IHNob3VsZCByZWNlaXZlIGF0dHJpYnV0ZXMgb3IKICAvLyB0aGUgaW5zZXJ0ZWQgbm9kZXMgd2VyZSBlbGVtZW50cyBhbmQgdGhleSBzaG91bGQgbm90IHJlY2VpdmUgYXR0cmlidXRlcy4KICAvLwogIC8vIFRoaXMgaXMgYSBtaXJyb3Igc2NlbmFyaW8gdG8gdGhlIG9uZSBkZXNjcmliZWQgaW4gYEF0dHJpYnV0ZU9wZXJhdGlvbmAgeCBgSW5zZXJ0T3BlcmF0aW9uYCB0cmFuc2Zvcm1hdGlvbiwKICAvLyBhbHRob3VnaCB0aGlzIGNhc2UgaXMgYSBsaXR0bGUgbGVzcyBjb21wbGljYXRlZC4gSW4gdGhpcyBjYXNlIHdlIHNpbXBseSBuZWVkIHRvIGNoYW5nZSBhdHRyaWJ1dGVzIG9mIHRoZQogIC8vIGluc2VydGVkIG5vZGVzIGFuZCB0aGF0J3MgaXQuCiAgLy8KCiAgaWYgKGEuc2hvdWxkUmVjZWl2ZUF0dHJpYnV0ZXMgJiYgYS5wb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5yYW5nZS5zdGFydCkgJiYgYi5yYW5nZS5jb250YWluc1Bvc2l0aW9uKGEucG9zaXRpb24pKSB7CiAgICB2YXIgb3AgPSBfZ2V0Q29tcGxlbWVudGFyeUF0dHJpYnV0ZU9wZXJhdGlvbnMoYSwgYi5rZXksIGIubmV3VmFsdWUpOwoKICAgIGlmIChvcCkgewogICAgICByZXN1bHQucHVzaChvcCk7CiAgICB9CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlIGlzOiBkbyBub3RoaW5nLgogIC8vIGBBdHRyaWJ1dGVPcGVyYXRpb25gIGRvZXMgbm90IGNoYW5nZSB0aGUgbW9kZWwgdHJlZSBzdHJ1Y3R1cmUgc28gYEluc2VydE9wZXJhdGlvbmAgZG9lcyBub3QgbmVlZCB0byBiZSBjaGFuZ2VkLgogIC8vCgoKICByZXR1cm4gcmVzdWx0Owp9KTsKc2V0VHJhbnNmb3JtYXRpb24oSW5zZXJ0T3BlcmF0aW9uLCBJbnNlcnRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVHdvIGluc2VydCBvcGVyYXRpb25zIGluc2VydCBub2RlcyBhdCB0aGUgc2FtZSBwb3NpdGlvbi4gU2luY2UgdGhleSBhcmUgdGhlIHNhbWUsIGl0IG5lZWRzIHRvIGJlIGRlY2lkZWQKICAvLyB3aGF0IHdpbGwgYmUgdGhlIG9yZGVyIG9mIGluc2VydGVkIG5vZGVzLiBIb3dldmVyLCB0aGVyZSBpcyBubyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIGhlbHAgaW4gdGhhdAogIC8vIGRlY2lzaW9uLiBBbHNvLCB3aGVuIGBiYCB3aWxsIGJlIHRyYW5zZm9ybWVkIGJ5IGBhYCwgdGhlIHNhbWUgb3JkZXIgbXVzdCBiZSBtYWludGFpbmVkLgogIC8vCiAgLy8gVG8gYWNoaWV2ZSB0aGF0LCB3ZSB3aWxsIGNoZWNrIGlmIHRoZSBvcGVyYXRpb24gaXMgc3Ryb25nLgogIC8vIElmIGl0IGlzLCBpdCB3b24ndCBnZXQgdHJhbnNmb3JtZWQuIElmIGl0IGlzIG5vdCwgaXQgd2lsbCBiZSBtb3ZlZC4KICAvLwogIGlmIChhLnBvc2l0aW9uLmlzRXF1YWwoYi5wb3NpdGlvbikgJiYgY29udGV4dC5hSXNTdHJvbmcpIHsKICAgIHJldHVybiBbYV07CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBhLnBvc2l0aW9uID0gYS5wb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oSW5zZXJ0T3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KICBhLnBvc2l0aW9uID0gYS5wb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKEluc2VydE9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwogIGEucG9zaXRpb24gPSBhLnBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKEluc2VydE9wZXJhdGlvbiwgTWVyZ2VPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgYS5wb3NpdGlvbiA9IGEucG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnNldFRyYW5zZm9ybWF0aW9uKE1hcmtlck9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIGlmIChhLm9sZFJhbmdlKSB7CiAgICBhLm9sZFJhbmdlID0gYS5vbGRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKVswXTsKICB9CgogIGlmIChhLm5ld1JhbmdlKSB7CiAgICBhLm5ld1JhbmdlID0gYS5uZXdSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKVswXTsKICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNYXJrZXJPcGVyYXRpb24sIE1hcmtlck9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICBpZiAoYS5uYW1lID09IGIubmFtZSkgewogICAgaWYgKGNvbnRleHQuYUlzU3Ryb25nKSB7CiAgICAgIGEub2xkUmFuZ2UgPSBiLm5ld1JhbmdlID8gYi5uZXdSYW5nZS5jbG9uZSgpIDogbnVsbDsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNYXJrZXJPcGVyYXRpb24sIE1lcmdlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIGlmIChhLm9sZFJhbmdlKSB7CiAgICBhLm9sZFJhbmdlID0gYS5vbGRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIH0KCiAgaWYgKGEubmV3UmFuZ2UpIHsKICAgIGEubmV3UmFuZ2UgPSBhLm5ld1JhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTWFya2VyT3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIGlmIChhLm9sZFJhbmdlKSB7CiAgICBhLm9sZFJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21SYW5nZXMoYS5vbGRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYikpOwogIH0KCiAgaWYgKGEubmV3UmFuZ2UpIHsKICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24pIHsKICAgICAgdmFyIGFOZXdSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUmFuZ2VzKGEubmV3UmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpKTsKCiAgICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24uc2lkZSA9PSAnbGVmdCcgJiYgYi50YXJnZXRQb3NpdGlvbi5pc0VxdWFsKGEubmV3UmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgYS5uZXdSYW5nZS5zdGFydC5wYXRoID0gY29udGV4dC5hYlJlbGF0aW9uLnBhdGg7CiAgICAgICAgYS5uZXdSYW5nZS5lbmQgPSBhTmV3UmFuZ2UuZW5kOwogICAgICAgIHJldHVybiBbYV07CiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5hYlJlbGF0aW9uLnNpZGUgPT0gJ3JpZ2h0JyAmJiBiLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYS5uZXdSYW5nZS5lbmQpKSB7CiAgICAgICAgYS5uZXdSYW5nZS5zdGFydCA9IGFOZXdSYW5nZS5zdGFydDsKICAgICAgICBhLm5ld1JhbmdlLmVuZC5wYXRoID0gY29udGV4dC5hYlJlbGF0aW9uLnBhdGg7CiAgICAgICAgcmV0dXJuIFthXTsKICAgICAgfQogICAgfQoKICAgIGEubmV3UmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVJhbmdlcyhhLm5ld1JhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKSk7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTWFya2VyT3BlcmF0aW9uLCBTcGxpdE9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICBpZiAoYS5vbGRSYW5nZSkgewogICAgYS5vbGRSYW5nZSA9IGEub2xkUmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICB9CgogIGlmIChhLm5ld1JhbmdlKSB7CiAgICBpZiAoY29udGV4dC5hYlJlbGF0aW9uKSB7CiAgICAgIHZhciBhTmV3UmFuZ2UgPSBhLm5ld1JhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CgogICAgICBpZiAoYS5uZXdSYW5nZS5zdGFydC5pc0VxdWFsKGIuc3BsaXRQb3NpdGlvbikgJiYgY29udGV4dC5hYlJlbGF0aW9uLndhc1N0YXJ0QmVmb3JlTWVyZ2VkRWxlbWVudCkgewogICAgICAgIGEubmV3UmFuZ2Uuc3RhcnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQoYi5pbnNlcnRpb25Qb3NpdGlvbik7CiAgICAgIH0gZWxzZSBpZiAoYS5uZXdSYW5nZS5zdGFydC5pc0VxdWFsKGIuc3BsaXRQb3NpdGlvbikgJiYgIWNvbnRleHQuYWJSZWxhdGlvbi53YXNJbkxlZnRFbGVtZW50KSB7CiAgICAgICAgYS5uZXdSYW5nZS5zdGFydCA9IFBvc2l0aW9uLl9jcmVhdGVBdChiLm1vdmVUYXJnZXRQb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIGlmIChhLm5ld1JhbmdlLmVuZC5pc0VxdWFsKGIuc3BsaXRQb3NpdGlvbikgJiYgY29udGV4dC5hYlJlbGF0aW9uLndhc0luUmlnaHRFbGVtZW50KSB7CiAgICAgICAgYS5uZXdSYW5nZS5lbmQgPSBQb3NpdGlvbi5fY3JlYXRlQXQoYi5tb3ZlVGFyZ2V0UG9zaXRpb24pOwogICAgICB9IGVsc2UgaWYgKGEubmV3UmFuZ2UuZW5kLmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSAmJiBjb250ZXh0LmFiUmVsYXRpb24ud2FzRW5kQmVmb3JlTWVyZ2VkRWxlbWVudCkgewogICAgICAgIGEubmV3UmFuZ2UuZW5kID0gUG9zaXRpb24uX2NyZWF0ZUF0KGIuaW5zZXJ0aW9uUG9zaXRpb24pOwogICAgICB9IGVsc2UgewogICAgICAgIGEubmV3UmFuZ2UuZW5kID0gYU5ld1JhbmdlLmVuZDsKICAgICAgfQoKICAgICAgcmV0dXJuIFthXTsKICAgIH0KCiAgICBhLm5ld1JhbmdlID0gYS5uZXdSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpzZXRUcmFuc2Zvcm1hdGlvbihNZXJnZU9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnBvc2l0aW9uKSkgewogICAgYS5ob3dNYW55ICs9IGIuaG93TWFueTsKICB9CgogIGEuc291cmNlUG9zaXRpb24gPSBhLnNvdXJjZVBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNZXJnZU9wZXJhdGlvbiwgTWVyZ2VPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gU2FtZSBtZXJnZSBvcGVyYXRpb25zLgogIC8vCiAgLy8gQm90aCBvcGVyYXRpb25zIGhhdmUgc2FtZSBzb3VyY2UgYW5kIHRhcmdldCBwb3NpdGlvbnMuIFNvIHRoZSBlbGVtZW50IGFscmVhZHkgZ290IG1lcmdlZCBhbmQgdGhlcmUgaXMKICAvLyB0aGVvcmV0aWNhbGx5IG5vdGhpbmcgdG8gZG8uCiAgLy8KICBpZiAoYS5zb3VyY2VQb3NpdGlvbi5pc0VxdWFsKGIuc291cmNlUG9zaXRpb24pICYmIGEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChiLnRhcmdldFBvc2l0aW9uKSkgewogICAgLy8gVGhlcmUgYXJlIHR3byB3YXlzIHRoYXQgd2UgY2FuIHByb3ZpZGUgYSBkby1ub3RoaW5nIG9wZXJhdGlvbi4KICAgIC8vCiAgICAvLyBGaXJzdCBpcyBzaW1wbHkgYSBOb09wZXJhdGlvbiBpbnN0YW5jZS4gV2Ugd2lsbCB1c2UgaXQgaWYgYGJgIG9wZXJhdGlvbiB3YXMgbm90IHVuZG9uZS4KICAgIC8vCiAgICAvLyBTZWNvbmQgaXMgYSBtZXJnZSBvcGVyYXRpb24gdGhhdCBoYXMgdGhlIHNvdXJjZSBvcGVyYXRpb24gaW4gdGhlIG1lcmdlZCBlbGVtZW50IC0gaW4gdGhlIGdyYXZleWFyZCAtCiAgICAvLyBzYW1lIHRhcmdldCBwb3NpdGlvbiBhbmQgYGhvd01hbnlgIGVxdWFsIHRvIGAwYC4gU28gaXQgaXMgYmFzaWNhbGx5IG1lcmdpbmcgYW4gZW1wdHkgZWxlbWVudCBmcm9tIGdyYXZleWFyZAogICAgLy8gd2hpY2ggaXMgYWxtb3N0IHRoZSBzYW1lIGFzIE5vT3BlcmF0aW9uLgogICAgLy8KICAgIC8vIFRoaXMgd2F5IHRoZSBtZXJnZSBvcGVyYXRpb24gY2FuIGJlIGxhdGVyIHRyYW5zZm9ybWVkIGJ5IHNwbGl0IG9wZXJhdGlvbgogICAgLy8gdG8gcHJvdmlkZSBjb3JyZWN0IHVuZG8uIFRoaXMgd2lsbCBiZSB1c2VkIGlmIGBiYCBvcGVyYXRpb24gd2FzIHVuZG9uZSAob25seSB0aGVuIGl0IGlzIGNvcnJlY3QpLgogICAgLy8KICAgIGlmICghY29udGV4dC5iV2FzVW5kb25lKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0gZWxzZSB7CiAgICAgIHZhciBwYXRoID0gYi5ncmF2ZXlhcmRQb3NpdGlvbi5wYXRoLnNsaWNlKCk7CiAgICAgIHBhdGgucHVzaCgwKTsKICAgICAgYS5zb3VyY2VQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihiLmdyYXZleWFyZFBvc2l0aW9uLnJvb3QsIHBhdGgpOwogICAgICBhLmhvd01hbnkgPSAwOwogICAgICByZXR1cm4gW2FdOwogICAgfQogIH0gLy8gQ2FzZSAyOgogIC8vCiAgLy8gU2FtZSBtZXJnZSBzb3VyY2UgcG9zaXRpb24gYnV0IGRpZmZlcmVudCB0YXJnZXQgcG9zaXRpb24uCiAgLy8KICAvLyBUaGlzIGNhbiBoYXBwZW4gZHVyaW5nIGNvbGxhYm9yYXRpb24uIEZvciBleGFtcGxlLCBpZiBvbmUgY2xpZW50IG1lcmdlZCBhIHBhcmFncmFwaCB0byB0aGUgcHJldmlvdXMgcGFyYWdyYXBoCiAgLy8gYW5kIHRoZSBvdGhlciBwZXJzb24gcmVtb3ZlZCB0aGF0IHBhcmFncmFwaCBhbmQgbWVyZ2VkIHRoZSBzYW1lIHBhcmFncmFwaCB0byBzb21ldGhpbmcgYmVmb3JlOgogIC8vCiAgLy8gQ2xpZW50IEE6CiAgLy8gPHA+Rm9vPC9wPjxwPkJhcjwvcD48cD5bXVh5ejwvcD4KICAvLyA8cD5Gb288L3A+PHA+QmFyWHl6PC9wPgogIC8vCiAgLy8gQ2xpZW50IEI6CiAgLy8gPHA+Rm9vPC9wPls8cD5CYXI8L3A+XTxwPlh5ejwvcD4KICAvLyA8cD5Gb288L3A+PHA+W11YeXo8L3A+CiAgLy8gPHA+Rm9vWHl6PC9wPgogIC8vCiAgLy8gSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXJlIGZpbmFsbHkgIlh5eiIgd2lsbCBsYW5kOgogIC8vCiAgLy8gPHA+Rm9vWHl6PC9wPiAgICAgICAgICAgICAgIGdyYXZleWFyZDogPHA+QmFyPC9wPgogIC8vIDxwPkZvbzwvcD4gICAgICAgICAgICAgICAgICBncmF2ZXlhcmQ6IDxwPkJhclh5ejwvcD4KICAvLwogIC8vIExldCdzIG1vdmUgaXQgaW4gYSB3YXkgc28gdGhhdCBhIG1lcmdlIG9wZXJhdGlvbiB0aGF0IGRvZXMgbm90IHRhcmdldCB0byBncmF2ZXlhcmQgaXMgbW9yZSBpbXBvcnRhbnQgc28gdGhhdAogIC8vIG5vZGVzIGRvZXMgbm90IGVuZCB1cCBpbiB0aGUgZ3JhdmV5YXJkLiBJdCBtYWtlcyBzZW5zZS4gQm90aCBmb3IgQ2xpZW50IEEgYW5kIGZvciBDbGllbnQgQiAiWHl6IiBmaW5hbGx5IGRpZCBub3QKICAvLyBlbmQgdXAgaW4gdGhlIGdyYXZleWFyZCAoc2VlIGFib3ZlKS4KICAvLwogIC8vIElmIG5laXRoZXIgb3IgYm90aCBvcGVyYXRpb25zIHBvaW50IHRvIGdyYXZleWFyZCwgdGhlbiBsZXQgYGFJc1N0cm9uZ2AgZGVjaWRlLgogIC8vCgoKICBpZiAoYS5zb3VyY2VQb3NpdGlvbi5pc0VxdWFsKGIuc291cmNlUG9zaXRpb24pICYmICFhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi50YXJnZXRQb3NpdGlvbikgJiYgIWNvbnRleHQuYldhc1VuZG9uZSAmJiBjb250ZXh0LmFiUmVsYXRpb24gIT0gJ3NwbGl0QXRTb3VyY2UnKSB7CiAgICB2YXIgYVRvR3JhdmV5YXJkID0gYS50YXJnZXRQb3NpdGlvbi5yb290LnJvb3ROYW1lID09ICckZ3JhdmV5YXJkJzsKICAgIHZhciBiVG9HcmF2ZXlhcmQgPSBiLnRhcmdldFBvc2l0aW9uLnJvb3Qucm9vdE5hbWUgPT0gJyRncmF2ZXlhcmQnOyAvLyBJZiBgYUlzV2Vha2AgaXQgbWVhbnMgdGhhdCBgYWAgcG9pbnRzIHRvIGdyYXZleWFyZCB3aGlsZSBgYmAgZG9lc24ndC4gRG9uJ3QgbW92ZSBub2RlcyB0aGVuLgoKICAgIHZhciBhSXNXZWFrID0gYVRvR3JhdmV5YXJkICYmICFiVG9HcmF2ZXlhcmQ7IC8vIElmIGBiSXNXZWFrYCBpdCBtZWFucyB0aGF0IGBiYCBwb2ludHMgdG8gZ3JhdmV5YXJkIHdoaWxlIGBhYCBkb2Vzbid0LiBGb3JjZSBtb3Zpbmcgbm9kZXMgdGhlbi4KCiAgICB2YXIgYklzV2VhayA9IGJUb0dyYXZleWFyZCAmJiAhYVRvR3JhdmV5YXJkOyAvLyBGb3JjZSBtb3ZlIGlmIGBiYCBpcyB3ZWFrIG9yIG5laXRoZXIgb3BlcmF0aW9uIGlzIHdlYWsgYnV0IGBhYCBpcyBzdHJvbmdlciB0aHJvdWdoIGBjb250ZXh0LmFJc1N0cm9uZ2AuCgogICAgdmFyIGZvcmNlTW92ZSA9IGJJc1dlYWsgfHwgIWFJc1dlYWsgJiYgY29udGV4dC5hSXNTdHJvbmc7CgogICAgaWYgKGZvcmNlTW92ZSkgewogICAgICB2YXIgc291cmNlUG9zaXRpb24gPSBiLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CgogICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CgogICAgICByZXR1cm4gW25ldyBNb3ZlT3BlcmF0aW9uKHNvdXJjZVBvc2l0aW9uLCBhLmhvd01hbnksIHRhcmdldFBvc2l0aW9uLCAwKV07CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbigwKV07CiAgICB9CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBpZiAoYS5zb3VyY2VQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi50YXJnZXRQb3NpdGlvbikpIHsKICAgIGEuaG93TWFueSArPSBiLmhvd01hbnk7CiAgfQoKICBhLnNvdXJjZVBvc2l0aW9uID0gYS5zb3VyY2VQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7IC8vIEhhbmRsZSBwb3NpdGlvbnMgaW4gZ3JhdmV5YXJkLgogIC8vIElmIGdyYXZleWFyZCBwb3NpdGlvbnMgYXJlIHNhbWUgYW5kIGBhYCBvcGVyYXRpb24gaXMgc3Ryb25nIC0gZG8gbm90IHRyYW5zZm9ybS4KCiAgaWYgKCFhLmdyYXZleWFyZFBvc2l0aW9uLmlzRXF1YWwoYi5ncmF2ZXlhcmRQb3NpdGlvbikgfHwgIWNvbnRleHQuYUlzU3Ryb25nKSB7CiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKE1lcmdlT3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIC8vIENhc2UgMToKICAvLwogIC8vIFRoZSBlbGVtZW50IHRvIG1lcmdlIGdvdCByZW1vdmVkLgogIC8vCiAgLy8gTWVyZ2Ugb3BlcmF0aW9uIGRvZXMgc3VwcG9ydCBtZXJnaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSBub3Qgc2libGluZ3MuIFNvIGl0IHdvdWxkIG5vdCBiZSBhIHByb2JsZW0KICAvLyBmcm9tIHRlY2huaWNhbCBwb2ludCBvZiB2aWV3LiBIb3dldmVyLCBpZiB0aGUgZWxlbWVudCB3YXMgcmVtb3ZlZCwgdGhlIGludGVudGlvbiBvZiB0aGUgdXNlciBkZWxldGluZyBpdAogIC8vIHdhcyB0byBoYXZlIGl0IGFsbCBkZWxldGVkLCB0b2dldGhlciB3aXRoIGl0cyBjaGlsZHJlbi4gRnJvbSB1c2VyIGV4cGVyaWVuY2UgcG9pbnQgb2YgdmlldywgbW92aW5nIGJhY2sgdGhlCiAgLy8gcmVtb3ZlZCBub2RlcyBtaWdodCBiZSB1bmV4cGVjdGVkLiBUaGlzIG1lYW5zIHRoYXQgaW4gdGhpcyBzY2VuYXJpbyB3ZSB3aWxsIGJsb2NrIHRoZSBtZXJnaW5nLgogIC8vCiAgLy8gVGhlIGV4Y2VwdGlvbiBvZiB0aGlzIHJ1bGUgd291bGQgYmUgaWYgdGhlIHJlbW92ZSBvcGVyYXRpb24gd2FzIGxhdGVyIHVuZG9uZS4KICAvLwogIHZhciByZW1vdmVkUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYi5zb3VyY2VQb3NpdGlvbiwgYi5ob3dNYW55KTsKCiAgaWYgKGIudHlwZSA9PSAncmVtb3ZlJyAmJiAhY29udGV4dC5iV2FzVW5kb25lICYmICFjb250ZXh0LmZvcmNlV2Vha1JlbW92ZSkgewogICAgaWYgKGEuZGVsZXRpb25Qb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5zb3VyY2VQb3NpdGlvbikgJiYgcmVtb3ZlZFJhbmdlLmNvbnRhaW5zUG9zaXRpb24oYS5zb3VyY2VQb3NpdGlvbikpIHsKICAgICAgcmV0dXJuIFtuZXcgTm9PcGVyYXRpb24oMCldOwogICAgfQogIH0gLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwoKCiAgaWYgKGEuc291cmNlUG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIudGFyZ2V0UG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogIH0KCiAgaWYgKGEuc291cmNlUG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIuc291cmNlUG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnkgLT0gYi5ob3dNYW55OwogIH0KCiAgYS5zb3VyY2VQb3NpdGlvbiA9IGEuc291cmNlUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwogIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKTsgLy8gYE1lcmdlT3BlcmF0aW9uYCBncmF2ZXlhcmQgcG9zaXRpb24gaXMgbGlrZSBgTW92ZU9wZXJhdGlvbmAgdGFyZ2V0IHBvc2l0aW9uLiBJdCBpcyBhIHBvc2l0aW9uIHdoZXJlIGVsZW1lbnQocykgd2lsbAogIC8vIGJlIG1vdmVkLiBMaWtlIGluIG90aGVyIHNpbWlsYXIgY2FzZXMsIHdlIG5lZWQgdG8gY29uc2lkZXIgdGhlIHNjZW5hcmlvIHdoZW4gdGhvc2UgcG9zaXRpb25zIGFyZSBzYW1lLgogIC8vIEhlcmUsIHdlIHdpbGwgdHJlYXQgYE1lcmdlT3BlcmF0aW9uYCBsaWtlIGl0IGlzIGFsd2F5cyBzdHJvbmcgKHNlZSBgSW5zZXJ0T3BlcmF0aW9uYCB4IGBJbnNlcnRPcGVyYXRpb25gIGZvciBjb21wYXJpc29uKS4KICAvLyBUaGlzIG1lYW5zIHRoYXQgd2Ugd29uJ3QgdHJhbnNmb3JtIGdyYXZleWFyZCBwb3NpdGlvbiBpZiBpdCBpcyBlcXVhbCB0byBtb3ZlIG9wZXJhdGlvbiB0YXJnZXQgcG9zaXRpb24uCgogIGlmICghYS5ncmF2ZXlhcmRQb3NpdGlvbi5pc0VxdWFsKGIudGFyZ2V0UG9zaXRpb24pKSB7CiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTWVyZ2VPcGVyYXRpb24sIFNwbGl0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIGlmIChiLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICAvLyBJZiBgYmAgb3BlcmF0aW9uIGRlZmluZXMgZ3JhdmV5YXJkIHBvc2l0aW9uLCBhIG5vZGUgZnJvbSBncmF2ZXlhcmQgd2lsbCBiZSBtb3ZlZC4gVGhpcyBtZWFucyB0aGF0IHdlIG5lZWQgdG8KICAgIC8vIHRyYW5zZm9ybSBgYS5ncmF2ZXlhcmRQb3NpdGlvbmAgYWNjb3JkaW5nbHkuCiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGIuZ3JhdmV5YXJkUG9zaXRpb24sIDEpOyAvLyBUaGlzIGlzIGEgc2NlbmFyaW8gZm9yZXNlZW4gaW4gYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAsIHdpdGggdHdvIGlkZW50aWNhbCBtZXJnZSBvcGVyYXRpb25zLgogICAgLy8KICAgIC8vIFNvLCB0aGVyZSB3YXMgYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24gZWFybGllci4gTm93LCBgYWAgaXMgYSBtZXJnZSBvcGVyYXRpb24gd2hpY2gKICAgIC8vIHNvdXJjZSBwb3NpdGlvbiBpcyBpbiBncmF2ZXlhcmQuIEludGVyZXN0aW5nbHksIHNwbGl0IG9wZXJhdGlvbiB3YW50cyB0byB1c2UgdGhlIG5vZGUgdG8gYmUgbWVyZ2VkIGJ5IGBhYC4gVGhpcwogICAgLy8gbWVhbnMgdGhhdCBgYmAgaXMgdW5kb2luZyB0aGF0IG1lcmdlIG9wZXJhdGlvbiBmcm9tIGVhcmxpZXIsIHdoaWNoIGNhdXNlZCBgYWAgdG8gYmUgaW4gZ3JhdmV5YXJkLgogICAgLy8KICAgIC8vIElmIHRoYXQncyB0aGUgY2FzZSwgYXQgdGhpcyBwb2ludCwgd2Ugd2lsbCBvbmx5ICJmaXgiIGBhLmhvd01hbnlgLiBJdCB3YXMgZWFybGllciBzZXQgdG8gYDBgIGluCiAgICAvLyBgTWVyZ2VPcGVyYXRpb25gIHggYE1lcmdlT3BlcmF0aW9uYCB0cmFuc2Zvcm1hdGlvbi4gTGF0ZXIgdHJhbnNmb3JtYXRpb25zIGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjaGFuZ2Ugb3RoZXIKICAgIC8vIHByb3BlcnRpZXMuCiAgICAvLwoKICAgIGlmIChhLmRlbGV0aW9uUG9zaXRpb24uaXNFcXVhbChiLmdyYXZleWFyZFBvc2l0aW9uKSkgewogICAgICBhLmhvd01hbnkgPSBiLmhvd01hbnk7CiAgICB9CiAgfSAvLyBDYXNlIDE6CiAgLy8KICAvLyBNZXJnZSBvcGVyYXRpb24gbW92ZXMgbm9kZXMgdG8gdGhlIHBsYWNlIHdoZXJlIHNwbGl0IGhhcHBlbnMuCiAgLy8gVGhpcyBpcyBhIGNsYXNzaWMgc2l0dWF0aW9uIHdoZW4gdGhlcmUgYXJlIHR3byBwYXJhZ3JhcGhzLCBhbmQgdGhlcmUgaXMgYSBzcGxpdCAoZW50ZXIpIGFmdGVyIHRoZSBmaXJzdAogIC8vIHBhcmFncmFwaCBhbmQgdGhlcmUgaXMgYSBtZXJnZSAoZGVsZXRlKSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgcGFyYWdyYXBoOgogIC8vCiAgLy8gPHA+Rm9ve308L3A+PHA+W11CYXI8L3A+LgogIC8vCiAgLy8gU3BsaXQgaXMgYWZ0ZXIgYEZvb2AsIHdoaWxlIG1lcmdlIGlzIGZyb20gYEJhcmAgdG8gdGhlIGVuZCBvZiBgRm9vYC4KICAvLwogIC8vIFN0YXRlIGFmdGVyIHNwbGl0OgogIC8vIDxwPkZvbzwvcD48cD48L3A+PHA+QmFyPC9wPgogIC8vCiAgLy8gTm93LCBgQmFyYCBzaG91bGQgYmUgbWVyZ2VkIHRvIHRoZSBuZXcgcGFyYWdyYXBoOgogIC8vIDxwPkZvbzwvcD48cD5CYXI8L3A+CiAgLy8KICAvLyBJbnN0ZWFkIG9mIG1lcmdpbmcgaXQgdG8gdGhlIG9yaWdpbmFsIHBhcmFncmFwaDoKICAvLyA8cD5Gb29CYXI8L3A+PHA+PC9wPgogIC8vCiAgLy8gVGhpcyBtZWFucyB0aGF0IGB0YXJnZXRQb3NpdGlvbmAgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQgY2FzZSB0aG91Z2guCiAgLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBzcGxpdCB3b3VsZCBiZSBhZnRlciBgRmAsIGB0YXJnZXRQb3NpdGlvbmAgc2hvdWxkIGFsc28gYmUgdHJhbnNmb3JtZWQuCiAgLy8KICAvLyBUaGVyZSBhcmUgdGhyZWUgZXhjZXB0aW9ucywgdGhvdWdoLCB3aGVuIHdlIHdhbnQgdG8ga2VlcCBgdGFyZ2V0UG9zaXRpb25gIGFzIGl0IHdhcy4KICAvLwogIC8vIEZpcnN0IGV4Y2VwdGlvbiBpcyB3aGVuIHRoZSBtZXJnZSB0YXJnZXQgcG9zaXRpb24gaXMgaW5zaWRlIGFuIGVsZW1lbnQgKG5vdCBhdCB0aGUgZW5kLCBhcyB1c3VhbCkuIFRoaXMKICAvLyBoYXBwZW5zIHdoZW4gdGhlIG1lcmdlIG9wZXJhdGlvbiBlYXJsaWVyIHdhcyB0cmFuc2Zvcm1lZCBieSAidGhlIHNhbWUiIG1lcmdlIG9wZXJhdGlvbi4gSWYgbWVyZ2Ugb3BlcmF0aW9uCiAgLy8gdGFyZ2V0cyBpbnNpZGUgdGhlIGVsZW1lbnQgd2Ugd2FudCB0byBrZWVwIHRoZSBvcmlnaW5hbCB0YXJnZXQgcG9zaXRpb24gKGFuZCBub3QgdHJhbnNmb3JtIGl0KSBiZWNhdXNlCiAgLy8gd2UgaGF2ZSBhZGRpdGlvbmFsIGNvbnRleHQgdGVsbGluZyB1cyB0aGF0IHdlIHdhbnQgdG8gbWVyZ2UgdG8gdGhlIG9yaWdpbmFsIGVsZW1lbnQuIFdlIGNhbiBjaGVjayBpZiB0aGUKICAvLyBtZXJnZSBvcGVyYXRpb24gcG9pbnRzIGluc2lkZSBlbGVtZW50IGJ5IGNoZWNraW5nIHdoYXQgaXMgYFNwbGl0T3BlcmF0aW9uI2hvd01hbnlgLiBTaW5jZSBtZXJnZSB0YXJnZXQgcG9zaXRpb24KICAvLyBpcyBzYW1lIGFzIHNwbGl0IHBvc2l0aW9uLCBpZiBgaG93TWFueWAgaXMgbm9uLXplcm8sIGl0IG1lYW5zIHRoYXQgdGhlIG1lcmdlIHRhcmdldCBwb3NpdGlvbiBpcyBpbnNpZGUgYW4gZWxlbWVudC4KICAvLwogIC8vIFNlY29uZCBleGNlcHRpb24gaXMgd2hlbiB0aGUgZWxlbWVudCB0byBtZXJnZSBpcyBpbiB0aGUgZ3JhdmV5YXJkIGFuZCBzcGxpdCBvcGVyYXRpb24gdXNlcyBpdC4gSW4gdGhhdCBjYXNlCiAgLy8gaWYgdGFyZ2V0IHBvc2l0aW9uIHdvdWxkIGJlIHRyYW5zZm9ybWVkLCB0aGUgbWVyZ2Ugb3BlcmF0aW9uIHdvdWxkIHRhcmdldCBhdCB0aGUgc291cmNlIHBvc2l0aW9uOgogIC8vCiAgLy8gcm9vdDogPHA+Rm9vPC9wPgkJCQlncmF2ZXlhcmQ6IDxwPjwvcD4KICAvLwogIC8vIFNwbGl0T3BlcmF0aW9uOiByb290IFsgMCwgMyBdIHVzaW5nIGdyYXZleWFyZCBbIDAgXSAoaG93TWFueSA9IDApCiAgLy8gTWVyZ2VPcGVyYXRpb246IGdyYXZleWFyZCBbIDAsIDAgXSAtPiByb290IFsgMCwgMyBdIChob3dNYW55ID0gMCkKICAvLwogIC8vIFNpbmNlIHNwbGl0IG9wZXJhdGlvbiBtb3ZlcyB0aGUgZ3JhdmV5YXJkIG5vZGUgYmFjayB0byB0aGUgcm9vdCwgdGhlIG1lcmdlIG9wZXJhdGlvbiBzb3VyY2UgcG9zaXRpb24gY2hhbmdlcy4KICAvLyBXZSB3b3VsZCBsaWtlIHRvIG1lcmdlIGZyb20gdGhlIGVtcHR5IDxwPiB0byB0aGUgIkZvbyIgPHA+OgogIC8vCiAgLy8gcm9vdDogPHA+Rm9vPC9wPjxwPjwvcD4JCQlncmF2ZXlhcmQ6CiAgLy8KICAvLyBNZXJnZU9wZXJhdGlvbiNzb3VyY2VQb3NpdGlvbiA9IHJvb3QgWyAxLCAwIF0KICAvLwogIC8vIElmIGB0YXJnZXRQb3NpdGlvbmAgaXMgdHJhbnNmb3JtZWQsIGl0IHdvdWxkIGJlY29tZSByb290IFsgMSwgMCBdIGFzIHdlbGwuIEl0IGhhcyB0byBiZSBrZXB0IGFzIGl0IHdhcy4KICAvLwogIC8vIFRoaXJkIGV4Y2VwdGlvbiBpcyBjb25uZWN0ZWQgd2l0aCByZWxhdGlvbnMuIElmIHRoaXMgaGFwcGVucyBkdXJpbmcgdW5kbyBhbmQgd2UgaGF2ZSBleHBsaWNpdCBpbmZvcm1hdGlvbgogIC8vIHRoYXQgdGFyZ2V0IHBvc2l0aW9uIGhhcyBub3QgYmVlbiBhZmZlY3RlZCBieSB0aGUgb3BlcmF0aW9uIHdoaWNoIGlzIHVuZG9uZSBieSB0aGlzIHNwbGl0IHRoZW4gdGhpcyBzcGxpdCBzaG91bGQKICAvLyBub3QgbW92ZSB0aGUgdGFyZ2V0IHBvc2l0aW9uIGVpdGhlci4KICAvLwoKCiAgaWYgKGEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChiLnNwbGl0UG9zaXRpb24pKSB7CiAgICB2YXIgbWVyZ2VJbnNpZGUgPSBiLmhvd01hbnkgIT0gMDsKICAgIHZhciBtZXJnZVNwbGl0dGluZ0VsZW1lbnQgPSBiLmdyYXZleWFyZFBvc2l0aW9uICYmIGEuZGVsZXRpb25Qb3NpdGlvbi5pc0VxdWFsKGIuZ3JhdmV5YXJkUG9zaXRpb24pOwoKICAgIGlmIChtZXJnZUluc2lkZSB8fCBtZXJnZVNwbGl0dGluZ0VsZW1lbnQgfHwgY29udGV4dC5hYlJlbGF0aW9uID09ICdtZXJnZVRhcmdldE5vdE1vdmVkJykgewogICAgICBhLnNvdXJjZVBvc2l0aW9uID0gYS5zb3VyY2VQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogICAgICByZXR1cm4gW2FdOwogICAgfQogIH0gLy8gQ2FzZSAyOgogIC8vCiAgLy8gTWVyZ2Ugc291cmNlIGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIHNwbGl0IHBvc2l0aW9uLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW4sIG1vc3RseSBkdXJpbmcgdW5kby4KICAvLyBUaGUgZGVjaXNpb24gaGVyZSBpcyBtb3N0bHkgdG8gY2hvb3NlIHdoZXRoZXIgbWVyZ2Ugc291cmNlIHBvc2l0aW9uIHNob3VsZCBzdGF5IHdoZXJlIGl0IGlzIChzbyBpdCB3aWxsIGJlIGF0IHRoZSBlbmQgb2YgdGhlCiAgLy8gc3BsaXQgZWxlbWVudCkgb3Igc2hvdWxkIGJlIG1vdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IGVsZW1lbnQuCiAgLy8KCgogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSkgewogICAgLy8gVXNlIGNvbnRleHQgdG8gY2hlY2sgaWYgYFNwbGl0T3BlcmF0aW9uYCBpcyBub3QgdW5kb2luZyBhIG1lcmdlIG9wZXJhdGlvbiwgdGhhdCBkaWRuJ3QgY2hhbmdlIHRoZSBgYWAgb3BlcmF0aW9uLgogICAgLy8gVGhpcyBzY2VuYXJpbyBoYXBwZW5zIHRoZSB1bmRvbmUgbWVyZ2Ugb3BlcmF0aW9uIG1vdmVkIG5vZGVzIGF0IHRoZSBzb3VyY2UgcG9zaXRpb24gb2YgYGFgIG9wZXJhdGlvbi4KICAgIC8vIEluIHRoYXQgY2FzZSBgYWAgb3BlcmF0aW9uIHNvdXJjZSBwb3NpdGlvbiBzaG91bGQgc3RheSB3aGVyZSBpdCBpcy4KICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24gPT0gJ21lcmdlU291cmNlTm90TW92ZWQnKSB7CiAgICAgIGEuaG93TWFueSA9IDA7CiAgICAgIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgICAgIHJldHVybiBbYV07CiAgICB9IC8vIFRoaXMgbWVyZ2Ugb3BlcmF0aW9uIG1pZ2h0IGhhdmUgYmVlbiBlYXJsaWVyIHRyYW5zZm9ybWVkIGJ5IGEgbWVyZ2Ugb3BlcmF0aW9uIHdoaWNoIGJvdGggbWVyZ2VkIHRoZSBzYW1lIGVsZW1lbnQuCiAgICAvLyBTZWUgdGhhdCBjYXNlIGluIGBNZXJnZU9wZXJhdGlvbmAgeCBgTWVyZ2VPcGVyYXRpb25gIHRyYW5zZm9ybWF0aW9uLiBJbiB0aGF0IHNjZW5hcmlvLCBpZiB0aGUgbWVyZ2Ugb3BlcmF0aW9uIGhhcyBiZWVuIHVuZG9uZSwKICAgIC8vIHRoZSBzcGVjaWFsIGNhc2UgaXMgbm90IGFwcGxpZWQuCiAgICAvLwogICAgLy8gTm93LCB0aGUgbWVyZ2Ugb3BlcmF0aW9uIGlzIHRyYW5zZm9ybWVkIGJ5IHRoZSBzcGxpdCB3aGljaCBoYXMgdW5kb25lIHRoYXQgcHJldmlvdXMgbWVyZ2Ugb3BlcmF0aW9uLgogICAgLy8gU28gbm93IHdlIGFyZSBmaXhpbmcgc2l0dWF0aW9uIHdoaWNoIHdhcyBza2lwcGVkIGluIGBNZXJnZU9wZXJhdGlvbmAgeCBgTWVyZ2VPcGVyYXRpb25gIGNhc2UuCiAgICAvLwoKCiAgICBpZiAoY29udGV4dC5hYlJlbGF0aW9uID09ICdtZXJnZVNhbWVFbGVtZW50JyB8fCBhLnNvdXJjZVBvc2l0aW9uLm9mZnNldCA+IDApIHsKICAgICAgYS5zb3VyY2VQb3NpdGlvbiA9IGIubW92ZVRhcmdldFBvc2l0aW9uLmNsb25lKCk7CiAgICAgIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgICAgIHJldHVybiBbYV07CiAgICB9CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBpZiAoYS5zb3VyY2VQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5zcGxpdFBvc2l0aW9uKSkgewogICAgYS5ob3dNYW55ID0gYi5zcGxpdFBvc2l0aW9uLm9mZnNldDsKICB9CgogIGEuc291cmNlUG9zaXRpb24gPSBhLnNvdXJjZVBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnNldFRyYW5zZm9ybWF0aW9uKE1vdmVPcGVyYXRpb24sIEluc2VydE9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIpIHsKICB2YXIgbW92ZVJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KGEuc291cmNlUG9zaXRpb24sIGEuaG93TWFueSk7CgogIHZhciB0cmFuc2Zvcm1lZCA9IG1vdmVSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiLCBmYWxzZSlbMF07CgogIGEuc291cmNlUG9zaXRpb24gPSB0cmFuc2Zvcm1lZC5zdGFydDsKICBhLmhvd01hbnkgPSB0cmFuc2Zvcm1lZC5lbmQub2Zmc2V0IC0gdHJhbnNmb3JtZWQuc3RhcnQub2Zmc2V0OyAvLyBTZWUgYEluc2VydE9wZXJhdGlvbmAgeCBgTW92ZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24gZm9yIGRldGFpbHMgb24gdGhpcyBjYXNlLgogIC8vCiAgLy8gSW4gc3VtbWFyeSwgYm90aCBvcGVyYXRpb25zIHBvaW50IHRvIHRoZSBzYW1lIHBsYWNlLCBzbyB0aGUgb3JkZXIgb2Ygbm9kZXMgbmVlZHMgdG8gYmUgZGVjaWRlZC4KICAvLyBgTW92ZU9wZXJhdGlvbmAgaXMgY29uc2lkZXJlZCB3ZWFrZXIsIHNvIGl0IGlzIGFsd2F5cyB0cmFuc2Zvcm1lZCwgdW5sZXNzIHRoZXJlIHdhcyBhIGNlcnRhaW4gcmVsYXRpb24KICAvLyBiZXR3ZWVuIG9wZXJhdGlvbnMuCiAgLy8KCiAgaWYgKCFhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi5wb3NpdGlvbikpIHsKICAgIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKE1vdmVPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgLy8KICAvLyBTZXR0aW5nIGFuZCBldmFsdWF0aW5nIHNvbWUgdmFyaWFibGVzIHRoYXQgd2lsbCBiZSB1c2VkIGluIHNwZWNpYWwgY2FzZXMgYW5kIGRlZmF1bHQgYWxnb3JpdGhtLgogIC8vCiAgLy8gQ3JlYXRlIHJhbmdlcyBmcm9tIGBNb3ZlT3BlcmF0aW9uc2AgcHJvcGVydGllcy4KICB2YXIgcmFuZ2VBID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KGEuc291cmNlUG9zaXRpb24sIGEuaG93TWFueSk7CgogIHZhciByYW5nZUIgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYi5zb3VyY2VQb3NpdGlvbiwgYi5ob3dNYW55KTsgLy8gQXNzaWduIGBjb250ZXh0LmFJc1N0cm9uZ2AgdG8gYSBkaWZmZXJlbnQgdmFyaWFibGUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBjaGFuZ2UgZHVyaW5nIGV4ZWN1dGlvbiBvZgogIC8vIHRoaXMgYWxnb3JpdGhtIGFuZCB3ZSBkbyBub3Qgd2FudCB0byBvdmVycmlkZSBvcmlnaW5hbCBgY29udGV4dC5hSXNTdHJvbmdgIHRoYXQgd2lsbCBiZSB1c2VkIGluIGxhdGVyIHRyYW5zZm9ybWF0aW9ucy4KCgogIHZhciBhSXNTdHJvbmcgPSBjb250ZXh0LmFJc1N0cm9uZzsgLy8gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHRoZSBvcmRlciBvZiBub2RlcyBpZiBib3RoIG9wZXJhdGlvbnMgdGFyZ2V0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLgogIC8vIEJ5IGRlZmF1bHQsIHVzZSBzdHJvbmcvd2VhayBvcGVyYXRpb24gbWVjaGFuaXNtLgoKICB2YXIgaW5zZXJ0QmVmb3JlID0gIWNvbnRleHQuYUlzU3Ryb25nOyAvLyBJZiB0aGUgcmVsYXRpb24gaXMgc2V0LCB0aGVuIHVzZSBpdCB0byBkZWNpZGUgbm9kZXMgb3JkZXIuCgogIGlmIChjb250ZXh0LmFiUmVsYXRpb24gPT0gJ2luc2VydEJlZm9yZScgfHwgY29udGV4dC5iYVJlbGF0aW9uID09ICdpbnNlcnRBZnRlcicpIHsKICAgIGluc2VydEJlZm9yZSA9IHRydWU7CiAgfSBlbHNlIGlmIChjb250ZXh0LmFiUmVsYXRpb24gPT0gJ2luc2VydEFmdGVyJyB8fCBjb250ZXh0LmJhUmVsYXRpb24gPT0gJ2luc2VydEJlZm9yZScpIHsKICAgIGluc2VydEJlZm9yZSA9IGZhbHNlOwogIH0gLy8gYGEudGFyZ2V0UG9zaXRpb25gIGNvdWxkIGJlIGFmZmVjdGVkIGJ5IHRoZSBgYmAgb3BlcmF0aW9uLiBXZSB3aWxsIHRyYW5zZm9ybSBpdC4KCgogIHZhciBuZXdUYXJnZXRQb3NpdGlvbjsKCiAgaWYgKGEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChiLnRhcmdldFBvc2l0aW9uKSAmJiBpbnNlcnRCZWZvcmUpIHsKICAgIG5ld1RhcmdldFBvc2l0aW9uID0gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSk7CiAgfSBlbHNlIHsKICAgIG5ld1RhcmdldFBvc2l0aW9uID0gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoYi5zb3VyY2VQb3NpdGlvbiwgYi50YXJnZXRQb3NpdGlvbiwgYi5ob3dNYW55KTsKICB9IC8vCiAgLy8gU3BlY2lhbCBjYXNlICMxICsgbWlycm9yLgogIC8vCiAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gYm90aCBtb3ZlIG9wZXJhdGlvbnMnIHRhcmdldCBwb3NpdGlvbnMgYXJlIGluc2lkZSBub2RlcyB0aGF0IGFyZQogIC8vIGJlaW5nIG1vdmVkIGJ5IHRoZSBvdGhlciBtb3ZlIG9wZXJhdGlvbi4gU28gaW4gb3RoZXIgd29yZHMsIHdlIG1vdmUgcmFuZ2VzIGludG8gaW5zaWRlIG9mIGVhY2ggb3RoZXIuCiAgLy8gVGhpcyBjYXNlIGNhbid0IGJlIHNvbHZlZCByZWFzb25hYmx5IChvbiB0aGUgb3RoZXIgaGFuZCwgaXQgc2hvdWxkIG5vdCBoYXBwZW4gb2Z0ZW4pLgoKCiAgaWYgKF9tb3ZlVGFyZ2V0SW50b01vdmVkUmFuZ2UoYSwgYikgJiYgX21vdmVUYXJnZXRJbnRvTW92ZWRSYW5nZShiLCBhKSkgewogICAgLy8gSW5zdGVhZCBvZiB0cmFuc2Zvcm1pbmcgb3BlcmF0aW9uLCB3ZSByZXR1cm4gYSByZXZlcnNlIG9mIHRoZSBvcGVyYXRpb24gdGhhdCB3ZSB0cmFuc2Zvcm0gYnkuCiAgICAvLyBTbyB3aGVuIHRoZSByZXN1bHRzIG9mIHRoaXMgInRyYW5zZm9ybWF0aW9uIiB3aWxsIGJlIGFwcGxpZWQsIGBiYCBNb3ZlT3BlcmF0aW9uIHdpbGwgZ2V0IHJldmVyc2VkLgogICAgcmV0dXJuIFtiLmdldFJldmVyc2VkKCldOwogIH0gLy8KICAvLyBFbmQgb2Ygc3BlY2lhbCBjYXNlICMxLgogIC8vCiAgLy8KICAvLyBTcGVjaWFsIGNhc2UgIzIuCiAgLy8KICAvLyBDaGVjayBpZiBgYmAgb3BlcmF0aW9uIHRhcmdldHMgaW5zaWRlIGByYW5nZUFgLgoKCiAgdmFyIGJUYXJnZXRzVG9BID0gcmFuZ2VBLmNvbnRhaW5zUG9zaXRpb24oYi50YXJnZXRQb3NpdGlvbik7IC8vIElmIGBiYCB0YXJnZXRzIHRvIGByYW5nZUFgIGFuZCBgcmFuZ2VBYCBjb250YWlucyBgcmFuZ2VCYCwgYGJgIG9wZXJhdGlvbiBoYXMgbm8gaW5mbHVlbmNlIG9uIGBhYCBvcGVyYXRpb24uCiAgLy8gWW91IG1pZ2h0IHNheSB0aGF0IG9wZXJhdGlvbiBgYmAgaXMgY2FwdHVyZWQgaW5zaWRlIG9wZXJhdGlvbiBgYWAuCgogIGlmIChiVGFyZ2V0c1RvQSAmJiByYW5nZUEuY29udGFpbnNSYW5nZShyYW5nZUIsIHRydWUpKSB7CiAgICAvLyBUaGVyZSBpcyBhIG1pbmktc3BlY2lhbCBjYXNlIGhlcmUsIHdoZXJlIGByYW5nZUJgIGlzIG9uIG90aGVyIGxldmVsIHRoYW4gYHJhbmdlQWAuIFRoYXQncyB3aHkKICAgIC8vIHdlIG5lZWQgdG8gdHJhbnNmb3JtIGBhYCBvcGVyYXRpb24gYW55d2F5LgogICAgcmFuZ2VBLnN0YXJ0ID0gcmFuZ2VBLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShiLnNvdXJjZVBvc2l0aW9uLCBiLnRhcmdldFBvc2l0aW9uLCBiLmhvd01hbnkpOwogICAgcmFuZ2VBLmVuZCA9IHJhbmdlQS5lbmQuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKGIuc291cmNlUG9zaXRpb24sIGIudGFyZ2V0UG9zaXRpb24sIGIuaG93TWFueSk7CiAgICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMoW3JhbmdlQV0sIG5ld1RhcmdldFBvc2l0aW9uKTsKICB9IC8vCiAgLy8gU3BlY2lhbCBjYXNlICMyIG1pcnJvci4KICAvLwoKCiAgdmFyIGFUYXJnZXRzVG9CID0gcmFuZ2VCLmNvbnRhaW5zUG9zaXRpb24oYS50YXJnZXRQb3NpdGlvbik7CgogIGlmIChhVGFyZ2V0c1RvQiAmJiByYW5nZUIuY29udGFpbnNSYW5nZShyYW5nZUEsIHRydWUpKSB7CiAgICAvLyBgYWAgb3BlcmF0aW9uIGlzICJtb3ZlZCB0b2dldGhlciIgd2l0aCBgYmAgb3BlcmF0aW9uLgogICAgLy8gSGVyZSwganVzdCBtb3ZlIGByYW5nZUFgICJpbnNpZGUiIGByYW5nZUJgLgogICAgcmFuZ2VBLnN0YXJ0ID0gcmFuZ2VBLnN0YXJ0Ll9nZXRDb21iaW5lZChiLnNvdXJjZVBvc2l0aW9uLCBiLmdldE1vdmVkUmFuZ2VTdGFydCgpKTsKICAgIHJhbmdlQS5lbmQgPSByYW5nZUEuZW5kLl9nZXRDb21iaW5lZChiLnNvdXJjZVBvc2l0aW9uLCBiLmdldE1vdmVkUmFuZ2VTdGFydCgpKTsKICAgIHJldHVybiBfbWFrZU1vdmVPcGVyYXRpb25zRnJvbVJhbmdlcyhbcmFuZ2VBXSwgbmV3VGFyZ2V0UG9zaXRpb24pOwogIH0gLy8KICAvLyBFbmQgb2Ygc3BlY2lhbCBjYXNlICMyLgogIC8vCiAgLy8KICAvLyBTcGVjaWFsIGNhc2UgIzMgKyBtaXJyb3IuCiAgLy8KICAvLyBgcmFuZ2VBYCBoYXMgYSBub2RlIHdoaWNoIGlzIGFuIGFuY2VzdG9yIG9mIGByYW5nZUJgLiBJbiBvdGhlciB3b3JkcywgYHJhbmdlQmAgaXMgaW5zaWRlIGByYW5nZUFgCiAgLy8gYnV0IG5vdCBvbiB0aGUgc2FtZSB0cmVlIGxldmVsLiBJbiBzdWNoIGNhc2UgcmFuZ2VzIGhhdmUgY29tbW9uIHBhcnQgYnV0IHdlIGhhdmUgdG8gdHJlYXQgaXQKICAvLyBkaWZmZXJlbnRseSwgYmVjYXVzZSBpbiBzdWNoIGNhc2UgdGhvc2UgcmFuZ2VzIGFyZSBub3QgcmVhbGx5IGNvbmZsaWN0aW5nIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBsaWtlCiAgLy8gdHdvIHNlcGFyYXRlIHJhbmdlcy4gQWxzbyB3ZSBoYXZlIHRvIGRpc2NhcmQgdHdvIGRpZmZlcmVuY2UgcGFydHMuCgoKICB2YXIgYUNvbXBCID0gY29tcGFyZUFycmF5cyhhLnNvdXJjZVBvc2l0aW9uLmdldFBhcmVudFBhdGgoKSwgYi5zb3VyY2VQb3NpdGlvbi5nZXRQYXJlbnRQYXRoKCkpOwoKICBpZiAoYUNvbXBCID09ICdwcmVmaXgnIHx8IGFDb21wQiA9PSAnZXh0ZW5zaW9uJykgewogICAgLy8gVHJhbnNmb3JtIGByYW5nZUFgIGJ5IGBiYCBvcGVyYXRpb24gYW5kIG1ha2Ugb3BlcmF0aW9uIG91dCBvZiBpdCwgYW5kIHRoYXQncyBhbGwuCiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBkZWZhdWx0IGNhc2UsIGJ1dCBoZXJlIHdlIHRyZWF0IHRoZSBjb21tb24gcGFydCAod2hvbGUgYHJhbmdlQWApCiAgICAvLyBsaWtlIGEgb25lIGRpZmZlcmVuY2UgcGFydC4KICAgIHJhbmdlQS5zdGFydCA9IHJhbmdlQS5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoYi5zb3VyY2VQb3NpdGlvbiwgYi50YXJnZXRQb3NpdGlvbiwgYi5ob3dNYW55KTsKICAgIHJhbmdlQS5lbmQgPSByYW5nZUEuZW5kLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShiLnNvdXJjZVBvc2l0aW9uLCBiLnRhcmdldFBvc2l0aW9uLCBiLmhvd01hbnkpOwogICAgcmV0dXJuIF9tYWtlTW92ZU9wZXJhdGlvbnNGcm9tUmFuZ2VzKFtyYW5nZUFdLCBuZXdUYXJnZXRQb3NpdGlvbik7CiAgfSAvLwogIC8vIEVuZCBvZiBzcGVjaWFsIGNhc2UgIzMuCiAgLy8KICAvLwogIC8vIERlZmF1bHQgY2FzZSAtIHJhbmdlcyBhcmUgb24gdGhlIHNhbWUgbGV2ZWwgb3IgYXJlIG5vdCBjb25uZWN0ZWQgd2l0aCBlYWNoIG90aGVyLgogIC8vCiAgLy8gTW9kaWZpZXIgZm9yIGRlZmF1bHQgY2FzZS4KICAvLyBNb2RpZmllcyBgYUlzU3Ryb25nYCBmbGFnIGluIGNlcnRhaW4gY29uZGl0aW9ucy4KICAvLwogIC8vIElmIG9ubHkgb25lIG9mIG9wZXJhdGlvbnMgaXMgYSByZW1vdmUgb3BlcmF0aW9uLCB3ZSBmb3JjZSByZW1vdmUgb3BlcmF0aW9uIHRvIGJlIHRoZSAic3Ryb25nZXIiIG9uZQogIC8vIHRvIHByb3ZpZGUgbW9yZSBleHBlY3RlZCByZXN1bHRzLgoKCiAgaWYgKGEudHlwZSA9PSAncmVtb3ZlJyAmJiBiLnR5cGUgIT0gJ3JlbW92ZScgJiYgIWNvbnRleHQuYVdhc1VuZG9uZSAmJiAhY29udGV4dC5mb3JjZVdlYWtSZW1vdmUpIHsKICAgIGFJc1N0cm9uZyA9IHRydWU7CiAgfSBlbHNlIGlmIChhLnR5cGUgIT0gJ3JlbW92ZScgJiYgYi50eXBlID09ICdyZW1vdmUnICYmICFjb250ZXh0LmJXYXNVbmRvbmUgJiYgIWNvbnRleHQuZm9yY2VXZWFrUmVtb3ZlKSB7CiAgICBhSXNTdHJvbmcgPSBmYWxzZTsKICB9IC8vIEhhbmRsZSBvcGVyYXRpb24ncyBzb3VyY2UgcmFuZ2VzIC0gY2hlY2sgaG93IGByYW5nZUFgIGlzIGFmZmVjdGVkIGJ5IGBiYCBvcGVyYXRpb24uCiAgLy8gVGhpcyB3aWxsIGFnZ3JlZ2F0ZSB0cmFuc2Zvcm1lZCByYW5nZXMuCgoKICB2YXIgcmFuZ2VzID0gW107IC8vIEdldCB0aGUgImRpZmZlcmVuY2UgcGFydCIgb2YgYGFgIG9wZXJhdGlvbiBzb3VyY2UgcmFuZ2UuCiAgLy8gVGhpcyBpcyBhbiBhcnJheSB3aXRoIG9uZSBvciB0d28gcmFuZ2VzLiBUd28gcmFuZ2VzIGlmIGByYW5nZUJgIGlzIGluc2lkZSBgcmFuZ2VBYC4KCiAgdmFyIGRpZmZlcmVuY2UgPSByYW5nZUEuZ2V0RGlmZmVyZW5jZShyYW5nZUIpOwoKICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRpZmZlcmVuY2UpLAogICAgICBfc3RlcDY7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykgewogICAgICB2YXIgcmFuZ2UgPSBfc3RlcDYudmFsdWU7CiAgICAgIC8vIFRyYW5zZm9ybSB0aG9zZSByYW5nZXMgYnkgYGJgIG9wZXJhdGlvbi4gRm9yIGV4YW1wbGUgaWYgYGJgIG1vdmVkIHJhbmdlIGZyb20gYmVmb3JlIHRob3NlIHJhbmdlcywgZml4IHRob3NlIHJhbmdlcy4KICAgICAgcmFuZ2Uuc3RhcnQgPSByYW5nZS5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSk7CiAgICAgIHJhbmdlLmVuZCA9IHJhbmdlLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSk7IC8vIElmIGBiYCBvcGVyYXRpb24gdGFyZ2V0cyBpbnRvIGByYW5nZUFgIG9uIHRoZSBzYW1lIGxldmVsLCBzcHJlYWQgYHJhbmdlQWAgaW50byB0d28gcmFuZ2VzLgoKICAgICAgdmFyIHNob3VsZFNwcmVhZCA9IGNvbXBhcmVBcnJheXMocmFuZ2Uuc3RhcnQuZ2V0UGFyZW50UGF0aCgpLCBiLmdldE1vdmVkUmFuZ2VTdGFydCgpLmdldFBhcmVudFBhdGgoKSkgPT0gJ3NhbWUnOwoKICAgICAgdmFyIG5ld1JhbmdlcyA9IHJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCksIGIuaG93TWFueSwgc2hvdWxkU3ByZWFkKTsKCiAgICAgIHJhbmdlcy5wdXNoLmFwcGx5KHJhbmdlcywgX3RvQ29uc3VtYWJsZUFycmF5KG5ld1JhbmdlcykpOwogICAgfSAvLyBUaGVuLCB3ZSBoYXZlIHRvIG1hbmFnZSB0aGUgImNvbW1vbiBwYXJ0IiBvZiBib3RoIG1vdmUgcmFuZ2VzLgoKICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjYuZShlcnIpOwogIH0gZmluYWxseSB7CiAgICBfaXRlcmF0b3I2LmYoKTsKICB9CgogIHZhciBjb21tb24gPSByYW5nZUEuZ2V0SW50ZXJzZWN0aW9uKHJhbmdlQik7CgogIGlmIChjb21tb24gIT09IG51bGwgJiYgYUlzU3Ryb25nKSB7CiAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGF0IHBhcnQgb2Ygb3JpZ2luYWwgcmFuZ2UuCiAgICBjb21tb24uc3RhcnQgPSBjb21tb24uc3RhcnQuX2dldENvbWJpbmVkKGIuc291cmNlUG9zaXRpb24sIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkpOwogICAgY29tbW9uLmVuZCA9IGNvbW1vbi5lbmQuX2dldENvbWJpbmVkKGIuc291cmNlUG9zaXRpb24sIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkpOyAvLyBUYWtlIGNhcmUgb2YgcHJvcGVyIHJhbmdlIG9yZGVyLgogICAgLy8KICAgIC8vIFB1dCBgY29tbW9uYCBhdCBhcHByb3ByaWF0ZSBwbGFjZS4gS2VlcCBpbiBtaW5kIHRoYXQgd2UgYXJlIGludGVyZXN0ZWQgaW4gb3JpZ2luYWwgb3JkZXIuCiAgICAvLyBCYXNpY2FsbHkgdGhlcmUgYXJlIG9ubHkgdGhyZWUgY2FzZXM6IHRoZXJlIGlzIHplcm8sIG9uZSBvciB0d28gZGlmZmVyZW5jZSByYW5nZXMuCiAgICAvLwogICAgLy8gSWYgdGhlcmUgaXMgemVybyBkaWZmZXJlbmNlIHJhbmdlcywganVzdCBwdXNoIGBjb21tb25gIGluIHRoZSBhcnJheS4KCiAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMCkgewogICAgICByYW5nZXMucHVzaChjb21tb24pOwogICAgfSAvLyBJZiB0aGVyZSBpcyBvbmUgZGlmZmVyZW5jZSByYW5nZSwgd2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIGNvbW1vbiBwYXJ0IHdhcyBiZWZvcmUgaXQgb3IgYWZ0ZXIgaXQuCiAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID09IDEpIHsKICAgICAgICBpZiAocmFuZ2VCLnN0YXJ0LmlzQmVmb3JlKHJhbmdlQS5zdGFydCkgfHwgcmFuZ2VCLnN0YXJ0LmlzRXF1YWwocmFuZ2VBLnN0YXJ0KSkgewogICAgICAgICAgcmFuZ2VzLnVuc2hpZnQoY29tbW9uKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmFuZ2VzLnB1c2goY29tbW9uKTsKICAgICAgICB9CiAgICAgIH0gLy8gSWYgdGhlcmUgYXJlIG1vcmUgcmFuZ2VzICh3aGljaCBtZWFucyB0d28pLCBwdXQgY29tbW9uIHBhcnQgYmV0d2VlbiB0aGVtLiBUaGlzIGlzIHRoZSBvbmx5IHNjZW5hcmlvCiAgICAgIC8vIHdoZXJlIHRoZXJlIGNvdWxkIGJlIHR3byBkaWZmZXJlbmNlIHJhbmdlcyBzbyB3ZSBkb24ndCBoYXZlIHRvIG1ha2UgYW55IGNvbXBhcmlzb25zLgogICAgICBlbHNlIHsKICAgICAgICAgIHJhbmdlcy5zcGxpY2UoMSwgMCwgY29tbW9uKTsKICAgICAgICB9CiAgfQoKICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMCkgewogICAgLy8gSWYgdGhlcmUgYXJlIG5vICJzb3VyY2UgcmFuZ2VzIiwgbm90aGluZyBzaG91bGQgYmUgY2hhbmdlZC4KICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNhbiBoYXBwZW4gb25seSBpZiBgYUlzU3Ryb25nID09IGZhbHNlYCBhbmQgYHJhbmdlQS5pc0VxdWFsKCByYW5nZUIgKWAuCiAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbihhLmJhc2VWZXJzaW9uKV07CiAgfQoKICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMocmFuZ2VzLCBuZXdUYXJnZXRQb3NpdGlvbik7Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNb3ZlT3BlcmF0aW9uLCBTcGxpdE9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICB2YXIgbmV3VGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLmNsb25lKCk7IC8vIERvIG5vdCB0cmFuc2Zvcm0gaWYgdGFyZ2V0IHBvc2l0aW9uIGlzIHNhbWUgYXMgc3BsaXQgaW5zZXJ0aW9uIHBvc2l0aW9uIGFuZCB0aGlzIHNwbGl0IGNvbWVzIGZyb20gdW5kby4KICAvLyBUaGlzIHNob3VsZCBiZSBkb25lIG9uIHJlbGF0aW9ucyBidXQgaXQgaXMgdG9vIG11Y2ggd29yayBmb3Igbm93IGFzIGl0IHdvdWxkIHJlcXVpcmUgcmVsYXRpb25zIHdvcmtpbmcgaW4gY29sbGFib3JhdGlvbi4KICAvLyBXZSBuZWVkIHRvIG1ha2UgYSBkZWNpc2lvbiBob3cgd2Ugd2lsbCByZXNvbHZlIHN1Y2ggY29uZmxpY3QgYW5kIHRoaXMgaXMgbGVzcyBoYXJtZnVsIHdheS4KCiAgaWYgKCFhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi5pbnNlcnRpb25Qb3NpdGlvbikgfHwgIWIuZ3JhdmV5YXJkUG9zaXRpb24gfHwgY29udGV4dC5hYlJlbGF0aW9uID09ICdtb3ZlVGFyZ2V0QWZ0ZXInKSB7CiAgICBuZXdUYXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICB9IC8vIENhc2UgMToKICAvLwogIC8vIExhc3QgZWxlbWVudCBpbiB0aGUgbW92ZWQgcmFuZ2UgZ290IHNwbGl0LgogIC8vCiAgLy8gSW4gdGhpcyBjYXNlIHRoZSBkZWZhdWx0IHJhbmdlIHRyYW5zZm9ybWF0aW9uIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGFzIHRoZSBlbGVtZW50IGNyZWF0ZWQgYnkKICAvLyBzcGxpdCBvcGVyYXRpb24gd291bGQgYmUgb3V0c2lkZSB0aGUgcmFuZ2UuIFRoZSByYW5nZSB0byBtb3ZlIG5lZWRzIHRvIGJlIGZpeGVkIG1hbnVhbGx5LgogIC8vCgoKICB2YXIgbW92ZVJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KGEuc291cmNlUG9zaXRpb24sIGEuaG93TWFueSk7CgogIGlmIChtb3ZlUmFuZ2UuZW5kLmlzRXF1YWwoYi5pbnNlcnRpb25Qb3NpdGlvbikpIHsKICAgIC8vIERvIGl0IG9ubHkgaWYgdGhpcyBpcyBhICJuYXR1cmFsIiBzcGxpdCwgbm90IGEgb25lIHRoYXQgY29tZXMgZnJvbSB1bmRvLgogICAgLy8gSWYgdGhpcyBpcyB1bmRvIHNwbGl0LCBvbmx5IGB0YXJnZXRQb3NpdGlvbmAgbmVlZHMgdG8gYmUgY2hhbmdlZCAoaWYgdGhlIG1vdmUgaXMgYSByZW1vdmUpLgogICAgaWYgKCFiLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICAgIGEuaG93TWFueSsrOwogICAgfQoKICAgIGEudGFyZ2V0UG9zaXRpb24gPSBuZXdUYXJnZXRQb3NpdGlvbjsKICAgIHJldHVybiBbYV07CiAgfSAvLyBDYXNlIDI6CiAgLy8KICAvLyBTcGxpdCBoYXBwZW5lZCBiZXR3ZWVuIHRoZSBtb3ZlZCBub2Rlcy4gSW4gdGhpcyBjYXNlIHR3byByYW5nZXMgdG8gbW92ZSBuZWVkIHRvIGJlIGdlbmVyYXRlZC4KICAvLwogIC8vIENoYXJhY3RlcnMgYG96YmFgIGFyZSBtb3ZlZCB0byB0aGUgZW5kIG9mIHBhcmFncmFwaCBgWHl6YCBidXQgc3BsaXQgaGFwcGVuZWQuCiAgLy8gPHA+RltvenxiYV1yPC9wPjxwPlh5ejwvcD4KICAvLwogIC8vIEFmdGVyIHNwbGl0OgogIC8vIDxwPkZbb3o8L3A+PHA+YmFdcjwvcD48cD5YeXo8L3A+CiAgLy8KICAvLyBDb3JyZWN0IHJhbmdlczoKICAvLyA8cD5GW296XTwvcD48cD5bYmFdcjwvcD48cD5YeXo8L3A+CiAgLy8KICAvLyBBZnRlciBtb3ZlOgogIC8vIDxwPkY8L3A+PHA+cjwvcD48cD5YeXpvemJhPC9wPgogIC8vCgoKICBpZiAobW92ZVJhbmdlLnN0YXJ0Lmhhc1NhbWVQYXJlbnRBcyhiLnNwbGl0UG9zaXRpb24pICYmIG1vdmVSYW5nZS5jb250YWluc1Bvc2l0aW9uKGIuc3BsaXRQb3NpdGlvbikpIHsKICAgIHZhciByaWdodFJhbmdlID0gbmV3IFJhbmdlKGIuc3BsaXRQb3NpdGlvbiwgbW92ZVJhbmdlLmVuZCk7CiAgICByaWdodFJhbmdlID0gcmlnaHRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogICAgdmFyIF9yYW5nZXMgPSBbbmV3IFJhbmdlKG1vdmVSYW5nZS5zdGFydCwgYi5zcGxpdFBvc2l0aW9uKSwgcmlnaHRSYW5nZV07CiAgICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMoX3JhbmdlcywgbmV3VGFyZ2V0UG9zaXRpb24pOwogIH0gLy8gQ2FzZSAzOgogIC8vCiAgLy8gTW92ZSBvcGVyYXRpb24gdGFyZ2V0cyBhdCB0aGUgc3BsaXQgcG9zaXRpb24uIFdlIG5lZWQgdG8gZGVjaWRlIGlmIHRoZSBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQKICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBzcGxpdCBlbGVtZW50IG9yIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBlbGVtZW50LgogIC8vCgoKICBpZiAoYS50YXJnZXRQb3NpdGlvbi5pc0VxdWFsKGIuc3BsaXRQb3NpdGlvbikgJiYgY29udGV4dC5hYlJlbGF0aW9uID09ICdpbnNlcnRBdFNvdXJjZScpIHsKICAgIG5ld1RhcmdldFBvc2l0aW9uID0gYi5tb3ZlVGFyZ2V0UG9zaXRpb247CiAgfSAvLyBDYXNlIDQ6CiAgLy8KICAvLyBNb3ZlIG9wZXJhdGlvbiB0YXJnZXRzIGp1c3QgYWZ0ZXIgdGhlIHNwbGl0IGVsZW1lbnQuIFdlIG5lZWQgdG8gZGVjaWRlIGlmIHRoZSBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQKICAvLyBiZXR3ZWVuIHR3byBwYXJ0cyBvZiBzcGxpdCBlbGVtZW50LCBvciBhZnRlciB0aGUgbmV3IGVsZW1lbnQuCiAgLy8KICAvLyBTcGxpdCBhdCBgfGAsIHdoaWxlIG1vdmUgb3BlcmF0aW9uIG1vdmVzIGA8cD5YeXo8L3A+YCBhbmQgdGFyZ2V0cyBhdCBgXmA6CiAgLy8gPHA+Rm9vfGJhcjwvcD5ePHA+YmF6PC9wPgogIC8vIDxwPkZvbzwvcD5ePHA+YmFyPC9wPjxwPmJhejwvcD4gb3IgPHA+Rm9vPC9wPjxwPmJhcjwvcD5ePHA+YmF6PC9wPj8KICAvLwogIC8vIElmIHRoZXJlIGlzIG5vIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiBvcGVyYXRpb25zIChmb3IgZXhhbXBsZSwgdGhleSBjb21lIGZyb20gY29sbGFib3JhdGl2ZQogIC8vIGVkaXRpbmcpLCB3ZSBkb24ndCB3YW50IHRvIHB1dCBzb21lIHVucmVsYXRlZCBjb250ZW50IChtb3ZlKSBiZXR3ZWVuIHBhcnRzIG9mIHJlbGF0ZWQgY29udGVudCAoc3BsaXQgcGFydHMpLgogIC8vIEhvd2V2ZXIsIGlmIHRoZSBzcGxpdCBpcyBmcm9tIHVuZG8sIGluIHRoZSBwYXN0LCB0aGUgbW92ZWQgY29udGVudCBtaWdodCBiZSB0YXJnZXRpbmcgYmV0d2VlbiB0aGUKICAvLyBzcGxpdCBwYXJ0cywgbWVhbmluZyB0aGF0IHdhcyBleGFjdGx5IHVzZXIncyBpbnRlbnRpb246CiAgLy8KICAvLyA8cD5Gb288L3A+XjxwPmJhcjwvcD4JCTwtLS0gb3JpZ2luYWwgc2l0dWF0aW9uLCBpbiAicGFzdCIuCiAgLy8gPHA+Rm9vYmFyPC9wPl4JCQkJPC0tLSBhZnRlciBtZXJnZSB0YXJnZXQgcG9zaXRpb24gaXMgdHJhbnNmb3JtZWQuCiAgLy8gPHA+Rm9vfGJhcjwvcD5eCQkJCTwtLS0gdGhlbiB0aGUgbWVyZ2UgaXMgdW5kb25lLCBhbmQgc3BsaXQgaGFwcGVucywgd2hpY2ggbGVhZHMgdXMgdG8gY3VycmVudCBzaXR1YXRpb24uCiAgLy8KICAvLyBJbiB0aGlzIGNhc2UgaXQgaXMgcHJldHR5IGNsZWFyIHRoYXQgdGhlIGludGVudGlvbiB3YXMgdG8gcHV0IG5ldyBwYXJhZ3JhcGggYmV0d2VlbiB0aG9zZSBub2RlcywKICAvLyBzbyB3ZSBuZWVkIHRvIHRyYW5zZm9ybSBhY2NvcmRpbmdseS4gV2UgY2FuIGRldGVjdCB0aGlzIHNjZW5hcmlvIHRoYW5rcyB0byByZWxhdGlvbnMuCiAgLy8KCgogIGlmIChhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi5pbnNlcnRpb25Qb3NpdGlvbikgJiYgY29udGV4dC5hYlJlbGF0aW9uID09ICdpbnNlcnRCZXR3ZWVuJykgewogICAgbmV3VGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uOwogIH0gLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwoKCiAgdmFyIHRyYW5zZm9ybWVkID0gbW92ZVJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CgogIHZhciByYW5nZXMgPSBbdHJhbnNmb3JtZWRdOyAvLyBDYXNlIDU6CiAgLy8KICAvLyBNb3ZlZCByYW5nZSBjb250YWlucyBncmF2ZXlhcmQgZWxlbWVudCB1c2VkIGJ5IHNwbGl0IG9wZXJhdGlvbi4gQWRkIGV4dHJhIG1vdmUgb3BlcmF0aW9uIHRvIHRoZSByZXN1bHQuCiAgLy8KCiAgaWYgKGIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgIHZhciBtb3Zlc0dyYXZleWFyZEVsZW1lbnQgPSBtb3ZlUmFuZ2Uuc3RhcnQuaXNFcXVhbChiLmdyYXZleWFyZFBvc2l0aW9uKSB8fCBtb3ZlUmFuZ2UuY29udGFpbnNQb3NpdGlvbihiLmdyYXZleWFyZFBvc2l0aW9uKTsKCiAgICBpZiAoYS5ob3dNYW55ID4gMSAmJiBtb3Zlc0dyYXZleWFyZEVsZW1lbnQgJiYgIWNvbnRleHQuYVdhc1VuZG9uZSkgewogICAgICByYW5nZXMucHVzaChSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYi5pbnNlcnRpb25Qb3NpdGlvbiwgMSkpOwogICAgfQogIH0KCiAgcmV0dXJuIF9tYWtlTW92ZU9wZXJhdGlvbnNGcm9tUmFuZ2VzKHJhbmdlcywgbmV3VGFyZ2V0UG9zaXRpb24pOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTW92ZU9wZXJhdGlvbiwgTWVyZ2VPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgdmFyIG1vdmVkUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYS5zb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55KTsKCiAgaWYgKGIuZGVsZXRpb25Qb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYS5zb3VyY2VQb3NpdGlvbikgJiYgbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKGIuc291cmNlUG9zaXRpb24pKSB7CiAgICBpZiAoYS50eXBlID09ICdyZW1vdmUnICYmICFjb250ZXh0LmZvcmNlV2Vha1JlbW92ZSkgewogICAgICAvLyBDYXNlIDE6CiAgICAgIC8vCiAgICAgIC8vIFRoZSBlbGVtZW50IHRvIHJlbW92ZSBnb3QgbWVyZ2VkLgogICAgICAvLwogICAgICAvLyBNZXJnZSBvcGVyYXRpb24gZG9lcyBzdXBwb3J0IG1lcmdpbmcgZWxlbWVudHMgd2hpY2ggYXJlIG5vdCBzaWJsaW5ncy4gU28gaXQgd291bGQgbm90IGJlIGEgcHJvYmxlbQogICAgICAvLyBmcm9tIHRlY2huaWNhbCBwb2ludCBvZiB2aWV3LiBIb3dldmVyLCBpZiB0aGUgZWxlbWVudCB3YXMgcmVtb3ZlZCwgdGhlIGludGVudGlvbiBvZiB0aGUgdXNlcgogICAgICAvLyBkZWxldGluZyBpdCB3YXMgdG8gaGF2ZSBpdCBhbGwgZGVsZXRlZC4gRnJvbSB1c2VyIGV4cGVyaWVuY2UgcG9pbnQgb2YgdmlldywgbW92aW5nIGJhY2sgdGhlCiAgICAgIC8vIHJlbW92ZWQgbm9kZXMgbWlnaHQgYmUgdW5leHBlY3RlZC4gVGhpcyBtZWFucyB0aGF0IGluIHRoaXMgc2NlbmFyaW8gd2Ugd2lsbCByZXZlcnNlIG1lcmdpbmcgYW5kIHJlbW92ZSB0aGUgZWxlbWVudC4KICAgICAgLy8KICAgICAgaWYgKCFjb250ZXh0LmFXYXNVbmRvbmUpIHsKICAgICAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgICAgIHZhciBneU1vdmVTb3VyY2UgPSBiLmdyYXZleWFyZFBvc2l0aW9uLmNsb25lKCk7CgogICAgICAgIHZhciBzcGxpdE5vZGVzTW92ZVNvdXJjZSA9IGIudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKCiAgICAgICAgaWYgKGEuaG93TWFueSA+IDEpIHsKICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgTW92ZU9wZXJhdGlvbihhLnNvdXJjZVBvc2l0aW9uLCBhLmhvd01hbnkgLSAxLCBhLnRhcmdldFBvc2l0aW9uLCAwKSk7CiAgICAgICAgICBneU1vdmVTb3VyY2UgPSBneU1vdmVTb3VyY2UuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKGEuc291cmNlUG9zaXRpb24sIGEudGFyZ2V0UG9zaXRpb24sIGEuaG93TWFueSAtIDEpOwogICAgICAgICAgc3BsaXROb2Rlc01vdmVTb3VyY2UgPSBzcGxpdE5vZGVzTW92ZVNvdXJjZS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoYS5zb3VyY2VQb3NpdGlvbiwgYS50YXJnZXRQb3NpdGlvbiwgYS5ob3dNYW55IC0gMSk7CiAgICAgICAgfQoKICAgICAgICB2YXIgZ3lNb3ZlVGFyZ2V0ID0gYi5kZWxldGlvblBvc2l0aW9uLl9nZXRDb21iaW5lZChhLnNvdXJjZVBvc2l0aW9uLCBhLnRhcmdldFBvc2l0aW9uKTsKCiAgICAgICAgdmFyIGd5TW92ZSA9IG5ldyBNb3ZlT3BlcmF0aW9uKGd5TW92ZVNvdXJjZSwgMSwgZ3lNb3ZlVGFyZ2V0LCAwKTsKICAgICAgICB2YXIgc3BsaXROb2Rlc01vdmVUYXJnZXRQYXRoID0gZ3lNb3ZlLmdldE1vdmVkUmFuZ2VTdGFydCgpLnBhdGguc2xpY2UoKTsKICAgICAgICBzcGxpdE5vZGVzTW92ZVRhcmdldFBhdGgucHVzaCgwKTsKICAgICAgICB2YXIgc3BsaXROb2Rlc01vdmVUYXJnZXQgPSBuZXcgUG9zaXRpb24oZ3lNb3ZlLnRhcmdldFBvc2l0aW9uLnJvb3QsIHNwbGl0Tm9kZXNNb3ZlVGFyZ2V0UGF0aCk7CiAgICAgICAgc3BsaXROb2Rlc01vdmVTb3VyY2UgPSBzcGxpdE5vZGVzTW92ZVNvdXJjZS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoZ3lNb3ZlU291cmNlLCBneU1vdmVUYXJnZXQsIDEpOwogICAgICAgIHZhciBzcGxpdE5vZGVzTW92ZSA9IG5ldyBNb3ZlT3BlcmF0aW9uKHNwbGl0Tm9kZXNNb3ZlU291cmNlLCBiLmhvd01hbnksIHNwbGl0Tm9kZXNNb3ZlVGFyZ2V0LCAwKTsKICAgICAgICByZXN1bHRzLnB1c2goZ3lNb3ZlKTsKICAgICAgICByZXN1bHRzLnB1c2goc3BsaXROb2Rlc01vdmUpOwogICAgICAgIHJldHVybiByZXN1bHRzOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICAvLyBDYXNlIDI6CiAgICAgIC8vCiAgICAgIC8vIFRoZSBlbGVtZW50IHRvIG1vdmUgZ290IG1lcmdlZCBhbmQgaXQgd2FzIHRoZSBvbmx5IGVsZW1lbnQgdG8gbW92ZS4KICAgICAgLy8gSW4gdGhpcyBjYXNlIGp1c3QgZG9uJ3QgZG8gYW55dGhpbmcsIGxlYXZlIHRoZSBub2RlIGluIHRoZSBncmF2ZXlhcmQuIFdpdGhvdXQgc3BlY2lhbCBjYXNlCiAgICAgIC8vIGl0IHdvdWxkIGJlIGEgbW92ZSBvcGVyYXRpb24gdGhhdCBtb3ZlcyAwIG5vZGVzLCBzbyBtYXliZSBpdCBpcyBiZXR0ZXIganVzdCB0byByZXR1cm4gbm8tb3AuCiAgICAgIC8vCiAgICAgIGlmIChhLmhvd01hbnkgPT0gMSkgewogICAgICAgIGlmICghY29udGV4dC5iV2FzVW5kb25lKSB7CiAgICAgICAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbigwKV07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGEuc291cmNlUG9zaXRpb24gPSBiLmdyYXZleWFyZFBvc2l0aW9uLmNsb25lKCk7CiAgICAgICAgICBhLnRhcmdldFBvc2l0aW9uID0gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogICAgICAgICAgcmV0dXJuIFthXTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIHZhciBtb3ZlUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYS5zb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55KTsKCiAgdmFyIHRyYW5zZm9ybWVkID0gbW92ZVJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CgogIGEuc291cmNlUG9zaXRpb24gPSB0cmFuc2Zvcm1lZC5zdGFydDsKICBhLmhvd01hbnkgPSB0cmFuc2Zvcm1lZC5lbmQub2Zmc2V0IC0gdHJhbnNmb3JtZWQuc3RhcnQub2Zmc2V0OwogIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgcmV0dXJuIFthXTsKfSk7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpzZXRUcmFuc2Zvcm1hdGlvbihSZW5hbWVPcGVyYXRpb24sIEluc2VydE9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIpIHsKICBhLnBvc2l0aW9uID0gYS5wb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oUmVuYW1lT3BlcmF0aW9uLCBNZXJnZU9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIpIHsKICAvLyBDYXNlIDE6CiAgLy8KICAvLyBFbGVtZW50IHRvIHJlbmFtZSBnb3QgbWVyZ2VkLCBzbyBpdCB3YXMgbW92ZWQgdG8gYGIuZ3JhdmV5YXJkUG9zaXRpb25gLgogIC8vCiAgaWYgKGEucG9zaXRpb24uaXNFcXVhbChiLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICBhLnBvc2l0aW9uID0gYi5ncmF2ZXlhcmRQb3NpdGlvbi5jbG9uZSgpOwogICAgYS5wb3NpdGlvbi5zdGlja2luZXNzID0gJ3RvTmV4dCc7CiAgICByZXR1cm4gW2FdOwogIH0KCiAgYS5wb3NpdGlvbiA9IGEucG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oUmVuYW1lT3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIGEucG9zaXRpb24gPSBhLnBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oUmVuYW1lT3BlcmF0aW9uLCBSZW5hbWVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgaWYgKGEucG9zaXRpb24uaXNFcXVhbChiLnBvc2l0aW9uKSkgewogICAgaWYgKGNvbnRleHQuYUlzU3Ryb25nKSB7CiAgICAgIGEub2xkTmFtZSA9IGIubmV3TmFtZTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihSZW5hbWVPcGVyYXRpb24sIFNwbGl0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIC8vIENhc2UgMToKICAvLwogIC8vIFRoZSBlbGVtZW50IHRvIHJlbmFtZSBoYXMgYmVlbiBzcGxpdC4gSW4gdGhpcyBjYXNlLCB0aGUgbmV3IGVsZW1lbnQgc2hvdWxkIGJlIGFsc28gcmVuYW1lZC4KICAvLwogIC8vIFVzZXIgZGVjaWRlcyB0byBjaGFuZ2UgdGhlIHBhcmFncmFwaCB0byBhIGxpc3QgaXRlbToKICAvLyA8cGFyYWdyYXBoPkZvb2JhcjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gSG93ZXZlciwgaW4gbWVhbnRpbWUsIHNwbGl0IGhhcHBlbnM6CiAgLy8gPHBhcmFncmFwaD5Gb288L3BhcmFncmFwaD48cGFyYWdyYXBoPmJhcjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gQXMgYSByZXN1bHQsIHJlbmFtZSBib3RoIGVsZW1lbnRzOgogIC8vIDxsaXN0SXRlbT5Gb288L2xpc3RJdGVtPjxsaXN0SXRlbT5iYXI8L2xpc3RJdGVtPgogIC8vCiAgdmFyIHJlbmFtZVBhdGggPSBhLnBvc2l0aW9uLnBhdGg7CiAgdmFyIHNwbGl0UGF0aCA9IGIuc3BsaXRQb3NpdGlvbi5nZXRQYXJlbnRQYXRoKCk7CgogIGlmIChjb21wYXJlQXJyYXlzKHJlbmFtZVBhdGgsIHNwbGl0UGF0aCkgPT0gJ3NhbWUnICYmICFiLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICB2YXIgZXh0cmFSZW5hbWUgPSBuZXcgUmVuYW1lT3BlcmF0aW9uKGEucG9zaXRpb24uZ2V0U2hpZnRlZEJ5KDEpLCBhLm9sZE5hbWUsIGEubmV3TmFtZSwgMCk7CiAgICByZXR1cm4gW2EsIGV4dHJhUmVuYW1lXTsKICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGEucG9zaXRpb24gPSBhLnBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgcmV0dXJuIFthXTsKfSk7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpzZXRUcmFuc2Zvcm1hdGlvbihSb290QXR0cmlidXRlT3BlcmF0aW9uLCBSb290QXR0cmlidXRlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIGlmIChhLnJvb3QgPT09IGIucm9vdCAmJiBhLmtleSA9PT0gYi5rZXkpIHsKICAgIGlmICghY29udGV4dC5hSXNTdHJvbmcgfHwgYS5uZXdWYWx1ZSA9PT0gYi5uZXdWYWx1ZSkgewogICAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbigwKV07CiAgICB9IGVsc2UgewogICAgICBhLm9sZFZhbHVlID0gYi5uZXdWYWx1ZTsKICAgIH0KICB9CgogIHJldHVybiBbYV07Cn0pOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKc2V0VHJhbnNmb3JtYXRpb24oU3BsaXRPcGVyYXRpb24sIEluc2VydE9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIpIHsKICAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCiAgaWYgKGEuc3BsaXRQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5wb3NpdGlvbikgJiYgYS5zcGxpdFBvc2l0aW9uLm9mZnNldCA8IGIucG9zaXRpb24ub2Zmc2V0KSB7CiAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogIH0KCiAgYS5zcGxpdFBvc2l0aW9uID0gYS5zcGxpdFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIGEuaW5zZXJ0aW9uUG9zaXRpb24gPSBhLmluc2VydGlvblBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihTcGxpdE9wZXJhdGlvbiwgTWVyZ2VPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gU3BsaXQgZWxlbWVudCBnb3QgbWVyZ2VkLiBJZiB0d28gZGlmZmVyZW50IGVsZW1lbnRzIHdlcmUgbWVyZ2VkLCBjbGllbnRzIHdpbGwgaGF2ZSBkaWZmZXJlbnQgY29udGVudC4KICAvLwogIC8vIEV4YW1wbGUuIE1lcmdlIGF0IGB7fWAsIHNwbGl0IGF0IGBbXWA6CiAgLy8gPGhlYWRpbmc+Rm9vPC9oZWFkaW5nPnt9PHBhcmFncmFwaD5CW11hcjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gT24gbWVyZ2Ugc2lkZSBpdCB3aWxsIGxvb2sgbGlrZSB0aGlzOgogIC8vIDxoZWFkaW5nPkZvb0JbXWFyPC9oZWFkaW5nPgogIC8vIDxoZWFkaW5nPkZvb0I8L2hlYWRpbmc+PGhlYWRpbmc+YXI8L2hlYWRpbmc+CiAgLy8KICAvLyBPbiBzcGxpdCBzaWRlIGl0IHdpbGwgbG9vayBsaWtlIHRoaXM6CiAgLy8gPGhlYWRpbmc+Rm9vPC9oZWFkaW5nPnt9PHBhcmFncmFwaD5CPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5hcjwvcGFyYWdyYXBoPgogIC8vIDxoZWFkaW5nPkZvb0I8L2hlYWRpbmc+PHBhcmFncmFwaD5hcjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gQ2xlYXJseSwgdGhlIHNlY29uZCBlbGVtZW50IGlzIGRpZmZlcmVudCBmb3IgYm90aCBjbGllbnRzLgogIC8vCiAgLy8gV2UgY291bGQgdXNlIHRoZSByZW1vdmVkIG1lcmdlIGVsZW1lbnQgZnJvbSBncmF2ZXlhcmQgYXMgYSBzcGxpdCBlbGVtZW50IGJ1dCB0aGVuIGNsaWVudHMgd291bGQgaGF2ZSBhIGRpZmZlcmVudAogIC8vIG1vZGVsIHN0YXRlIChpbiBncmF2ZXlhcmQpLCBiZWNhdXNlIHRoZSBzcGxpdCBzaWRlIGNsaWVudCB3b3VsZCBzdGlsbCBoYXZlIGFuIGVsZW1lbnQgaW4gZ3JhdmV5YXJkIChyZW1vdmVkIGJ5IG1lcmdlKS4KICAvLwogIC8vIFRvIG92ZXJjb21lIHRoaXMsIGluIGBTcGxpdE9wZXJhdGlvbmAgeCBgTWVyZ2VPcGVyYXRpb25gIHRyYW5zZm9ybWF0aW9uIHdlIHdpbGwgYWRkIGFkZGl0aW9uYWwgYFNwbGl0T3BlcmF0aW9uYAogIC8vIGluIHRoZSBncmF2ZXlhcmQsIHdoaWNoIHdpbGwgYWN0dWFsbHkgY2xvbmUgdGhlIG1lcmdlZC1hbmQtZGVsZXRlZCBlbGVtZW50LiBUaGVuLCB0aGF0IGNsb25lZCBlbGVtZW50IHdpbGwgYmUKICAvLyB1c2VkIGZvciBzcGxpdHRpbmcuIEV4YW1wbGUgYmVsb3cuCiAgLy8KICAvLyBPcmlnaW5hbCBzdGF0ZToKICAvLyA8aGVhZGluZz5Gb288L2hlYWRpbmc+e308cGFyYWdyYXBoPkJbXWFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBNZXJnZSBzaWRlIGNsaWVudDoKICAvLwogIC8vIEFmdGVyIG1lcmdlOgogIC8vIDxoZWFkaW5nPkZvb0JbXWFyPC9oZWFkaW5nPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXZleWFyZDogPHBhcmFncmFwaD48L3BhcmFncmFwaD4KICAvLwogIC8vIEV4dHJhIHNwbGl0OgogIC8vIDxoZWFkaW5nPkZvb0JbXWFyPC9oZWFkaW5nPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXZleWFyZDogPHBhcmFncmFwaD48L3BhcmFncmFwaD48cGFyYWdyYXBoPjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gVXNlIHRoZSAiY2xvbmVkIiBlbGVtZW50IGZyb20gZ3JhdmV5YXJkOgogIC8vIDxoZWFkaW5nPkZvb0I8L2hlYWRpbmc+PHBhcmFncmFwaD5hcjwvcGFyYWdyYXBoPiAgICAgICAgICAgIGdyYXZleWFyZDogPHBhcmFncmFwaD48L3BhcmFncmFwaD4KICAvLwogIC8vIFNwbGl0IHNpZGUgY2xpZW50OgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPGhlYWRpbmc+Rm9vPC9oZWFkaW5nPnt9PHBhcmFncmFwaD5CPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5hcjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gQWZ0ZXIgbWVyZ2U6CiAgLy8gPGhlYWRpbmc+Rm9vQjwvaGVhZGluZz48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+ICAgICAgICAgICAgZ3JhdmV5YXJkOiA8cGFyYWdyYXBoPjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gVGhpcyBzcGVjaWFsIGNhc2Ugc2NlbmFyaW8gb25seSBhcHBsaWVzIGlmIHRoZSBvcmlnaW5hbCBzcGxpdCBvcGVyYXRpb24gY2xvbmVzIHRoZSBzcGxpdCBlbGVtZW50LgogIC8vIElmIHRoZSBvcmlnaW5hbCBzcGxpdCBvcGVyYXRpb24gaGFzIGBncmF2ZXlhcmRQb3NpdGlvbmAgc2V0LCBpdCBhbGwgZG9lc24ndCBoYXZlIHNlbnNlIGJlY2F1c2Ugc3BsaXQgb3BlcmF0aW9uCiAgLy8ga25vd3MgZXhhY3RseSB3aGljaCBlbGVtZW50IGl0IHNob3VsZCB1c2UuIFNvIHRoZXJlIHdvdWxkIGJlIG5vIG9yaWdpbmFsIHByb2JsZW0gd2l0aCBkaWZmZXJlbnQgY29udGVudHMuCiAgLy8KICAvLyBBZGRpdGlvbmFsbHksIHRoZSBzcGVjaWFsIGNhc2UgYXBwbGllcyBvbmx5IGlmIHRoZSBtZXJnZSB3YXNuJ3QgYWxyZWFkeSB1bmRvbmUuCiAgLy8KICBpZiAoIWEuZ3JhdmV5YXJkUG9zaXRpb24gJiYgIWNvbnRleHQuYldhc1VuZG9uZSAmJiBhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIuc291cmNlUG9zaXRpb24pKSB7CiAgICB2YXIgc3BsaXRQYXRoID0gYi5ncmF2ZXlhcmRQb3NpdGlvbi5wYXRoLnNsaWNlKCk7CiAgICBzcGxpdFBhdGgucHVzaCgwKTsKICAgIHZhciBzcGxpdFBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGIuZ3JhdmV5YXJkUG9zaXRpb24ucm9vdCwgc3BsaXRQYXRoKTsKICAgIHZhciBpbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKG5ldyBQb3NpdGlvbihiLmdyYXZleWFyZFBvc2l0aW9uLnJvb3QsIHNwbGl0UGF0aCkpOwogICAgdmFyIGFkZGl0aW9uYWxTcGxpdCA9IG5ldyBTcGxpdE9wZXJhdGlvbihzcGxpdFBvc2l0aW9uLCAwLCBpbnNlcnRpb25Qb3NpdGlvbiwgbnVsbCwgMCk7CiAgICBhLnNwbGl0UG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICAgIGEuaW5zZXJ0aW9uUG9zaXRpb24gPSBTcGxpdE9wZXJhdGlvbi5nZXRJbnNlcnRpb25Qb3NpdGlvbihhLnNwbGl0UG9zaXRpb24pOwogICAgYS5ncmF2ZXlhcmRQb3NpdGlvbiA9IGFkZGl0aW9uYWxTcGxpdC5pbnNlcnRpb25Qb3NpdGlvbi5jbG9uZSgpOwogICAgYS5ncmF2ZXlhcmRQb3NpdGlvbi5zdGlja2luZXNzID0gJ3RvTmV4dCc7CiAgICByZXR1cm4gW2FkZGl0aW9uYWxTcGxpdCwgYV07CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLmRlbGV0aW9uUG9zaXRpb24pICYmICFhLnNwbGl0UG9zaXRpb24uaXNBZnRlcihiLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnktLTsKICB9CgogIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIudGFyZ2V0UG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogIH0KCiAgYS5zcGxpdFBvc2l0aW9uID0gYS5zcGxpdFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbik7CgogIGlmIChhLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKFNwbGl0T3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIHZhciByYW5nZVRvTW92ZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChiLnNvdXJjZVBvc2l0aW9uLCBiLmhvd01hbnkpOwoKICBpZiAoYS5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgLy8gQ2FzZSAxOgogICAgLy8KICAgIC8vIFNwbGl0IG9wZXJhdGlvbiBncmF2ZXlhcmQgbm9kZSB3YXMgbW92ZWQuIEluIHRoaXMgY2FzZSBtb3ZlIG9wZXJhdGlvbiBpcyBzdHJvbmdlci4gU2luY2UgZ3JhdmV5YXJkIGVsZW1lbnQKICAgIC8vIGlzIGFscmVhZHkgbW92ZWQgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb24sIHdlIG5lZWQgdG8gb25seSBtb3ZlIHRoZSBub2RlcyBhZnRlciB0aGUgc3BsaXQgcG9zaXRpb24uCiAgICAvLyBUaGlzIHdpbGwgYmUgZG9uZSBieSBgTW92ZU9wZXJhdGlvbmAgaW5zdGVhZCBvZiBgU3BsaXRPcGVyYXRpb25gLgogICAgLy8KICAgIHZhciBneUVsZW1lbnRNb3ZlZCA9IHJhbmdlVG9Nb3ZlLnN0YXJ0LmlzRXF1YWwoYS5ncmF2ZXlhcmRQb3NpdGlvbikgfHwgcmFuZ2VUb01vdmUuY29udGFpbnNQb3NpdGlvbihhLmdyYXZleWFyZFBvc2l0aW9uKTsKCiAgICBpZiAoIWNvbnRleHQuYldhc1VuZG9uZSAmJiBneUVsZW1lbnRNb3ZlZCkgewogICAgICB2YXIgc291cmNlUG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwoKICAgICAgdmFyIG5ld1BhcmVudFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CgogICAgICB2YXIgbmV3VGFyZ2V0UGF0aCA9IG5ld1BhcmVudFBvc2l0aW9uLnBhdGguc2xpY2UoKTsKICAgICAgbmV3VGFyZ2V0UGF0aC5wdXNoKDApOwogICAgICB2YXIgbmV3VGFyZ2V0UG9zaXRpb24gPSBuZXcgUG9zaXRpb24obmV3UGFyZW50UG9zaXRpb24ucm9vdCwgbmV3VGFyZ2V0UGF0aCk7CiAgICAgIHZhciBtb3ZlT3AgPSBuZXcgTW92ZU9wZXJhdGlvbihzb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55LCBuZXdUYXJnZXRQb3NpdGlvbiwgMCk7CiAgICAgIHJldHVybiBbbW92ZU9wXTsKICAgIH0KCiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CiAgfSAvLyBDYXNlIDI6CiAgLy8KICAvLyBTcGxpdCBpcyBhdCBhIHBvc2l0aW9uIHdoZXJlIG5vZGVzIHdlcmUgbW92ZWQuCiAgLy8KICAvLyBUaGlzIGlzIGEgc2NlbmFyaW8gZGVzY3JpYmVkIGluIGBNb3ZlT3BlcmF0aW9uYCB4IGBTcGxpdE9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24gYnV0IGZyb20gdGhlCiAgLy8gInNwbGl0IG9wZXJhdGlvbiBwb2ludCBvZiB2aWV3Ii4KICAvLwoKCiAgdmFyIHNwbGl0QXRUYXJnZXQgPSBhLnNwbGl0UG9zaXRpb24uaXNFcXVhbChiLnRhcmdldFBvc2l0aW9uKTsKCiAgaWYgKHNwbGl0QXRUYXJnZXQgJiYgKGNvbnRleHQuYmFSZWxhdGlvbiA9PSAnaW5zZXJ0QXRTb3VyY2UnIHx8IGNvbnRleHQuYWJSZWxhdGlvbiA9PSAnc3BsaXRCZWZvcmUnKSkgewogICAgYS5ob3dNYW55ICs9IGIuaG93TWFueTsKICAgIGEuc3BsaXRQb3NpdGlvbiA9IGEuc3BsaXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSk7CiAgICBhLmluc2VydGlvblBvc2l0aW9uID0gU3BsaXRPcGVyYXRpb24uZ2V0SW5zZXJ0aW9uUG9zaXRpb24oYS5zcGxpdFBvc2l0aW9uKTsKICAgIHJldHVybiBbYV07CiAgfQoKICBpZiAoc3BsaXRBdFRhcmdldCAmJiBjb250ZXh0LmFiUmVsYXRpb24gJiYgY29udGV4dC5hYlJlbGF0aW9uLmhvd01hbnkpIHsKICAgIHZhciBfY29udGV4dCRhYlJlbGF0aW9uID0gY29udGV4dC5hYlJlbGF0aW9uLAogICAgICAgIGhvd01hbnkgPSBfY29udGV4dCRhYlJlbGF0aW9uLmhvd01hbnksCiAgICAgICAgb2Zmc2V0ID0gX2NvbnRleHQkYWJSZWxhdGlvbi5vZmZzZXQ7CiAgICBhLmhvd01hbnkgKz0gaG93TWFueTsKICAgIGEuc3BsaXRQb3NpdGlvbiA9IGEuc3BsaXRQb3NpdGlvbi5nZXRTaGlmdGVkQnkob2Zmc2V0KTsKICAgIHJldHVybiBbYV07CiAgfSAvLyBDYXNlIDM6CiAgLy8KICAvLyBJZiB0aGUgc3BsaXQgcG9zaXRpb24gaXMgaW5zaWRlIHRoZSBtb3ZlZCByYW5nZSwgd2UgbmVlZCB0byBzaGlmdCB0aGUgc3BsaXQgcG9zaXRpb24gdG8gYSBwcm9wZXIgcGxhY2UuCiAgLy8gVGhlIHBvc2l0aW9uIGNhbm5vdCBiZSBtb3ZlZCB0b2dldGhlciB3aXRoIG1vdmVkIHJhbmdlIGJlY2F1c2UgdGhhdCB3b3VsZCByZXN1bHQgaW4gc3BsaXR0aW5nIG9mIGFuIGluY29ycmVjdCBlbGVtZW50LgogIC8vCiAgLy8gQ2hhcmFjdGVycyBgYmNgIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgc2Vjb25kIHBhcmFncmFwaCB3aGlsZSBzcGxpdCBwb3NpdGlvbiBpcyBiZXR3ZWVuIHRoZW06CiAgLy8gPHBhcmFncmFwaD5BW2J8Y11kPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5YeXo8L3BhcmFncmFwaD4KICAvLwogIC8vIEFmdGVyIG1vdmUsIG5ldyBzcGxpdCBwb3NpdGlvbiBpcyBpbmNvcnJlY3Q6CiAgLy8gPHBhcmFncmFwaD5BZDwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+WGJ8Y3l6PC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBDb3JyZWN0IHNwbGl0IHBvc2l0aW9uOgogIC8vIDxwYXJhZ3JhcGg+QXxkPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5YYmN5ejwvcGFyYWdyYXBoPgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPHBhcmFncmFwaD5BPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5kPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5YYmN5ejwvcGFyYWdyYXBoPgogIC8vCgoKICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnNvdXJjZVBvc2l0aW9uKSAmJiByYW5nZVRvTW92ZS5jb250YWluc1Bvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbikpIHsKICAgIHZhciBob3dNYW55UmVtb3ZlZCA9IGIuaG93TWFueSAtIChhLnNwbGl0UG9zaXRpb24ub2Zmc2V0IC0gYi5zb3VyY2VQb3NpdGlvbi5vZmZzZXQpOwogICAgYS5ob3dNYW55IC09IGhvd01hbnlSZW1vdmVkOwoKICAgIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIudGFyZ2V0UG9zaXRpb24pICYmIGEuc3BsaXRQb3NpdGlvbi5vZmZzZXQgPCBiLnRhcmdldFBvc2l0aW9uLm9mZnNldCkgewogICAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogICAgfQoKICAgIGEuc3BsaXRQb3NpdGlvbiA9IGIuc291cmNlUG9zaXRpb24uY2xvbmUoKTsKICAgIGEuaW5zZXJ0aW9uUG9zaXRpb24gPSBTcGxpdE9wZXJhdGlvbi5nZXRJbnNlcnRpb25Qb3NpdGlvbihhLnNwbGl0UG9zaXRpb24pOwogICAgcmV0dXJuIFthXTsKICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8gRG9uJ3QgY2hhbmdlIGBob3dNYW55YCBpZiBtb3ZlIG9wZXJhdGlvbiBkb2VzIG5vdCByZWFsbHkgbW92ZSBhbnl0aGluZy4KICAvLwoKCiAgaWYgKCFiLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwoYi50YXJnZXRQb3NpdGlvbikpIHsKICAgIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIuc291cmNlUG9zaXRpb24pICYmIGEuc3BsaXRQb3NpdGlvbi5vZmZzZXQgPD0gYi5zb3VyY2VQb3NpdGlvbi5vZmZzZXQpIHsKICAgICAgYS5ob3dNYW55IC09IGIuaG93TWFueTsKICAgIH0KCiAgICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnRhcmdldFBvc2l0aW9uKSAmJiBhLnNwbGl0UG9zaXRpb24ub2Zmc2V0IDwgYi50YXJnZXRQb3NpdGlvbi5vZmZzZXQpIHsKICAgICAgYS5ob3dNYW55ICs9IGIuaG93TWFueTsKICAgIH0KICB9IC8vIENoYW5nZSBwb3NpdGlvbiBzdGlja2luZXNzIHRvIGZvcmNlIGEgY29ycmVjdCB0cmFuc2Zvcm1hdGlvbi4KCgogIGEuc3BsaXRQb3NpdGlvbi5zdGlja2luZXNzID0gJ3RvTm9uZSc7CiAgYS5zcGxpdFBvc2l0aW9uID0gYS5zcGxpdFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKTsKICBhLnNwbGl0UG9zaXRpb24uc3RpY2tpbmVzcyA9ICd0b05leHQnOwoKICBpZiAoYS5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IGEuaW5zZXJ0aW9uUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwogIH0gZWxzZSB7CiAgICBhLmluc2VydGlvblBvc2l0aW9uID0gU3BsaXRPcGVyYXRpb24uZ2V0SW5zZXJ0aW9uUG9zaXRpb24oYS5zcGxpdFBvc2l0aW9uKTsKICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihTcGxpdE9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gU3BsaXQgYXQgdGhlIHNhbWUgcG9zaXRpb24uCiAgLy8KICAvLyBJZiB0aGVyZSBhbHJlYWR5IHdhcyBhIHNwbGl0IGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIGluIGBhYCBvcGVyYXRpb24sIGl0IG1lYW5zIHRoYXQgdGhlIGludGVudGlvbgogIC8vIGNvbnZleWVkIGJ5IGBhYCBvcGVyYXRpb24gaGFzIGFscmVhZHkgYmVlbiBmdWxmaWxsZWQgYW5kIGBhYCBzaG91bGQgbm90IGRvIGFueXRoaW5nICh0byBhdm9pZCBkb3VibGUgc3BsaXQpLgogIC8vCiAgLy8gSG93ZXZlciwgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGlmIHRoZXNlIGFyZSBuZXcgc3BsaXRzIG9yIHNwbGl0cyBjcmVhdGVkIGJ5IHVuZG8uIFRoZXNlIGhhdmUgZGlmZmVyZW50CiAgLy8gaW50ZW50aW9ucy4gQWxzbyBzcGxpdHMgbW92aW5nIGJhY2sgZGlmZmVyZW50IGVsZW1lbnRzIGZyb20gZ3JhdmV5YXJkIGhhdmUgZGlmZmVyZW50IGludGVudGlvbnMuIFRoZXkKICAvLyBhcmUganVzdCBkaWZmZXJlbnQgb3BlcmF0aW9ucy4KICAvLwogIC8vIFNvIHdlIGNhbmNlbCBzcGxpdCBvcGVyYXRpb24gb25seSBpZiBpdCB3YXMgcmVhbGx5IGlkZW50aWNhbC4KICAvLwogIC8vIEFsc28sIHRoZXJlIGlzIGFkZGl0aW9uYWwgY2FzZSwgd2hlcmUgc3BsaXQgb3BlcmF0aW9ucyBhcmVuJ3QgaWRlbnRpY2FsIGFuZCBzaG91bGQgbm90IGJlIGNhbmNlbGxlZCwgaG93ZXZlciB0aGUKICAvLyBkZWZhdWx0IHRyYW5zZm9ybWF0aW9uIGlzIGluY29ycmVjdCB0b28uCiAgLy8KICBpZiAoYS5zcGxpdFBvc2l0aW9uLmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSkgewogICAgaWYgKCFhLmdyYXZleWFyZFBvc2l0aW9uICYmICFiLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KCiAgICBpZiAoYS5ncmF2ZXlhcmRQb3NpdGlvbiAmJiBiLmdyYXZleWFyZFBvc2l0aW9uICYmIGEuZ3JhdmV5YXJkUG9zaXRpb24uaXNFcXVhbChiLmdyYXZleWFyZFBvc2l0aW9uKSkgewogICAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbigwKV07CiAgICB9IC8vIFVzZSBjb250ZXh0IHRvIGtub3cgdGhhdCB0aGUgYGEuc3BsaXRQb3NpdGlvbmAgc2hvdWxkIHN0YXkgd2hlcmUgaXQgaXMuCiAgICAvLyBUaGlzIGhhcHBlbnMgZHVyaW5nIHVuZG8gd2hlbiBmaXJzdCBhIG1lcmdlIG9wZXJhdGlvbiBtb3ZlZCBub2RlcyB0byBgYS5zcGxpdFBvc2l0aW9uYCBhbmQgbm93IGBiYCBvcGVyYXRpb24gdW5kb2VzIHRoYXQgbWVyZ2UuCgoKICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24gPT0gJ3NwbGl0QmVmb3JlJykgewogICAgICAvLyBTaW5jZSBzcGxpdCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgdGhlcmUgYXJlIG5vIG5vZGVzIGxlZnQgdG8gc3BsaXQuCiAgICAgIGEuaG93TWFueSA9IDA7IC8vIE5vdGU6IHRoZXJlIHdhcyBgaWYgKCBhLmdyYXZleWFyZFBvc2l0aW9uIClgIGhlcmUgYnV0IGl0IHdhcyB1bmNvdmVyZWQgaW4gdGVzdHMgYW5kIEkgY291bGRuJ3QgZmluZCBhbnkgc2NlbmFyaW9zIGZvciBub3cuCiAgICAgIC8vIFRoYXQgd291bGQgaGF2ZSB0byBiZSBhIGBTcGxpdE9wZXJhdGlvbmAgdGhhdCBkaWRuJ3QgY29tZSBmcm9tIHVuZG8gYnV0IGlzIHRyYW5zZm9ybWVkIGJ5IG9wZXJhdGlvbnMgdGhhdCB3ZXJlIHVuZG9uZS4KICAgICAgLy8gSXQgY291bGQgaGFwcGVuIGlmIGBjb250ZXh0YCBpcyBlbmFibGVkIGluIGNvbGxhYm9yYXRpb24uCgogICAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogICAgICByZXR1cm4gW2FdOwogICAgfQogIH0gLy8gQ2FzZSAyOgogIC8vCiAgLy8gU2FtZSBub2RlIGlzIHVzaW5nIHRvIHNwbGl0IGRpZmZlcmVudCBlbGVtZW50cy4gVGhpcyBoYXBwZW5zIGluIHVuZG8gd2hlbiBwcmV2aW91c2x5IHNhbWUgZWxlbWVudCB3YXMgbWVyZ2VkIHRvCiAgLy8gdHdvIGRpZmZlcmVudCBlbGVtZW50cy4gVGhpcyBpcyBkZXNjcmliZWQgaW4gYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uCiAgLy8KICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBmb2xsb3cgdGhlIHNhbWUgbG9naWMuIFdlIHdpbGwgYXNzdW1lIHRoYXQgYGluc2VydGlvblBvc2l0aW9uYCBpcyBzYW1lIGZvciBib3RoCiAgLy8gc3BsaXQgb3BlcmF0aW9ucy4gVGhpcyBtaWdodCBub3QgYWx3YXlzIGJlIHRydWUgYnV0IGluIHRoZSByZWFsIGNhc2VzIHRoYXQgd2VyZSBleHBlcmllbmNlZCBpdCB3YXMuIEFmdGVyIGFsbCwKICAvLyBpZiB0aGVzZSBzcGxpdHMgYXJlIHJldmVyc2VzIG9mIG1lcmdlIG9wZXJhdGlvbnMgdGhhdCB3ZXJlIG1lcmdpbmcgdGhlIHNhbWUgZWxlbWVudCwgdGhlbiB0aGUgYGluc2VydGlvblBvc2l0aW9uYAogIC8vIHNob3VsZCBiZSBzYW1lIGZvciBib3RoIG9mIHRob3NlIHNwbGl0cy4KICAvLwogIC8vIEFnYWluLCB3ZSB3aWxsIGRlY2lkZSB3aGljaCBvcGVyYXRpb24gaXMgc3Ryb25nZXIgYnkgY2hlY2tpbmcgaWYgc3BsaXQgaGFwcGVucyBpbiBncmF2ZXlhcmQgb3IgaW4gbm9uLWdyYXZleWFyZCByb290LgogIC8vCgoKICBpZiAoYS5ncmF2ZXlhcmRQb3NpdGlvbiAmJiBiLmdyYXZleWFyZFBvc2l0aW9uICYmIGEuZ3JhdmV5YXJkUG9zaXRpb24uaXNFcXVhbChiLmdyYXZleWFyZFBvc2l0aW9uKSkgewogICAgdmFyIGFJbkdyYXZleWFyZCA9IGEuc3BsaXRQb3NpdGlvbi5yb290LnJvb3ROYW1lID09ICckZ3JhdmV5YXJkJzsKICAgIHZhciBiSW5HcmF2ZXlhcmQgPSBiLnNwbGl0UG9zaXRpb24ucm9vdC5yb290TmFtZSA9PSAnJGdyYXZleWFyZCc7IC8vIElmIGBhSXNXZWFrYCBpdCBtZWFucyB0aGF0IGBhYCBwb2ludHMgdG8gZ3JhdmV5YXJkIHdoaWxlIGBiYCBkb2Vzbid0LiBEb24ndCBtb3ZlIG5vZGVzIHRoZW4uCgogICAgdmFyIGFJc1dlYWsgPSBhSW5HcmF2ZXlhcmQgJiYgIWJJbkdyYXZleWFyZDsgLy8gSWYgYGJJc1dlYWtgIGl0IG1lYW5zIHRoYXQgYGJgIHBvaW50cyB0byBncmF2ZXlhcmQgd2hpbGUgYGFgIGRvZXNuJ3QuIEZvcmNlIG1vdmluZyBub2RlcyB0aGVuLgoKICAgIHZhciBiSXNXZWFrID0gYkluR3JhdmV5YXJkICYmICFhSW5HcmF2ZXlhcmQ7IC8vIEZvcmNlIG1vdmUgaWYgYGJgIGlzIHdlYWsgb3IgbmVpdGhlciBvcGVyYXRpb24gaXMgd2VhayBidXQgYGFgIGlzIHN0cm9uZ2VyIHRocm91Z2ggYGNvbnRleHQuYUlzU3Ryb25nYC4KCiAgICB2YXIgZm9yY2VNb3ZlID0gYklzV2VhayB8fCAhYUlzV2VhayAmJiBjb250ZXh0LmFJc1N0cm9uZzsKCiAgICBpZiAoZm9yY2VNb3ZlKSB7CiAgICAgIHZhciByZXN1bHQgPSBbXTsgLy8gRmlyc3Qgd2UgbmVlZCB0byBtb3ZlIGFueSBub2RlcyBzcGxpdCBieSBgYmAgYmFjayB0byB3aGVyZSB0aGV5IHdlcmUuCiAgICAgIC8vIERvIGl0IG9ubHkgaWYgYGJgIGFjdHVhbGx5IG1vdmVkIHNvbWV0aGluZy4KCiAgICAgIGlmIChiLmhvd01hbnkpIHsKICAgICAgICByZXN1bHQucHVzaChuZXcgTW92ZU9wZXJhdGlvbihiLm1vdmVUYXJnZXRQb3NpdGlvbiwgYi5ob3dNYW55LCBiLnNwbGl0UG9zaXRpb24sIDApKTsKICAgICAgfSAvLyBUaGVuIHdlIG5lZWQgdG8gbW92ZSBub2RlcyBmcm9tIGBhYCBzcGxpdCBwb3NpdGlvbiB0byB0aGVpciBuZXcgZWxlbWVudC4KICAgICAgLy8gRG8gaXQgb25seSBpZiBgYWAgYWN0dWFsbHkgc2hvdWxkIG1vdmUgc29tZXRoaW5nLgoKCiAgICAgIGlmIChhLmhvd01hbnkpIHsKICAgICAgICByZXN1bHQucHVzaChuZXcgTW92ZU9wZXJhdGlvbihhLnNwbGl0UG9zaXRpb24sIGEuaG93TWFueSwgYS5tb3ZlVGFyZ2V0UG9zaXRpb24sIDApKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KICB9CgogIGlmIChhLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogIH0gLy8gQ2FzZSAzOgogIC8vCiAgLy8gUG9zaXRpb24gd2hlcmUgb3BlcmF0aW9uIGBiYCBpbnNlcnRlZCBhIG5ldyBub2RlIGFmdGVyIHNwbGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBvcGVyYXRpb24gYGFgIHNwbGl0IHBvc2l0aW9uLgogIC8vIEFzIGluIHNpbWlsYXIgY2FzZXMsIHRoZXJlIGlzIGFtYmlndWl0eSBpZiB0aGUgc3BsaXQgc2hvdWxkIGJlIGJlZm9yZSB0aGUgbmV3IG5vZGUgKGNyZWF0ZWQgYnkgYGJgKSBvciBhZnRlci4KICAvLwoKCiAgaWYgKGEuc3BsaXRQb3NpdGlvbi5pc0VxdWFsKGIuaW5zZXJ0aW9uUG9zaXRpb24pICYmIGNvbnRleHQuYWJSZWxhdGlvbiA9PSAnc3BsaXRCZWZvcmUnKSB7CiAgICBhLmhvd01hbnkrKzsKICAgIHJldHVybiBbYV07CiAgfSAvLyBDYXNlIDQ6CiAgLy8KICAvLyBUaGlzIGlzIGEgbWlycm9yIHRvIHRoZSBjYXNlIDIuIGFib3ZlLgogIC8vCgoKICBpZiAoYi5zcGxpdFBvc2l0aW9uLmlzRXF1YWwoYS5pbnNlcnRpb25Qb3NpdGlvbikgJiYgY29udGV4dC5iYVJlbGF0aW9uID09ICdzcGxpdEJlZm9yZScpIHsKICAgIHZhciBuZXdQb3NpdGlvblBhdGggPSBiLmluc2VydGlvblBvc2l0aW9uLnBhdGguc2xpY2UoKTsKICAgIG5ld1Bvc2l0aW9uUGF0aC5wdXNoKDApOwogICAgdmFyIG5ld1Bvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGIuaW5zZXJ0aW9uUG9zaXRpb24ucm9vdCwgbmV3UG9zaXRpb25QYXRoKTsKICAgIHZhciBtb3ZlT3AgPSBuZXcgTW92ZU9wZXJhdGlvbihhLmluc2VydGlvblBvc2l0aW9uLCAxLCBuZXdQb3NpdGlvbiwgMCk7CiAgICByZXR1cm4gW2EsIG1vdmVPcF07CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnNwbGl0UG9zaXRpb24pICYmIGEuc3BsaXRQb3NpdGlvbi5vZmZzZXQgPCBiLnNwbGl0UG9zaXRpb24ub2Zmc2V0KSB7CiAgICBhLmhvd01hbnkgLT0gYi5ob3dNYW55OwogIH0KCiAgYS5zcGxpdFBvc2l0aW9uID0gYS5zcGxpdFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbik7CiAgcmV0dXJuIFthXTsKfSk7IC8vIENoZWNrcyB3aGV0aGVyIGBNb3ZlT3BlcmF0aW9uYCBgdGFyZ2V0UG9zaXRpb25gIGlzIGluc2lkZSBhIG5vZGUgZnJvbSB0aGUgbW92ZWQgcmFuZ2Ugb2YgdGhlIG90aGVyIGBNb3ZlT3BlcmF0aW9uYC4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tb3Zlb3BlcmF0aW9ufk1vdmVPcGVyYXRpb259IGEKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tb3Zlb3BlcmF0aW9ufk1vdmVPcGVyYXRpb259IGIKLy8gQHJldHVybnMge0Jvb2xlYW59CgpmdW5jdGlvbiBfbW92ZVRhcmdldEludG9Nb3ZlZFJhbmdlKGEsIGIpIHsKICByZXR1cm4gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSkgPT09IG51bGw7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBgTW92ZU9wZXJhdGlvbmAgeCBgTW92ZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uIENvbnZlcnRzIGdpdmVuIHJhbmdlcyBhbmQgdGFyZ2V0IHBvc2l0aW9uIHRvCi8vIG1vdmUgb3BlcmF0aW9ucyBhbmQgcmV0dXJucyB0aGVtLgovLwovLyBSYW5nZXMgYW5kIHRhcmdldCBwb3NpdGlvbiB3aWxsIGJlIHRyYW5zZm9ybWVkIG9uLXRoZS1mbHkgd2hlbiBnZW5lcmF0aW5nIG9wZXJhdGlvbnMuCi8vCi8vIEdpdmVuIGByYW5nZXNgIHNob3VsZCBiZSBpbiB0aGUgb3JkZXIgb2YgaG93IHRoZXkgd2VyZSBpbiB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtZWQgb3BlcmF0aW9uLgovLwovLyBHaXZlbiBgdGFyZ2V0UG9zaXRpb25gIGlzIHRoZSB0YXJnZXQgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHJhbmdlIGZyb20gYHJhbmdlc2AuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSByYW5nZXMKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSB0YXJnZXRQb3NpdGlvbgovLyBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL21vdmVvcGVyYXRpb25+TW92ZU9wZXJhdGlvbj59CgoKZnVuY3Rpb24gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMocmFuZ2VzLCB0YXJnZXRQb3NpdGlvbikgewogIC8vIEF0IHRoaXMgbW9tZW50IHdlIGhhdmUgc29tZSByYW5nZXMgYW5kIGEgdGFyZ2V0IHBvc2l0aW9uLCB0byB3aGljaCB0aG9zZSByYW5nZXMgc2hvdWxkIGJlIG1vdmVkLgogIC8vIE9yZGVyIGluIGByYW5nZXNgIGFycmF5IGlzIHRoZSBnby10byBvcmRlciBvZiBhZnRlciB0cmFuc2Zvcm1hdGlvbi4KICAvLwogIC8vIFdlIGFyZSBhbG1vc3QgZG9uZS4gV2UgaGF2ZSBgcmFuZ2VzYCBhbmQgYHRhcmdldFBvc2l0aW9uYCB0byBtYWtlIG9wZXJhdGlvbnMgZnJvbS4KICAvLyBVbmZvcnR1bmF0ZWx5LCB0aG9zZSBvcGVyYXRpb25zIG1heSBhZmZlY3QgZWFjaCBvdGhlci4gUHJlY2lzZWx5LCBmaXJzdCBvcGVyYXRpb24gYWZ0ZXIgbW92ZQogIC8vIG1heSBhZmZlY3Qgc291cmNlIHJhbmdlIGFuZCB0YXJnZXQgcG9zaXRpb24gb2Ygc2Vjb25kIGFuZCB0aGlyZCBvcGVyYXRpb24uIFNhbWUgd2l0aCBzZWNvbmQKICAvLyBvcGVyYXRpb24gYWZmZWN0aW5nIHRoaXJkLgogIC8vCiAgLy8gV2UgbmVlZCB0byBmaXggdGhvc2Ugc291cmNlIHJhbmdlcyBhbmQgdGFyZ2V0IHBvc2l0aW9ucyBvbmNlIGFnYWluLCBiZWZvcmUgY29udmVydGluZyBgcmFuZ2VzYCB0byBvcGVyYXRpb25zLgogIHZhciBvcGVyYXRpb25zID0gW107IC8vIEtlZXAgaW4gbWluZCB0aGF0IG5vdGhpbmcgd2lsbCBiZSB0cmFuc2Zvcm1lZCBpZiB0aGVyZSBpcyBqdXN0IG9uZSByYW5nZSBpbiBgcmFuZ2VzYC4KCiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHsKICAgIC8vIENyZWF0ZSBuZXcgb3BlcmF0aW9uIG91dCBvZiBhIHJhbmdlIGFuZCB0YXJnZXQgcG9zaXRpb24uCiAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07CiAgICB2YXIgb3AgPSBuZXcgTW92ZU9wZXJhdGlvbihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLm9mZnNldCAtIHJhbmdlLnN0YXJ0Lm9mZnNldCwgdGFyZ2V0UG9zaXRpb24sIDApOwogICAgb3BlcmF0aW9ucy5wdXNoKG9wKTsgLy8gVHJhbnNmb3JtIG90aGVyIHJhbmdlcyBieSB0aGUgZ2VuZXJhdGVkIG9wZXJhdGlvbi4KCiAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspIHsKICAgICAgLy8gQWxsIHJhbmdlcyBpbiBgcmFuZ2VzYCBhcnJheSBzaG91bGQgYmU6CiAgICAgIC8vCiAgICAgIC8vICogbm9uLWludGVyc2VjdGluZyAodGhlc2UgYXJlIHBhcnQgb2Ygb3JpZ2luYWwgb3BlcmF0aW9uIHNvdXJjZSByYW5nZSksIGFuZAogICAgICAvLyAqIGB0YXJnZXRQb3NpdGlvbmAgZG9lcyBub3QgdGFyZ2V0IGludG8gdGhlbSAob3Bwb3NpdGUgd291bGQgbWVhbiB0aGF0IHRyYW5zZm9ybWVkIG9wZXJhdGlvbiB0YXJnZXRzICJpbnNpZGUgaXRzZWxmIikuCiAgICAgIC8vCiAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSAiY2xlYW4iIGFuZCBhbHdheXMgcmV0dXJuIG9uZSByZXN1bHQuCiAgICAgIHJhbmdlc1tqXSA9IHJhbmdlc1tqXS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUob3Auc291cmNlUG9zaXRpb24sIG9wLnRhcmdldFBvc2l0aW9uLCBvcC5ob3dNYW55KVswXTsKICAgIH0KCiAgICB0YXJnZXRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShvcC5zb3VyY2VQb3NpdGlvbiwgb3AudGFyZ2V0UG9zaXRpb24sIG9wLmhvd01hbnkpOwogIH0KCiAgcmV0dXJuIG9wZXJhdGlvbnM7Cn0="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js"],"names":["InsertOperation","AttributeOperation","RenameOperation","MarkerOperation","MoveOperation","RootAttributeOperation","MergeOperation","SplitOperation","NoOperation","Range","Position","compareArrays","transformations","Map","setTransformation","OperationA","OperationB","transformationFunction","aGroup","get","set","getTransformation","has","noUpdateTransformation","a","transform","b","context","constructor","clone","e","transformSets","operationsA","operationsB","options","slice","contextFactory","ContextFactory","document","useRelations","forceWeakRemove","setOriginalOperations","originalOperations","length","nextTransformIndex","WeakMap","op","data","nextBaseVersionA","baseVersion","nextBaseVersionB","originalOperationsACount","originalOperationsBCount","i","opA","indexB","opB","newOpsA","getContext","newOpsB","updateRelation","newOpA","splice","padWithNoOps","brokenOperationsACount","brokenOperationsBCount","updateBaseVersions","_history","history","_useRelations","_forceWeakRemove","_relations","operations","takeFrom","originalOperation","operation","targetPosition","isEqual","sourcePosition","movedRange","containsPosition","_setRelation","deletionPosition","isAfter","isBefore","splitPosition","range","_createFromPositionAndShift","howMany","hasSameParentAs","end","offset","start","markerRange","newRange","affectedLeft","affectedRight","containsRange","side","path","wasInLeftElement","wasStartBeforeMergedElement","wasEndBeforeMergedElement","wasInRightElement","aIsStrong","aWasUndone","_wasUndone","bWasUndone","abRelation","_getRelation","baRelation","originalOp","wasUndone","isUndoneOperation","origB","undoneB","getUndoneOperation","origA","relationsA","relation","push","key","getDifference","map","oldValue","newValue","common","getIntersection","position","_getTransformedByInsertion","shouldReceiveAttributes","result","r","_getComplementaryAttributeOperations","unshift","insertOperation","nodes","insertValue","getNode","getAttribute","getShiftedBy","ranges","graveyardPosition","_getTransformedByMergeOperation","isCollapsed","_breakRangeByMoveOperation","moveOp","moveRange","difference","diff","_getTransformedByDeletion","getMovedRangeStart","spread","_getTransformedByMove","insertionPosition","secondPart","moveTargetPosition","_getCombined","stickiness","_getTransformedBySplitOperation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","oldRange","name","_createFromRanges","aNewRange","_createAt","root","aToGraveyard","rootName","bToGraveyard","aIsWeak","bIsWeak","forceMove","removedRange","type","mergeInside","mergeSplittingElement","transformed","rangeA","rangeB","insertBefore","newTargetPosition","_moveTargetIntoMovedRange","getReversed","bTargetsToA","_makeMoveOperationsFromRanges","aTargetsToB","aCompB","getParentPath","shouldSpread","newRanges","rightRange","movesGraveyardElement","results","gyMoveSource","splitNodesMoveSource","gyMoveTarget","gyMove","splitNodesMoveTargetPath","splitNodesMoveTarget","splitNodesMove","oldName","newName","renamePath","splitPath","extraRename","getInsertionPosition","additionalSplit","rangeToMove","gyElementMoved","newParentPosition","newTargetPath","splitAtTarget","howManyRemoved","aInGraveyard","bInGraveyard","newPositionPath","newPosition","j"],"mappings":"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,EAAXA,WAAf;AAA4BS,MAAAA,kBAAkB,EAAlBA;AAA5B,KAAP;AACA,GAfiE,CAgBlE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA,MAAME,kBAAkB,GAAG,IAAIC,OAAJ,EAA3B,CAnJkE,CAqJlE;;AArJkE,6CAsJhDb,WAtJgD;AAAA;;AAAA;AAsJlE,wDAAgC;AAAA,UAApBc,EAAoB;AAC/BF,MAAAA,kBAAkB,CAACxB,GAAnB,CAAwB0B,EAAxB,EAA4B,CAA5B;AACA,KAxJiE,CA0JlE;;AA1JkE;AAAA;AAAA;AAAA;AAAA;;AA2JlE,MAAMC,IAAI,GAAG;AACZC,IAAAA,gBAAgB,EAAEhB,WAAW,CAAEA,WAAW,CAACW,MAAZ,GAAqB,CAAvB,CAAX,CAAsCM,WAAtC,GAAoD,CAD1D;AAEZC,IAAAA,gBAAgB,EAAEjB,WAAW,CAAEA,WAAW,CAACU,MAAZ,GAAqB,CAAvB,CAAX,CAAsCM,WAAtC,GAAoD,CAF1D;AAGZE,IAAAA,wBAAwB,EAAEnB,WAAW,CAACW,MAH1B;A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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport InsertOperation from './insertoperation';\nimport AttributeOperation from './attributeoperation';\nimport RenameOperation from './renameoperation';\nimport MarkerOperation from './markeroperation';\nimport MoveOperation from './moveoperation';\nimport RootAttributeOperation from './rootattributeoperation';\nimport MergeOperation from './mergeoperation';\nimport SplitOperation from './splitoperation';\nimport NoOperation from './nooperation';\nimport Range from '../range';\nimport Position from '../position';\n\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\nconst transformations = new Map();\n\n/**\n * @module engine/model/operation/transform\n */\n\n/**\n * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.\n *\n * The `transformationFunction` is passed three parameters:\n *\n * * `a` - operation to be transformed, an instance of `OperationA`,\n * * `b` - operation to be transformed by, an instance of `OperationB`,\n * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about\n * transformation context.\n *\n * The `transformationFunction` should return transformation result, which is an array with one or multiple\n * {@link module:engine/model/operation/operation~Operation operation} instances.\n *\n * @protected\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @param {Function} transformationFunction Function to use for transforming.\n */\nfunction setTransformation( OperationA, OperationB, transformationFunction ) {\n\tlet aGroup = transformations.get( OperationA );\n\n\tif ( !aGroup ) {\n\t\taGroup = new Map();\n\t\ttransformations.set( OperationA, aGroup );\n\t}\n\n\taGroup.set( OperationB, transformationFunction );\n}\n\n/**\n * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.\n *\n * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}\n * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed\n * by the `OperationB` instance.\n *\n * @private\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.\n */\nfunction getTransformation( OperationA, OperationB ) {\n\tconst aGroup = transformations.get( OperationA );\n\n\tif ( aGroup && aGroup.has( OperationB ) ) {\n\t\treturn aGroup.get( OperationB );\n\t}\n\n\treturn noUpdateTransformation;\n}\n\n/**\n * A transformation function that only clones operation to transform, without changing it.\n *\n * @private\n * @param {module:engine/model/operation/operation~Operation} a Operation to transform.\n * @returns {Array.<module:engine/model/operation/operation~Operation>}\n */\nfunction noUpdateTransformation( a ) {\n\treturn [ a ];\n}\n\n/**\n * Transforms operation `a` by operation `b`.\n *\n * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/operation/transform~TransformationContext} context Transformation context for this transformation.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.\n */\nexport function transform( a, b, context = {} ) {\n\tconst transformationFunction = getTransformation( a.constructor, b.constructor );\n\n\t/* eslint-disable no-useless-catch */\n\ttry {\n\t\ta = a.clone();\n\n\t\treturn transformationFunction( a, b, context );\n\t} catch ( e ) {\n\t\t// @if CK_DEBUG // console.warn( 'Error during operation transformation!', e.message );\n\t\t// @if CK_DEBUG // console.warn( 'Transformed operation', a );\n\t\t// @if CK_DEBUG // console.warn( 'Operation transformed by', b );\n\t\t// @if CK_DEBUG // console.warn( 'context.aIsStrong', context.aIsStrong );\n\t\t// @if CK_DEBUG // console.warn( 'context.aWasUndone', context.aWasUndone );\n\t\t// @if CK_DEBUG // console.warn( 'context.bWasUndone', context.bWasUndone );\n\t\t// @if CK_DEBUG // console.warn( 'context.abRelation', context.abRelation );\n\t\t// @if CK_DEBUG // console.warn( 'context.baRelation', context.baRelation );\n\n\t\tthrow e;\n\t}\n\t/* eslint-enable no-useless-catch */\n}\n\n/**\n * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -\n * both transformed `operationsA` and transformed `operationsB` are returned.\n *\n * Note, that the first operation in each set should base on the same document state (\n * {@link module:engine/model/document~Document#version document version}).\n *\n * It is assumed that `operationsA` are \"more important\" during conflict resolution between two operations.\n *\n * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.\n *\n * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`\n * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:\n *\n * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),\n * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).\n *\n * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:\n *\n * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,\n * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.\n *\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB\n * @param {Object} options Additional transformation options.\n * @param {module:engine/model/document~Document|null} options.document Document which the operations change.\n * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for\n * better conflict resolution).\n * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s\n * should be added to the transformation results to force the same last base version for both transformed sets (in case\n * if some operations got broken into multiple operations during transformation).\n * @returns {Object} Transformation result.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.\n * @returns {Map} return.originalOperations A map that links transformed operations to original operations. The keys are the transformed\n * operations and the values are the original operations from the input (`operationsA` and `operationsB`).\n */\nexport function transformSets( operationsA, operationsB, options ) {\n\t// Create new arrays so the originally passed arguments are not changed.\n\t// No need to clone operations, they are cloned as they are transformed.\n\toperationsA = operationsA.slice();\n\toperationsB = operationsB.slice();\n\n\tconst contextFactory = new ContextFactory( options.document, options.useRelations, options.forceWeakRemove );\n\tcontextFactory.setOriginalOperations( operationsA );\n\tcontextFactory.setOriginalOperations( operationsB );\n\n\tconst originalOperations = contextFactory.originalOperations;\n\n\t// If one of sets is empty there is simply nothing to transform, so return sets as they are.\n\tif ( operationsA.length == 0 || operationsB.length == 0 ) {\n\t\treturn { operationsA, operationsB, originalOperations };\n\t}\n\t//\n\t// Following is a description of transformation process:\n\t//\n\t// There are `operationsA` and `operationsB` to be transformed, both by both.\n\t//\n\t// So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.\n\t//\n\t// Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on\n\t// the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`\n\t// is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.\n\t//\n\t// However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that\n\t// we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.\n\t// All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.\n\t//\n\t// The transformation process can be visualized on a transformation diagram (\"diamond diagram\"):\n\t//\n\t//          [the initial state]\n\t//         [common for a1 and b1]\n\t//\n\t//                   *\n\t//                  / \\\n\t//                 /   \\\n\t//               b1     a1\n\t//               /       \\\n\t//              /         \\\n\t//             *           *\n\t//            / \\         / \\\n\t//           /   \\       /   \\\n\t//         b2    a1'   b1'    a2\n\t//         /       \\   /       \\\n\t//        /         \\ /         \\\n\t//       *           *           *\n\t//        \\         / \\         /\n\t//         \\       /   \\       /\n\t//        a1''   b2'   a2'   b1''\n\t//           \\   /       \\   /\n\t//            \\ /         \\ /\n\t//             *           *\n\t//              \\         /\n\t//               \\       /\n\t//              a2''   b2''\n\t//                 \\   /\n\t//                  \\ /\n\t//                   *\n\t//\n\t//           [the final state]\n\t//\n\t// The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by\n\t// applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is\n\t// transformed.\n\t//\n\t// Another thing to consider is that an operation during transformation can be broken into multiple operations.\n\t// Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).\n\t//\n\t// In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`\n\t// (in our case it is just `b2`). At this point, `b1` is transformed by \"whole\" `a1`, while `b2` is only transformed\n\t// by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`\n\t// from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, \"the whole\" `a1` is transformed\n\t// by `operationsB`, while all `operationsB` are transformed by \"the whole\" `a1`. This means that we can continue with\n\t// following `operationsA` (in our case it is just `a2`).\n\t//\n\t// Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,\n\t// the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will\n\t// be transformed by both of them.\n\t//\n\t//                       *\n\t//                      / \\\n\t//                     /   \\\n\t//                    /     \\\n\t//                  b1       a1\n\t//                  /         \\\n\t//                 /           \\\n\t//                /             \\\n\t//               *               *\n\t//              / \\             / \\\n\t//             /  a11'         /   \\\n\t//            /     \\         /     \\\n\t//          b2       *      b1'      a2\n\t//          /       / \\     /         \\\n\t//         /       /  a12' /           \\\n\t//        /       /     \\ /             \\\n\t//       *       b2'     *               *\n\t//        \\     /       / \\             /\n\t//       a11'' /     b21'' \\           /\n\t//          \\ /       /     \\         /\n\t//           *       *      a2'     b1''\n\t//            \\     / \\       \\     /\n\t//          a12'' b22''\\       \\   /\n\t//              \\ /     \\       \\ /\n\t//               *      a2''     *\n\t//                \\       \\     /\n\t//                 \\       \\  b21'''\n\t//                  \\       \\ /\n\t//                a2'''      *\n\t//                    \\     /\n\t//                     \\  b22'''\n\t//                      \\ /\n\t//                       *\n\t//\n\t// Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.\n\t//\n\t// Having all that on mind, here is an outline for the transformation process algorithm:\n\t//\n\t// 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.\n\t//\n\t// 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.\n\t// All original `operationsA` are set to be transformed starting from the first operation `b`.\n\t//\n\t// 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`\n\t// by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations\n\t// with the transformation results.\n\t//\n\t// 4. If operation is broken into multiple operations, we save all the new operations in the place of the\n\t// original operation.\n\t//\n\t// 5. Additionally, if operation `a` was broken, for the \"new\" operation, we remember from which operation `b` it should\n\t// be transformed by.\n\t//\n\t// 6. We continue transforming \"current\" operation `a` until it is transformed by all `operationsB`. Then, go to 2.\n\t// unless the last operation `a` was transformed.\n\t//\n\t// The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.\n\t// The difference is that we have \"current\" `a` operation to transform and we store the index of the next `b` operation\n\t// to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and\n\t// index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop\n\t// operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change\n\t// current `a` operation index to the next one.\n\t//\n\n\t// For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.\n\tconst nextTransformIndex = new WeakMap();\n\n\t// For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.\n\tfor ( const op of operationsA ) {\n\t\tnextTransformIndex.set( op, 0 );\n\t}\n\n\t// Additional data that is used for some postprocessing after the main transformation process is done.\n\tconst data = {\n\t\tnextBaseVersionA: operationsA[ operationsA.length - 1 ].baseVersion + 1,\n\t\tnextBaseVersionB: operationsB[ operationsB.length - 1 ].baseVersion + 1,\n\t\toriginalOperationsACount: operationsA.length,\n\t\toriginalOperationsBCount: operationsB.length\n\t};\n\n\t// Index of currently transformed operation `a`.\n\tlet i = 0;\n\n\t// While not all `operationsA` are transformed...\n\twhile ( i < operationsA.length ) {\n\t\t// Get \"current\" operation `a`.\n\t\tconst opA = operationsA[ i ];\n\n\t\t// For the \"current\" operation `a`, get the index of the next operation `b` to transform by.\n\t\tconst indexB = nextTransformIndex.get( opA );\n\n\t\t// If operation `a` was already transformed by every operation `b`, change \"current\" operation `a` to the next one.\n\t\tif ( indexB == operationsB.length ) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst opB = operationsB[ indexB ];\n\n\t\t// Transform `a` by `b` and `b` by `a`.\n\t\tconst newOpsA = transform( opA, opB, contextFactory.getContext( opA, opB, true ) );\n\t\tconst newOpsB = transform( opB, opA, contextFactory.getContext( opB, opA, false ) );\n\t\t// As a result we get one or more `newOpsA` and one or more `newOpsB` operations.\n\n\t\t// Update contextual information about operations.\n\t\tcontextFactory.updateRelation( opA, opB );\n\n\t\tcontextFactory.setOriginalOperations( newOpsA, opA );\n\t\tcontextFactory.setOriginalOperations( newOpsB, opB );\n\n\t\t// For new `a` operations, update their index of the next operation `b` to transform them by.\n\t\t//\n\t\t// This is needed even if there was only one result (`a` was not broken) because that information is used\n\t\t// at the beginning of this loop every time.\n\t\tfor ( const newOpA of newOpsA ) {\n\t\t\t// Acknowledge, that operation `b` also might be broken into multiple operations.\n\t\t\t//\n\t\t\t// This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be\n\t\t\t// spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't\n\t\t\t// be transformed by the same operation (part of it) again.\n\t\t\tnextTransformIndex.set( newOpA, indexB + newOpsB.length );\n\t\t}\n\n\t\t// Update `operationsA` and `operationsB` with the transformed versions.\n\t\toperationsA.splice( i, 1, ...newOpsA );\n\t\toperationsB.splice( indexB, 1, ...newOpsB );\n\t}\n\n\tif ( options.padWithNoOps ) {\n\t\t// If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.\n\t\tconst brokenOperationsACount = operationsA.length - data.originalOperationsACount;\n\t\tconst brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;\n\n\t\t// Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so\n\t\t// that the base versions are equalled.\n\t\t//\n\t\t// Note that only one array will be updated, as only one of those subtractions can be greater than zero.\n\t\tpadWithNoOps( operationsA, brokenOperationsBCount - brokenOperationsACount );\n\t\tpadWithNoOps( operationsB, brokenOperationsACount - brokenOperationsBCount );\n\t}\n\n\t// Finally, update base versions of transformed operations.\n\tupdateBaseVersions( operationsA, data.nextBaseVersionB );\n\tupdateBaseVersions( operationsB, data.nextBaseVersionA );\n\n\treturn { operationsA, operationsB, originalOperations };\n}\n\n// Gathers additional data about operations processed during transformation. Can be used to obtain contextual information\n// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.\nclass ContextFactory {\n\t// Creates `ContextFactory` instance.\n\t//\n\t// @param {module:engine/model/document~Document} document Document which the operations change.\n\t// @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for\n\t// better conflict resolution).\n\t// @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,\n\t// so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n\tconstructor( document, useRelations, forceWeakRemove = false ) {\n\t\t// For each operation that is created during transformation process, we keep a reference to the original operation\n\t\t// which it comes from. The original operation works as a kind of \"identifier\". Every contextual information\n\t\t// gathered during transformation that we want to save for given operation, is actually saved for the original operation.\n\t\t// This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously\n\t\t// gathered data through original operation reference.\n\t\tthis.originalOperations = new Map();\n\n\t\t// `model.History` instance which information about undone operations will be taken from.\n\t\tthis._history = document.history;\n\n\t\t// Whether additional context should be used.\n\t\tthis._useRelations = useRelations;\n\n\t\tthis._forceWeakRemove = !!forceWeakRemove;\n\n\t\t// Relations is a double-map structure (maps in map) where for two operations we store how those operations were related\n\t\t// to each other. Those relations are evaluated during transformation process. For every transformated pair of operations\n\t\t// we keep relations between them.\n\t\tthis._relations = new Map();\n\t}\n\n\t// Sets \"original operation\" for given operations.\n\t//\n\t// During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two\n\t// or multiple operations. When gathering additional data it is important that all operations can be somehow linked\n\t// so a cloned and transformed \"version\" still kept track of the data assigned earlier to it.\n\t//\n\t// The original operation object will be used as such an universal linking id. Throughout the transformation process\n\t// all cloned operations will refer to \"the original operation\" when storing and reading additional data.\n\t//\n\t// If `takeFrom` is not set, each operation from `operations` array will be assigned itself as \"the original operation\".\n\t// This should be used as an initialization step.\n\t//\n\t// If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned\n\t// for `takeFrom` operation. This should be used to update original operations. It should be used in a way that\n\t// `operations` are the result of `takeFrom` transformation to ensure proper \"original operation propagation\".\n\t//\n\t// @param {Array.<module:engine/model/operation/operation~Operation>} operations\n\t// @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]\n\tsetOriginalOperations( operations, takeFrom = null ) {\n\t\tconst originalOperation = takeFrom ? this.originalOperations.get( takeFrom ) : null;\n\n\t\tfor ( const operation of operations ) {\n\t\t\tthis.originalOperations.set( operation, originalOperation || operation );\n\t\t}\n\t}\n\n\t// Saves a relation between operations `opA` and `opB`.\n\t//\n\t// Relations are then later used to help solve conflicts when operations are transformed.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\tupdateRelation( opA, opB ) {\n\t\t// The use of relations is described in a bigger detail in transformation functions.\n\t\t//\n\t\t// In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.\n\t\t// Then those relations are saved. For example, for two move operations, it is saved if one of those operations target\n\t\t// position is before the other operation source position. This kind of information gives contextual information when\n\t\t// transformation is used during undo. Similar checks are done for other pairs of operations.\n\t\t//\n\t\tswitch ( opA.constructor ) {\n\t\t\tcase MoveOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( opA.targetPosition.isEqual( opB.sourcePosition ) || opB.movedRange.containsPosition( opA.targetPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertAtSource' );\n\t\t\t\t\t\t} else if ( opA.targetPosition.isEqual( opB.deletionPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertBetween' );\n\t\t\t\t\t\t} else if ( opA.targetPosition.isAfter( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'moveTargetAfter' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tif ( opA.targetPosition.isEqual( opB.sourcePosition ) || opA.targetPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertBefore' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertAfter' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase SplitOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( opA.splitPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitBefore' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tif ( opA.splitPosition.isEqual( opB.sourcePosition ) || opA.splitPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitBefore' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst range = Range._createFromPositionAndShift( opB.sourcePosition, opB.howMany );\n\n\t\t\t\t\t\t\tif ( opA.splitPosition.hasSameParentAs( opB.sourcePosition ) && range.containsPosition( opA.splitPosition ) ) {\n\t\t\t\t\t\t\t\tconst howMany = range.end.offset - opA.splitPosition.offset;\n\t\t\t\t\t\t\t\tconst offset = opA.splitPosition.offset - range.start.offset;\n\n\t\t\t\t\t\t\t\tthis._setRelation( opA, opB, { howMany, offset } );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MergeOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( !opA.targetPosition.isEqual( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeTargetNotMoved' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.targetPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeSourceNotMoved' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeSameElement' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase SplitOperation: {\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.splitPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitAtSource' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MarkerOperation: {\n\t\t\t\tconst markerRange = opA.newRange;\n\n\t\t\t\tif ( !markerRange ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tconst movedRange = Range._createFromPositionAndShift( opB.sourcePosition, opB.howMany );\n\n\t\t\t\t\t\tconst affectedLeft = movedRange.containsPosition( markerRange.start ) ||\n\t\t\t\t\t\t\tmovedRange.start.isEqual( markerRange.start );\n\n\t\t\t\t\t\tconst affectedRight = movedRange.containsPosition( markerRange.end ) ||\n\t\t\t\t\t\t\tmovedRange.end.isEqual( markerRange.end );\n\n\t\t\t\t\t\tif ( ( affectedLeft || affectedRight ) && !movedRange.containsRange( markerRange ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, {\n\t\t\t\t\t\t\t\tside: affectedLeft ? 'left' : 'right',\n\t\t\t\t\t\t\t\tpath: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tconst wasInLeftElement = markerRange.start.isEqual( opB.targetPosition );\n\t\t\t\t\t\tconst wasStartBeforeMergedElement = markerRange.start.isEqual( opB.deletionPosition );\n\t\t\t\t\t\tconst wasEndBeforeMergedElement = markerRange.end.isEqual( opB.deletionPosition );\n\t\t\t\t\t\tconst wasInRightElement = markerRange.end.isEqual( opB.sourcePosition );\n\n\t\t\t\t\t\tif ( wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, {\n\t\t\t\t\t\t\t\twasInLeftElement,\n\t\t\t\t\t\t\t\twasStartBeforeMergedElement,\n\t\t\t\t\t\t\t\twasEndBeforeMergedElement,\n\t\t\t\t\t\t\t\twasInRightElement\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @returns {module:engine/model/operation/transform~TransformationContext}\n\tgetContext( opA, opB, aIsStrong ) {\n\t\treturn {\n\t\t\taIsStrong,\n\t\t\taWasUndone: this._wasUndone( opA ),\n\t\t\tbWasUndone: this._wasUndone( opB ),\n\t\t\tabRelation: this._useRelations ? this._getRelation( opA, opB ) : null,\n\t\t\tbaRelation: this._useRelations ? this._getRelation( opB, opA ) : null,\n\t\t\tforceWeakRemove: this._forceWeakRemove\n\t\t};\n\t}\n\n\t// Returns whether given operation `op` has already been undone.\n\t//\n\t// Information whether an operation was undone gives more context when making a decision when two operations are in conflict.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} op\n\t// @returns {Boolean}\n\t_wasUndone( op ) {\n\t\t// For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another\n\t\t// operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins\n\t\t// from which was undone. So get that original operation.\n\t\tconst originalOp = this.originalOperations.get( op );\n\n\t\t// And check with the document if the original operation was undone.\n\t\treturn originalOp.wasUndone || this._history.isUndoneOperation( originalOp );\n\t}\n\n\t// Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation\n\t// was set earlier or `null` if there was no relation between those operations.\n\t//\n\t// This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.\n\t//\n\t// When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the\n\t// undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,\n\t// we look forward in the future and ask if in that future `opB` was undone.\n\t//\n\t// Relations is a backward process to `wasUndone()`.\n\t//\n\t// Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing\n\t// operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is\n\t// a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation\n\t// between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make\n\t// a better decision when resolving a conflict between two operations, because we know more about the context of\n\t// those two operations.\n\t//\n\t// This is why this function does not return a relation directly between `opA` and `opB` because we need to look\n\t// back to search for a meaningful contextual information.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @returns {String|null}\n\t_getRelation( opA, opB ) {\n\t\t// Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.\n\t\tconst origB = this.originalOperations.get( opB );\n\t\tconst undoneB = this._history.getUndoneOperation( origB );\n\n\t\t// If `opB` is not undoing any operation, there is no relation.\n\t\tif ( !undoneB ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst origA = this.originalOperations.get( opA );\n\t\tconst relationsA = this._relations.get( origA );\n\n\t\t// Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.\n\t\tif ( relationsA ) {\n\t\t\treturn relationsA.get( undoneB ) || null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Helper function for `ContextFactory#updateRelations`.\n\t//\n\t// @private\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @param {String} relation\n\t_setRelation( opA, opB, relation ) {\n\t\t// As always, setting is for original operations, not the clones/transformed operations.\n\t\tconst origA = this.originalOperations.get( opA );\n\t\tconst origB = this.originalOperations.get( opB );\n\n\t\tlet relationsA = this._relations.get( origA );\n\n\t\tif ( !relationsA ) {\n\t\t\trelationsA = new Map();\n\t\t\tthis._relations.set( origA, relationsA );\n\t\t}\n\n\t\trelationsA.set( origB, relation );\n\t}\n}\n\n/**\n * Holds additional contextual information about a transformed pair of operations (`a` and `b`). Those information\n * can be used for better conflict resolving.\n *\n * @typedef {Object} module:engine/model/operation/transform~TransformationContext\n *\n * @property {Boolean} aIsStrong Whether `a` is strong operation in this transformation, or weak.\n * @property {Boolean} aWasUndone Whether `a` operation was undone.\n * @property {Boolean} bWasUndone Whether `b` operation was undone.\n * @property {String|null} abRelation The relation between `a` operation and an operation undone by `b` operation.\n * @property {String|null} baRelation The relation between `b` operation and an operation undone by `a` operation.\n */\n\n/**\n * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}\n * of passed operations.\n *\n * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for\n * each following operation in `operations`.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.\n * @param {Number} baseVersion Base version to set for the first operation in `operations`.\n */\nfunction updateBaseVersions( operations, baseVersion ) {\n\tfor ( const operation of operations ) {\n\t\toperation.baseVersion = baseVersion++;\n\t}\n}\n\n/**\n * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations\n * @param {Number} howMany\n */\nfunction padWithNoOps( operations, howMany ) {\n\tfor ( let i = 0; i < howMany; i++ ) {\n\t\toperations.push( new NoOperation( 0 ) );\n\t}\n}\n\n// -----------------------\n\nsetTransformation( AttributeOperation, AttributeOperation, ( a, b, context ) => {\n\t// If operations in conflict, check if their ranges intersect and manage them properly.\n\t//\n\t// Operations can be in conflict only if:\n\t//\n\t// * their key is the same (they change the same attribute), and\n\t// * they are in the same parent (operations for ranges [ 1 ] - [ 3 ] and [ 2, 0 ] - [ 2, 5 ] change different\n\t// elements and can't be in conflict).\n\tif ( a.key === b.key && a.range.start.hasSameParentAs( b.range.start ) ) {\n\t\t// First, we want to apply change to the part of a range that has not been changed by the other operation.\n\t\tconst operations = a.range.getDifference( b.range ).map( range => {\n\t\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, 0 );\n\t\t} );\n\n\t\t// Then we take care of the common part of ranges.\n\t\tconst common = a.range.getIntersection( b.range );\n\n\t\tif ( common ) {\n\t\t\t// If this operation is more important, we also want to apply change to the part of the\n\t\t\t// original range that has already been changed by the other operation. Since that range\n\t\t\t// got changed we also have to update `oldValue`.\n\t\t\tif ( context.aIsStrong ) {\n\t\t\t\toperations.push( new AttributeOperation( common, b.key, b.newValue, a.newValue, 0 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( operations.length == 0 ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\treturn operations;\n\t} else {\n\t\t// If operations don't conflict, simply return an array containing just a clone of this operation.\n\t\treturn [ a ];\n\t}\n} );\n\nsetTransformation( AttributeOperation, InsertOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// The attribute operation range includes the position where nodes were inserted.\n\t// There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n\t// the inserted nodes were elements and they should not receive attributes.\n\t//\n\tif ( a.range.start.hasSameParentAs( b.position ) && a.range.containsPosition( b.position ) ) {\n\t\t// If new nodes should not receive attributes, two separated ranges will be returned.\n\t\t// Otherwise, one expanded range will be returned.\n\t\tconst range = a.range._getTransformedByInsertion( b.position, b.howMany, !b.shouldReceiveAttributes );\n\t\tconst result = range.map( r => {\n\t\t\treturn new AttributeOperation( r, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t\t} );\n\n\t\tif ( b.shouldReceiveAttributes ) {\n\t\t\t// `AttributeOperation#range` includes some newly inserted text.\n\t\t\t// The operation should also change the attribute of that text. An example:\n\t\t\t//\n\t\t\t// Bold should be applied on the following range:\n\t\t\t// <p>Fo[zb]ar</p>\n\t\t\t//\n\t\t\t// In meantime, new text is typed:\n\t\t\t// <p>Fozxxbar</p>\n\t\t\t//\n\t\t\t// Bold should be applied also on the new text:\n\t\t\t// <p>Fo[zxxb]ar</p>\n\t\t\t// <p>Fo<$text bold=\"true\">zxxb</$text>ar</p>\n\t\t\t//\n\t\t\t// There is a special case to consider here to consider.\n\t\t\t//\n\t\t\t// Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might\n\t\t\t// have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:\n\t\t\t//\n\t\t\t// Attribute `highlight=\"yellow\"` should be applied on the following range:\n\t\t\t// <p>Fo[zb]ar<p>\n\t\t\t//\n\t\t\t// In meantime, character `x` with `highlight=\"red\"` is typed:\n\t\t\t// <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>\n\t\t\t//\n\t\t\t// In this case we cannot simply apply operation changing the attribute value from `null` to `\"yellow\"` for the whole range\n\t\t\t// because that would lead to an exception (`oldValue` is incorrect for `x`).\n\t\t\t//\n\t\t\t// We also cannot break the original range as this would mess up a scenario when there are multiple following\n\t\t\t// insert operations, because then only the first inserted character is included in those ranges:\n\t\t\t// <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>\n\t\t\t//\n\t\t\t// So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:\n\t\t\t//\n\t\t\t// <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.\n\t\t\t//\n\t\t\t// But before that operation would be applied, we will add an additional attribute operation that will change\n\t\t\t// attributes on the inserted nodes in a way which would make the original operation correct:\n\t\t\t//\n\t\t\t// <p>Fo[z{<$text highlight=\"red\">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.\n\t\t\t// <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.\n\t\t\t//\n\n\t\t\t// Generate complementary attribute operation. Be sure to add it before the original operation.\n\t\t\tconst op = _getComplementaryAttributeOperations( b, a.key, a.oldValue );\n\n\t\t\tif ( op ) {\n\t\t\t\tresult.unshift( op );\n\t\t\t}\n\t\t}\n\n\t\t// If nodes should not receive new attribute, we are done here.\n\t\treturn result;\n\t}\n\n\t// If insert operation is not expanding the attribute operation range, simply transform the range.\n\ta.range = a.range._getTransformedByInsertion( b.position, b.howMany, false )[ 0 ];\n\n\treturn [ a ];\n} );\n\n/**\n * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.\n *\n * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different\n * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.\n *\n * @private\n * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation\n * @param {String} key\n * @param {*} newValue\n * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}\n */\nfunction _getComplementaryAttributeOperations( insertOperation, key, newValue ) {\n\tconst nodes = insertOperation.nodes;\n\n\t// At the beginning we store the attribute value from the first node.\n\tconst insertValue = nodes.getNode( 0 ).getAttribute( key );\n\n\tif ( insertValue == newValue ) {\n\t\treturn null;\n\t}\n\n\tconst range = new Range( insertOperation.position, insertOperation.position.getShiftedBy( insertOperation.howMany ) );\n\n\treturn new AttributeOperation( range, key, insertValue, newValue, 0 );\n}\n\nsetTransformation( AttributeOperation, MergeOperation, ( a, b ) => {\n\tconst ranges = [];\n\n\t// Case 1:\n\t//\n\t// Attribute change on the merged element. In this case, the merged element was moved to the graveyard.\n\t// An additional attribute operation that will change the (re)moved element needs to be generated.\n\t//\n\tif ( a.range.start.hasSameParentAs( b.deletionPosition ) ) {\n\t\tif ( a.range.containsPosition( b.deletionPosition ) || a.range.start.isEqual( b.deletionPosition ) ) {\n\t\t\tranges.push( Range._createFromPositionAndShift( b.graveyardPosition, 1 ) );\n\t\t}\n\t}\n\n\tconst range = a.range._getTransformedByMergeOperation( b );\n\n\t// Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.\n\tif ( !range.isCollapsed ) {\n\t\tranges.push( range );\n\t}\n\n\t// Create `AttributeOperation`s out of the ranges.\n\treturn ranges.map( range => {\n\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t} );\n} );\n\nsetTransformation( AttributeOperation, MoveOperation, ( a, b ) => {\n\tconst ranges = _breakRangeByMoveOperation( a.range, b );\n\n\t// Create `AttributeOperation`s out of the ranges.\n\treturn ranges.map( range => new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion ) );\n} );\n\n// Helper function for `AttributeOperation` x `MoveOperation` transformation.\n//\n// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`\n// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't\n// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as\n// top-level nodes of the original `range`.\n//\n// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to\n// track only how those nodes have been affected by `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp\n// @returns {Array.<module:engine/model/range~Range>}\nfunction _breakRangeByMoveOperation( range, moveOp ) {\n\tconst moveRange = Range._createFromPositionAndShift( moveOp.sourcePosition, moveOp.howMany );\n\n\t// We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to\n\t// transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).\n\tlet common = null;\n\tlet difference = [];\n\n\t// Let's compare the ranges.\n\tif ( moveRange.containsRange( range, true ) ) {\n\t\t// If the whole original range is moved, treat it whole as a common part. There's also no difference part.\n\t\tcommon = range;\n\t} else if ( range.start.hasSameParentAs( moveRange.start ) ) {\n\t\t// If the ranges are \"on the same level\" (in the same parent) then move operation may move exactly those nodes\n\t\t// that are changed by the attribute operation. In this case we get common part and difference part in the usual way.\n\t\tdifference = range.getDifference( moveRange );\n\t\tcommon = range.getIntersection( moveRange );\n\t} else {\n\t\t// In any other situation we assume that original range is different than move range, that is that move operation\n\t\t// moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.\n\t\t//\n\t\t// Note that this is different than in `.getIntersection` (we would get a common part in that case) and different\n\t\t// than `.getDifference` (we would get two ranges).\n\t\tdifference = [ range ];\n\t}\n\n\tconst result = [];\n\n\t// The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so\n\t// we do it by hand.\n\tfor ( let diff of difference ) {\n\t\t// First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned\n\t\t// as the range is different than the moved range.\n\t\tdiff = diff._getTransformedByDeletion( moveOp.sourcePosition, moveOp.howMany );\n\n\t\t// Transform also `targetPosition`.\n\t\tconst targetPosition = moveOp.getMovedRangeStart();\n\n\t\t// Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.\n\t\tconst spread = diff.start.hasSameParentAs( targetPosition );\n\n\t\t// Transform by insertion of moved nodes.\n\t\tdiff = diff._getTransformedByInsertion( targetPosition, moveOp.howMany, spread );\n\n\t\tresult.push( ...diff );\n\t}\n\n\t// Common part can be simply transformed by the move operation. This is because move operation will not target to\n\t// that common part (the operation would have to target inside its own moved range).\n\tif ( common ) {\n\t\tresult.push(\n\t\t\tcommon._getTransformedByMove( moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false )[ 0 ]\n\t\t);\n\t}\n\n\treturn result;\n}\n\nsetTransformation( AttributeOperation, SplitOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// Split node is the last node in `AttributeOperation#range`.\n\t// `AttributeOperation#range` needs to be expanded to include the new (split) node.\n\t//\n\t// Attribute `type` to be changed to `numbered` but the `listItem` is split.\n\t// <listItem type=\"bulleted\">foobar</listItem>\n\t//\n\t// After split:\n\t// <listItem type=\"bulleted\">foo</listItem><listItem type=\"bulleted\">bar</listItem>\n\t//\n\t// After attribute change:\n\t// <listItem type=\"numbered\">foo</listItem><listItem type=\"numbered\">foo</listItem>\n\t//\n\tif ( a.range.end.isEqual( b.insertionPosition ) ) {\n\t\tif ( !b.graveyardPosition ) {\n\t\t\ta.range.end.offset++;\n\t\t}\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 2:\n\t//\n\t// Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are\n\t// not going to make a flat range.\n\t//\n\t// Content with range-to-change and split position:\n\t// <p>Fo[zb^a]r</p>\n\t//\n\t// After split:\n\t// <p>Fozb</p><p>ar</p>\n\t//\n\t// Make two separate ranges containing all nodes to change:\n\t// <p>Fo[zb]</p><p>[a]r</p>\n\t//\n\tif ( a.range.start.hasSameParentAs( b.splitPosition ) && a.range.containsPosition( b.splitPosition ) ) {\n\t\tconst secondPart = a.clone();\n\n\t\tsecondPart.range = new Range(\n\t\t\tb.moveTargetPosition.clone(),\n\t\t\ta.range.end._getCombined( b.splitPosition, b.moveTargetPosition )\n\t\t);\n\n\t\ta.range.end = b.splitPosition.clone();\n\t\ta.range.end.stickiness = 'toPrevious';\n\n\t\treturn [ a, secondPart ];\n\t}\n\n\t// The default case.\n\t//\n\ta.range = a.range._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, AttributeOperation, ( a, b ) => {\n\tconst result = [ a ];\n\n\t// Case 1:\n\t//\n\t// The attribute operation range includes the position where nodes were inserted.\n\t// There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n\t// the inserted nodes were elements and they should not receive attributes.\n\t//\n\t// This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,\n\t// although this case is a little less complicated. In this case we simply need to change attributes of the\n\t// inserted nodes and that's it.\n\t//\n\tif ( a.shouldReceiveAttributes && a.position.hasSameParentAs( b.range.start ) && b.range.containsPosition( a.position ) ) {\n\t\tconst op = _getComplementaryAttributeOperations( a, b.key, b.newValue );\n\n\t\tif ( op ) {\n\t\t\tresult.push( op );\n\t\t}\n\t}\n\n\t// The default case is: do nothing.\n\t// `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.\n\t//\n\treturn result;\n} );\n\nsetTransformation( InsertOperation, InsertOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided\n\t// what will be the order of inserted nodes. However, there is no additional information to help in that\n\t// decision. Also, when `b` will be transformed by `a`, the same order must be maintained.\n\t//\n\t// To achieve that, we will check if the operation is strong.\n\t// If it is, it won't get transformed. If it is not, it will be moved.\n\t//\n\tif ( a.position.isEqual( b.position ) && context.aIsStrong ) {\n\t\treturn [ a ];\n\t}\n\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, MoveOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedByMoveOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, SplitOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, MergeOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MarkerOperation, InsertOperation, ( a, b ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedByInsertOperation( b )[ 0 ];\n\t}\n\n\tif ( a.newRange ) {\n\t\ta.newRange = a.newRange._getTransformedByInsertOperation( b )[ 0 ];\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MarkerOperation, ( a, b, context ) => {\n\tif ( a.name == b.name ) {\n\t\tif ( context.aIsStrong ) {\n\t\t\ta.oldRange = b.newRange ? b.newRange.clone() : null;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MergeOperation, ( a, b ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedByMergeOperation( b );\n\t}\n\n\tif ( a.newRange ) {\n\t\ta.newRange = a.newRange._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MoveOperation, ( a, b, context ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = Range._createFromRanges( a.oldRange._getTransformedByMoveOperation( b ) );\n\t}\n\n\tif ( a.newRange ) {\n\t\tif ( context.abRelation ) {\n\t\t\tconst aNewRange = Range._createFromRanges( a.newRange._getTransformedByMoveOperation( b ) );\n\n\t\t\tif ( context.abRelation.side == 'left' && b.targetPosition.isEqual( a.newRange.start ) ) {\n\t\t\t\ta.newRange.start.path = context.abRelation.path;\n\t\t\t\ta.newRange.end = aNewRange.end;\n\n\t\t\t\treturn [ a ];\n\t\t\t} else if ( context.abRelation.side == 'right' && b.targetPosition.isEqual( a.newRange.end ) ) {\n\t\t\t\ta.newRange.start = aNewRange.start;\n\t\t\t\ta.newRange.end.path = context.abRelation.path;\n\n\t\t\t\treturn [ a ];\n\t\t\t}\n\t\t}\n\n\t\ta.newRange = Range._createFromRanges( a.newRange._getTransformedByMoveOperation( b ) );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, SplitOperation, ( a, b, context ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedBySplitOperation( b );\n\t}\n\n\tif ( a.newRange ) {\n\t\tif ( context.abRelation ) {\n\t\t\tconst aNewRange = a.newRange._getTransformedBySplitOperation( b );\n\n\t\t\tif ( a.newRange.start.isEqual( b.splitPosition ) && context.abRelation.wasStartBeforeMergedElement ) {\n\t\t\t\ta.newRange.start = Position._createAt( b.insertionPosition );\n\t\t\t} else if ( a.newRange.start.isEqual( b.splitPosition ) && !context.abRelation.wasInLeftElement ) {\n\t\t\t\ta.newRange.start = Position._createAt( b.moveTargetPosition );\n\t\t\t}\n\n\t\t\tif ( a.newRange.end.isEqual( b.splitPosition ) && context.abRelation.wasInRightElement ) {\n\t\t\t\ta.newRange.end = Position._createAt( b.moveTargetPosition );\n\t\t\t} else if ( a.newRange.end.isEqual( b.splitPosition ) && context.abRelation.wasEndBeforeMergedElement ) {\n\t\t\t\ta.newRange.end = Position._createAt( b.insertionPosition );\n\t\t\t} else {\n\t\t\t\ta.newRange.end = aNewRange.end;\n\t\t\t}\n\n\t\t\treturn [ a ];\n\t\t}\n\n\t\ta.newRange = a.newRange._getTransformedBySplitOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MergeOperation, InsertOperation, ( a, b ) => {\n\tif ( a.sourcePosition.hasSameParentAs( b.position ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByInsertOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, MergeOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Same merge operations.\n\t//\n\t// Both operations have same source and target positions. So the element already got merged and there is\n\t// theoretically nothing to do.\n\t//\n\tif ( a.sourcePosition.isEqual( b.sourcePosition ) && a.targetPosition.isEqual( b.targetPosition ) ) {\n\t\t// There are two ways that we can provide a do-nothing operation.\n\t\t//\n\t\t// First is simply a NoOperation instance. We will use it if `b` operation was not undone.\n\t\t//\n\t\t// Second is a merge operation that has the source operation in the merged element - in the graveyard -\n\t\t// same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard\n\t\t// which is almost the same as NoOperation.\n\t\t//\n\t\t// This way the merge operation can be later transformed by split operation\n\t\t// to provide correct undo. This will be used if `b` operation was undone (only then it is correct).\n\t\t//\n\t\tif ( !context.bWasUndone ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t} else {\n\t\t\tconst path = b.graveyardPosition.path.slice();\n\t\t\tpath.push( 0 );\n\n\t\t\ta.sourcePosition = new Position( b.graveyardPosition.root, path );\n\t\t\ta.howMany = 0;\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Same merge source position but different target position.\n\t//\n\t// This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph\n\t// and the other person removed that paragraph and merged the same paragraph to something before:\n\t//\n\t// Client A:\n\t// <p>Foo</p><p>Bar</p><p>[]Xyz</p>\n\t// <p>Foo</p><p>BarXyz</p>\n\t//\n\t// Client B:\n\t// <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>\n\t// <p>Foo</p><p>[]Xyz</p>\n\t// <p>FooXyz</p>\n\t//\n\t// In this case we need to decide where finally \"Xyz\" will land:\n\t//\n\t// <p>FooXyz</p>               graveyard: <p>Bar</p>\n\t// <p>Foo</p>                  graveyard: <p>BarXyz</p>\n\t//\n\t// Let's move it in a way so that a merge operation that does not target to graveyard is more important so that\n\t// nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B \"Xyz\" finally did not\n\t// end up in the graveyard (see above).\n\t//\n\t// If neither or both operations point to graveyard, then let `aIsStrong` decide.\n\t//\n\tif (\n\t\ta.sourcePosition.isEqual( b.sourcePosition ) && !a.targetPosition.isEqual( b.targetPosition ) &&\n\t\t!context.bWasUndone && context.abRelation != 'splitAtSource'\n\t) {\n\t\tconst aToGraveyard = a.targetPosition.root.rootName == '$graveyard';\n\t\tconst bToGraveyard = b.targetPosition.root.rootName == '$graveyard';\n\n\t\t// If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\t\tconst aIsWeak = aToGraveyard && !bToGraveyard;\n\n\t\t// If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\t\tconst bIsWeak = bToGraveyard && !aToGraveyard;\n\n\t\t// Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\t\tconst forceMove = bIsWeak || ( !aIsWeak && context.aIsStrong );\n\n\t\tif ( forceMove ) {\n\t\t\tconst sourcePosition = b.targetPosition._getTransformedByMergeOperation( b );\n\t\t\tconst targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\treturn [ new MoveOperation( sourcePosition, a.howMany, targetPosition, 0 ) ];\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByMergeOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t// Handle positions in graveyard.\n\t// If graveyard positions are same and `a` operation is strong - do not transform.\n\tif ( !a.graveyardPosition.isEqual( b.graveyardPosition ) || !context.aIsStrong ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, MoveOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// The element to merge got removed.\n\t//\n\t// Merge operation does support merging elements which are not siblings. So it would not be a problem\n\t// from technical point of view. However, if the element was removed, the intention of the user deleting it\n\t// was to have it all deleted, together with its children. From user experience point of view, moving back the\n\t// removed nodes might be unexpected. This means that in this scenario we will block the merging.\n\t//\n\t// The exception of this rule would be if the remove operation was later undone.\n\t//\n\tconst removedRange = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\tif ( b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove ) {\n\t\tif ( a.deletionPosition.hasSameParentAs( b.sourcePosition ) && removedRange.containsPosition( a.sourcePosition ) ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\tif ( a.sourcePosition.hasSameParentAs( b.sourcePosition ) ) {\n\t\ta.howMany -= b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByMoveOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByMoveOperation( b );\n\n\t// `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will\n\t// be moved. Like in other similar cases, we need to consider the scenario when those positions are same.\n\t// Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).\n\t// This means that we won't transform graveyard position if it is equal to move operation target position.\n\tif ( !a.graveyardPosition.isEqual( b.targetPosition ) ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, SplitOperation, ( a, b, context ) => {\n\tif ( b.graveyardPosition ) {\n\t\t// If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to\n\t\t// transform `a.graveyardPosition` accordingly.\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByDeletion( b.graveyardPosition, 1 );\n\n\t\t// This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.\n\t\t//\n\t\t// So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which\n\t\t// source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This\n\t\t// means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.\n\t\t//\n\t\t// If that's the case, at this point, we will only \"fix\" `a.howMany`. It was earlier set to `0` in\n\t\t// `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other\n\t\t// properties.\n\t\t//\n\t\tif ( a.deletionPosition.isEqual( b.graveyardPosition ) ) {\n\t\t\ta.howMany = b.howMany;\n\t\t}\n\t}\n\n\t// Case 1:\n\t//\n\t// Merge operation moves nodes to the place where split happens.\n\t// This is a classic situation when there are two paragraphs, and there is a split (enter) after the first\n\t// paragraph and there is a merge (delete) at the beginning of the second paragraph:\n\t//\n\t// <p>Foo{}</p><p>[]Bar</p>.\n\t//\n\t// Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.\n\t//\n\t// State after split:\n\t// <p>Foo</p><p></p><p>Bar</p>\n\t//\n\t// Now, `Bar` should be merged to the new paragraph:\n\t// <p>Foo</p><p>Bar</p>\n\t//\n\t// Instead of merging it to the original paragraph:\n\t// <p>FooBar</p><p></p>\n\t//\n\t// This means that `targetPosition` needs to be transformed. This is the default case though.\n\t// For example, if the split would be after `F`, `targetPosition` should also be transformed.\n\t//\n\t// There are three exceptions, though, when we want to keep `targetPosition` as it was.\n\t//\n\t// First exception is when the merge target position is inside an element (not at the end, as usual). This\n\t// happens when the merge operation earlier was transformed by \"the same\" merge operation. If merge operation\n\t// targets inside the element we want to keep the original target position (and not transform it) because\n\t// we have additional context telling us that we want to merge to the original element. We can check if the\n\t// merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position\n\t// is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.\n\t//\n\t// Second exception is when the element to merge is in the graveyard and split operation uses it. In that case\n\t// if target position would be transformed, the merge operation would target at the source position:\n\t//\n\t// root: <p>Foo</p>\t\t\t\tgraveyard: <p></p>\n\t//\n\t// SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)\n\t// MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)\n\t//\n\t// Since split operation moves the graveyard node back to the root, the merge operation source position changes.\n\t// We would like to merge from the empty <p> to the \"Foo\" <p>:\n\t//\n\t// root: <p>Foo</p><p></p>\t\t\tgraveyard:\n\t//\n\t// MergeOperation#sourcePosition = root [ 1, 0 ]\n\t//\n\t// If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.\n\t//\n\t// Third exception is connected with relations. If this happens during undo and we have explicit information\n\t// that target position has not been affected by the operation which is undone by this split then this split should\n\t// not move the target position either.\n\t//\n\tif ( a.targetPosition.isEqual( b.splitPosition ) ) {\n\t\tconst mergeInside = b.howMany != 0;\n\t\tconst mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual( b.graveyardPosition );\n\n\t\tif ( mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved' ) {\n\t\t\ta.sourcePosition = a.sourcePosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Merge source is at the same position as split position. This sometimes happen, mostly during undo.\n\t// The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the\n\t// split element) or should be move to the beginning of the new element.\n\t//\n\tif ( a.sourcePosition.isEqual( b.splitPosition ) ) {\n\t\t// Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.\n\t\t// This scenario happens the undone merge operation moved nodes at the source position of `a` operation.\n\t\t// In that case `a` operation source position should stay where it is.\n\t\tif ( context.abRelation == 'mergeSourceNotMoved' ) {\n\t\t\ta.howMany = 0;\n\t\t\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\n\t\t// This merge operation might have been earlier transformed by a merge operation which both merged the same element.\n\t\t// See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,\n\t\t// the special case is not applied.\n\t\t//\n\t\t// Now, the merge operation is transformed by the split which has undone that previous merge operation.\n\t\t// So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.\n\t\t//\n\t\tif ( context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0 ) {\n\t\t\ta.sourcePosition = b.moveTargetPosition.clone();\n\t\t\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.splitPosition ) ) {\n\t\ta.howMany = b.splitPosition.offset;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedBySplitOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MoveOperation, InsertOperation, ( a, b ) => {\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst transformed = moveRange._getTransformedByInsertOperation( b, false )[ 0 ];\n\n\ta.sourcePosition = transformed.start;\n\ta.howMany = transformed.end.offset - transformed.start.offset;\n\n\t// See `InsertOperation` x `MoveOperation` transformation for details on this case.\n\t//\n\t// In summary, both operations point to the same place, so the order of nodes needs to be decided.\n\t// `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation\n\t// between operations.\n\t//\n\tif ( !a.targetPosition.isEqual( b.position ) ) {\n\t\ta.targetPosition = a.targetPosition._getTransformedByInsertOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MoveOperation, MoveOperation, ( a, b, context ) => {\n\t//\n\t// Setting and evaluating some variables that will be used in special cases and default algorithm.\n\t//\n\t// Create ranges from `MoveOperations` properties.\n\tconst rangeA = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst rangeB = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\t// Assign `context.aIsStrong` to a different variable, because the value may change during execution of\n\t// this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.\n\tlet aIsStrong = context.aIsStrong;\n\n\t// This will be used to decide the order of nodes if both operations target at the same position.\n\t// By default, use strong/weak operation mechanism.\n\tlet insertBefore = !context.aIsStrong;\n\n\t// If the relation is set, then use it to decide nodes order.\n\tif ( context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter' ) {\n\t\tinsertBefore = true;\n\t} else if ( context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore' ) {\n\t\tinsertBefore = false;\n\t}\n\n\t// `a.targetPosition` could be affected by the `b` operation. We will transform it.\n\tlet newTargetPosition;\n\n\tif ( a.targetPosition.isEqual( b.targetPosition ) && insertBefore ) {\n\t\tnewTargetPosition = a.targetPosition._getTransformedByDeletion(\n\t\t\tb.sourcePosition,\n\t\t\tb.howMany\n\t\t);\n\t} else {\n\t\tnewTargetPosition = a.targetPosition._getTransformedByMove(\n\t\t\tb.sourcePosition,\n\t\t\tb.targetPosition,\n\t\t\tb.howMany\n\t\t);\n\t}\n\n\t//\n\t// Special case #1 + mirror.\n\t//\n\t// Special case when both move operations' target positions are inside nodes that are\n\t// being moved by the other move operation. So in other words, we move ranges into inside of each other.\n\t// This case can't be solved reasonably (on the other hand, it should not happen often).\n\tif ( _moveTargetIntoMovedRange( a, b ) && _moveTargetIntoMovedRange( b, a ) ) {\n\t\t// Instead of transforming operation, we return a reverse of the operation that we transform by.\n\t\t// So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n\t\treturn [ b.getReversed() ];\n\t}\n\t//\n\t// End of special case #1.\n\t//\n\n\t//\n\t// Special case #2.\n\t//\n\t// Check if `b` operation targets inside `rangeA`.\n\tconst bTargetsToA = rangeA.containsPosition( b.targetPosition );\n\n\t// If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n\t// You might say that operation `b` is captured inside operation `a`.\n\tif ( bTargetsToA && rangeA.containsRange( rangeB, true ) ) {\n\t\t// There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n\t\t// we need to transform `a` operation anyway.\n\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\n\t//\n\t// Special case #2 mirror.\n\t//\n\tconst aTargetsToB = rangeB.containsPosition( a.targetPosition );\n\n\tif ( aTargetsToB && rangeB.containsRange( rangeA, true ) ) {\n\t\t// `a` operation is \"moved together\" with `b` operation.\n\t\t// Here, just move `rangeA` \"inside\" `rangeB`.\n\t\trangeA.start = rangeA.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\trangeA.end = rangeA.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\t//\n\t// End of special case #2.\n\t//\n\n\t//\n\t// Special case #3 + mirror.\n\t//\n\t// `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n\t// but not on the same tree level. In such case ranges have common part but we have to treat it\n\t// differently, because in such case those ranges are not really conflicting and should be treated like\n\t// two separate ranges. Also we have to discard two difference parts.\n\tconst aCompB = compareArrays( a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath() );\n\n\tif ( aCompB == 'prefix' || aCompB == 'extension' ) {\n\t\t// Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n\t\t// Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n\t\t// like a one difference part.\n\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\t//\n\t// End of special case #3.\n\t//\n\n\t//\n\t// Default case - ranges are on the same level or are not connected with each other.\n\t//\n\t// Modifier for default case.\n\t// Modifies `aIsStrong` flag in certain conditions.\n\t//\n\t// If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n\t// to provide more expected results.\n\tif ( a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove ) {\n\t\taIsStrong = true;\n\t} else if ( a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove ) {\n\t\taIsStrong = false;\n\t}\n\n\t// Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n\t// This will aggregate transformed ranges.\n\tconst ranges = [];\n\n\t// Get the \"difference part\" of `a` operation source range.\n\t// This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n\tconst difference = rangeA.getDifference( rangeB );\n\n\tfor ( const range of difference ) {\n\t\t// Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n\t\trange.start = range.start._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\trange.end = range.end._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\n\t\t// If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n\t\tconst shouldSpread = compareArrays( range.start.getParentPath(), b.getMovedRangeStart().getParentPath() ) == 'same';\n\t\tconst newRanges = range._getTransformedByInsertion( b.getMovedRangeStart(), b.howMany, shouldSpread );\n\n\t\tranges.push( ...newRanges );\n\t}\n\n\t// Then, we have to manage the \"common part\" of both move ranges.\n\tconst common = rangeA.getIntersection( rangeB );\n\n\tif ( common !== null && aIsStrong ) {\n\t\t// Calculate the new position of that part of original range.\n\t\tcommon.start = common.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\tcommon.end = common.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\t// Take care of proper range order.\n\t\t//\n\t\t// Put `common` at appropriate place. Keep in mind that we are interested in original order.\n\t\t// Basically there are only three cases: there is zero, one or two difference ranges.\n\t\t//\n\t\t// If there is zero difference ranges, just push `common` in the array.\n\t\tif ( ranges.length === 0 ) {\n\t\t\tranges.push( common );\n\t\t}\n\t\t// If there is one difference range, we need to check whether common part was before it or after it.\n\t\telse if ( ranges.length == 1 ) {\n\t\t\tif ( rangeB.start.isBefore( rangeA.start ) || rangeB.start.isEqual( rangeA.start ) ) {\n\t\t\t\tranges.unshift( common );\n\t\t\t} else {\n\t\t\t\tranges.push( common );\n\t\t\t}\n\t\t}\n\t\t// If there are more ranges (which means two), put common part between them. This is the only scenario\n\t\t// where there could be two difference ranges so we don't have to make any comparisons.\n\t\telse {\n\t\t\tranges.splice( 1, 0, common );\n\t\t}\n\t}\n\n\tif ( ranges.length === 0 ) {\n\t\t// If there are no \"source ranges\", nothing should be changed.\n\t\t// Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.\n\t\treturn [ new NoOperation( a.baseVersion ) ];\n\t}\n\n\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n} );\n\nsetTransformation( MoveOperation, SplitOperation, ( a, b, context ) => {\n\tlet newTargetPosition = a.targetPosition.clone();\n\n\t// Do not transform if target position is same as split insertion position and this split comes from undo.\n\t// This should be done on relations but it is too much work for now as it would require relations working in collaboration.\n\t// We need to make a decision how we will resolve such conflict and this is less harmful way.\n\tif ( !a.targetPosition.isEqual( b.insertionPosition ) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter' ) {\n\t\tnewTargetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\t}\n\n\t// Case 1:\n\t//\n\t// Last element in the moved range got split.\n\t//\n\t// In this case the default range transformation will not work correctly as the element created by\n\t// split operation would be outside the range. The range to move needs to be fixed manually.\n\t//\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\n\tif ( moveRange.end.isEqual( b.insertionPosition ) ) {\n\t\t// Do it only if this is a \"natural\" split, not a one that comes from undo.\n\t\t// If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).\n\t\tif ( !b.graveyardPosition ) {\n\t\t\ta.howMany++;\n\t\t}\n\n\t\ta.targetPosition = newTargetPosition;\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 2:\n\t//\n\t// Split happened between the moved nodes. In this case two ranges to move need to be generated.\n\t//\n\t// Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.\n\t// <p>F[oz|ba]r</p><p>Xyz</p>\n\t//\n\t// After split:\n\t// <p>F[oz</p><p>ba]r</p><p>Xyz</p>\n\t//\n\t// Correct ranges:\n\t// <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>\n\t//\n\t// After move:\n\t// <p>F</p><p>r</p><p>Xyzozba</p>\n\t//\n\tif ( moveRange.start.hasSameParentAs( b.splitPosition ) && moveRange.containsPosition( b.splitPosition ) ) {\n\t\tlet rightRange = new Range( b.splitPosition, moveRange.end );\n\t\trightRange = rightRange._getTransformedBySplitOperation( b );\n\n\t\tconst ranges = [\n\t\t\tnew Range( moveRange.start, b.splitPosition ),\n\t\t\trightRange\n\t\t];\n\n\t\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n\t}\n\n\t// Case 3:\n\t//\n\t// Move operation targets at the split position. We need to decide if the nodes should be inserted\n\t// at the end of the split element or at the beginning of the new element.\n\t//\n\tif ( a.targetPosition.isEqual( b.splitPosition ) && context.abRelation == 'insertAtSource' ) {\n\t\tnewTargetPosition = b.moveTargetPosition;\n\t}\n\n\t// Case 4:\n\t//\n\t// Move operation targets just after the split element. We need to decide if the nodes should be inserted\n\t// between two parts of split element, or after the new element.\n\t//\n\t// Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:\n\t// <p>Foo|bar</p>^<p>baz</p>\n\t// <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?\n\t//\n\t// If there is no contextual information between operations (for example, they come from collaborative\n\t// editing), we don't want to put some unrelated content (move) between parts of related content (split parts).\n\t// However, if the split is from undo, in the past, the moved content might be targeting between the\n\t// split parts, meaning that was exactly user's intention:\n\t//\n\t// <p>Foo</p>^<p>bar</p>\t\t<--- original situation, in \"past\".\n\t// <p>Foobar</p>^\t\t\t\t<--- after merge target position is transformed.\n\t// <p>Foo|bar</p>^\t\t\t\t<--- then the merge is undone, and split happens, which leads us to current situation.\n\t//\n\t// In this case it is pretty clear that the intention was to put new paragraph between those nodes,\n\t// so we need to transform accordingly. We can detect this scenario thanks to relations.\n\t//\n\tif ( a.targetPosition.isEqual( b.insertionPosition ) && context.abRelation == 'insertBetween' ) {\n\t\tnewTargetPosition = a.targetPosition;\n\t}\n\n\t// The default case.\n\t//\n\tconst transformed = moveRange._getTransformedBySplitOperation( b );\n\tconst ranges = [ transformed ];\n\n\t// Case 5:\n\t//\n\t// Moved range contains graveyard element used by split operation. Add extra move operation to the result.\n\t//\n\tif ( b.graveyardPosition ) {\n\t\tconst movesGraveyardElement = moveRange.start.isEqual( b.graveyardPosition ) || moveRange.containsPosition( b.graveyardPosition );\n\n\t\tif ( a.howMany > 1 && movesGraveyardElement && !context.aWasUndone ) {\n\t\t\tranges.push( Range._createFromPositionAndShift( b.insertionPosition, 1 ) );\n\t\t}\n\t}\n\n\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n} );\n\nsetTransformation( MoveOperation, MergeOperation, ( a, b, context ) => {\n\tconst movedRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\n\tif ( b.deletionPosition.hasSameParentAs( a.sourcePosition ) && movedRange.containsPosition( b.sourcePosition ) ) {\n\t\tif ( a.type == 'remove' && !context.forceWeakRemove ) {\n\t\t\t// Case 1:\n\t\t\t//\n\t\t\t// The element to remove got merged.\n\t\t\t//\n\t\t\t// Merge operation does support merging elements which are not siblings. So it would not be a problem\n\t\t\t// from technical point of view. However, if the element was removed, the intention of the user\n\t\t\t// deleting it was to have it all deleted. From user experience point of view, moving back the\n\t\t\t// removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.\n\t\t\t//\n\t\t\tif ( !context.aWasUndone ) {\n\t\t\t\tconst results = [];\n\n\t\t\t\tlet gyMoveSource = b.graveyardPosition.clone();\n\t\t\t\tlet splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\t\tif ( a.howMany > 1 ) {\n\t\t\t\t\tresults.push( new MoveOperation( a.sourcePosition, a.howMany - 1, a.targetPosition, 0 ) );\n\n\t\t\t\t\tgyMoveSource = gyMoveSource._getTransformedByMove( a.sourcePosition, a.targetPosition, a.howMany - 1 );\n\t\t\t\t\tsplitNodesMoveSource = splitNodesMoveSource._getTransformedByMove( a.sourcePosition, a.targetPosition, a.howMany - 1 );\n\t\t\t\t}\n\n\t\t\t\tconst gyMoveTarget = b.deletionPosition._getCombined( a.sourcePosition, a.targetPosition );\n\t\t\t\tconst gyMove = new MoveOperation( gyMoveSource, 1, gyMoveTarget, 0 );\n\n\t\t\t\tconst splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();\n\t\t\t\tsplitNodesMoveTargetPath.push( 0 );\n\n\t\t\t\tconst splitNodesMoveTarget = new Position( gyMove.targetPosition.root, splitNodesMoveTargetPath );\n\t\t\t\tsplitNodesMoveSource = splitNodesMoveSource._getTransformedByMove( gyMoveSource, gyMoveTarget, 1 );\n\t\t\t\tconst splitNodesMove = new MoveOperation( splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0 );\n\n\t\t\t\tresults.push( gyMove );\n\t\t\t\tresults.push( splitNodesMove );\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t} else {\n\t\t\t// Case 2:\n\t\t\t//\n\t\t\t// The element to move got merged and it was the only element to move.\n\t\t\t// In this case just don't do anything, leave the node in the graveyard. Without special case\n\t\t\t// it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.\n\t\t\t//\n\t\t\tif ( a.howMany == 1 ) {\n\t\t\t\tif ( !context.bWasUndone ) {\n\t\t\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t\t\t} else {\n\t\t\t\t\ta.sourcePosition = b.graveyardPosition.clone();\n\t\t\t\t\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\t\t\treturn [ a ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst transformed = moveRange._getTransformedByMergeOperation( b );\n\n\ta.sourcePosition = transformed.start;\n\ta.howMany = transformed.end.offset - transformed.start.offset;\n\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( RenameOperation, InsertOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, MergeOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// Element to rename got merged, so it was moved to `b.graveyardPosition`.\n\t//\n\tif ( a.position.isEqual( b.deletionPosition ) ) {\n\t\ta.position = b.graveyardPosition.clone();\n\t\ta.position.stickiness = 'toNext';\n\n\t\treturn [ a ];\n\t}\n\n\ta.position = a.position._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, MoveOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByMoveOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, RenameOperation, ( a, b, context ) => {\n\tif ( a.position.isEqual( b.position ) ) {\n\t\tif ( context.aIsStrong ) {\n\t\t\ta.oldName = b.newName;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, SplitOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// The element to rename has been split. In this case, the new element should be also renamed.\n\t//\n\t// User decides to change the paragraph to a list item:\n\t// <paragraph>Foobar</paragraph>\n\t//\n\t// However, in meantime, split happens:\n\t// <paragraph>Foo</paragraph><paragraph>bar</paragraph>\n\t//\n\t// As a result, rename both elements:\n\t// <listItem>Foo</listItem><listItem>bar</listItem>\n\t//\n\tconst renamePath = a.position.path;\n\tconst splitPath = b.splitPosition.getParentPath();\n\n\tif ( compareArrays( renamePath, splitPath ) == 'same' && !b.graveyardPosition ) {\n\t\tconst extraRename = new RenameOperation( a.position.getShiftedBy( 1 ), a.oldName, a.newName, 0 );\n\n\t\treturn [ a, extraRename ];\n\t}\n\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( RootAttributeOperation, RootAttributeOperation, ( a, b, context ) => {\n\tif ( a.root === b.root && a.key === b.key ) {\n\t\tif ( !context.aIsStrong || a.newValue === b.newValue ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t} else {\n\t\t\ta.oldValue = b.newValue;\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( SplitOperation, InsertOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.position ) && a.splitPosition.offset < b.position.offset ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedByInsertOperation( b );\n\ta.insertionPosition = a.insertionPosition._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, MergeOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Split element got merged. If two different elements were merged, clients will have different content.\n\t//\n\t// Example. Merge at `{}`, split at `[]`:\n\t// <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n\t//\n\t// On merge side it will look like this:\n\t// <heading>FooB[]ar</heading>\n\t// <heading>FooB</heading><heading>ar</heading>\n\t//\n\t// On split side it will look like this:\n\t// <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n\t// <heading>FooB</heading><paragraph>ar</paragraph>\n\t//\n\t// Clearly, the second element is different for both clients.\n\t//\n\t// We could use the removed merge element from graveyard as a split element but then clients would have a different\n\t// model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).\n\t//\n\t// To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`\n\t// in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be\n\t// used for splitting. Example below.\n\t//\n\t// Original state:\n\t// <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n\t//\n\t// Merge side client:\n\t//\n\t// After merge:\n\t// <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>\n\t//\n\t// Extra split:\n\t// <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>\n\t//\n\t// Use the \"cloned\" element from graveyard:\n\t// <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n\t//\n\t// Split side client:\n\t//\n\t// After split:\n\t// <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n\t//\n\t// After merge:\n\t// <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n\t//\n\t// This special case scenario only applies if the original split operation clones the split element.\n\t// If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation\n\t// knows exactly which element it should use. So there would be no original problem with different contents.\n\t//\n\t// Additionally, the special case applies only if the merge wasn't already undone.\n\t//\n\tif ( !a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs( b.sourcePosition ) ) {\n\t\tconst splitPath = b.graveyardPosition.path.slice();\n\t\tsplitPath.push( 0 );\n\n\t\tconst splitPosition = new Position( b.graveyardPosition.root, splitPath );\n\t\tconst insertionPosition = SplitOperation.getInsertionPosition( new Position( b.graveyardPosition.root, splitPath ) );\n\n\t\tconst additionalSplit = new SplitOperation( splitPosition, 0, insertionPosition, null, 0 );\n\n\t\ta.splitPosition = a.splitPosition._getTransformedByMergeOperation( b );\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\t\ta.graveyardPosition = additionalSplit.insertionPosition.clone();\n\t\ta.graveyardPosition.stickiness = 'toNext';\n\n\t\treturn [ additionalSplit, a ];\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.deletionPosition ) && !a.splitPosition.isAfter( b.deletionPosition ) ) {\n\t\ta.howMany--;\n\t}\n\n\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedByMergeOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\tif ( a.graveyardPosition ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, MoveOperation, ( a, b, context ) => {\n\tconst rangeToMove = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\tif ( a.graveyardPosition ) {\n\t\t// Case 1:\n\t\t//\n\t\t// Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element\n\t\t// is already moved to the correct position, we need to only move the nodes after the split position.\n\t\t// This will be done by `MoveOperation` instead of `SplitOperation`.\n\t\t//\n\t\tconst gyElementMoved = rangeToMove.start.isEqual( a.graveyardPosition ) || rangeToMove.containsPosition( a.graveyardPosition );\n\n\t\tif ( !context.bWasUndone && gyElementMoved ) {\n\t\t\tconst sourcePosition = a.splitPosition._getTransformedByMoveOperation( b );\n\n\t\t\tconst newParentPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t\t\tconst newTargetPath = newParentPosition.path.slice();\n\t\t\tnewTargetPath.push( 0 );\n\n\t\t\tconst newTargetPosition = new Position( newParentPosition.root, newTargetPath );\n\t\t\tconst moveOp = new MoveOperation( sourcePosition, a.howMany, newTargetPosition, 0 );\n\n\t\t\treturn [ moveOp ];\n\t\t}\n\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t}\n\n\t// Case 2:\n\t//\n\t// Split is at a position where nodes were moved.\n\t//\n\t// This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the\n\t// \"split operation point of view\".\n\t//\n\tconst splitAtTarget = a.splitPosition.isEqual( b.targetPosition );\n\n\tif ( splitAtTarget && ( context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore' ) ) {\n\t\ta.howMany += b.howMany;\n\t\ta.splitPosition = a.splitPosition._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\t\treturn [ a ];\n\t}\n\n\tif ( splitAtTarget && context.abRelation && context.abRelation.howMany ) {\n\t\tconst { howMany, offset } = context.abRelation;\n\n\t\ta.howMany += howMany;\n\t\ta.splitPosition = a.splitPosition.getShiftedBy( offset );\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 3:\n\t//\n\t// If the split position is inside the moved range, we need to shift the split position to a proper place.\n\t// The position cannot be moved together with moved range because that would result in splitting of an incorrect element.\n\t//\n\t// Characters `bc` should be moved to the second paragraph while split position is between them:\n\t// <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>\n\t//\n\t// After move, new split position is incorrect:\n\t// <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>\n\t//\n\t// Correct split position:\n\t// <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>\n\t//\n\t// After split:\n\t// <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.sourcePosition ) && rangeToMove.containsPosition( a.splitPosition ) ) {\n\t\tconst howManyRemoved = b.howMany - ( a.splitPosition.offset - b.sourcePosition.offset );\n\t\ta.howMany -= howManyRemoved;\n\n\t\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) && a.splitPosition.offset < b.targetPosition.offset ) {\n\t\t\ta.howMany += b.howMany;\n\t\t}\n\n\t\ta.splitPosition = b.sourcePosition.clone();\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\t\treturn [ a ];\n\t}\n\n\t// The default case.\n\t// Don't change `howMany` if move operation does not really move anything.\n\t//\n\tif ( !b.sourcePosition.isEqual( b.targetPosition ) ) {\n\t\tif ( a.splitPosition.hasSameParentAs( b.sourcePosition ) && a.splitPosition.offset <= b.sourcePosition.offset ) {\n\t\t\ta.howMany -= b.howMany;\n\t\t}\n\n\t\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) && a.splitPosition.offset < b.targetPosition.offset ) {\n\t\t\ta.howMany += b.howMany;\n\t\t}\n\t}\n\n\t// Change position stickiness to force a correct transformation.\n\ta.splitPosition.stickiness = 'toNone';\n\ta.splitPosition = a.splitPosition._getTransformedByMoveOperation( b );\n\ta.splitPosition.stickiness = 'toNext';\n\n\tif ( a.graveyardPosition ) {\n\t\ta.insertionPosition = a.insertionPosition._getTransformedByMoveOperation( b );\n\t} else {\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, SplitOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Split at the same position.\n\t//\n\t// If there already was a split at the same position as in `a` operation, it means that the intention\n\t// conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).\n\t//\n\t// However, there is a difference if these are new splits or splits created by undo. These have different\n\t// intentions. Also splits moving back different elements from graveyard have different intentions. They\n\t// are just different operations.\n\t//\n\t// So we cancel split operation only if it was really identical.\n\t//\n\t// Also, there is additional case, where split operations aren't identical and should not be cancelled, however the\n\t// default transformation is incorrect too.\n\t//\n\tif ( a.splitPosition.isEqual( b.splitPosition ) ) {\n\t\tif ( !a.graveyardPosition && !b.graveyardPosition ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\tif ( a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual( b.graveyardPosition ) ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\t// Use context to know that the `a.splitPosition` should stay where it is.\n\t\t// This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.\n\t\tif ( context.abRelation == 'splitBefore' ) {\n\t\t\t// Since split is at the same position, there are no nodes left to split.\n\t\t\ta.howMany = 0;\n\n\t\t\t// Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.\n\t\t\t// That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.\n\t\t\t// It could happen if `context` is enabled in collaboration.\n\t\t\ta.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Same node is using to split different elements. This happens in undo when previously same element was merged to\n\t// two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.\n\t//\n\t// In this case we will follow the same logic. We will assume that `insertionPosition` is same for both\n\t// split operations. This might not always be true but in the real cases that were experienced it was. After all,\n\t// if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`\n\t// should be same for both of those splits.\n\t//\n\t// Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.\n\t//\n\tif ( a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual( b.graveyardPosition ) ) {\n\t\tconst aInGraveyard = a.splitPosition.root.rootName == '$graveyard';\n\t\tconst bInGraveyard = b.splitPosition.root.rootName == '$graveyard';\n\n\t\t// If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\t\tconst aIsWeak = aInGraveyard && !bInGraveyard;\n\n\t\t// If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\t\tconst bIsWeak = bInGraveyard && !aInGraveyard;\n\n\t\t// Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\t\tconst forceMove = bIsWeak || ( !aIsWeak && context.aIsStrong );\n\n\t\tif ( forceMove ) {\n\t\t\tconst result = [];\n\n\t\t\t// First we need to move any nodes split by `b` back to where they were.\n\t\t\t// Do it only if `b` actually moved something.\n\t\t\tif ( b.howMany ) {\n\t\t\t\tresult.push( new MoveOperation( b.moveTargetPosition, b.howMany, b.splitPosition, 0 ) );\n\t\t\t}\n\n\t\t\t// Then we need to move nodes from `a` split position to their new element.\n\t\t\t// Do it only if `a` actually should move something.\n\t\t\tif ( a.howMany ) {\n\t\t\t\tresult.push( new MoveOperation( a.splitPosition, a.howMany, a.moveTargetPosition, 0 ) );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\tif ( a.graveyardPosition ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation( b );\n\t}\n\n\t// Case 3:\n\t//\n\t// Position where operation `b` inserted a new node after split is the same as the operation `a` split position.\n\t// As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.\n\t//\n\tif ( a.splitPosition.isEqual( b.insertionPosition ) && context.abRelation == 'splitBefore' ) {\n\t\ta.howMany++;\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 4:\n\t//\n\t// This is a mirror to the case 2. above.\n\t//\n\tif ( b.splitPosition.isEqual( a.insertionPosition ) && context.baRelation == 'splitBefore' ) {\n\t\tconst newPositionPath = b.insertionPosition.path.slice();\n\t\tnewPositionPath.push( 0 );\n\n\t\tconst newPosition = new Position( b.insertionPosition.root, newPositionPath );\n\t\tconst moveOp = new MoveOperation( a.insertionPosition, 1, newPosition, 0 );\n\n\t\treturn [ a, moveOp ];\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.splitPosition ) && a.splitPosition.offset < b.splitPosition.offset ) {\n\t\ta.howMany -= b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedBySplitOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\treturn [ a ];\n} );\n\n// Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/operation/moveoperation~MoveOperation} a\n// @param {module:engine/model/operation/moveoperation~MoveOperation} b\n// @returns {Boolean}\nfunction _moveTargetIntoMovedRange( a, b ) {\n\treturn a.targetPosition._getTransformedByDeletion( b.sourcePosition, b.howMany ) === null;\n}\n\n// Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to\n// move operations and returns them.\n//\n// Ranges and target position will be transformed on-the-fly when generating operations.\n//\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n//\n// Given `targetPosition` is the target position of the first range from `ranges`.\n//\n// @private\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @param {module:engine/model/position~Position} targetPosition\n// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}\nfunction _makeMoveOperationsFromRanges( ranges, targetPosition ) {\n\t// At this moment we have some ranges and a target position, to which those ranges should be moved.\n\t// Order in `ranges` array is the go-to order of after transformation.\n\t//\n\t// We are almost done. We have `ranges` and `targetPosition` to make operations from.\n\t// Unfortunately, those operations may affect each other. Precisely, first operation after move\n\t// may affect source range and target position of second and third operation. Same with second\n\t// operation affecting third.\n\t//\n\t// We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n\tconst operations = [];\n\n\t// Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t// Create new operation out of a range and target position.\n\t\tconst range = ranges[ i ];\n\t\tconst op = new MoveOperation(\n\t\t\trange.start,\n\t\t\trange.end.offset - range.start.offset,\n\t\t\ttargetPosition,\n\t\t\t0\n\t\t);\n\n\t\toperations.push( op );\n\n\t\t// Transform other ranges by the generated operation.\n\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t// All ranges in `ranges` array should be:\n\t\t\t//\n\t\t\t// * non-intersecting (these are part of original operation source range), and\n\t\t\t// * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n\t\t\t//\n\t\t\t// This means that the transformation will be \"clean\" and always return one result.\n\t\t\tranges[ j ] = ranges[ j ]._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany )[ 0 ];\n\t\t}\n\n\t\ttargetPosition = targetPosition._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany );\n\t}\n\n\treturn operations;\n}\n"]}]}