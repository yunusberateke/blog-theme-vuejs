{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIjsKCnZhciBfbWFya2VkID0gLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKF9nZXRBbGxVcGNhc3REZWZpbml0aW9ucyksCiAgICBfbWFya2VkMiA9IC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhfZ2V0VXBjYXN0RGVmaW5pdGlvbik7CgppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbgogKi8KaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7CmltcG9ydCBVcGNhc3RIZWxwZXJzIGZyb20gJy4vdXBjYXN0aGVscGVycyc7CmltcG9ydCBEb3duY2FzdEhlbHBlcnMgZnJvbSAnLi9kb3duY2FzdGhlbHBlcnMnOwppbXBvcnQgdG9BcnJheSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy90b2FycmF5JzsKLyoqCiAqIEEgdXRpbGl0eSBjbGFzcyB0aGF0IGhlbHBzIGFkZCBjb252ZXJ0ZXJzIHRvIHVwY2FzdCBhbmQgZG93bmNhc3QgZGlzcGF0Y2hlcnMuCiAqCiAqIFdlIHJlY29tbWVuZCByZWFkaW5nIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lIEVkaXRpbmcgZW5naW5lIGFyY2hpdGVjdHVyZX0gZ3VpZGUgZmlyc3QgdG8KICogdW5kZXJzdGFuZCB0aGUgY29yZSBjb25jZXB0cyBvZiB0aGUgY29udmVyc2lvbiBtZWNoYW5pc21zLgogKgogKiBBbiBpbnN0YW5jZSBvZiB0aGUgY29udmVyc2lvbiBtYW5hZ2VyIGlzIGF2YWlsYWJsZSBpbiB0aGUKICoge0BsaW5rIG1vZHVsZTpjb3JlL2VkaXRvci9lZGl0b3J+RWRpdG9yI2NvbnZlcnNpb24gYGVkaXRvci5jb252ZXJzaW9uYH0gcHJvcGVydHkKICogYW5kIGJ5IGRlZmF1bHQgaGFzIHRoZSBmb2xsb3dpbmcgZ3JvdXBzIG9mIGRpc3BhdGNoZXJzIChpLmUuIGRpcmVjdGlvbnMgb2YgY29udmVyc2lvbik6CiAqCiAqICogYGRvd25jYXN0YCAoZWRpdGluZyBhbmQgZGF0YSBkb3duY2FzdHMpCiAqICogYGVkaXRpbmdEb3duY2FzdGAKICogKiBgZGF0YURvd25jYXN0YAogKiAqIGB1cGNhc3RgCiAqCiAqICMgT25lLXdheSBjb252ZXJ0ZXJzCiAqCiAqIFRvIGFkZCBhIGNvbnZlcnRlciB0byBhIHNwZWNpZmljIGdyb3VwLCB1c2UgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgZm9yKClgfQogKiBtZXRob2Q6CiAqCiAqCQkvLyBBZGQgYSBjb252ZXJ0ZXIgdG8gZWRpdGluZyBkb3duY2FzdCBhbmQgZGF0YSBkb3duY2FzdC4KICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmVsZW1lbnRUb0VsZW1lbnQoIGNvbmZpZyApICk7CiAqCiAqCQkvLyBBZGQgYSBjb252ZXJ0ZXIgdG8gdGhlIGRhdGEgcGlwZXBsaW5lIG9ubHk6CiAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkYXRhRG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggZGF0YUNvbnZlcnNpb25Db25maWcgKSApOwogKgogKgkJLy8gQW5kIGEgc2xpZ2h0bHkgZGlmZmVyZW50IG9uZSBmb3IgdGhlIGVkaXRpbmcgcGlwZWxpbmU6CiAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdlZGl0aW5nRG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggZWRpdGluZ0NvbnZlcnNpb25Db25maWcgKSApOwogKgogKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBmb3IoKWB9IG1ldGhvZCBkb2N1bWVudGF0aW9uIHRvIGxlYXJuIG1vcmUgYWJvdXQKICogYXZhaWxhYmxlIGNvbnZlcnNpb24gaGVscGVycyBhbmQgaG93IHRvIHVzZSB5b3VyIGN1c3RvbSBvbmVzLgogKgogKiAjIFR3by13YXkgY29udmVydGVycwogKgogKiBCZXNpZGVzIHVzaW5nIG9uZS13YXkgY29udmVydGVycyB2aWEgdGhlIGBmb3IoKWAgbWV0aG9kLCB5b3UgY2FuIGFsc28gdXNlIG90aGVyIG1ldGhvZHMgYXZhaWxhYmxlIGluIHRoaXMKICogY2xhc3MgdG8gYWRkIHR3by13YXkgY29udmVydGVycyAodXBjYXN0IGFuZCBkb3duY2FzdCk6CiAqCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZWxlbWVudFRvRWxlbWVudCBgZWxlbWVudFRvRWxlbWVudCgpYH0gJm5kYXNoOwogKiBNb2RlbCBlbGVtZW50IHRvIHZpZXcgZWxlbWVudCBhbmQgdmljZSB2ZXJzYS4KICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNhdHRyaWJ1dGVUb0VsZW1lbnQgYGF0dHJpYnV0ZVRvRWxlbWVudCgpYH0gJm5kYXNoOwogKiBNb2RlbCBhdHRyaWJ1dGUgdG8gdmlldyBlbGVtZW50IGFuZCB2aWNlIHZlcnNhLgogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2F0dHJpYnV0ZVRvQXR0cmlidXRlIGBhdHRyaWJ1dGVUb0F0dHJpYnV0ZSgpYH0gJm5kYXNoOwogKiBNb2RlbCBhdHRyaWJ1dGUgdG8gdmlldyBlbGVtZW50IGFuZCB2aWNlIHZlcnNhLgogKi8KCnZhciBDb252ZXJzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IGNvbnZlcnNpb24gaW5zdGFuY2UuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfAogICAqIEFycmF5Ljxtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcj59IGRvd25jYXN0RGlzcGF0Y2hlcnMKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXJ8CiAgICogQXJyYXkuPG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXI+fSB1cGNhc3REaXNwYXRjaGVycwogICAqLwogIGZ1bmN0aW9uIENvbnZlcnNpb24oZG93bmNhc3REaXNwYXRjaGVycywgdXBjYXN0RGlzcGF0Y2hlcnMpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb252ZXJzaW9uKTsKCiAgICAvKioKICAgICAqIE1hcHMgZGlzcGF0Y2hlcnMgZ3JvdXAgbmFtZSB0byBDb252ZXJzaW9uSGVscGVycyBpbnN0YW5jZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge01hcC48U3RyaW5nLG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9uaGVscGVyc35Db252ZXJzaW9uSGVscGVycz59CiAgICAgKi8KICAgIHRoaXMuX2hlbHBlcnMgPSBuZXcgTWFwKCk7IC8vIERlZmluZSBkZWZhdWx0ICdkb3duY2FzdCcgJiAndXBjYXN0JyBkaXNwYXRjaGVycyBncm91cHMuIFRob3NlIGdyb3VwcyBhcmUgYWx3YXlzIGF2YWlsYWJsZSBhcyB0d28td2F5IGNvbnZlcnRlcnMgbmVlZHMgdGhlbS4KCiAgICB0aGlzLl9kb3duY2FzdCA9IHRvQXJyYXkoZG93bmNhc3REaXNwYXRjaGVycyk7CgogICAgdGhpcy5fY3JlYXRlQ29udmVyc2lvbkhlbHBlcnMoewogICAgICBuYW1lOiAnZG93bmNhc3QnLAogICAgICBkaXNwYXRjaGVyczogdGhpcy5fZG93bmNhc3QsCiAgICAgIGlzRG93bmNhc3Q6IHRydWUKICAgIH0pOwoKICAgIHRoaXMuX3VwY2FzdCA9IHRvQXJyYXkodXBjYXN0RGlzcGF0Y2hlcnMpOwoKICAgIHRoaXMuX2NyZWF0ZUNvbnZlcnNpb25IZWxwZXJzKHsKICAgICAgbmFtZTogJ3VwY2FzdCcsCiAgICAgIGRpc3BhdGNoZXJzOiB0aGlzLl91cGNhc3QsCiAgICAgIGlzRG93bmNhc3Q6IGZhbHNlCiAgICB9KTsKICB9CiAgLyoqCiAgICogRGVmaW5lIGFuIGFsaWFzIGZvciByZWdpc3RlcmVkIGRpc3BhdGNoZXIuCiAgICoKICAgKgkJY29uc3QgY29udmVyc2lvbiA9IG5ldyBDb252ZXJzaW9uKAogICAqCQkJWyBkYXRhRG93bmNhc3REaXNwYXRjaGVyLCBlZGl0aW5nRG93bmNhc3REaXNwYXRjaGVyIF0sCiAgICoJCQl1cGNhc3REaXNwYXRjaGVyCiAgICoJCSk7CiAgICoKICAgKgkJY29udmVyc2lvbi5hZGRBbGlhcyggJ2RhdGFEb3duY2FzdCcsIGRhdGFEb3duY2FzdERpc3BhdGNoZXIgKTsKICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhcyBBbiBhbGlhcyBvZiBhIGRpc3BhdGNoZXIuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcnwKICAgKiBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyfSBkaXNwYXRjaGVyIERpc3BhdGNoZXIgd2hpY2ggc2hvdWxkIGhhdmUgYW4gYWxpYXMuCiAgICovCgoKICBfY3JlYXRlQ2xhc3MoQ29udmVyc2lvbiwgW3sKICAgIGtleTogImFkZEFsaWFzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBbGlhcyhhbGlhcywgZGlzcGF0Y2hlcikgewogICAgICB2YXIgaXNEb3duY2FzdCA9IHRoaXMuX2Rvd25jYXN0LmluY2x1ZGVzKGRpc3BhdGNoZXIpOwoKICAgICAgdmFyIGlzVXBjYXN0ID0gdGhpcy5fdXBjYXN0LmluY2x1ZGVzKGRpc3BhdGNoZXIpOwoKICAgICAgaWYgKCFpc1VwY2FzdCAmJiAhaXNEb3duY2FzdCkgewogICAgICAgIC8qKgogICAgICAgICAqIFRyeWluZyB0byByZWdpc3RlciBhbmQgYWxpYXMgZm9yIGEgZGlzcGF0Y2hlciB0aGF0IG5hcyBub3QgYmVlbiByZWdpc3RlcmVkLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIGNvbnZlcnNpb24tYWRkLWFsaWFzLWRpc3BhdGNoZXItbm90LXJlZ2lzdGVyZWQKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignY29udmVyc2lvbi1hZGQtYWxpYXMtZGlzcGF0Y2hlci1ub3QtcmVnaXN0ZXJlZCcsIHRoaXMpOwogICAgICB9CgogICAgICB0aGlzLl9jcmVhdGVDb252ZXJzaW9uSGVscGVycyh7CiAgICAgICAgbmFtZTogYWxpYXMsCiAgICAgICAgZGlzcGF0Y2hlcnM6IFtkaXNwYXRjaGVyXSwKICAgICAgICBpc0Rvd25jYXN0OiBpc0Rvd25jYXN0CiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBBUEkgdG8gYXNzaWduIGNvbnZlcnRlcnMgdG8gY29udmVyc2lvbiBkaXNwYXRjaGVycyBncm91cC4KICAgICAqCiAgICAgKiBJZiB0aGUgZ2l2ZW4gZ3JvdXAgbmFtZSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCwgdGhlCiAgICAgKiB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBgY29udmVyc2lvbi1mb3ItdW5rbm93bi1ncm91cGAgZXJyb3J9IGlzIHRocm93bi4KICAgICAqCiAgICAgKiBZb3UgY2FuIHVzZSBjb252ZXJzaW9uIGhlbHBlcnMgYXZhaWxhYmxlIGRpcmVjdGx5IGluIHRoZSBgZm9yKClgIGNoYWluIG9yIHlvdXIgY3VzdG9tIG9uZXMgdmlhCiAgICAgKiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9uaGVscGVyc35Db252ZXJzaW9uSGVscGVycyNhZGQgYGFkZCgpYH0gbWV0aG9kLgogICAgICoKICAgICAqICMgVXNpbmcgYnVsaXQtaW4gY29udmVyc2lvbiBoZWxwZXJzCiAgICAgKgogICAgICogVGhlIGBmb3IoKWAgY2hhaW4gY29tZXMgd2l0aCBhIHNldCBvZiBjb252ZXJzaW9uIGhlbHBlcnMgd2hpY2ggeW91IGNhbiB1c2UgbGlrZSB0aGlzOgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKQogICAgICoJCQkuZWxlbWVudFRvRWxlbWVudCggY29uZmlnMSApICAgICAgICAvLyBBZGRzIGFuIGVsZW1lbnQtdG8tZWxlbWVudCBkb3duY2FzdCBjb252ZXJ0ZXIuCiAgICAgKgkJCS5hdHRyaWJ1dGVUb0VsZW1lbnQoIGNvbmZpZzIgKTsgICAgIC8vIEFkZHMgYW4gYXR0cmlidXRlLXRvLWVsZW1lbnQgZG93bmNhc3QgY29udmVydGVyLgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkKICAgICAqCQkJLmVsZW1lbnRUb0F0dHJpYnV0ZSggY29uZmlnMyApOyAgICAgLy8gQWRkcyBhbiBlbGVtZW50LXRvLWF0dHJpYnV0ZSB1cGNhc3QgY29udmVydGVyLgogICAgICoKICAgICAqIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9mIGJ1aWx0LWluIGNvbnZlcnNpb24gaGVscGVycyB0byBsZWFybiBhYm91dCB0aGVpciBjb25maWd1cmF0aW9uIG9wdGlvbnMuCiAgICAgKgogICAgICogKiBkb3duY2FzdCAobW9kZWwtdG8tdmlldykgY29udmVyc2lvbiBoZWxwZXJzOgogICAgICoKICAgICAqCSoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzI2VsZW1lbnRUb0VsZW1lbnQgYGVsZW1lbnRUb0VsZW1lbnQoKWB9LAogICAgICoJKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnMjYXR0cmlidXRlVG9FbGVtZW50IGBhdHRyaWJ1dGVUb0VsZW1lbnQoKWB9LAogICAgICoJKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnMjYXR0cmlidXRlVG9BdHRyaWJ1dGUgYGF0dHJpYnV0ZVRvQXR0cmlidXRlKClgfS4KICAgICAqCSoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzI21hcmtlclRvRWxlbWVudCBgbWFya2VyVG9FbGVtZW50KClgfS4KICAgICAqCSoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzI21hcmtlclRvSGlnaGxpZ2h0IGBtYXJrZXJUb0hpZ2hsaWdodCgpYH0uCiAgICAgKgogICAgICogKiB1cGNhc3QgKHZpZXctdG8tbW9kZWwpIGNvbnZlcnNpb24gaGVscGVyczoKICAgICAqCiAgICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb0VsZW1lbnQgYGVsZW1lbnRUb0VsZW1lbnQoKWB9LAogICAgICoJKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVycyNlbGVtZW50VG9BdHRyaWJ1dGUgYGVsZW1lbnRUb0F0dHJpYnV0ZSgpYH0sCiAgICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2F0dHJpYnV0ZVRvQXR0cmlidXRlIGBhdHRyaWJ1dGVUb0F0dHJpYnV0ZSgpYH0uCiAgICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb01hcmtlciBgZWxlbWVudFRvTWFya2VyKClgfS4KICAgICAqCiAgICAgKiAjIFVzaW5nIGN1c3RvbSBjb252ZXJzaW9uIGhlbHBlcnMKICAgICAqCiAgICAgKiBJZiB5b3UgbmVlZCB0byBpbXBsZW1lbnQgYSBub250eXBpY2FsIGNvbnZlcnRlciwgeW91IGNhbiBkbyBzbyBieSBjYWxsaW5nOgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoIGRpcmVjdGlvbiApLmFkZCggY3VzdG9tSGVscGVyICk7CiAgICAgKgogICAgICogVGhlIGAuYWRkKClgIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBwYXJhbWV0ZXIsIHdoaWNoIGlzIGEgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGFjY2VwdCBvbmUgcGFyYW1ldGVyIHRoYXQKICAgICAqIGlzIGEgZGlzcGF0Y2hlciBpbnN0YW5jZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCBhZGQgYW4gYWN0dWFsIGNvbnZlcnRlciB0byB0aGUgcGFzc2VkIGRpc3BhdGNoZXIgaW5zdGFuY2UuCiAgICAgKgogICAgICogRXhhbXBsZToKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmFkZCggZGlzcGF0Y2hlciA9PiB7CiAgICAgKgkJCWRpc3BhdGNoZXIub24oICdlbGVtZW50OmEnLCAgKCBldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkgKSA9PiB7CiAgICAgKgkJCQkvLyBEbyBzb21ldGhpbmcgd2l0aCBhIHZpZXcgPGE+IGVsZW1lbnQuCiAgICAgKgkJCX0gKTsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24gb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXJ9CiAgICAgKiBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfSB0byBsZWFybiBob3cgdG8gd3JpdGUKICAgICAqIGN1c3RvbSBjb252ZXJ0ZXJzLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgVGhlIG5hbWUgb2YgZGlzcGF0Y2hlcnMgZ3JvdXAgdG8gYWRkIHRoZSBjb252ZXJ0ZXJzIHRvLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzfG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnN9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZm9yIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9yKGdyb3VwTmFtZSkgewogICAgICBpZiAoIXRoaXMuX2hlbHBlcnMuaGFzKGdyb3VwTmFtZSkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUcnlpbmcgdG8gYWRkIGEgY29udmVydGVyIHRvIGFuIHVua25vd24gZGlzcGF0Y2hlcnMgZ3JvdXAuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgY29udmVyc2lvbi1mb3ItdW5rbm93bi1ncm91cAogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdjb252ZXJzaW9uLWZvci11bmtub3duLWdyb3VwJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLl9oZWxwZXJzLmdldChncm91cE5hbWUpOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIHVwIGNvbnZlcnRlcnMgYmV0d2VlbiB0aGUgbW9kZWwgYW5kIHRoZSB2aWV3IHRoYXQgY29udmVydCBhIG1vZGVsIGVsZW1lbnQgdG8gYSB2aWV3IGVsZW1lbnQgKGFuZCB2aWNlIHZlcnNhKS4KICAgICAqIEZvciBleGFtcGxlLCB0aGUgbW9kZWwgYDxwYXJhZ3JhcGg+Rm9vPC9wYXJhZ3JhcGg+YCBpcyBgPHA+Rm9vPC9wPmAgaW4gdGhlIHZpZXcuCiAgICAgKgogICAgICoJCS8vIEEgc2ltcGxlIGNvbnZlcnNpb24gZnJvbSB0aGUgYHBhcmFncmFwaGAgbW9kZWwgZWxlbWVudCB0byB0aGUgYDxwPmAgdmlldyBlbGVtZW50IChhbmQgdmljZSB2ZXJzYSkuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZWxlbWVudFRvRWxlbWVudCggeyBtb2RlbDogJ3BhcmFncmFwaCcsIHZpZXc6ICdwJyB9ICk7CiAgICAgKgogICAgICoJCS8vIE92ZXJyaWRlIG90aGVyIGNvbnZlcnRlcnMgYnkgc3BlY2lmeWluZyBhIGNvbnZlcnRlciBkZWZpbml0aW9uIHdpdGggYSBoaWdoZXIgcHJpb3JpdHkuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZWxlbWVudFRvRWxlbWVudCggeyBtb2RlbDogJ3BhcmFncmFwaCcsIHZpZXc6ICdkaXYnLCBjb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnIH0gKTsKICAgICAqCiAgICAgKgkJLy8gVmlldyBzcGVjaWZpZWQgYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYSBzdHJpbmcuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZWxlbWVudFRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ2ZhbmN5UGFyYWdyYXBoJywKICAgICAqCQkJdmlldzogewogICAgICoJCQkJbmFtZTogJ3AnLAogICAgICoJCQkJY2xhc3NlczogJ2ZhbmN5JwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBVc2UgYHVwY2FzdEFsc29gIHRvIGRlZmluZSBvdGhlciB2aWV3IGVsZW1lbnRzIHRoYXQgc2hvdWxkIGFsc28gYmUgY29udmVydGVkIHRvIGEgYHBhcmFncmFwaGAgZWxlbWVudC4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5lbGVtZW50VG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAncGFyYWdyYXBoJywKICAgICAqCQkJdmlldzogJ3AnLAogICAgICoJCQl1cGNhc3RBbHNvOiBbCiAgICAgKgkJCQknZGl2JywKICAgICAqCQkJCXsKICAgICAqCQkJCQkvLyBBbnkgZWxlbWVudCB3aXRoIHRoZSBgZGlzcGxheTogYmxvY2tgIHN0eWxlLgogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQlkaXNwbGF5OiAnYmxvY2snCiAgICAgKgkJCQkJfQogICAgICoJCQkJfQogICAgICoJCQldCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBgdXBjYXN0QWxzb2Agc2V0IGFzIGNhbGxiYWNrIGVuYWJsZXMgYSBjb252ZXJzaW9uIG9mIGEgd2lkZSByYW5nZSBvZiBkaWZmZXJlbnQgdmlldyBlbGVtZW50cy4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5lbGVtZW50VG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnaGVhZGluZycsCiAgICAgKgkJCXZpZXc6ICdoMicsCiAgICAgKgkJCS8vIENvbnZlcnQgImhlYWRpbmctbGlrZSIgcGFyYWdyYXBocyB0byBoZWFkaW5ncy4KICAgICAqCQkJdXBjYXN0QWxzbzogdmlld0VsZW1lbnQgPT4gewogICAgICoJCQkJY29uc3QgZm9udFNpemUgPSB2aWV3RWxlbWVudC5nZXRTdHlsZSggJ2ZvbnQtc2l6ZScgKTsKICAgICAqCiAgICAgKgkJCQlpZiAoICFmb250U2l6ZSApIHsKICAgICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCX0KICAgICAqCiAgICAgKgkJCQljb25zdCBtYXRjaCA9IGZvbnRTaXplLm1hdGNoKCAvKFxkKylccypweC8gKTsKICAgICAqCiAgICAgKgkJCQlpZiAoICFtYXRjaCApIHsKICAgICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCX0KICAgICAqCiAgICAgKgkJCQljb25zdCBzaXplID0gTnVtYmVyKCBtYXRjaFsgMSBdICk7CiAgICAgKgogICAgICoJCQkJaWYgKCBzaXplID4gMjYgKSB7CiAgICAgKgkJCQkJLy8gUmV0dXJuZWQgdmFsdWUgY2FuIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBtYXRjaGVkIHByb3BlcnRpZXMuCiAgICAgKgkJCQkJLy8gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlICJjb25zdW1lZCIgZHVyaW5nIHRoZSBjb252ZXJzaW9uLgogICAgICoJCQkJCS8vIFNlZSBgZW5naW5lLnZpZXcuTWF0Y2hlcn5NYXRjaGVyUGF0dGVybmAgYW5kIGBlbmdpbmUudmlldy5NYXRjaGVyI21hdGNoYCBmb3IgbW9yZSBkZXRhaWxzLgogICAgICoKICAgICAqCQkJCQlyZXR1cm4geyBuYW1lOiB0cnVlLCBzdHlsZXM6IFsgJ2ZvbnQtc2l6ZScgXSB9OwogICAgICoJCQkJfQogICAgICoKICAgICAqCQkJCXJldHVybiBudWxsOwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIGBkZWZpbml0aW9uLm1vZGVsYCBpcyBhIGBTdHJpbmdgIHdpdGggYSBtb2RlbCBlbGVtZW50IG5hbWUgdG8gY29udmVydCBmcm9tIG9yIHRvLgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9ufSB0byBsZWFybiBhYm91dCBvdGhlciBwYXJhbWV0ZXJzLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVydGVyRGVmaW5pdGlvbn0gZGVmaW5pdGlvbiBUaGUgY29udmVydGVyIGRlZmluaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZWxlbWVudFRvRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudFRvRWxlbWVudChkZWZpbml0aW9uKSB7CiAgICAgIC8vIFNldCB1cCBkb3duY2FzdCBjb252ZXJ0ZXIuCiAgICAgIHRoaXMuZm9yKCdkb3duY2FzdCcpLmVsZW1lbnRUb0VsZW1lbnQoZGVmaW5pdGlvbik7IC8vIFNldCB1cCB1cGNhc3QgY29udmVydGVyLgoKICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF9nZXRBbGxVcGNhc3REZWZpbml0aW9ucyhkZWZpbml0aW9uKSksCiAgICAgICAgICBfc3RlcDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLAogICAgICAgICAgICAgIG1vZGVsID0gX3N0ZXAkdmFsdWUubW9kZWwsCiAgICAgICAgICAgICAgdmlldyA9IF9zdGVwJHZhbHVlLnZpZXc7CiAgICAgICAgICB0aGlzLmZvcigndXBjYXN0JykuZWxlbWVudFRvRWxlbWVudCh7CiAgICAgICAgICAgIG1vZGVsOiBtb2RlbCwKICAgICAgICAgICAgdmlldzogdmlldywKICAgICAgICAgICAgY29udmVydGVyUHJpb3JpdHk6IGRlZmluaXRpb24uY29udmVydGVyUHJpb3JpdHkKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdXAgY29udmVydGVycyBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdGhlIHZpZXcgdGhhdCBjb252ZXJ0IGEgbW9kZWwgYXR0cmlidXRlIHRvIGEgdmlldyBlbGVtZW50IChhbmQgdmljZSB2ZXJzYSkuCiAgICAgKiBGb3IgZXhhbXBsZSwgYSBtb2RlbCB0ZXh0IG5vZGUgd2l0aCBgIkZvbyJgIGFzIGRhdGEgYW5kIHRoZSBgYm9sZGAgYXR0cmlidXRlIGlzIGA8c3Ryb25nPkZvbzwvc3Ryb25nPmAgaW4gdGhlIHZpZXcuCiAgICAgKgogICAgICoJCS8vIEEgc2ltcGxlIGNvbnZlcnNpb24gZnJvbSB0aGUgYGJvbGQ9dHJ1ZWAgYXR0cmlidXRlIHRvIHRoZSBgPHN0cm9uZz5gIHZpZXcgZWxlbWVudCAoYW5kIHZpY2UgdmVyc2EpLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggeyBtb2RlbDogJ2JvbGQnLCB2aWV3OiAnc3Ryb25nJyB9ICk7CiAgICAgKgogICAgICoJCS8vIE92ZXJyaWRlIG90aGVyIGNvbnZlcnRlcnMgYnkgc3BlY2lmeWluZyBhIGNvbnZlcnRlciBkZWZpbml0aW9uIHdpdGggYSBoaWdoZXIgcHJpb3JpdHkuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uYXR0cmlidXRlVG9FbGVtZW50KCB7IG1vZGVsOiAnYm9sZCcsIHZpZXc6ICdiJywgY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAgICAgKgogICAgICoJCS8vIFZpZXcgc3BlY2lmaWVkIGFzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ2JvbGQnLAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQljbGFzc2VzOiAnYm9sZCcKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJLy8gVXNlIGBjb25maWcubW9kZWwubmFtZWAgdG8gZGVmaW5lIHRoZSBjb252ZXJzaW9uIG9ubHkgZnJvbSBhIGdpdmVuIG5vZGUgdHlwZSwgYCR0ZXh0YCBpbiB0aGlzIGNhc2UuCiAgICAgKgkJLy8gVGhlIHNhbWUgYXR0cmlidXRlIG9uIGRpZmZlcmVudCBlbGVtZW50cyBtYXkgdGhlbiBiZSBoYW5kbGVkIGJ5IGEgZGlmZmVyZW50IGNvbnZlcnRlci4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6IHsKICAgICAqCQkJCWtleTogJ3RleHREZWNvcmF0aW9uJywKICAgICAqCQkJCXZhbHVlczogWyAndW5kZXJsaW5lJywgJ2xpbmVUaHJvdWdoJyBdLAogICAgICoJCQkJbmFtZTogJyR0ZXh0JwogICAgICoJCQl9LAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQl1bmRlcmxpbmU6IHsKICAgICAqCQkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQkJc3R5bGVzOiB7CiAgICAgKgkJCQkJCSd0ZXh0LWRlY29yYXRpb24nOiAndW5kZXJsaW5lJwogICAgICoJCQkJCX0KICAgICAqCQkJCX0sCiAgICAgKgkJCQlsaW5lVGhyb3VnaDogewogICAgICoJCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCQlzdHlsZXM6IHsKICAgICAqCQkJCQkJJ3RleHQtZGVjb3JhdGlvbic6ICdsaW5lLXRocm91Z2gnCiAgICAgKgkJCQkJfQogICAgICoJCQkJfQogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBVc2UgYHVwY2FzdEFsc29gIHRvIGRlZmluZSBvdGhlciB2aWV3IGVsZW1lbnRzIHRoYXQgc2hvdWxkIGFsc28gYmUgY29udmVydGVkIHRvIHRoZSBgYm9sZGAgYXR0cmlidXRlLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ2JvbGQnLAogICAgICoJCQl2aWV3OiAnc3Ryb25nJywKICAgICAqCQkJdXBjYXN0QWxzbzogWwogICAgICoJCQkJJ2InLAogICAgICoJCQkJewogICAgICoJCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCQljbGFzc2VzOiAnYm9sZCcKICAgICAqCQkJCX0sCiAgICAgKgkJCQl7CiAgICAgKgkJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQknZm9udC13ZWlnaHQnOiAnYm9sZCcKICAgICAqCQkJCQl9CiAgICAgKgkJCQl9LAogICAgICoJCQkJdmlld0VsZW1lbnQgPT4gewogICAgICoJCQkJCWNvbnN0IGZvbnRXZWlnaHQgPSB2aWV3RWxlbWVudC5nZXRTdHlsZSggJ2ZvbnQtd2VpZ2h0JyApOwogICAgICoKICAgICAqCQkJCQlpZiAoIHZpZXdFbGVtZW50LmlzKCAnZWxlbWVudCcsICdzcGFuJyApICYmIGZvbnRXZWlnaHQgJiYgL1xkKy8udGVzdCgpICYmIE51bWJlciggZm9udFdlaWdodCApID4gNTAwICkgewogICAgICoJCQkJCQkvLyBSZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gb2JqZWN0IHdpdGggdGhlIG1hdGNoZWQgcHJvcGVydGllcy4KICAgICAqCQkJCQkJLy8gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlICJjb25zdW1lZCIgZHVyaW5nIHRoZSBjb252ZXJzaW9uLgogICAgICoJCQkJCQkvLyBTZWUgYGVuZ2luZS52aWV3Lk1hdGNoZXJ+TWF0Y2hlclBhdHRlcm5gIGFuZCBgZW5naW5lLnZpZXcuTWF0Y2hlciNtYXRjaGAgZm9yIG1vcmUgZGV0YWlscy4KICAgICAqCiAgICAgKgkJCQkJCXJldHVybiB7CiAgICAgKgkJCQkJCQluYW1lOiB0cnVlLAogICAgICoJCQkJCQkJc3R5bGVzOiBbICdmb250LXdlaWdodCcgXQogICAgICoJCQkJCQl9OwogICAgICoJCQkJCX0KICAgICAqCQkJCX0KICAgICAqCQkJXQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJLy8gQ29udmVyc2lvbiBmcm9tIGFuZCB0byBhIG1vZGVsIGF0dHJpYnV0ZSBrZXkgd2hvc2UgdmFsdWUgaXMgYW4gZW51bSAoYGZvbnRTaXplPWJpZ3xzbWFsbGApLgogICAgICoJCS8vIGB1cGNhc3RBbHNvYCBzZXQgYXMgY2FsbGJhY2sgZW5hYmxlcyBhIGNvbnZlcnNpb24gb2YgYSB3aWRlIHJhbmdlIG9mIGRpZmZlcmVudCB2aWV3IGVsZW1lbnRzLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogewogICAgICoJCQkJa2V5OiAnZm9udFNpemUnLAogICAgICoJCQkJdmFsdWVzOiBbICdiaWcnLCAnc21hbGwnIF0KICAgICAqCQkJfSwKICAgICAqCQkJdmlldzogewogICAgICoJCQkJYmlnOiB7CiAgICAgKgkJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQknZm9udC1zaXplJzogJzEuMmVtJwogICAgICoJCQkJCX0KICAgICAqCQkJCX0sCiAgICAgKgkJCQlzbWFsbDogewogICAgICoJCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCQlzdHlsZXM6IHsKICAgICAqCQkJCQkJJ2ZvbnQtc2l6ZSc6ICcwLjhlbScKICAgICAqCQkJCQl9CiAgICAgKgkJCQl9CiAgICAgKgkJCX0sCiAgICAgKgkJCXVwY2FzdEFsc286IHsKICAgICAqCQkJCWJpZzogdmlld0VsZW1lbnQgPT4gewogICAgICoJCQkJCWNvbnN0IGZvbnRTaXplID0gdmlld0VsZW1lbnQuZ2V0U3R5bGUoICdmb250LXNpemUnICk7CiAgICAgKgogICAgICoJCQkJCWlmICggIWZvbnRTaXplICkgewogICAgICoJCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCQl9CiAgICAgKgogICAgICoJCQkJCWNvbnN0IG1hdGNoID0gZm9udFNpemUubWF0Y2goIC8oXGQrKVxzKnB4LyApOwogICAgICoKICAgICAqCQkJCQlpZiAoICFtYXRjaCApIHsKICAgICAqCQkJCQkJcmV0dXJuIG51bGw7CiAgICAgKgkJCQkJfQogICAgICoKICAgICAqCQkJCQljb25zdCBzaXplID0gTnVtYmVyKCBtYXRjaFsgMSBdICk7CiAgICAgKgogICAgICoJCQkJCWlmICggdmlld0VsZW1lbnQuaXMoICdlbGVtZW50JywgJ3NwYW4nICkgJiYgc2l6ZSA+IDEwICkgewogICAgICoJCQkJCQkvLyBSZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gb2JqZWN0IHdpdGggdGhlIG1hdGNoZWQgcHJvcGVydGllcy4KICAgICAqCQkJCQkJLy8gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlICJjb25zdW1lZCIgZHVyaW5nIHRoZSBjb252ZXJzaW9uLgogICAgICoJCQkJCQkvLyBTZWUgYGVuZ2luZS52aWV3Lk1hdGNoZXJ+TWF0Y2hlclBhdHRlcm5gIGFuZCBgZW5naW5lLnZpZXcuTWF0Y2hlciNtYXRjaGAgZm9yIG1vcmUgZGV0YWlscy4KICAgICAqCiAgICAgKgkJCQkJCXJldHVybiB7IG5hbWU6IHRydWUsIHN0eWxlczogWyAnZm9udC1zaXplJyBdIH07CiAgICAgKgkJCQkJfQogICAgICoKICAgICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCX0sCiAgICAgKgkJCQlzbWFsbDogdmlld0VsZW1lbnQgPT4gewogICAgICoJCQkJCWNvbnN0IGZvbnRTaXplID0gdmlld0VsZW1lbnQuZ2V0U3R5bGUoICdmb250LXNpemUnICk7CiAgICAgKgogICAgICoJCQkJCWlmICggIWZvbnRTaXplICkgewogICAgICoJCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCQl9CiAgICAgKgogICAgICoJCQkJCWNvbnN0IG1hdGNoID0gZm9udFNpemUubWF0Y2goIC8oXGQrKVxzKnB4LyApOwogICAgICoKICAgICAqCQkJCQlpZiAoICFtYXRjaCApIHsKICAgICAqCQkJCQkJcmV0dXJuIG51bGw7CiAgICAgKgkJCQkJfQogICAgICoKICAgICAqCQkJCQljb25zdCBzaXplID0gTnVtYmVyKCBtYXRjaFsgMSBdICk7CiAgICAgKgogICAgICoJCQkJCWlmICggdmlld0VsZW1lbnQuaXMoICdlbGVtZW50JywgJ3NwYW4nICkgJiYgc2l6ZSA8IDEwICkgewogICAgICoJCQkJCQkvLyBSZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gb2JqZWN0IHdpdGggdGhlIG1hdGNoZWQgcHJvcGVydGllcy4KICAgICAqCQkJCQkJLy8gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlICJjb25zdW1lZCIgZHVyaW5nIHRoZSBjb252ZXJzaW9uLgogICAgICoJCQkJCQkvLyBTZWUgYGVuZ2luZS52aWV3Lk1hdGNoZXJ+TWF0Y2hlclBhdHRlcm5gIGFuZCBgZW5naW5lLnZpZXcuTWF0Y2hlciNtYXRjaGAgZm9yIG1vcmUgZGV0YWlscy4KICAgICAqCiAgICAgKgkJCQkJCXJldHVybiB7IG5hbWU6IHRydWUsIHN0eWxlczogWyAnZm9udC1zaXplJyBdIH07CiAgICAgKgkJCQkJfQogICAgICoKICAgICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCX0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBUaGUgYGRlZmluaXRpb24ubW9kZWxgIHBhcmFtZXRlciBzcGVjaWZpZXMgd2hpY2ggbW9kZWwgYXR0cmlidXRlIHNob3VsZCBiZSBjb252ZXJ0ZWQgZnJvbSBvciB0by4gSXQgY2FuIGJlIGEgYHsga2V5LCB2YWx1ZSB9YCBvYmplY3QKICAgICAqIGRlc2NyaWJpbmcgdGhlIGF0dHJpYnV0ZSBrZXkgYW5kIHZhbHVlIHRvIGNvbnZlcnQgb3IgYSBgU3RyaW5nYCBzcGVjaWZ5aW5nIGp1c3QgdGhlIGF0dHJpYnV0ZSBrZXkgKHRoZW4gYHZhbHVlYCBpcyBzZXQgdG8gYHRydWVgKS4KICAgICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVydGVyRGVmaW5pdGlvbn0gdG8gbGVhcm4gYWJvdXQgb3RoZXIgcGFyYW1ldGVycy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnRlckRlZmluaXRpb259IGRlZmluaXRpb24gVGhlIGNvbnZlcnRlciBkZWZpbml0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogImF0dHJpYnV0ZVRvRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlVG9FbGVtZW50KGRlZmluaXRpb24pIHsKICAgICAgLy8gU2V0IHVwIGRvd25jYXN0IGNvbnZlcnRlci4KICAgICAgdGhpcy5mb3IoJ2Rvd25jYXN0JykuYXR0cmlidXRlVG9FbGVtZW50KGRlZmluaXRpb24pOyAvLyBTZXQgdXAgdXBjYXN0IGNvbnZlcnRlci4KCiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX2dldEFsbFVwY2FzdERlZmluaXRpb25zKGRlZmluaXRpb24pKSwKICAgICAgICAgIF9zdGVwMjsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc3RlcDIudmFsdWUsCiAgICAgICAgICAgICAgbW9kZWwgPSBfc3RlcDIkdmFsdWUubW9kZWwsCiAgICAgICAgICAgICAgdmlldyA9IF9zdGVwMiR2YWx1ZS52aWV3OwogICAgICAgICAgdGhpcy5mb3IoJ3VwY2FzdCcpLmVsZW1lbnRUb0F0dHJpYnV0ZSh7CiAgICAgICAgICAgIHZpZXc6IHZpZXcsCiAgICAgICAgICAgIG1vZGVsOiBtb2RlbCwKICAgICAgICAgICAgY29udmVydGVyUHJpb3JpdHk6IGRlZmluaXRpb24uY29udmVydGVyUHJpb3JpdHkKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU2V0cyB1cCBjb252ZXJ0ZXJzIGJldHdlZW4gdGhlIG1vZGVsIGFuZCB0aGUgdmlldyB0aGF0IGNvbnZlcnQgYSBtb2RlbCBhdHRyaWJ1dGUgdG8gYSB2aWV3IGF0dHJpYnV0ZSAoYW5kIHZpY2UgdmVyc2EpLgogICAgICogRm9yIGV4YW1wbGUsIGA8aW1hZ2Ugc3JjPSdmb28uanBnJz48L2ltYWdlPmAgaXMgY29udmVydGVkIHRvIGA8aW1nIHNyYz0nZm9vLmpwZyc+PC9pbWc+YCAodGhlIHNhbWUgYXR0cmlidXRlIGtleSBhbmQgdmFsdWUpLgogICAgICogVGhpcyB0eXBlIG9mIGNvbnZlcnRlcnMgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBtb2RlbCBlbGVtZW50fSBub2Rlcy4KICAgICAqIFRvIGNvbnZlcnQgdGV4dCBhdHRyaWJ1dGVzIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2F0dHJpYnV0ZVRvRWxlbWVudCBgYXR0cmlidXRlVG9FbGVtZW50IGNvbnZlcnRlcmB9CiAgICAgKiBzaG91bGQgYmUgc2V0IHVwLgogICAgICoKICAgICAqCQkvLyBBIHNpbXBsZSBjb252ZXJzaW9uIGZyb20gdGhlIGBzb3VyY2VgIG1vZGVsIGF0dHJpYnV0ZSB0byB0aGUgYHNyY2AgdmlldyBhdHRyaWJ1dGUgKGFuZCB2aWNlIHZlcnNhKS4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggeyBtb2RlbDogJ3NvdXJjZScsIHZpZXc6ICdzcmMnIH0gKTsKICAgICAqCiAgICAgKgkJLy8gQXR0cmlidXRlIHZhbHVlcyBhcmUgc3RyaWN0bHkgc3BlY2lmaWVkLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQluYW1lOiAnaW1hZ2UnLAogICAgICoJCQkJa2V5OiAnYXNpZGUnLAogICAgICoJCQkJdmFsdWVzOiBbICdhc2lkZScgXQogICAgICoJCQl9LAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQlhc2lkZTogewogICAgICoJCQkJCW5hbWU6ICdpbWcnLAogICAgICoJCQkJCWtleTogJ2NsYXNzJywKICAgICAqCQkJCQl2YWx1ZTogWyAnYXNpZGUnLCAnaGFsZi1zaXplJyBdCiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIFNldCB0aGUgc3R5bGUgYXR0cmlidXRlLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQluYW1lOiAnaW1hZ2UnLAogICAgICoJCQkJa2V5OiAnYXNpZGUnLAogICAgICoJCQkJdmFsdWVzOiBbICdhc2lkZScgXQogICAgICoJCQl9LAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQlhc2lkZTogewogICAgICoJCQkJCW5hbWU6ICdpbWcnLAogICAgICoJCQkJCWtleTogJ3N0eWxlJywKICAgICAqCQkJCQl2YWx1ZTogewogICAgICoJCQkJCQlmbG9hdDogJ3JpZ2h0JywKICAgICAqCQkJCQkJd2lkdGg6ICc1MCUnLAogICAgICoJCQkJCQltYXJnaW46ICc1cHgnCiAgICAgKgkJCQkJfQogICAgICoJCQkJfQogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBDb252ZXJzaW9uIGZyb20gYW5kIHRvIGEgbW9kZWwgYXR0cmlidXRlIGtleSB3aG9zZSB2YWx1ZSBpcyBhbiBlbnVtIChgYWxpZ249cmlnaHR8Y2VudGVyYCkuCiAgICAgKgkJLy8gVXNlIGB1cGNhc3RBbHNvYCB0byBkZWZpbmUgb3RoZXIgdmlldyBlbGVtZW50cyB0aGF0IHNob3VsZCBhbHNvIGJlIGNvbnZlcnRlZCB0byB0aGUgYGFsaWduPXJpZ2h0YCBhdHRyaWJ1dGUuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJbW9kZWw6IHsKICAgICAqCQkJCWtleTogJ2FsaWduJywKICAgICAqCQkJCXZhbHVlczogWyAncmlnaHQnLCAnY2VudGVyJyBdCiAgICAgKgkJCX0sCiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCXJpZ2h0OiB7CiAgICAgKgkJCQkJa2V5OiAnY2xhc3MnLAogICAgICoJCQkJCXZhbHVlOiAnYWxpZ24tcmlnaHQnCiAgICAgKgkJCQl9LAogICAgICoJCQkJY2VudGVyOiB7CiAgICAgKgkJCQkJa2V5OiAnY2xhc3MnLAogICAgICoJCQkJCXZhbHVlOiAnYWxpZ24tY2VudGVyJwogICAgICoJCQkJfQogICAgICoJCQl9LAogICAgICoJCQl1cGNhc3RBbHNvOiB7CiAgICAgKgkJCQlyaWdodDogewogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQkndGV4dC1hbGlnbic6ICdyaWdodCcKICAgICAqCQkJCQl9CiAgICAgKgkJCQl9LAogICAgICoJCQkJY2VudGVyOiB7CiAgICAgKgkJCQkJc3R5bGVzOiB7CiAgICAgKgkJCQkJCSd0ZXh0LWFsaWduJzogJ2NlbnRlcicKICAgICAqCQkJCQl9CiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogVGhlIGBkZWZpbml0aW9uLm1vZGVsYCBwYXJhbWV0ZXIgc3BlY2lmaWVzIHdoaWNoIG1vZGVsIGF0dHJpYnV0ZSBzaG91bGQgYmUgY29udmVydGVkIGZyb20gYW5kIHRvLgogICAgICogSXQgY2FuIGJlIGEgYHsga2V5LCBbIHZhbHVlcyBdLCBbIG5hbWUgXSB9YCBvYmplY3Qgb3IgYSBgU3RyaW5nYCwgd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGxpa2UgYHsga2V5OiBkZWZpbml0aW9uLm1vZGVsIH1gLgogICAgICogVGhlIGBrZXlgIHByb3BlcnR5IGlzIHRoZSBtb2RlbCBhdHRyaWJ1dGUga2V5IHRvIGNvbnZlcnQgZnJvbSBhbmQgdG8uCiAgICAgKiBUaGUgYHZhbHVlc2AgYXJlIHRoZSBwb3NzaWJsZSBtb2RlbCBhdHRyaWJ1dGUgdmFsdWVzLiBJZiBgdmFsdWVzYCBpcyBub3Qgc2V0LCB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlCiAgICAgKiB2aWV3IGF0dHJpYnV0ZSB2YWx1ZS4KICAgICAqIElmIGBuYW1lYCBpcyBzZXQsIHRoZSBjb252ZXJzaW9uIHdpbGwgYmUgc2V0IHVwIG9ubHkgZm9yIG1vZGVsIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIG5hbWUuCiAgICAgKgogICAgICogVGhlIGBkZWZpbml0aW9uLnZpZXdgIHBhcmFtZXRlciBzcGVjaWZpZXMgd2hpY2ggdmlldyBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnZlcnRlZCBmcm9tIGFuZCB0by4KICAgICAqIEl0IGNhbiBiZSBhIGB7IGtleSwgdmFsdWUsIFsgbmFtZSBdIH1gIG9iamVjdCBvciBhIGBTdHJpbmdgLCB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgbGlrZSBgeyBrZXk6IGRlZmluaXRpb24udmlldyB9YC4KICAgICAqIFRoZSBga2V5YCBwcm9wZXJ0eSBpcyB0aGUgdmlldyBhdHRyaWJ1dGUga2V5IHRvIGNvbnZlcnQgZnJvbSBhbmQgdG8uCiAgICAgKiBUaGUgYHZhbHVlYCBpcyB0aGUgdmlldyBhdHRyaWJ1dGUgdmFsdWUgdG8gY29udmVydCBmcm9tIGFuZCB0by4gSWYgYGRlZmluaXRpb24udmFsdWVgIGlzIG5vdCBzZXQsIHRoZSB2aWV3IGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlCiAgICAgKiB0aGUgc2FtZSBhcyB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlLgogICAgICogSWYgYGtleWAgaXMgYCdjbGFzcydgLCBgdmFsdWVgIGNhbiBiZSBhIGBTdHJpbmdgIG9yIGFuIGFycmF5IG9mIGBTdHJpbmdgcy4KICAgICAqIElmIGBrZXlgIGlzIGAnc3R5bGUnYCwgYHZhbHVlYCBpcyBhbiBvYmplY3Qgd2l0aCBrZXktdmFsdWUgcGFpcnMuCiAgICAgKiBJbiBvdGhlciBjYXNlcywgYHZhbHVlYCBpcyBhIGBTdHJpbmdgLgogICAgICogSWYgYG5hbWVgIGlzIHNldCwgdGhlIGNvbnZlcnNpb24gd2lsbCBiZSBzZXQgdXAgb25seSBmb3IgbW9kZWwgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gbmFtZS4KICAgICAqIElmIGBkZWZpbml0aW9uLm1vZGVsLnZhbHVlc2AgaXMgc2V0LCBgZGVmaW5pdGlvbi52aWV3YCBpcyBhbiBvYmplY3QgdGhhdCBhc3NpZ25zIHZhbHVlcyBmcm9tIGBkZWZpbml0aW9uLm1vZGVsLnZhbHVlc2AKICAgICAqIHRvIGB7IGtleSwgdmFsdWUsIFsgbmFtZSBdIH1gIG9iamVjdHMuCiAgICAgKgogICAgICogYGRlZmluaXRpb24udXBjYXN0QWxzb2Agc3BlY2lmaWVzIHdoaWNoIG90aGVyIG1hdGNoaW5nIHZpZXcgZWxlbWVudHMgc2hvdWxkIGFsc28gYmUgdXBjYXN0IHRvIHRoZSBnaXZlbiBtb2RlbCBjb25maWd1cmF0aW9uLgogICAgICogSWYgYGRlZmluaXRpb24ubW9kZWwudmFsdWVzYCBpcyBzZXQsIGBkZWZpbml0aW9uLnVwY2FzdEFsc29gIHNob3VsZCBiZSBhbiBvYmplY3QgYXNzaWduaW5nIHZhbHVlcyBmcm9tIGBkZWZpbml0aW9uLm1vZGVsLnZhbHVlc2AKICAgICAqIHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybn1zIG9yIGFycmF5cyBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59cy4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogYGRlZmluaXRpb24ubW9kZWxgIGFuZCBgZGVmaW5pdGlvbi52aWV3YCBmb3JtIHNob3VsZCBiZSBtaXJyb3JlZCwgc28gdGhlIHNhbWUgdHlwZXMgb2YgcGFyYW1ldGVycyBzaG91bGQKICAgICAqIGJlIGdpdmVuIGluIGJvdGggcGFyYW1ldGVycy4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiBUaGUgY29udmVydGVyIGRlZmluaXRpb24uCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRlZmluaXRpb24ubW9kZWwgVGhlIG1vZGVsIGF0dHJpYnV0ZSB0byBjb252ZXJ0IGZyb20gYW5kIHRvLgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkZWZpbml0aW9uLnZpZXcgVGhlIHZpZXcgYXR0cmlidXRlIHRvIGNvbnZlcnQgZnJvbSBhbmQgdG8uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufEFycmF5Ljxtb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybj59IFtkZWZpbml0aW9uLnVwY2FzdEFsc29dCiAgICAgKiBBbnkgdmlldyBlbGVtZW50IG1hdGNoaW5nIGBkZWZpbml0aW9uLnVwY2FzdEFsc29gIHdpbGwgYWxzbyBiZSBjb252ZXJ0ZWQgdG8gdGhlIGdpdmVuIG1vZGVsIGF0dHJpYnV0ZS4gYGRlZmluaXRpb24udXBjYXN0QWxzb2AKICAgICAqIGlzIHVzZWQgb25seSBpZiBgY29uZmlnLm1vZGVsLnZhbHVlc2AgaXMgc3BlY2lmaWVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogImF0dHJpYnV0ZVRvQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVUb0F0dHJpYnV0ZShkZWZpbml0aW9uKSB7CiAgICAgIC8vIFNldCB1cCBkb3duY2FzdCBjb252ZXJ0ZXIuCiAgICAgIHRoaXMuZm9yKCdkb3duY2FzdCcpLmF0dHJpYnV0ZVRvQXR0cmlidXRlKGRlZmluaXRpb24pOyAvLyBTZXQgdXAgdXBjYXN0IGNvbnZlcnRlci4KCiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX2dldEFsbFVwY2FzdERlZmluaXRpb25zKGRlZmluaXRpb24pKSwKICAgICAgICAgIF9zdGVwMzsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc3RlcDMudmFsdWUsCiAgICAgICAgICAgICAgbW9kZWwgPSBfc3RlcDMkdmFsdWUubW9kZWwsCiAgICAgICAgICAgICAgdmlldyA9IF9zdGVwMyR2YWx1ZS52aWV3OwogICAgICAgICAgdGhpcy5mb3IoJ3VwY2FzdCcpLmF0dHJpYnV0ZVRvQXR0cmlidXRlKHsKICAgICAgICAgICAgdmlldzogdmlldywKICAgICAgICAgICAgbW9kZWw6IG1vZGVsCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjMuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjMuZigpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYW5kIGNhY2hlcyBjb252ZXJzaW9uIGhlbHBlcnMgZm9yIGdpdmVuIGRpc3BhdGNoZXJzIGdyb3VwLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucwogICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubmFtZSBHcm91cCBuYW1lLgogICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ8CiAgICAgKiBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyPn0gb3B0aW9ucy5kaXNwYXRjaGVycwogICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmlzRG93bmNhc3QKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlQ29udmVyc2lvbkhlbHBlcnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDb252ZXJzaW9uSGVscGVycyhfcmVmKSB7CiAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLAogICAgICAgICAgZGlzcGF0Y2hlcnMgPSBfcmVmLmRpc3BhdGNoZXJzLAogICAgICAgICAgaXNEb3duY2FzdCA9IF9yZWYuaXNEb3duY2FzdDsKCiAgICAgIGlmICh0aGlzLl9oZWxwZXJzLmhhcyhuYW1lKSkgewogICAgICAgIC8qKgogICAgICAgICAqIFRyeWluZyB0byByZWdpc3RlciBhIGdyb3VwIG5hbWUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgY29udmVyc2lvbi1ncm91cC1leGlzdHMKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignY29udmVyc2lvbi1ncm91cC1leGlzdHMnLCB0aGlzKTsKICAgICAgfQoKICAgICAgdmFyIGhlbHBlcnMgPSBpc0Rvd25jYXN0ID8gbmV3IERvd25jYXN0SGVscGVycyhkaXNwYXRjaGVycykgOiBuZXcgVXBjYXN0SGVscGVycyhkaXNwYXRjaGVycyk7CgogICAgICB0aGlzLl9oZWxwZXJzLnNldChuYW1lLCBoZWxwZXJzKTsKICAgIH0KICB9XSk7CgogIHJldHVybiBDb252ZXJzaW9uOwp9KCk7Ci8qKgogKiBEZWZpbmVzIGhvdyB0aGUgbW9kZWwgc2hvdWxkIGJlIGNvbnZlcnRlZCBmcm9tIGFuZCB0byB0aGUgdmlldy4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVydGVyRGVmaW5pdGlvbgogKgogKiBAcHJvcGVydHkgeyp9IFttb2RlbF0gVGhlIG1vZGVsIGNvbnZlcnNpb24gZGVmaW5pdGlvbi4gRGVzY3JpYmVzIHRoZSBtb2RlbCBlbGVtZW50IG9yIG1vZGVsIGF0dHJpYnV0ZSB0byBjb252ZXJ0LiBUaGlzIHBhcmFtZXRlciBkaWZmZXJzCiAqIGZvciBkaWZmZXJlbnQgZnVuY3Rpb25zIHRoYXQgYWNjZXB0IGBDb252ZXJ0ZXJEZWZpbml0aW9uYC4gU2VlIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24gdG8gbGVhcm4gaG93IHRvIHNldCBpdC4KICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb258T2JqZWN0fSB2aWV3IFRoZSBkZWZpbml0aW9uIG9mIHRoZSB2aWV3IGVsZW1lbnQgdG8gY29udmVydCBmcm9tIGFuZAogKiB0by4gSWYgYG1vZGVsYCBkZXNjcmliZXMgbXVsdGlwbGUgdmFsdWVzLCBgdmlld2AgaXMgYW4gb2JqZWN0IHRoYXQgYXNzaWducyB0aGVzZSB2YWx1ZXMgKGB2aWV3YCBvYmplY3Qga2V5cykgdG8gdmlldyBlbGVtZW50IGRlZmluaXRpb25zCiAqIChgdmlld2Agb2JqZWN0IHZhbHVlcykuCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm58QXJyYXkuPG1vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJuPn0gW3VwY2FzdEFsc29dCiAqIEFueSB2aWV3IGVsZW1lbnQgbWF0Y2hpbmcgYHVwY2FzdEFsc29gIHdpbGwgYWxzbyBiZSBjb252ZXJ0ZWQgdG8gdGhlIG1vZGVsLiBJZiBgbW9kZWxgIGRlc2NyaWJlcyBtdWx0aXBsZSB2YWx1ZXMsIGB1cGNhc3RBbHNvYAogKiBpcyBhbiBvYmplY3QgdGhhdCBhc3NpZ25zIHRoZXNlIHZhbHVlcyAoYHVwY2FzdEFsc29gIG9iamVjdCBrZXlzKSB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59cwogKiAoYHVwY2FzdEFsc29gIG9iamVjdCB2YWx1ZXMpLgogKiBAcHJvcGVydHkge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29udmVydGVyUHJpb3JpdHldIFRoZSBjb252ZXJ0ZXIgcHJpb3JpdHkuCiAqLwovLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgam9pbnQgYXJyYXkgb3V0IG9mIGFuIGl0ZW0gcGFzc2VkIGluIGBkZWZpbml0aW9uLnZpZXdgIGFuZCBpdGVtcyBwYXNzZWQgaW4KLy8gYGRlZmluaXRpb24udXBjYXN0QWxzb2AuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVydGVyRGVmaW5pdGlvbn0gZGVmaW5pdGlvbgovLyBAcmV0dXJucyB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgdmlldyBkZWZpbml0aW9ucy4KCgpleHBvcnQgeyBDb252ZXJzaW9uIGFzIGRlZmF1bHQgfTsKCmZ1bmN0aW9uIF9nZXRBbGxVcGNhc3REZWZpbml0aW9ucyhkZWZpbml0aW9uKSB7CiAgdmFyIF9pdGVyYXRvcjQsIF9zdGVwNCwgdmFsdWUsIG1vZGVsLCB2aWV3LCB1cGNhc3RBbHNvOwoKICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2dldEFsbFVwY2FzdERlZmluaXRpb25zJChfY29udGV4dCkgewogICAgd2hpbGUgKDEpIHsKICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgIGNhc2UgMDoKICAgICAgICAgIGlmICghZGVmaW5pdGlvbi5tb2RlbC52YWx1ZXMpIHsKICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGVmaW5pdGlvbi5tb2RlbC52YWx1ZXMpOwogICAgICAgICAgX2NvbnRleHQucHJldiA9IDI7CgogICAgICAgICAgX2l0ZXJhdG9yNC5zKCk7CgogICAgICAgIGNhc2UgNDoKICAgICAgICAgIGlmICgoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmUpIHsKICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICB2YWx1ZSA9IF9zdGVwNC52YWx1ZTsKICAgICAgICAgIG1vZGVsID0gewogICAgICAgICAgICBrZXk6IGRlZmluaXRpb24ubW9kZWwua2V5LAogICAgICAgICAgICB2YWx1ZTogdmFsdWUKICAgICAgICAgIH07CiAgICAgICAgICB2aWV3ID0gZGVmaW5pdGlvbi52aWV3W3ZhbHVlXTsKICAgICAgICAgIHVwY2FzdEFsc28gPSBkZWZpbml0aW9uLnVwY2FzdEFsc28gPyBkZWZpbml0aW9uLnVwY2FzdEFsc29bdmFsdWVdIDogdW5kZWZpbmVkOwogICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmRlbGVnYXRlWWllbGQoX2dldFVwY2FzdERlZmluaXRpb24obW9kZWwsIHZpZXcsIHVwY2FzdEFsc28pLCAidDAiLCAxMCk7CgogICAgICAgIGNhc2UgMTA6CiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlIDEyOgogICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3OwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTQ7CiAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0WyJjYXRjaCJdKDIpOwoKICAgICAgICAgIF9pdGVyYXRvcjQuZShfY29udGV4dC50MSk7CgogICAgICAgIGNhc2UgMTc6CiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTc7CgogICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7CgogICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgxNyk7CgogICAgICAgIGNhc2UgMjA6CiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAyMjoKICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKF9nZXRVcGNhc3REZWZpbml0aW9uKGRlZmluaXRpb24ubW9kZWwsIGRlZmluaXRpb24udmlldywgZGVmaW5pdGlvbi51cGNhc3RBbHNvKSwgInQyIiwgMjMpOwoKICAgICAgICBjYXNlIDIzOgogICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpOwogICAgICB9CiAgICB9CiAgfSwgX21hcmtlZCwgbnVsbCwgW1syLCAxNCwgMTcsIDIwXV0pOwp9CgpmdW5jdGlvbiBfZ2V0VXBjYXN0RGVmaW5pdGlvbihtb2RlbCwgdmlldywgdXBjYXN0QWxzbykgewogIHZhciBfaXRlcmF0b3I1LCBfc3RlcDUsIHVwY2FzdEFsc29JdGVtOwoKICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2dldFVwY2FzdERlZmluaXRpb24kKF9jb250ZXh0MikgewogICAgd2hpbGUgKDEpIHsKICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7CiAgICAgICAgY2FzZSAwOgogICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOwogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgbW9kZWw6IG1vZGVsLAogICAgICAgICAgICB2aWV3OiB2aWV3CiAgICAgICAgICB9OwoKICAgICAgICBjYXNlIDI6CiAgICAgICAgICBpZiAoIXVwY2FzdEFsc28pIHsKICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRvQXJyYXkodXBjYXN0QWxzbykpOwogICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA0OwoKICAgICAgICAgIF9pdGVyYXRvcjUucygpOwoKICAgICAgICBjYXNlIDY6CiAgICAgICAgICBpZiAoKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lKSB7CiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIHVwY2FzdEFsc29JdGVtID0gX3N0ZXA1LnZhbHVlOwogICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIG1vZGVsOiBtb2RlbCwKICAgICAgICAgICAgdmlldzogdXBjYXN0QWxzb0l0ZW0KICAgICAgICAgIH07CgogICAgICAgIGNhc2UgMTA6CiAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAxMjoKICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAxNDoKICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTQ7CiAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbImNhdGNoIl0oNCk7CgogICAgICAgICAgX2l0ZXJhdG9yNS5lKF9jb250ZXh0Mi50MCk7CgogICAgICAgIGNhc2UgMTc6CiAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE3OwoKICAgICAgICAgIF9pdGVyYXRvcjUuZigpOwoKICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDE3KTsKCiAgICAgICAgY2FzZSAyMDoKICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgIH0KICAgIH0KICB9LCBfbWFya2VkMiwgbnVsbCwgW1s0LCAxNCwgMTcsIDIwXV0pOwp9"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js"],"names":["_getAllUpcastDefinitions","_getUpcastDefinition","CKEditorError","UpcastHelpers","DowncastHelpers","toArray","Conversion","downcastDispatchers","upcastDispatchers","_helpers","Map","_downcast","_createConversionHelpers","name","dispatchers","isDowncast","_upcast","alias","dispatcher","includes","isUpcast","groupName","has","get","definition","for","elementToElement","model","view","converterPriority","attributeToElement","elementToAttribute","attributeToAttribute","helpers","set","values","value","key","upcastAlso","undefined","upcastAlsoItem"],"mappings":";;;;;mDA6mBUA,wB;oDAcAC,oB;;;;;;;;;;AA3nBV;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,OAAOC,OAAP,MAAoB,uCAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,U;AACpB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACC,sBAAaC,mBAAb,EAAkCC,iBAAlC,EAAsD;AAAA;;AACrD;AACF;AACA;AACA;AACA;AACA;AACE,SAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB,CAPqD,CASrD;;AACA,SAAKC,SAAL,GAAiBN,OAAO,CAAEE,mBAAF,CAAxB;;AACA,SAAKK,wBAAL,CAA+B;AAAEC,MAAAA,IAAI,EAAE,UAAR;AAAoBC,MAAAA,WAAW,EAAE,KAAKH,SAAtC;AAAiDI,MAAAA,UAAU,EAAE;AAA7D,KAA/B;;AAEA,SAAKC,OAAL,GAAeX,OAAO,CAAEG,iBAAF,CAAtB;;AACA,SAAKI,wBAAL,CAA+B;AAAEC,MAAAA,IAAI,EAAE,QAAR;AAAkBC,MAAAA,WAAW,EAAE,KAAKE,OAApC;AAA6CD,MAAAA,UAAU,EAAE;AAAzD,KAA/B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACC,kBAAUE,KAAV,EAAiBC,UAAjB,EAA8B;AAC7B,UAAMH,UAAU,GAAG,KAAKJ,SAAL,CAAeQ,QAAf,CAAyBD,UAAzB,CAAnB;;AACA,UAAME,QAAQ,GAAG,KAAKJ,OAAL,CAAaG,QAAb,CAAuBD,UAAvB,CAAjB;;AAEA,UAAK,CAACE,QAAD,IAAa,CAACL,UAAnB,EAAgC;AAC/B;AACH;AACA;AACA;AACA;AACG,cAAM,IAAIb,aAAJ,CACL,gDADK,EAEL,IAFK,CAAN;AAIA;;AAED,WAAKU,wBAAL,CAA+B;AAAEC,QAAAA,IAAI,EAAEI,KAAR;AAAeH,QAAAA,WAAW,EAAE,CAAEI,UAAF,CAA5B;AAA4CH,QAAAA,UAAU,EAAVA;AAA5C,OAA/B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,cAAKM,SAAL,EAAiB;AAChB,UAAK,CAAC,KAAKZ,QAAL,CAAca,GAAd,CAAmBD,SAAnB,CAAN,EAAuC;AACtC;AACH;AACA;AACA;AACA;AACG,cAAM,IAAInB,aAAJ,CAAmB,8BAAnB,EAAmD,IAAnD,CAAN;AACA;;AAED,aAAO,KAAKO,QAAL,CAAcc,GAAd,CAAmBF,SAAnB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,0BAAkBG,UAAlB,EAA+B;AAC9B;AACA,WAAKC,GAAL,CAAU,UAAV,EAAuBC,gBAAvB,CAAyCF,UAAzC,EAF8B,CAI9B;;AAJ8B,iDAKCxB,wBAAwB,CAAEwB,UAAF,CALzB;AAAA;;AAAA;AAK9B,4DAAwE;AAAA;AAAA,cAA1DG,KAA0D,eAA1DA,KAA0D;AAAA,cAAnDC,IAAmD,eAAnDA,IAAmD;AACvE,eAAKH,GAAL,CAAU,QAAV,EACEC,gBADF,CACoB;AAClBC,YAAAA,KAAK,EAALA,KADkB;AAElBC,YAAAA,IAAI,EAAJA,IAFkB;AAGlBC,YAAAA,iBAAiB,EAAEL,UAAU,CAACK;AAHZ,WADpB;AAMA;AAZ6B;AAAA;AAAA;AAAA;AAAA;AAa9B;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,4BAAoBL,UAApB,EAAiC;AAChC;AACA,WAAKC,GAAL,CAAU,UAAV,EAAuBK,kBAAvB,CAA2CN,UAA3C,EAFgC,CAIhC;;AAJgC,kDAKDxB,wBAAwB,CAAEwB,UAAF,CALvB;AAAA;;AAAA;AAKhC,+DAAwE;AAAA;AAAA,cAA1DG,KAA0D,gBAA1DA,KAA0D;AAAA,cAAnDC,IAAmD,gBAAnDA,IAAmD;AACvE,eAAKH,GAAL,CAAU,QAAV,EACEM,kBADF,CACsB;AACpBH,YAAAA,IAAI,EAAJA,IADoB;AAEpBD,YAAAA,KAAK,EAALA,KAFoB;AAGpBE,YAAAA,iBAAiB,EAAEL,UAAU,CAACK;AAHV,WADtB;AAMA;AAZ+B;AAAA;AAAA;AAAA;AAAA;AAahC;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,8BAAsBL,UAAtB,EAAmC;AAClC;AACA,WAAKC,GAAL,CAAU,UAAV,EAAuBO,oBAAvB,CAA6CR,UAA7C,EAFkC,CAIlC;;AAJkC,kDAKHxB,wBAAwB,CAAEwB,UAAF,CALrB;AAAA;;AAAA;AAKlC,+DAAwE;AAAA;AAAA,cAA1DG,KAA0D,gBAA1DA,KAA0D;AAAA,cAAnDC,IAAmD,gBAAnDA,IAAmD;AACvE,eAAKH,GAAL,CAAU,QAAV,EACEO,oBADF,CACwB;AACtBJ,YAAAA,IAAI,EAAJA,IADsB;AAEtBD,YAAAA,KAAK,EAALA;AAFsB,WADxB;AAKA;AAXiC;AAAA;AAAA;AAAA;AAAA;AAYlC;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,wCAA8D;AAAA,UAAlCd,IAAkC,QAAlCA,IAAkC;AAAA,UAA5BC,WAA4B,QAA5BA,WAA4B;AAAA,UAAfC,UAAe,QAAfA,UAAe;;AAC7D,UAAK,KAAKN,QAAL,CAAca,GAAd,CAAmBT,IAAnB,CAAL,EAAiC;AAChC;AACH;AACA;AACA;AACA;AACG,cAAM,IAAIX,aAAJ,CAAmB,yBAAnB,EAA8C,IAA9C,CAAN;AACA;;AAED,UAAM+B,OAAO,GAAGlB,UAAU,GAAG,IAAIX,eAAJ,CAAqBU,WAArB,CAAH,GAAwC,IAAIX,aAAJ,CAAmBW,WAAnB,CAAlE;;AAEA,WAAKL,QAAL,CAAcyB,GAAd,CAAmBrB,IAAnB,EAAyBoB,OAAzB;AACA;;;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;SAljBqB3B,U;;AAmjBrB,SAAUN,wBAAV,CAAoCwB,UAApC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,eACMA,UAAU,CAACG,KAAX,CAAiBQ,MADvB;AAAA;AAAA;AAAA;;AAAA,kDAEuBX,UAAU,CAACG,KAAX,CAAiBQ,MAFxC;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEcC,UAAAA,KAFd;AAGST,UAAAA,KAHT,GAGiB;AAAEU,YAAAA,GAAG,EAAEb,UAAU,CAACG,KAAX,CAAiBU,GAAxB;AAA6BD,YAAAA,KAAK,EAALA;AAA7B,WAHjB;AAISR,UAAAA,IAJT,GAIgBJ,UAAU,CAACI,IAAX,CAAiBQ,KAAjB,CAJhB;AAKSE,UAAAA,UALT,GAKsBd,UAAU,CAACc,UAAX,GAAwBd,UAAU,CAACc,UAAX,CAAuBF,KAAvB,CAAxB,GAAyDG,SAL/E;AAOG,wCAAOtC,oBAAoB,CAAE0B,KAAF,EAASC,IAAT,EAAeU,UAAf,CAA3B;;AAPH;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAUE,wCAAOrC,oBAAoB,CAAEuB,UAAU,CAACG,KAAb,EAAoBH,UAAU,CAACI,IAA/B,EAAqCJ,UAAU,CAACc,UAAhD,CAA3B;;AAVF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAcA,SAAUrC,oBAAV,CAAgC0B,KAAhC,EAAuCC,IAAvC,EAA6CU,UAA7C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACC,iBAAM;AAAEX,YAAAA,KAAK,EAALA,KAAF;AAASC,YAAAA,IAAI,EAAJA;AAAT,WAAN;;AADD;AAAA,eAGMU,UAHN;AAAA;AAAA;AAAA;;AAAA,kDAIgCjC,OAAO,CAAEiC,UAAF,CAJvC;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIcE,UAAAA,cAJd;AAAA;AAKG,iBAAM;AAAEb,YAAAA,KAAK,EAALA,KAAF;AAASC,YAAAA,IAAI,EAAEY;AAAf,WAAN;;AALH;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/conversion\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport UpcastHelpers from './upcasthelpers';\nimport DowncastHelpers from './downcasthelpers';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n\n/**\n * A utility class that helps add converters to upcast and downcast dispatchers.\n *\n * We recommend reading the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide first to\n * understand the core concepts of the conversion mechanisms.\n *\n * An instance of the conversion manager is available in the\n * {@link module:core/editor/editor~Editor#conversion `editor.conversion`} property\n * and by default has the following groups of dispatchers (i.e. directions of conversion):\n *\n * * `downcast` (editing and data downcasts)\n * * `editingDowncast`\n * * `dataDowncast`\n * * `upcast`\n *\n * # One-way converters\n *\n * To add a converter to a specific group, use the {@link module:engine/conversion/conversion~Conversion#for `for()`}\n * method:\n *\n *\t\t// Add a converter to editing downcast and data downcast.\n *\t\teditor.conversion.for( 'downcast' ).elementToElement( config ) );\n *\n *\t\t// Add a converter to the data pipepline only:\n *\t\teditor.conversion.for( 'dataDowncast' ).elementToElement( dataConversionConfig ) );\n *\n *\t\t// And a slightly different one for the editing pipeline:\n *\t\teditor.conversion.for( 'editingDowncast' ).elementToElement( editingConversionConfig ) );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for `for()`} method documentation to learn more about\n * available conversion helpers and how to use your custom ones.\n *\n * # Two-way converters\n *\n * Besides using one-way converters via the `for()` method, you can also use other methods available in this\n * class to add two-way converters (upcast and downcast):\n *\n * * {@link module:engine/conversion/conversion~Conversion#elementToElement `elementToElement()`} &ndash;\n * Model element to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement()`} &ndash;\n * Model attribute to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `attributeToAttribute()`} &ndash;\n * Model attribute to view element and vice versa.\n */\nexport default class Conversion {\n\t/**\n\t * Creates a new conversion instance.\n\t *\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher>} downcastDispatchers\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastDispatcher|\n\t * Array.<module:engine/conversion/upcastdispatcher~UpcastDispatcher>} upcastDispatchers\n\t */\n\tconstructor( downcastDispatchers, upcastDispatchers ) {\n\t\t/**\n\t\t * Maps dispatchers group name to ConversionHelpers instances.\n\t\t *\n\t\t * @private\n\t\t * @member {Map.<String,module:engine/conversion/conversionhelpers~ConversionHelpers>}\n\t\t */\n\t\tthis._helpers = new Map();\n\n\t\t// Define default 'downcast' & 'upcast' dispatchers groups. Those groups are always available as two-way converters needs them.\n\t\tthis._downcast = toArray( downcastDispatchers );\n\t\tthis._createConversionHelpers( { name: 'downcast', dispatchers: this._downcast, isDowncast: true } );\n\n\t\tthis._upcast = toArray( upcastDispatchers );\n\t\tthis._createConversionHelpers( { name: 'upcast', dispatchers: this._upcast, isDowncast: false } );\n\t}\n\n\t/**\n\t * Define an alias for registered dispatcher.\n\t *\n\t *\t\tconst conversion = new Conversion(\n\t *\t\t\t[ dataDowncastDispatcher, editingDowncastDispatcher ],\n\t *\t\t\tupcastDispatcher\n\t *\t\t);\n\t *\n\t *\t\tconversion.addAlias( 'dataDowncast', dataDowncastDispatcher );\n\t *\n\t * @param {String} alias An alias of a dispatcher.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * module:engine/conversion/upcastdispatcher~UpcastDispatcher} dispatcher Dispatcher which should have an alias.\n\t */\n\taddAlias( alias, dispatcher ) {\n\t\tconst isDowncast = this._downcast.includes( dispatcher );\n\t\tconst isUpcast = this._upcast.includes( dispatcher );\n\n\t\tif ( !isUpcast && !isDowncast ) {\n\t\t\t/**\n\t\t\t * Trying to register and alias for a dispatcher that nas not been registered.\n\t\t\t *\n\t\t\t * @error conversion-add-alias-dispatcher-not-registered\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'conversion-add-alias-dispatcher-not-registered',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tthis._createConversionHelpers( { name: alias, dispatchers: [ dispatcher ], isDowncast } );\n\t}\n\n\t/**\n\t * Provides a chainable API to assign converters to conversion dispatchers group.\n\t *\n\t * If the given group name has not been registered, the\n\t * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.\n\t *\n\t * You can use conversion helpers available directly in the `for()` chain or your custom ones via\n\t * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.\n\t *\n\t * # Using bulit-in conversion helpers\n\t *\n\t * The `for()` chain comes with a set of conversion helpers which you can use like this:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' )\n\t *\t\t\t.elementToElement( config1 )        // Adds an element-to-element downcast converter.\n\t *\t\t\t.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' )\n\t *\t\t\t.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.\n\t *\n\t * Refer to the documentation of built-in conversion helpers to learn about their configuration options.\n\t *\n\t * * downcast (model-to-view) conversion helpers:\n\t *\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.\n\t *\n\t * * upcast (view-to-model) conversion helpers:\n\t *\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.\n\t *\n\t * # Using custom conversion helpers\n\t *\n\t * If you need to implement a nontypical converter, you can do so by calling:\n\t *\n\t *\t\teditor.conversion.for( direction ).add( customHelper );\n\t *\n\t * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that\n\t * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.\n\t *\n\t * Example:\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).add( dispatcher => {\n\t *\t\t\tdispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {\n\t *\t\t\t\t// Do something with a view <a> element.\n\t *\t\t\t} );\n\t *\t\t} );\n\t *\n\t * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write\n\t * custom converters.\n\t *\n\t * @param {String} groupName The name of dispatchers group to add the converters to.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers|module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tfor( groupName ) {\n\t\tif ( !this._helpers.has( groupName ) ) {\n\t\t\t/**\n\t\t\t * Trying to add a converter to an unknown dispatchers group.\n\t\t\t *\n\t\t\t * @error conversion-for-unknown-group\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-for-unknown-group', this );\n\t\t}\n\n\t\treturn this._helpers.get( groupName );\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).\n\t * For example, the model `<paragraph>Foo</paragraph>` is `<p>Foo</p>` in the view.\n\t *\n\t *\t\t// A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).\n\t *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );\n\t *\n\t *\t\t// Override other converters by specifying a converter definition with a higher priority.\n\t *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );\n\t *\n\t *\t\t// View specified as an object instead of a string.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'fancyParagraph',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'p',\n\t *\t\t\tupcastAlso: [\n\t *\t\t\t\t'div',\n\t *\t\t\t\t{\n\t *\t\t\t\t\t// Any element with the `display: block` style.\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\tdisplay: 'block'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'heading',\n\t *\t\t\tview: 'h2',\n\t *\t\t\t// Convert \"heading-like\" paragraphs to headings.\n\t *\t\t\tupcastAlso: viewElement => {\n\t *\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\tif ( size > 26 ) {\n\t *\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\treturn null;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * `definition.model` is a `String` with a model element name to convert from or to.\n\t * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n\t *\n\t * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n\t */\n\telementToElement( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).elementToElement( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.elementToElement( {\n\t\t\t\t\tmodel,\n\t\t\t\t\tview,\n\t\t\t\t\tconverterPriority: definition.converterPriority\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).\n\t * For example, a model text node with `\"Foo\"` as data and the `bold` attribute is `<strong>Foo</strong>` in the view.\n\t *\n\t *\t\t// A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).\n\t *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );\n\t *\n\t *\t\t// Override other converters by specifying a converter definition with a higher priority.\n\t *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );\n\t *\n\t *\t\t// View specified as an object instead of a string.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.\n\t *\t\t// The same attribute on different elements may then be handled by a different converter.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'textDecoration',\n\t *\t\t\t\tvalues: [ 'underline', 'lineThrough' ],\n\t *\t\t\t\tname: '$text'\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tunderline: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-decoration': 'underline'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tlineThrough: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-decoration': 'line-through'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'strong',\n\t *\t\t\tupcastAlso: [\n\t *\t\t\t\t'b',\n\t *\t\t\t\t{\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tclasses: 'bold'\n\t *\t\t\t\t},\n\t *\t\t\t\t{\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tviewElement => {\n\t *\t\t\t\t\tconst fontWeight = viewElement.getStyle( 'font-weight' );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'element', 'span' ) && fontWeight && /\\d+/.test() && Number( fontWeight ) > 500 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn {\n\t *\t\t\t\t\t\t\tname: true,\n\t *\t\t\t\t\t\t\tstyles: [ 'font-weight' ]\n\t *\t\t\t\t\t\t};\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).\n\t *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalues: [ 'big', 'small' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tbig: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '1.2em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '0.8em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tupcastAlso: {\n\t *\t\t\t\tbig: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'element', 'span' ) && size > 10 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'element', 'span' ) && size < 10 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object\n\t * describing the attribute key and value to convert or a `String` specifying just the attribute key (then `value` is set to `true`).\n\t * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n\t *\n\t * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n\t */\n\tattributeToElement( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).attributeToElement( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.elementToAttribute( {\n\t\t\t\t\tview,\n\t\t\t\t\tmodel,\n\t\t\t\t\tconverterPriority: definition.converterPriority\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa).\n\t * For example, `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).\n\t * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.\n\t * To convert text attributes {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}\n\t * should be set up.\n\t *\n\t *\t\t// A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).\n\t *\t\teditor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );\n\t *\n\t *\t\t// Attribute values are strictly specified.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'aside',\n\t *\t\t\t\tvalues: [ 'aside' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\taside: {\n\t *\t\t\t\t\tname: 'img',\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'aside', 'half-size' ]\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Set the style attribute.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'aside',\n\t *\t\t\t\tvalues: [ 'aside' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\taside: {\n\t *\t\t\t\t\tname: 'img',\n\t *\t\t\t\t\tkey: 'style',\n\t *\t\t\t\t\tvalue: {\n\t *\t\t\t\t\t\tfloat: 'right',\n\t *\t\t\t\t\t\twidth: '50%',\n\t *\t\t\t\t\t\tmargin: '5px'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Conversion from and to a model attribute key whose value is an enum (`align=right|center`).\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'align',\n\t *\t\t\t\tvalues: [ 'right', 'center' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tright: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: 'align-right'\n\t *\t\t\t\t},\n\t *\t\t\t\tcenter: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: 'align-center'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tupcastAlso: {\n\t *\t\t\t\tright: {\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-align': 'right'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tcenter: {\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-align': 'center'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `definition.model` parameter specifies which model attribute should be converted from and to.\n\t * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.\n\t * The `key` property is the model attribute key to convert from and to.\n\t * The `values` are the possible model attribute values. If `values` is not set, the model attribute value will be the same as the\n\t * view attribute value.\n\t * If `name` is set, the conversion will be set up only for model elements with the given name.\n\t *\n\t * The `definition.view` parameter specifies which view attribute should be converted from and to.\n\t * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.\n\t * The `key` property is the view attribute key to convert from and to.\n\t * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be\n\t * the same as the model attribute value.\n\t * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.\n\t * If `key` is `'style'`, `value` is an object with key-value pairs.\n\t * In other cases, `value` is a `String`.\n\t * If `name` is set, the conversion will be set up only for model elements with the given name.\n\t * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`\n\t * to `{ key, value, [ name ] }` objects.\n\t *\n\t * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.\n\t * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`\n\t * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.\n\t *\n\t * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should\n\t * be given in both parameters.\n\t *\n\t * @param {Object} definition The converter definition.\n\t * @param {String|Object} definition.model The model attribute to convert from and to.\n\t * @param {String|Object} definition.view The view attribute to convert from and to.\n\t * @param {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [definition.upcastAlso]\n\t * Any view element matching `definition.upcastAlso` will also be converted to the given model attribute. `definition.upcastAlso`\n\t * is used only if `config.model.values` is specified.\n\t */\n\tattributeToAttribute( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).attributeToAttribute( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.attributeToAttribute( {\n\t\t\t\t\tview,\n\t\t\t\t\tmodel\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Creates and caches conversion helpers for given dispatchers group.\n\t *\n\t * @private\n\t * @param {Object} options\n\t * @param {String} options.name Group name.\n\t * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} options.dispatchers\n\t * @param {Boolean} options.isDowncast\n\t */\n\t_createConversionHelpers( { name, dispatchers, isDowncast } ) {\n\t\tif ( this._helpers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Trying to register a group name that has already been registered.\n\t\t\t *\n\t\t\t * @error conversion-group-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-group-exists', this );\n\t\t}\n\n\t\tconst helpers = isDowncast ? new DowncastHelpers( dispatchers ) : new UpcastHelpers( dispatchers );\n\n\t\tthis._helpers.set( name, helpers );\n\t}\n}\n\n/**\n * Defines how the model should be converted from and to the view.\n *\n * @typedef {Object} module:engine/conversion/conversion~ConverterDefinition\n *\n * @property {*} [model] The model conversion definition. Describes the model element or model attribute to convert. This parameter differs\n * for different functions that accept `ConverterDefinition`. See the description of the function to learn how to set it.\n * @property {module:engine/view/elementdefinition~ElementDefinition|Object} view The definition of the view element to convert from and\n * to. If `model` describes multiple values, `view` is an object that assigns these values (`view` object keys) to view element definitions\n * (`view` object values).\n * @property {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [upcastAlso]\n * Any view element matching `upcastAlso` will also be converted to the model. If `model` describes multiple values, `upcastAlso`\n * is an object that assigns these values (`upcastAlso` object keys) to {@link module:engine/view/matcher~MatcherPattern}s\n * (`upcastAlso` object values).\n * @property {module:utils/priorities~PriorityString} [converterPriority] The converter priority.\n */\n\n// Helper function that creates a joint array out of an item passed in `definition.view` and items passed in\n// `definition.upcastAlso`.\n//\n// @param {module:engine/conversion/conversion~ConverterDefinition} definition\n// @returns {Array} Array containing view definitions.\nfunction* _getAllUpcastDefinitions( definition ) {\n\tif ( definition.model.values ) {\n\t\tfor ( const value of definition.model.values ) {\n\t\t\tconst model = { key: definition.model.key, value };\n\t\t\tconst view = definition.view[ value ];\n\t\t\tconst upcastAlso = definition.upcastAlso ? definition.upcastAlso[ value ] : undefined;\n\n\t\t\tyield* _getUpcastDefinition( model, view, upcastAlso );\n\t\t}\n\t} else {\n\t\tyield* _getUpcastDefinition( definition.model, definition.view, definition.upcastAlso );\n\t}\n}\n\nfunction* _getUpcastDefinition( model, view, upcastAlso ) {\n\tyield { model, view };\n\n\tif ( upcastAlso ) {\n\t\tfor ( const upcastAlsoItem of toArray( upcastAlso ) ) {\n\t\t\tyield { model, view: upcastAlsoItem };\n\t\t}\n\t}\n}\n"]}]}