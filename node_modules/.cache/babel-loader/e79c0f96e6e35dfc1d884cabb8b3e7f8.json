{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/element.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/element.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCBfZ2V0IGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0IjsKaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mIjsKaW1wb3J0IF9pbmhlcml0cyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzIjsKaW1wb3J0IF9jcmVhdGVTdXBlciBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZVN1cGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLnVybC50by1qc29uLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL2VsZW1lbnQKICovCmltcG9ydCBOb2RlIGZyb20gJy4vbm9kZSc7CmltcG9ydCBOb2RlTGlzdCBmcm9tICcuL25vZGVsaXN0JzsKaW1wb3J0IFRleHQgZnJvbSAnLi90ZXh0JzsKaW1wb3J0IFRleHRQcm94eSBmcm9tICcuL3RleHRwcm94eSc7CmltcG9ydCBpc0l0ZXJhYmxlIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2lzaXRlcmFibGUnOyAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGNvbnN0IHsgc3RyaW5naWZ5TWFwLCBjb252ZXJ0TWFwVG9TdHJpbmdpZmllZE9iamVjdCwgY29udmVydE1hcFRvVGFncyB9ID0gcmVxdWlyZSggJy4uL2Rldi11dGlscy91dGlscycgKTsKCi8qKgogKiBNb2RlbCBlbGVtZW50LiBUeXBlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSBub2RlfSB0aGF0IGhhcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCNuYW1lIG5hbWV9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQjZ2V0Q2hpbGRyZW4gY2hpbGQgbm9kZXN9LgogKgogKiAqKkltcG9ydGFudCoqOiBzZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSB0byByZWFkIGFib3V0IHJlc3RyaWN0aW9ucyB1c2luZyBgRWxlbWVudGAgYW5kIGBOb2RlYCBBUEkuCiAqCiAqIEBleHRlbmRzIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlCiAqLwoKdmFyIEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7CiAgX2luaGVyaXRzKEVsZW1lbnQsIF9Ob2RlKTsKCiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihFbGVtZW50KTsKCiAgLyoqCiAgICogQ3JlYXRlcyBhIG1vZGVsIGVsZW1lbnQuCiAgICoKICAgKiAqKk5vdGU6KiogQ29uc3RydWN0b3Igb2YgdGhpcyBjbGFzcyBzaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseSBpbiB0aGUgY29kZS4KICAgKiBVc2UgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY3JlYXRlRWxlbWVudH0gbWV0aG9kIGluc3RlYWQuCiAgICoKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgRWxlbWVudCdzIG5hbWUuCiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyc10gRWxlbWVudCdzIGF0dHJpYnV0ZXMuIFNlZSB7QGxpbmsgbW9kdWxlOnV0aWxzL3RvbWFwfnRvTWFwfSBmb3IgYSBsaXN0IG9mIGFjY2VwdGVkIHZhbHVlcy4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfEl0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59IFtjaGlsZHJlbl0KICAgKiBPbmUgb3IgbW9yZSBub2RlcyB0byBiZSBpbnNlcnRlZCBhcyBjaGlsZHJlbiBvZiBjcmVhdGVkIGVsZW1lbnQuCiAgICovCiAgZnVuY3Rpb24gRWxlbWVudChuYW1lLCBhdHRycywgY2hpbGRyZW4pIHsKICAgIHZhciBfdGhpczsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudCk7CgogICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBhdHRycyk7CiAgICAvKioKICAgICAqIEVsZW1lbnQgbmFtZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge1N0cmluZ30gbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQjbmFtZQogICAgICovCgogICAgX3RoaXMubmFtZSA9IG5hbWU7CiAgICAvKioKICAgICAqIExpc3Qgb2YgY2hpbGRyZW4gbm9kZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZWxpc3R+Tm9kZUxpc3R9IG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50I19jaGlsZHJlbgogICAgICovCgogICAgX3RoaXMuX2NoaWxkcmVuID0gbmV3IE5vZGVMaXN0KCk7CgogICAgaWYgKGNoaWxkcmVuKSB7CiAgICAgIF90aGlzLl9pbnNlcnRDaGlsZCgwLCBjaGlsZHJlbik7CiAgICB9CgogICAgcmV0dXJuIF90aGlzOwogIH0KICAvKioKICAgKiBOdW1iZXIgb2YgdGhpcyBlbGVtZW50J3MgY2hpbGRyZW4uCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7TnVtYmVyfQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKEVsZW1lbnQsIFt7CiAgICBrZXk6ICJjaGlsZENvdW50IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOwogICAgfQogICAgLyoqCiAgICAgKiBTdW0gb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI29mZnNldFNpemUgb2Zmc2V0IHNpemVzfSBvZiBhbGwgb2YgdGhpcyBlbGVtZW50J3MgY2hpbGRyZW4uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogIH0sIHsKICAgIGtleTogIm1heE9mZnNldCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLm1heE9mZnNldDsKICAgIH0KICAgIC8qKgogICAgICogSXMgYHRydWVgIGlmIHRoZXJlIGFyZSBubyBub2RlcyBpbnNpZGUgdGhpcyBlbGVtZW50LCBgZmFsc2VgIG90aGVyd2lzZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzRW1wdHkiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLmNoaWxkQ291bnQgPT09IDA7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbi4KICAgICAqCiAgICAgKgkJZWxlbWVudC5pcyggJ2VsZW1lbnQnICk7IC8vIC0+IHRydWUKICAgICAqCQllbGVtZW50LmlzKCAnbm9kZScgKTsgLy8gLT4gdHJ1ZQogICAgICoJCWVsZW1lbnQuaXMoICdtb2RlbDplbGVtZW50JyApOyAvLyAtPiB0cnVlCiAgICAgKgkJZWxlbWVudC5pcyggJ21vZGVsOm5vZGUnICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJZWxlbWVudC5pcyggJ3ZpZXc6ZWxlbWVudCcgKTsgLy8gLT4gZmFsc2UKICAgICAqCQllbGVtZW50LmlzKCAnZG9jdW1lbnRTZWxlY3Rpb24nICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICogQXNzdW1pbmcgdGhhdCB0aGUgb2JqZWN0IGJlaW5nIGNoZWNrZWQgaXMgYW4gZWxlbWVudCwgeW91IGNhbiBhbHNvIGNoZWNrIGl0cwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50I25hbWUgbmFtZX06CiAgICAgKgogICAgICoJCWVsZW1lbnQuaXMoICdlbGVtZW50JywgJ2ltYWdlJyApOyAvLyAtPiB0cnVlIGlmIHRoaXMgaXMgYW4gPGltYWdlPiBlbGVtZW50CiAgICAgKgkJZWxlbWVudC5pcyggJ2VsZW1lbnQnLCAnaW1hZ2UnICk7IC8vIC0+IHNhbWUgYXMgYWJvdmUKICAgICAqCQl0ZXh0LmlzKCAnZWxlbWVudCcsICdpbWFnZScgKTsgLT4gZmFsc2UKICAgICAqCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjaXMgQ2hlY2sgdGhlIGVudGlyZSBsaXN0IG9mIG1vZGVsIG9iamVjdHN9IHdoaWNoIGltcGxlbWVudCB0aGUgYGlzKClgIG1ldGhvZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIHRvIGNoZWNrLgogICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSBFbGVtZW50IG5hbWUuCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXModHlwZSkgewogICAgICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDsKCiAgICAgIGlmICghbmFtZSkgewogICAgICAgIHJldHVybiB0eXBlID09PSAnZWxlbWVudCcgfHwgdHlwZSA9PT0gJ21vZGVsOmVsZW1lbnQnIHx8IC8vIEZyb20gc3VwZXIuaXMoKS4gVGhpcyBpcyBoaWdobHkgdXRpbGlzZWQgbWV0aG9kIGFuZCBjYW5ub3QgY2FsbCBzdXBlci4gU2VlIGNrZWRpdG9yL2NrZWRpdG9yNSM2NTI5LgogICAgICAgIHR5cGUgPT09ICdub2RlJyB8fCB0eXBlID09PSAnbW9kZWw6bm9kZSc7CiAgICAgIH0KCiAgICAgIHJldHVybiBuYW1lID09PSB0aGlzLm5hbWUgJiYgKHR5cGUgPT09ICdlbGVtZW50JyB8fCB0eXBlID09PSAnbW9kZWw6ZWxlbWVudCcpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXguCiAgICAgKgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IG9mIGNoaWxkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBDaGlsZCBub2RlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENoaWxkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZChpbmRleCkgewogICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZ2V0Tm9kZShpbmRleCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCBpdGVyYXRlcyBvdmVyIGFsbCBvZiB0aGlzIGVsZW1lbnQncyBjaGlsZHJlbi4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDaGlsZHJlbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oKSB7CiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltTeW1ib2wuaXRlcmF0b3JdKCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gaW5kZXggb2YgdGhlIGdpdmVuIGNoaWxkIG5vZGUuIFJldHVybnMgYG51bGxgIGlmIGdpdmVuIG5vZGUgaXMgbm90IGEgY2hpbGQgb2YgdGhpcyBlbGVtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IG5vZGUgQ2hpbGQgbm9kZSB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IENoaWxkIG5vZGUncyBpbmRleCBpbiB0aGlzIGVsZW1lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Q2hpbGRJbmRleCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hpbGRJbmRleChub2RlKSB7CiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5nZXROb2RlSW5kZXgobm9kZSk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIG9mZnNldCBvZiBnaXZlbiBjaGlsZC4gU3RhcnRpbmcgb2Zmc2V0IGlzIGVxdWFsIHRvIHRoZSBzdW0gb2YKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNvZmZzZXRTaXplIG9mZnNldCBzaXplc30gb2YgYWxsIG5vZGUncyBzaWJsaW5ncyB0aGF0IGFyZSBiZWZvcmUgaXQuIFJldHVybnMgYG51bGxgIGlmCiAgICAgKiBnaXZlbiBub2RlIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgZWxlbWVudC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlIENoaWxkIG5vZGUgdG8gbG9vayBmb3IuCiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBDaGlsZCBub2RlJ3Mgc3RhcnRpbmcgb2Zmc2V0LgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENoaWxkU3RhcnRPZmZzZXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkU3RhcnRPZmZzZXQobm9kZSkgewogICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZ2V0Tm9kZVN0YXJ0T2Zmc2V0KG5vZGUpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGluZGV4IG9mIGEgbm9kZSB0aGF0IG9jY3VwaWVzIGdpdmVuIG9mZnNldC4gSWYgZ2l2ZW4gb2Zmc2V0IGlzIHRvbyBsb3csIHJldHVybnMgYDBgLiBJZiBnaXZlbiBvZmZzZXQgaXMKICAgICAqIHRvbyBoaWdoLCByZXR1cm5zIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCNnZXRDaGlsZEluZGV4IGluZGV4IGFmdGVyIGxhc3QgY2hpbGR9LgogICAgICoKICAgICAqCQljb25zdCB0ZXh0Tm9kZSA9IG5ldyBUZXh0KCAnZm9vJyApOwogICAgICoJCWNvbnN0IHBFbGVtZW50ID0gbmV3IEVsZW1lbnQoICdwJyApOwogICAgICoJCWNvbnN0IGRpdkVsZW1lbnQgPSBuZXcgRWxlbWVudCggWyB0ZXh0Tm9kZSwgcEVsZW1lbnQgXSApOwogICAgICoJCWRpdkVsZW1lbnQub2Zmc2V0VG9JbmRleCggLTEgKTsgLy8gUmV0dXJucyAwLCBiZWNhdXNlIG9mZnNldCBpcyB0b28gbG93LgogICAgICoJCWRpdkVsZW1lbnQub2Zmc2V0VG9JbmRleCggMCApOyAvLyBSZXR1cm5zIDAsIGJlY2F1c2Ugb2Zmc2V0IDAgaXMgdGFrZW4gYnkgYHRleHROb2RlYCB3aGljaCBpcyBhdCBpbmRleCAwLgogICAgICoJCWRpdkVsZW1lbnQub2Zmc2V0VG9JbmRleCggMSApOyAvLyBSZXR1cm5zIDAsIGJlY2F1c2UgYHRleHROb2RlYCBoYXMgYG9mZnNldFNpemVgIGVxdWFsIHRvIDMsIHNvIGl0IG9jY3VwaWVzIG9mZnNldCAxIHRvby4KICAgICAqCQlkaXZFbGVtZW50Lm9mZnNldFRvSW5kZXgoIDIgKTsgLy8gUmV0dXJucyAwLgogICAgICoJCWRpdkVsZW1lbnQub2Zmc2V0VG9JbmRleCggMyApOyAvLyBSZXR1cm5zIDEuCiAgICAgKgkJZGl2RWxlbWVudC5vZmZzZXRUb0luZGV4KCA0ICk7IC8vIFJldHVybnMgMi4gVGhlcmUgYXJlIG5vIG5vZGVzIGF0IG9mZnNldCA0LCBzbyBsYXN0IGF2YWlsYWJsZSBpbmRleCBpcyByZXR1cm5lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE9mZnNldCB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAib2Zmc2V0VG9JbmRleCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gb2Zmc2V0VG9JbmRleChvZmZzZXQpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLm9mZnNldFRvSW5kZXgob2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIGRlc2NlbmRhbnQgbm9kZSBieSBpdHMgcGF0aCByZWxhdGl2ZSB0byB0aGlzIGVsZW1lbnQuCiAgICAgKgogICAgICoJCS8vIDx0aGlzPmE8Yj5jPC9iPjwvdGhpcz4KICAgICAqCQl0aGlzLmdldE5vZGVCeVBhdGgoIFsgMCBdICk7ICAgICAvLyAtPiAiYSIKICAgICAqCQl0aGlzLmdldE5vZGVCeVBhdGgoIFsgMSBdICk7ICAgICAvLyAtPiA8Yj4KICAgICAqCQl0aGlzLmdldE5vZGVCeVBhdGgoIFsgMSwgMCBdICk7ICAvLyAtPiAiYyIKICAgICAqCiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSByZWxhdGl2ZVBhdGggUGF0aCBvZiB0aGUgbm9kZSB0byBmaW5kLCByZWxhdGl2ZSB0byB0aGlzIGVsZW1lbnQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Tm9kZUJ5UGF0aCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZUJ5UGF0aChyZWxhdGl2ZVBhdGgpIHsKICAgICAgdmFyIG5vZGUgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpcwoKICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJlbGF0aXZlUGF0aCksCiAgICAgICAgICBfc3RlcDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBpbmRleCA9IF9zdGVwLnZhbHVlOwogICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0Q2hpbGQobm9kZS5vZmZzZXRUb0luZGV4KGluZGV4KSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvci5mKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBub2RlOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbmFtZS4gUmV0dXJucyBudWxsIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBpbnNpZGUgdGhlIGRlc2lyZWQgcGFyZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgZWxlbWVudCB0byBmaW5kLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZVNlbGY9ZmFsc2VdIFdoZW4gc2V0IHRvIGB0cnVlYCB0aGlzIG5vZGUgd2lsbCBiZSBhbHNvIGluY2x1ZGVkIHdoaWxlIHNlYXJjaGluZy4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImZpbmRBbmNlc3RvciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFuY2VzdG9yKHBhcmVudE5hbWUpIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHsKICAgICAgICBpbmNsdWRlU2VsZjogZmFsc2UKICAgICAgfTsKICAgICAgdmFyIHBhcmVudCA9IG9wdGlvbnMuaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy5wYXJlbnQ7CgogICAgICB3aGlsZSAocGFyZW50KSB7CiAgICAgICAgaWYgKHBhcmVudC5uYW1lID09PSBwYXJlbnROYW1lKSB7CiAgICAgICAgICByZXR1cm4gcGFyZW50OwogICAgICAgIH0KCiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDsKICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIGBFbGVtZW50YCBpbnN0YW5jZSB0byBwbGFpbiBvYmplY3QgYW5kIHJldHVybnMgaXQuIFRha2VzIGNhcmUgb2YgY29udmVydGluZyBhbGwgb2YgdGhpcyBlbGVtZW50J3MgY2hpbGRyZW4uCiAgICAgKgogICAgICogQHJldHVybnMge09iamVjdH0gYEVsZW1lbnRgIGluc3RhbmNlIGNvbnZlcnRlZCB0byBwbGFpbiBvYmplY3QuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9KU09OIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7CiAgICAgIHZhciBqc29uID0gX2dldChfZ2V0UHJvdG90eXBlT2YoRWxlbWVudC5wcm90b3R5cGUpLCAidG9KU09OIiwgdGhpcykuY2FsbCh0aGlzKTsKCiAgICAgIGpzb24ubmFtZSA9IHRoaXMubmFtZTsKCiAgICAgIGlmICh0aGlzLl9jaGlsZHJlbi5sZW5ndGggPiAwKSB7CiAgICAgICAganNvbi5jaGlsZHJlbiA9IFtdOwoKICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX2NoaWxkcmVuKSwKICAgICAgICAgICAgX3N0ZXAyOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgICAgIGpzb24uY2hpbGRyZW4ucHVzaChub2RlLnRvSlNPTigpKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBqc29uOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIGVsZW1lbnQgYW5kIHJldHVybnMgaXQuIENyZWF0ZWQgZWxlbWVudCBoYXMgdGhlIHNhbWUgbmFtZSBhbmQgYXR0cmlidXRlcyBhcyB0aGUgb3JpZ2luYWwgZWxlbWVudC4KICAgICAqIElmIGNsb25lIGlzIGRlZXAsIHRoZSBvcmlnaW5hbCBlbGVtZW50J3MgY2hpbGRyZW4gYXJlIGFsc28gY2xvbmVkLiBJZiBub3QsIHRoZW4gZW1wdHkgZWxlbWVudCBpcyByZXR1cm5lZC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWVwPWZhbHNlXSBJZiBzZXQgdG8gYHRydWVgIGNsb25lcyBlbGVtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LiBXaGVuIHNldCB0byBgZmFsc2VgLAogICAgICogZWxlbWVudCB3aWxsIGJlIGNsb25lZCB3aXRob3V0IGFueSBjaGlsZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY2xvbmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9uZSgpIHsKICAgICAgdmFyIGRlZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlOwogICAgICB2YXIgY2hpbGRyZW4gPSBkZWVwID8gQXJyYXkuZnJvbSh0aGlzLl9jaGlsZHJlbikubWFwKGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgcmV0dXJuIG5vZGUuX2Nsb25lKHRydWUpOwogICAgICB9KSA6IG51bGw7CiAgICAgIHJldHVybiBuZXcgRWxlbWVudCh0aGlzLm5hbWUsIHRoaXMuZ2V0QXR0cmlidXRlcygpLCBjaGlsZHJlbik7CiAgICB9CiAgICAvKioKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCNfaW5zZXJ0Q2hpbGQgSW5zZXJ0c30gb25lIG9yIG1vcmUgbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGlzIGVsZW1lbnQuCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjYXBwZW5kCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfEl0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbT59IG5vZGVzIE5vZGVzIHRvIGJlIGluc2VydGVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9hcHBlbmRDaGlsZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGVuZENoaWxkKG5vZGVzKSB7CiAgICAgIHRoaXMuX2luc2VydENoaWxkKHRoaXMuY2hpbGRDb3VudCwgbm9kZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBJbnNlcnRzIG9uZSBvciBtb3JlIG5vZGVzIGF0IHRoZSBnaXZlbiBpbmRleCBhbmQgc2V0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjcGFyZW50IHBhcmVudH0gb2YgdGhlc2Ugbm9kZXMKICAgICAqIHRvIHRoaXMgZWxlbWVudC4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNpbnNlcnQKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfEl0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbT59IGl0ZW1zIEl0ZW1zIHRvIGJlIGluc2VydGVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9pbnNlcnRDaGlsZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydENoaWxkKGluZGV4LCBpdGVtcykgewogICAgICB2YXIgbm9kZXMgPSBub3JtYWxpemUoaXRlbXMpOwoKICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihub2RlcyksCiAgICAgICAgICBfc3RlcDM7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwMy52YWx1ZTsKCiAgICAgICAgICAvLyBJZiBub2RlIHRoYXQgaXMgYmVpbmcgYWRkZWQgdG8gdGhpcyBlbGVtZW50IGlzIGFscmVhZHkgaW5zaWRlIGFub3RoZXIgZWxlbWVudCwgZmlyc3QgcmVtb3ZlIGl0IGZyb20gdGhlIG9sZCBwYXJlbnQuCiAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgIT09IG51bGwpIHsKICAgICAgICAgICAgbm9kZS5fcmVtb3ZlKCk7CiAgICAgICAgICB9CgogICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7CiAgICAgIH0KCiAgICAgIHRoaXMuX2NoaWxkcmVuLl9pbnNlcnROb2RlcyhpbmRleCwgbm9kZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIG5vZGVzIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBpbmRleCBhbmQgc2V0cwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI3BhcmVudCBwYXJlbnR9IG9mIHRoZXNlIG5vZGVzIHRvIGBudWxsYC4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNyZW1vdmUKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgZmlyc3Qgbm9kZSB0byByZW1vdmUuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2hvd01hbnk9MV0gTnVtYmVyIG9mIG5vZGVzIHRvIHJlbW92ZS4KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fSBBcnJheSBjb250YWluaW5nIHJlbW92ZWQgbm9kZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3JlbW92ZUNoaWxkcmVuIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlQ2hpbGRyZW4oaW5kZXgpIHsKICAgICAgdmFyIGhvd01hbnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7CgogICAgICB2YXIgbm9kZXMgPSB0aGlzLl9jaGlsZHJlbi5fcmVtb3ZlTm9kZXMoaW5kZXgsIGhvd01hbnkpOwoKICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihub2RlcyksCiAgICAgICAgICBfc3RlcDQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwNC52YWx1ZTsKICAgICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjQuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjQuZigpOwogICAgICB9CgogICAgICByZXR1cm4gbm9kZXM7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYW4gYEVsZW1lbnRgIGluc3RhbmNlIGZyb20gZ2l2ZW4gcGxhaW4gb2JqZWN0IChpLmUuIHBhcnNlZCBKU09OIHN0cmluZykuCiAgICAgKiBDb252ZXJ0cyBgRWxlbWVudGAgY2hpbGRyZW4gdG8gcHJvcGVyIG5vZGVzLgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIFBsYWluIG9iamVjdCB0byBiZSBjb252ZXJ0ZWQgdG8gYEVsZW1lbnRgLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBgRWxlbWVudGAgaW5zdGFuY2UgY3JlYXRlZCB1c2luZyBnaXZlbiBwbGFpbiBvYmplY3QuCiAgICAgKi8KCiAgfV0sIFt7CiAgICBrZXk6ICJmcm9tSlNPTiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikgewogICAgICB2YXIgY2hpbGRyZW4gPSBudWxsOwoKICAgICAgaWYgKGpzb24uY2hpbGRyZW4pIHsKICAgICAgICBjaGlsZHJlbiA9IFtdOwoKICAgICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGpzb24uY2hpbGRyZW4pLAogICAgICAgICAgICBfc3RlcDU7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykgewogICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcDUudmFsdWU7CgogICAgICAgICAgICBpZiAoY2hpbGQubmFtZSkgewogICAgICAgICAgICAgIC8vIElmIGNoaWxkIGhhcyBuYW1lIHByb3BlcnR5LCBpdCBpcyBhbiBFbGVtZW50LgogICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goRWxlbWVudC5mcm9tSlNPTihjaGlsZCkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgYSBUZXh0IG5vZGUuCiAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChUZXh0LmZyb21KU09OKGNoaWxkKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3I1LmYoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgRWxlbWVudChqc29uLm5hbWUsIGpzb24uYXR0cmlidXRlcywgY2hpbGRyZW4pOwogICAgfSAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRvU3RyaW5nKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJcmV0dXJuIGA8JHsgdGhpcy5yb290TmFtZSB8fCB0aGlzLm5hbWUgfT5gOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGxvZygpIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCWNvbnNvbGUubG9nKCAnTW9kZWxFbGVtZW50OiAnICsgdGhpcyApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGxvZ0V4dGVuZGVkKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJY29uc29sZS5sb2coIGBNb2RlbEVsZW1lbnQ6ICR7IHRoaXMgfSwgJHsgdGhpcy5jaGlsZENvdW50IH0gY2hpbGRyZW4sCiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQlhdHRyczogJHsgY29udmVydE1hcFRvU3RyaW5naWZpZWRPYmplY3QoIHRoaXMuZ2V0QXR0cmlidXRlcygpICkgfWAgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2dBbGwoKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAljb25zb2xlLmxvZyggJy0tLS0tLS0tLS0tLS0tLS0tLS0tJyApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJdGhpcy5sb2dFeHRlbmRlZCgpOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwljb25zb2xlLmxvZyggJ0xpc3Qgb2YgY2hpbGRyZW46JyApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJZm9yICggY29uc3QgY2hpbGQgb2YgdGhpcy5nZXRDaGlsZHJlbigpICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJCWNoaWxkLmxvZygpOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHByaW50VHJlZSggbGV2ZWwgPSAwKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlsZXQgc3RyaW5nID0gJyc7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlzdHJpbmcgKz0gJ1x0Jy5yZXBlYXQoIGxldmVsICk7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlzdHJpbmcgKz0gYDwkeyB0aGlzLnJvb3ROYW1lIHx8IHRoaXMubmFtZSB9JHsgY29udmVydE1hcFRvVGFncyggdGhpcy5nZXRBdHRyaWJ1dGVzKCkgKSB9PmA7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlmb3IgKCBjb25zdCBjaGlsZCBvZiB0aGlzLmdldENoaWxkcmVuKCkgKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAkJc3RyaW5nICs9ICdcbic7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAkJaWYgKCBjaGlsZC5pcyggJyR0ZXh0JyApICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJCQljb25zdCB0ZXh0QXR0cnMgPSBjb252ZXJ0TWFwVG9UYWdzKCBjaGlsZC5fYXR0cnMgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCQkJc3RyaW5nICs9ICdcdCcucmVwZWF0KCBsZXZlbCArIDEgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCQkJaWYgKCB0ZXh0QXR0cnMgIT09ICcnICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJCQkJc3RyaW5nICs9IGA8JHRleHQkeyB0ZXh0QXR0cnMgfT5gICsgY2hpbGQuZGF0YSArICc8LyR0ZXh0Pic7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAkJCX0gZWxzZSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAkJCQlzdHJpbmcgKz0gY2hpbGQuZGF0YTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCQkJfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJCX0gZWxzZSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAkJCXN0cmluZyArPSBjaGlsZC5wcmludFRyZWUoIGxldmVsICsgMSApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJCX0KICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCX0KICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCWlmICggdGhpcy5jaGlsZENvdW50ICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJCXN0cmluZyArPSAnXG4nICsgJ1x0Jy5yZXBlYXQoIGxldmVsICk7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAl9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlzdHJpbmcgKz0gYDwvJHsgdGhpcy5yb290TmFtZSB8fCB0aGlzLm5hbWUgfT5gOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJcmV0dXJuIHN0cmluZzsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2dUcmVlKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJY29uc29sZS5sb2coIHRoaXMucHJpbnRUcmVlKCkgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKICB9XSk7CgogIHJldHVybiBFbGVtZW50Owp9KE5vZGUpOyAvLyBDb252ZXJ0cyBzdHJpbmdzIHRvIFRleHQgYW5kIG5vbi1pdGVyYWJsZXMgdG8gYXJyYXlzLgovLwovLyBAcGFyYW0ge1N0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxJdGVyYWJsZS48U3RyaW5nfG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtPn0KLy8gQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59CgoKZXhwb3J0IHsgRWxlbWVudCBhcyBkZWZhdWx0IH07CgpmdW5jdGlvbiBub3JtYWxpemUobm9kZXMpIHsKICAvLyBTZXBhcmF0ZSBjb25kaXRpb24gYmVjYXVzZSBzdHJpbmcgaXMgaXRlcmFibGUuCiAgaWYgKHR5cGVvZiBub2RlcyA9PSAnc3RyaW5nJykgewogICAgcmV0dXJuIFtuZXcgVGV4dChub2RlcyldOwogIH0KCiAgaWYgKCFpc0l0ZXJhYmxlKG5vZGVzKSkgewogICAgbm9kZXMgPSBbbm9kZXNdOwogIH0gLy8gQXJyYXkuZnJvbSB0byBlbmFibGUgLm1hcCgpIG9uIG5vbi1hcnJheXMuCgoKICByZXR1cm4gQXJyYXkuZnJvbShub2RlcykubWFwKGZ1bmN0aW9uIChub2RlKSB7CiAgICBpZiAodHlwZW9mIG5vZGUgPT0gJ3N0cmluZycpIHsKICAgICAgcmV0dXJuIG5ldyBUZXh0KG5vZGUpOwogICAgfQoKICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGV4dFByb3h5KSB7CiAgICAgIHJldHVybiBuZXcgVGV4dChub2RlLmRhdGEsIG5vZGUuZ2V0QXR0cmlidXRlcygpKTsKICAgIH0KCiAgICByZXR1cm4gbm9kZTsKICB9KTsKfQ=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/element.js"],"names":["Node","NodeList","Text","TextProxy","isIterable","Element","name","attrs","children","_children","_insertChild","length","maxOffset","childCount","type","index","getNode","Symbol","iterator","node","getNodeIndex","getNodeStartOffset","offset","offsetToIndex","relativePath","getChild","parentName","options","includeSelf","parent","json","push","toJSON","deep","Array","from","map","_clone","getAttributes","nodes","items","normalize","_remove","_insertNodes","howMany","_removeNodes","child","fromJSON","attributes","data"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/element\n */\n\nimport Node from './node';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n// @if CK_DEBUG_ENGINE // const { stringifyMap, convertMapToStringifiedObject, convertMapToTags } = require( '../dev-utils/utils' );\n\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends module:engine/model/node~Node\n */\nexport default class Element extends Node {\n\t/**\n\t * Creates a model element.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n\t *\n\t * @protected\n\t * @param {String} name Element's name.\n\t * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n\t * One or more nodes to be inserted as children of created element.\n\t */\n\tconstructor( name, attrs, children ) {\n\t\tsuper( attrs );\n\n\t\t/**\n\t\t * Element name.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} module:engine/model/element~Element#name\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * List of children nodes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n\t\t */\n\t\tthis._children = new NodeList();\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Number of this element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._children.maxOffset;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this element, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\telement.is( 'element' ); // -> true\n\t *\t\telement.is( 'node' ); // -> true\n\t *\t\telement.is( 'model:element' ); // -> true\n\t *\t\telement.is( 'model:node' ); // -> true\n\t *\n\t *\t\telement.is( 'view:element' ); // -> false\n\t *\t\telement.is( 'documentSelection' ); // -> false\n\t *\n\t * Assuming that the object being checked is an element, you can also check its\n\t * {@link module:engine/model/element~Element#name name}:\n\t *\n\t *\t\telement.is( 'element', 'image' ); // -> true if this is an <image> element\n\t *\t\telement.is( 'element', 'image' ); // -> same as above\n\t *\t\ttext.is( 'element', 'image' ); -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type Type to check.\n\t * @param {String} [name] Element name.\n\t * @returns {Boolean}\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type === 'element' || type === 'model:element' ||\n\t\t\t\t// From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n\t\t\t\ttype === 'node' || type === 'model:node';\n\t\t}\n\n\t\treturn name === this.name && ( type === 'element' || type === 'model:element' );\n\t}\n\n\t/**\n\t * Gets the child at the given index.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/model/node~Node} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children.getNode( index );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all of this element's children.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number} Child node's index in this element.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.getNodeIndex( node );\n\t}\n\n\t/**\n\t * Returns the starting offset of given child. Starting offset is equal to the sum of\n\t * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n\t * given node is not a child of this element.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number} Child node's starting offset.\n\t */\n\tgetChildStartOffset( node ) {\n\t\treturn this._children.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n\t * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n\t *\n\t *\t\tconst textNode = new Text( 'foo' );\n\t *\t\tconst pElement = new Element( 'p' );\n\t *\t\tconst divElement = new Element( [ textNode, pElement ] );\n\t *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n\t *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n\t *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n\t *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n\t *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n\t *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number}\n\t */\n\toffsetToIndex( offset ) {\n\t\treturn this._children.offsetToIndex( offset );\n\t}\n\n\t/**\n\t * Returns a descendant node by its path relative to this element.\n\t *\n\t *\t\t// <this>a<b>c</b></this>\n\t *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n\t *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n\t *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n\t *\n\t * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n\t * @returns {module:engine/model/node~Node}\n\t */\n\tgetNodeByPath( relativePath ) {\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\tfor ( const index of relativePath ) {\n\t\t\tnode = node.getChild( node.offsetToIndex( index ) );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.\n\t *\n\t * @param {String} parentName The name of the parent element to find.\n\t * @param {Object} [options] Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included while searching.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tfindAncestor( parentName, options = { includeSelf: false } ) {\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( parent.name === parentName ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n\t *\n\t * @returns {Object} `Element` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tjson.name = this.name;\n\n\t\tif ( this._children.length > 0 ) {\n\t\t\tjson.children = [];\n\n\t\t\tfor ( const node of this._children ) {\n\t\t\t\tjson.children.push( node.toJSON() );\n\t\t\t}\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n\t * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n\t *\n\t * @protected\n\t * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any child.\n\t */\n\t_clone( deep = false ) {\n\t\tconst children = deep ? Array.from( this._children ).map( node => node._clone( true ) ) : null;\n\n\t\treturn new Element( this.name, this.getAttributes(), children );\n\t}\n\n\t/**\n\t * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n\t *\n\t * @see module:engine/model/writer~Writer#append\n\t * @protected\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} nodes Nodes to be inserted.\n\t */\n\t_appendChild( nodes ) {\n\t\tthis._insertChild( this.childCount, nodes );\n\t}\n\n\t/**\n\t * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n\t * to this element.\n\t *\n\t * @see module:engine/model/writer~Writer#insert\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_insertChild( index, items ) {\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t}\n\n\t\tthis._children._insertNodes( index, nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index and sets\n\t * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t * @param {Number} index Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tconst nodes = this._children._removeNodes( index, howMany );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t/**\n\t * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n\t * Converts `Element` children to proper nodes.\n\t *\n\t * @param {Object} json Plain object to be converted to `Element`.\n\t * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\tlet children = null;\n\n\t\tif ( json.children ) {\n\t\t\tchildren = [];\n\n\t\t\tfor ( const child of json.children ) {\n\t\t\t\tif ( child.name ) {\n\t\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Element( json.name, json.attributes, children );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `<${ this.rootName || this.name }>`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelElement: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logExtended() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( `ModelElement: ${ this }, ${ this.childCount } children,\n\t// @if CK_DEBUG_ENGINE //\t\tattrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logAll() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( '--------------------' );\n\t// @if CK_DEBUG_ENGINE //\n\t// @if CK_DEBUG_ENGINE // \tthis.logExtended();\n\t// @if CK_DEBUG_ENGINE //\tconsole.log( 'List of children:' );\n\t// @if CK_DEBUG_ENGINE //\n\t// @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE // \t\tchild.log();\n\t// @if CK_DEBUG_ENGINE // \t}\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // printTree( level = 0) {\n\t// @if CK_DEBUG_ENGINE // \tlet string = '';\n\n\t// @if CK_DEBUG_ENGINE // \tstring += '\\t'.repeat( level );\n\t// @if CK_DEBUG_ENGINE // \tstring += `<${ this.rootName || this.name }${ convertMapToTags( this.getAttributes() ) }>`;\n\n\t// @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE // \t\tstring += '\\n';\n\n\t// @if CK_DEBUG_ENGINE // \t\tif ( child.is( '$text' ) ) {\n\t// @if CK_DEBUG_ENGINE // \t\t\tconst textAttrs = convertMapToTags( child._attrs );\n\n\t// @if CK_DEBUG_ENGINE // \t\t\tstring += '\\t'.repeat( level + 1 );\n\n\t// @if CK_DEBUG_ENGINE // \t\t\tif ( textAttrs !== '' ) {\n\t// @if CK_DEBUG_ENGINE // \t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n\t// @if CK_DEBUG_ENGINE // \t\t\t} else {\n\t// @if CK_DEBUG_ENGINE // \t\t\t\tstring += child.data;\n\t// @if CK_DEBUG_ENGINE // \t\t\t}\n\t// @if CK_DEBUG_ENGINE // \t\t} else {\n\t// @if CK_DEBUG_ENGINE // \t\t\tstring += child.printTree( level + 1 );\n\t// @if CK_DEBUG_ENGINE // \t\t}\n\t// @if CK_DEBUG_ENGINE // \t}\n\n\t// @if CK_DEBUG_ENGINE // \tif ( this.childCount ) {\n\t// @if CK_DEBUG_ENGINE // \t\tstring += '\\n' + '\\t'.repeat( level );\n\t// @if CK_DEBUG_ENGINE // \t}\n\n\t// @if CK_DEBUG_ENGINE // \tstring += `</${ this.rootName || this.name }>`;\n\n\t// @if CK_DEBUG_ENGINE // \treturn string;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logTree() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data, node.getAttributes() );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n"]}]}