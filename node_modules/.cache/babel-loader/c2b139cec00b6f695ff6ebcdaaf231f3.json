{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/document.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/document.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zZXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9kb2N1bWVudAogKi8KaW1wb3J0IERpZmZlciBmcm9tICcuL2RpZmZlcic7CmltcG9ydCBSb290RWxlbWVudCBmcm9tICcuL3Jvb3RlbGVtZW50JzsKaW1wb3J0IEhpc3RvcnkgZnJvbSAnLi9oaXN0b3J5JzsKaW1wb3J0IERvY3VtZW50U2VsZWN0aW9uIGZyb20gJy4vZG9jdW1lbnRzZWxlY3Rpb24nOwppbXBvcnQgQ29sbGVjdGlvbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9jb2xsZWN0aW9uJzsKaW1wb3J0IEVtaXR0ZXJNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9lbWl0dGVybWl4aW4nOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IG1peCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9taXgnOwppbXBvcnQgeyBpc0luc2lkZVN1cnJvZ2F0ZVBhaXIsIGlzSW5zaWRlQ29tYmluZWRTeW1ib2wgfSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy91bmljb2RlJzsKaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdsb2Rhc2gtZXMnOyAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGNvbnN0IHsgbG9nRG9jdW1lbnQgfSA9IHJlcXVpcmUoICcuLi9kZXYtdXRpbHMvdXRpbHMnICk7Cgp2YXIgZ3JhdmV5YXJkTmFtZSA9ICckZ3JhdmV5YXJkJzsKLyoqCiAqIERhdGEgbW9kZWwncyBkb2N1bWVudC4gSXQgY29udGFpbnMgdGhlIG1vZGVsJ3Mgc3RydWN0dXJlLCBpdHMgc2VsZWN0aW9uIGFuZCB0aGUgaGlzdG9yeSBvZiBjaGFuZ2VzLgogKgogKiBSZWFkIG1vcmUgYWJvdXQgd29ya2luZyB3aXRoIHRoZSBtb2RlbCBpbgogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI21vZGVsIGludHJvZHVjdGlvbiB0byB0aGUgdGhlIGVkaXRpbmcgZW5naW5lJ3MgYXJjaGl0ZWN0dXJlfS4KICoKICogVXN1YWxseSwgdGhlIGRvY3VtZW50IGNvbnRhaW5zIGp1c3Qgb25lIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3Jvb3RzIHJvb3QgZWxlbWVudH0sIHNvCiAqIHlvdSBjYW4gcmV0cmlldmUgaXQgYnkganVzdCBjYWxsaW5nIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I2dldFJvb3R9IHdpdGhvdXQgc3BlY2lmeWluZyBpdHMgbmFtZToKICoKICoJCW1vZGVsLmRvY3VtZW50LmdldFJvb3QoKTsgLy8gLT4gcmV0dXJucyB0aGUgbWFpbiByb290CiAqCiAqIEhvd2V2ZXIsIHRoZSBkb2N1bWVudCBtYXkgY29udGFpbiBtdWx0aXBsZSByb290cyDigJMgZS5nLiB3aGVuIHRoZSBlZGl0b3IgaGFzIG11bHRpcGxlIGVkaXRhYmxlIGFyZWFzCiAqIChlLmcuIGEgdGl0bGUgYW5kIGEgYm9keSBvZiBhIG1lc3NhZ2UpLgogKgogKiBAbWl4ZXMgbW9kdWxlOnV0aWxzL2VtaXR0ZXJtaXhpbn5FbWl0dGVyTWl4aW4KICovCgp2YXIgRG9jdW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYW4gZW1wdHkgZG9jdW1lbnQgaW5zdGFuY2Ugd2l0aCBubyB7QGxpbmsgI3Jvb3RzfSAob3RoZXIgdGhhbgogICAqIHRoZSB7QGxpbmsgI2dyYXZleWFyZCBncmF2ZXlhcmQgcm9vdH0pLgogICAqLwogIGZ1bmN0aW9uIERvY3VtZW50KG1vZGVsKSB7CiAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb2N1bWVudCk7CgogICAgLyoqCiAgICAgKiBUaGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwgbW9kZWx9IHRoYXQgdGhlIGRvY3VtZW50IGlzIGEgcGFydCBvZi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfQogICAgICovCiAgICB0aGlzLm1vZGVsID0gbW9kZWw7CiAgICAvKioKICAgICAqIFRoZSBkb2N1bWVudCB2ZXJzaW9uLiBJdCBzdGFydHMgZnJvbSBgMGAgYW5kIGV2ZXJ5IG9wZXJhdGlvbiBpbmNyZWFzZXMgdGhlIHZlcnNpb24gbnVtYmVyLiBJdCBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0CiAgICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIG9uIGEgcHJvcGVyIGRvY3VtZW50IHZlcnNpb24uCiAgICAgKgogICAgICogSWYgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uI2Jhc2VWZXJzaW9uIGJhc2UgdmVyc2lvbn0gZG9lcyBub3QgbWF0Y2ggdGhlIGRvY3VtZW50IHZlcnNpb24sCiAgICAgKiBhIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIG1vZGVsLWRvY3VtZW50LWFwcGx5b3BlcmF0aW9uLXdyb25nLXZlcnNpb259IGVycm9yIGlzIHRocm93bi4KICAgICAqCiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogICAgdGhpcy52ZXJzaW9uID0gMDsKICAgIC8qKgogICAgICogVGhlIGRvY3VtZW50J3MgaGlzdG9yeS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL2hpc3Rvcnl+SGlzdG9yeX0KICAgICAqLwoKICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMpOwogICAgLyoqCiAgICAgKiBUaGUgc2VsZWN0aW9uIGluIHRoaXMgZG9jdW1lbnQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0KICAgICAqLwoKICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IERvY3VtZW50U2VsZWN0aW9uKHRoaXMpOwogICAgLyoqCiAgICAgKiBBIGxpc3Qgb2Ygcm9vdHMgdGhhdCBhcmUgb3duZWQgYW5kIG1hbmFnZWQgYnkgdGhpcyBkb2N1bWVudC4gVXNlIHtAbGluayAjY3JlYXRlUm9vdH0gYW5kCiAgICAgKiB7QGxpbmsgI2dldFJvb3R9IHRvIG1hbmlwdWxhdGUgaXQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2NvbGxlY3Rpb25+Q29sbGVjdGlvbn0KICAgICAqLwoKICAgIHRoaXMucm9vdHMgPSBuZXcgQ29sbGVjdGlvbih7CiAgICAgIGlkUHJvcGVydHk6ICdyb290TmFtZScKICAgIH0pOwogICAgLyoqCiAgICAgKiBUaGUgbW9kZWwgZGlmZmVyIG9iamVjdC4gSXRzIHJvbGUgaXMgdG8gYnVmZmVyIGNoYW5nZXMgZG9uZSBvbiB0aGUgbW9kZWwgZG9jdW1lbnQgYW5kIHRoZW4gY2FsY3VsYXRlIGEgZGlmZiBvZiB0aG9zZSBjaGFuZ2VzLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvZGlmZmVyfkRpZmZlcn0KICAgICAqLwoKICAgIHRoaXMuZGlmZmVyID0gbmV3IERpZmZlcihtb2RlbC5tYXJrZXJzKTsKICAgIC8qKgogICAgICogUG9zdC1maXhlciBjYWxsYmFja3MgcmVnaXN0ZXJlZCB0byB0aGUgbW9kZWwgZG9jdW1lbnQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtTZXQuPEZ1bmN0aW9uPn0KICAgICAqLwoKICAgIHRoaXMuX3Bvc3RGaXhlcnMgPSBuZXcgU2V0KCk7CiAgICAvKioKICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkIHVudGlsCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtCb29sZWFufQogICAgICovCgogICAgdGhpcy5faGFzU2VsZWN0aW9uQ2hhbmdlZEZyb21UaGVMYXN0Q2hhbmdlQmxvY2sgPSBmYWxzZTsgLy8gR3JhdmV5YXJkIHRyZWUgcm9vdC4gRG9jdW1lbnQgYWx3YXlzIGhhdmUgYSBncmF2ZXlhcmQgcm9vdCwgd2hpY2ggc3RvcmVzIHJlbW92ZWQgbm9kZXMuCgogICAgdGhpcy5jcmVhdGVSb290KCckcm9vdCcsIGdyYXZleWFyZE5hbWUpOyAvLyBGaXJzdCwgaWYgdGhlIG9wZXJhdGlvbiBpcyBhIGRvY3VtZW50IG9wZXJhdGlvbiBjaGVjayBpZiBpdCdzIGJhc2UgdmVyc2lvbiBpcyBjb3JyZWN0LgoKICAgIHRoaXMubGlzdGVuVG8obW9kZWwsICdhcHBseU9wZXJhdGlvbicsIGZ1bmN0aW9uIChldnQsIGFyZ3MpIHsKICAgICAgdmFyIG9wZXJhdGlvbiA9IGFyZ3NbMF07CgogICAgICBpZiAob3BlcmF0aW9uLmlzRG9jdW1lbnRPcGVyYXRpb24gJiYgb3BlcmF0aW9uLmJhc2VWZXJzaW9uICE9PSBfdGhpcy52ZXJzaW9uKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogT25seSBvcGVyYXRpb25zIHdpdGggbWF0Y2hpbmcgdmVyc2lvbnMgY2FuIGJlIGFwcGxpZWQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgbW9kZWwtZG9jdW1lbnQtYXBwbHlvcGVyYXRpb24td3JvbmctdmVyc2lvbgogICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLWRvY3VtZW50LWFwcGx5b3BlcmF0aW9uLXdyb25nLXZlcnNpb24nLCBfdGhpcywgewogICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24KICAgICAgICB9KTsKICAgICAgfQogICAgfSwgewogICAgICBwcmlvcml0eTogJ2hpZ2hlc3QnCiAgICB9KTsgLy8gVGhlbiwgc3RpbGwgYmVmb3JlIGFuIG9wZXJhdGlvbiBpcyBhcHBsaWVkIG9uIG1vZGVsLCBidWZmZXIgdGhlIGNoYW5nZSBpbiBkaWZmZXIuCgogICAgdGhpcy5saXN0ZW5Ubyhtb2RlbCwgJ2FwcGx5T3BlcmF0aW9uJywgZnVuY3Rpb24gKGV2dCwgYXJncykgewogICAgICB2YXIgb3BlcmF0aW9uID0gYXJnc1swXTsKCiAgICAgIGlmIChvcGVyYXRpb24uaXNEb2N1bWVudE9wZXJhdGlvbikgewogICAgICAgIF90aGlzLmRpZmZlci5idWZmZXJPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgICAgfQogICAgfSwgewogICAgICBwcmlvcml0eTogJ2hpZ2gnCiAgICB9KTsgLy8gQWZ0ZXIgdGhlIG9wZXJhdGlvbiBpcyBhcHBsaWVkLCBidW1wIGRvY3VtZW50J3MgdmVyc2lvbiBhbmQgYWRkIHRoZSBvcGVyYXRpb24gdG8gdGhlIGhpc3RvcnkuCgogICAgdGhpcy5saXN0ZW5Ubyhtb2RlbCwgJ2FwcGx5T3BlcmF0aW9uJywgZnVuY3Rpb24gKGV2dCwgYXJncykgewogICAgICB2YXIgb3BlcmF0aW9uID0gYXJnc1swXTsKCiAgICAgIGlmIChvcGVyYXRpb24uaXNEb2N1bWVudE9wZXJhdGlvbikgewogICAgICAgIF90aGlzLnZlcnNpb24rKzsKCiAgICAgICAgX3RoaXMuaGlzdG9yeS5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgICAgfQogICAgfSwgewogICAgICBwcmlvcml0eTogJ2xvdycKICAgIH0pOyAvLyBMaXN0ZW4gdG8gc2VsZWN0aW9uIGNoYW5nZXMuIElmIHNlbGVjdGlvbiBjaGFuZ2VkLCBtYXJrIGl0LgoKICAgIHRoaXMubGlzdGVuVG8odGhpcy5zZWxlY3Rpb24sICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7CiAgICAgIF90aGlzLl9oYXNTZWxlY3Rpb25DaGFuZ2VkRnJvbVRoZUxhc3RDaGFuZ2VCbG9jayA9IHRydWU7CiAgICB9KTsgLy8gQnVmZmVyIG1hcmtlciBjaGFuZ2VzLgogICAgLy8gVGhpcyBpcyBub3QgY292ZXJlZCBpbiBidWZmZXJpbmcgb3BlcmF0aW9ucyBiZWNhdXNlIG1hcmtlcnMgbWF5IGNoYW5nZSBvdXRzaWRlIG9mIHRoZW0gKHdoZW4gdGhleQogICAgLy8gYXJlIG1vZGlmaWVkIHVzaW5nIGBtb2RlbC5tYXJrZXJzYCBjb2xsZWN0aW9uLCBub3QgdGhyb3VnaCBgTWFya2VyT3BlcmF0aW9uYCkuCgogICAgdGhpcy5saXN0ZW5Ubyhtb2RlbC5tYXJrZXJzLCAndXBkYXRlJywgZnVuY3Rpb24gKGV2dCwgbWFya2VyLCBvbGRSYW5nZSwgbmV3UmFuZ2UpIHsKICAgICAgLy8gV2hlbmV2ZXIgbWFya2VyIGlzIHVwZGF0ZWQsIGJ1ZmZlciB0aGF0IGNoYW5nZS4KICAgICAgX3RoaXMuZGlmZmVyLmJ1ZmZlck1hcmtlckNoYW5nZShtYXJrZXIubmFtZSwgb2xkUmFuZ2UsIG5ld1JhbmdlLCBtYXJrZXIuYWZmZWN0c0RhdGEpOwoKICAgICAgaWYgKG9sZFJhbmdlID09PSBudWxsKSB7CiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBtYXJrZXIsIGFkZCBhIGxpc3RlbmVyIHRoYXQgd2lsbCBidWZmZXIgY2hhbmdlIHdoZW5ldmVyIG1hcmtlciBjaGFuZ2VzLgogICAgICAgIG1hcmtlci5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2dCwgb2xkUmFuZ2UpIHsKICAgICAgICAgIF90aGlzLmRpZmZlci5idWZmZXJNYXJrZXJDaGFuZ2UobWFya2VyLm5hbWUsIG9sZFJhbmdlLCBtYXJrZXIuZ2V0UmFuZ2UoKSwgbWFya2VyLmFmZmVjdHNEYXRhKTsKICAgICAgICB9KTsKICAgICAgfQogICAgfSk7CiAgfQogIC8qKgogICAqIFRoZSBncmF2ZXlhcmQgdHJlZSByb290LiBBIGRvY3VtZW50IGFsd2F5cyBoYXMgYSBncmF2ZXlhcmQgcm9vdCB0aGF0IHN0b3JlcyByZW1vdmVkIG5vZGVzLgogICAqCiAgICogQHJlYWRvbmx5CiAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yb290ZWxlbWVudH5Sb290RWxlbWVudH0KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhEb2N1bWVudCwgW3sKICAgIGtleTogImdyYXZleWFyZCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0Um9vdChncmF2ZXlhcmROYW1lKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyByb290LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZWxlbWVudE5hbWU9JyRyb290J10gVGhlIGVsZW1lbnQgbmFtZS4gRGVmYXVsdHMgdG8gYCckcm9vdCdgIHdoaWNoIGFsc28gaGFzIHNvbWUgYmFzaWMgc2NoZW1hIGRlZmluZWQKICAgICAqIChgJGJsb2NrYHMgYXJlIGFsbG93ZWQgaW5zaWRlIHRoZSBgJHJvb3RgKS4gTWFrZSBzdXJlIHRvIGRlZmluZSBhIHByb3BlciBzY2hlbWEgaWYgeW91IHVzZSBhIGRpZmZlcmVudCBuYW1lLgogICAgICogQHBhcmFtIHtTdHJpbmd9IFtyb290TmFtZT0nbWFpbiddIEEgdW5pcXVlIHJvb3QgbmFtZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Jvb3RlbGVtZW50flJvb3RFbGVtZW50fSBUaGUgY3JlYXRlZCByb290LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVJvb3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoKSB7CiAgICAgIHZhciBlbGVtZW50TmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyRyb290JzsKICAgICAgdmFyIHJvb3ROYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnbWFpbic7CgogICAgICBpZiAodGhpcy5yb290cy5nZXQocm9vdE5hbWUpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQSByb290IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGFscmVhZHkgZXhpc3RzLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIG1vZGVsLWRvY3VtZW50LWNyZWF0ZXJvb3QtbmFtZS1leGlzdHMKICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9IGRvYwogICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLWRvY3VtZW50LWNyZWF0ZXJvb3QtbmFtZS1leGlzdHMnLCB0aGlzLCB7CiAgICAgICAgICBuYW1lOiByb290TmFtZQogICAgICAgIH0pOwogICAgICB9CgogICAgICB2YXIgcm9vdCA9IG5ldyBSb290RWxlbWVudCh0aGlzLCBlbGVtZW50TmFtZSwgcm9vdE5hbWUpOwogICAgICB0aGlzLnJvb3RzLmFkZChyb290KTsKICAgICAgcmV0dXJuIHJvb3Q7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycyBzZXQgYnkgdGhlIGRvY3VtZW50IGluc3RhbmNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImRlc3Ryb3kiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7CiAgICAgIHRoaXMuc2VsZWN0aW9uLmRlc3Ryb3koKTsKICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSByb290IGJ5IGl0cyBuYW1lLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZT0nbWFpbiddIEEgdW5pcXVlIHJvb3QgbmFtZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Jvb3RlbGVtZW50flJvb3RFbGVtZW50fG51bGx9IFRoZSByb290IHJlZ2lzdGVyZWQgdW5kZXIgYSBnaXZlbiBuYW1lIG9yIGBudWxsYCB3aGVuCiAgICAgKiB0aGVyZSBpcyBubyByb290IHdpdGggdGhlIGdpdmVuIG5hbWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Um9vdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdCgpIHsKICAgICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdtYWluJzsKICAgICAgcmV0dXJuIHRoaXMucm9vdHMuZ2V0KG5hbWUpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggbmFtZXMgb2YgYWxsIHJvb3RzICh3aXRob3V0IHRoZSB7QGxpbmsgI2dyYXZleWFyZH0pIGFkZGVkIHRvIHRoZSBkb2N1bWVudC4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59IFJvb3RzIG5hbWVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFJvb3ROYW1lcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdE5hbWVzKCkgewogICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJvb3RzLCBmdW5jdGlvbiAocm9vdCkgewogICAgICAgIHJldHVybiByb290LnJvb3ROYW1lOwogICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsKICAgICAgICByZXR1cm4gbmFtZSAhPSBncmF2ZXlhcmROYW1lOwogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogVXNlZCB0byByZWdpc3RlciBhIHBvc3QtZml4ZXIgY2FsbGJhY2suIEEgcG9zdC1maXhlciBtZWNoYW5pc20gZ3VhcmFudGVlcyB0aGF0IHRoZSBmZWF0dXJlcwogICAgICogd2lsbCBvcGVyYXRlIG9uIGEgY29ycmVjdCBtb2RlbCBzdGF0ZS4KICAgICAqCiAgICAgKiBBbiBleGVjdXRpb24gb2YgYSBmZWF0dXJlIG1heSBsZWFkIHRvIGFuIGluY29ycmVjdCBkb2N1bWVudCB0cmVlIHN0YXRlLiBUaGUgY2FsbGJhY2tzIGFyZSB1c2VkIHRvIGZpeCB0aGUgZG9jdW1lbnQgdHJlZSBhZnRlcgogICAgICogaXQgaGFzIGNoYW5nZWQuIFBvc3QtZml4ZXJzIGFyZSBmaXJlZCBqdXN0IGFmdGVyIGFsbCBjaGFuZ2VzIGZyb20gdGhlIG91dGVybW9zdCBjaGFuZ2UgYmxvY2sgd2VyZSBhcHBsaWVkIGJ1dAogICAgICogYmVmb3JlIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpjaGFuZ2UgY2hhbmdlIGV2ZW50fSBpcyBmaXJlZC4gSWYgYSBwb3N0LWZpeGVyIGNhbGxiYWNrIG1hZGUKICAgICAqIGEgY2hhbmdlLCBpdCBzaG91bGQgcmV0dXJuIGB0cnVlYC4gV2hlbiB0aGlzIGhhcHBlbnMsIGFsbCBwb3N0LWZpeGVycyBhcmUgZmlyZWQgYWdhaW4gdG8gY2hlY2sgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkCiAgICAgKiBub3QgYmUgZml4ZWQgaW4gdGhlIG5ldyBkb2N1bWVudCB0cmVlIHN0YXRlLgogICAgICoKICAgICAqIEFzIGEgcGFyYW1ldGVyLCBhIHBvc3QtZml4ZXIgY2FsbGJhY2sgcmVjZWl2ZXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyIHdyaXRlcn0gaW5zdGFuY2UgY29ubmVjdGVkIHdpdGggdGhlCiAgICAgKiBleGVjdXRlZCBjaGFuZ2VzIGJsb2NrLiBUaGFua3MgdG8gdGhhdCwgYWxsIGNoYW5nZXMgZG9uZSBieSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2FtZQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvYmF0Y2h+QmF0Y2ggYmF0Y2h9IChhbmQgdW5kbyBzdGVwKSBhcyB0aGUgb3JpZ2luYWwgY2hhbmdlcy4gVGhpcyBtYWtlcyBwb3N0LWZpeGVyIGNoYW5nZXMgdHJhbnNwYXJlbnQKICAgICAqIGZvciB0aGUgdXNlci4KICAgICAqCiAgICAgKiBBbiBleGFtcGxlIG9mIGEgcG9zdC1maXhlciBpcyBhIGNhbGxiYWNrIHRoYXQgY2hlY2tzIGlmIGFsbCB0aGUgZGF0YSB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgZWRpdG9yLiBJZiBzbywgdGhlCiAgICAgKiBjYWxsYmFjayBzaG91bGQgYWRkIGFuIGVtcHR5IHBhcmFncmFwaCBzbyB0aGF0IHRoZSBlZGl0b3IgaXMgbmV2ZXIgZW1wdHk6CiAgICAgKgogICAgICoJCWRvY3VtZW50LnJlZ2lzdGVyUG9zdEZpeGVyKCB3cml0ZXIgPT4gewogICAgICoJCQljb25zdCBjaGFuZ2VzID0gZG9jdW1lbnQuZGlmZmVyLmdldENoYW5nZXMoKTsKICAgICAqCiAgICAgKgkJCS8vIENoZWNrIGlmIHRoZSBjaGFuZ2VzIGxlYWQgdG8gYW4gZW1wdHkgcm9vdCBpbiB0aGUgZWRpdG9yLgogICAgICoJCQlmb3IgKCBjb25zdCBlbnRyeSBvZiBjaGFuZ2VzICkgewogICAgICoJCQkJaWYgKCBlbnRyeS50eXBlID09ICdyZW1vdmUnICYmIGVudHJ5LnBvc2l0aW9uLnJvb3QuaXNFbXB0eSApIHsKICAgICAqCQkJCQl3cml0ZXIuaW5zZXJ0RWxlbWVudCggJ3BhcmFncmFwaCcsIGVudHJ5LnBvc2l0aW9uLnJvb3QsIDAgKTsKICAgICAqCiAgICAgKgkJCQkJLy8gSXQgaXMgZmluZSB0byByZXR1cm4gZWFybHksIGV2ZW4gaWYgbXVsdGlwbGUgcm9vdHMgd291bGQgbmVlZCB0byBiZSBmaXhlZC4KICAgICAqCQkJCQkvLyBBbGwgcG9zdC1maXhlcnMgd2lsbCBiZSBmaXJlZCBhZ2Fpbiwgc28gaWYgdGhlcmUgYXJlIG1vcmUgZW1wdHkgcm9vdHMsIHRob3NlIHdpbGwgYmUgZml4ZWQsIHRvby4KICAgICAqCQkJCQlyZXR1cm4gdHJ1ZTsKICAgICAqCQkJCX0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb3N0Rml4ZXIKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZWdpc3RlclBvc3RGaXhlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJQb3N0Rml4ZXIocG9zdEZpeGVyKSB7CiAgICAgIHRoaXMuX3Bvc3RGaXhlcnMuYWRkKHBvc3RGaXhlcik7CiAgICB9CiAgICAvKioKICAgICAqIEEgY3VzdG9tIGB0b0pTT04oKWAgbWV0aG9kIHRvIHNvbHZlIGNoaWxkLXBhcmVudCBjaXJjdWxhciBkZXBlbmRlbmNpZXMuCiAgICAgKgogICAgICogQHJldHVybnMge09iamVjdH0gQSBjbG9uZSBvZiB0aGlzIG9iamVjdCB3aXRoIHRoZSBkb2N1bWVudCBwcm9wZXJ0eSBjaGFuZ2VkIHRvIGEgc3RyaW5nLgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvSlNPTiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkgewogICAgICB2YXIganNvbiA9IGNsb25lKHRoaXMpOyAvLyBEdWUgdG8gY2lyY3VsYXIgcmVmZXJlbmNlcyB3ZSBuZWVkIHRvIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlLgoKICAgICAganNvbi5zZWxlY3Rpb24gPSAnW2VuZ2luZS5tb2RlbC5Eb2N1bWVudFNlbGVjdGlvbl0nOwogICAgICBqc29uLm1vZGVsID0gJ1tlbmdpbmUubW9kZWwuTW9kZWxdJzsKICAgICAgcmV0dXJuIGpzb247CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrIGlmIHRoZXJlIHdlcmUgYW55IGNoYW5nZXMgZG9uZSBvbiBkb2N1bWVudCwgYW5kIGlmIHNvLCBjYWxsIHBvc3QtZml4ZXJzLAogICAgICogZmlyZSBgY2hhbmdlYCBldmVudCBmb3IgZmVhdHVyZXMgYW5kIGNvbnZlcnNpb24gYW5kIHRoZW4gcmVzZXQgdGhlIGRpZmZlci4KICAgICAqIEZpcmUgYGNoYW5nZTpkYXRhYCBldmVudCB3aGVuIGF0IGxlYXN0IG9uZSBvcGVyYXRpb24gb3IgYnVmZmVyZWQgbWFya2VyIGNoYW5nZXMgdGhlIGRhdGEuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQGZpcmVzIGNoYW5nZQogICAgICogQGZpcmVzIGNoYW5nZTpkYXRhCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyIFRoZSB3cml0ZXIgb24gd2hpY2ggcG9zdC1maXhlcnMgd2lsbCBiZSBjYWxsZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2hhbmRsZUNoYW5nZUJsb2NrIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2hhbmdlQmxvY2sod3JpdGVyKSB7CiAgICAgIGlmICh0aGlzLl9oYXNEb2N1bWVudENoYW5nZWRGcm9tVGhlTGFzdENoYW5nZUJsb2NrKCkpIHsKICAgICAgICB0aGlzLl9jYWxsUG9zdEZpeGVycyh3cml0ZXIpOyAvLyBSZWZyZXNoIHNlbGVjdGlvbiBhdHRyaWJ1dGVzIGFjY29yZGluZyB0byB0aGUgZmluYWwgcG9zaXRpb24gaW4gdGhlIG1vZGVsIGFmdGVyIHRoZSBjaGFuZ2UuCgoKICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZWZyZXNoKCk7CgogICAgICAgIGlmICh0aGlzLmRpZmZlci5oYXNEYXRhQ2hhbmdlcygpKSB7CiAgICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZTpkYXRhJywgd3JpdGVyLmJhdGNoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnLCB3cml0ZXIuYmF0Y2gpOwogICAgICAgIH0gLy8gVGhlb3JldGljYWxseSwgaXQgaXMgbm90IG5lY2Vzc2FyeSB0byByZWZyZXNoIHNlbGVjdGlvbiBhZnRlciBjaGFuZ2UgZXZlbnQgYmVjYXVzZQogICAgICAgIC8vIHBvc3QtZml4ZXJzIGFyZSB0aGUgbGFzdCB3aG8gc2hvdWxkIGNoYW5nZSB0aGUgbW9kZWwsIGJ1dCBqdXN0IGluIGNhc2UuLi4KCgogICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlZnJlc2goKTsKICAgICAgICB0aGlzLmRpZmZlci5yZXNldCgpOwogICAgICB9CgogICAgICB0aGlzLl9oYXNTZWxlY3Rpb25DaGFuZ2VkRnJvbVRoZUxhc3RDaGFuZ2VCbG9jayA9IGZhbHNlOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlcmUgaXMgYSBidWZmZXJlZCBjaGFuZ2Ugb3IgaWYgdGhlIHNlbGVjdGlvbiBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0CiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNlbnF1ZXVlQ2hhbmdlIGBlbnF1ZXVlQ2hhbmdlKClgIGJsb2NrfQogICAgICogb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlIGBjaGFuZ2UoKWAgYmxvY2t9LgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBkb2N1bWVudCBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGBjaGFuZ2UoKWAgb3IgYGVucXVldWVDaGFuZ2UoKWAgYmxvY2suCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2hhc0RvY3VtZW50Q2hhbmdlZEZyb21UaGVMYXN0Q2hhbmdlQmxvY2siLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9oYXNEb2N1bWVudENoYW5nZWRGcm9tVGhlTGFzdENoYW5nZUJsb2NrKCkgewogICAgICByZXR1cm4gIXRoaXMuZGlmZmVyLmlzRW1wdHkgfHwgdGhpcy5faGFzU2VsZWN0aW9uQ2hhbmdlZEZyb21UaGVMYXN0Q2hhbmdlQmxvY2s7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgcm9vdCBmb3IgdGhpcyBkb2N1bWVudCB3aGljaCBpcyBlaXRoZXIgdGhlIGZpcnN0IHJvb3QgdGhhdCB3YXMgYWRkZWQgdG8gdGhlIGRvY3VtZW50IHVzaW5nCiAgICAgKiB7QGxpbmsgI2NyZWF0ZVJvb3R9IG9yIHRoZSB7QGxpbmsgI2dyYXZleWFyZCBncmF2ZXlhcmQgcm9vdH0gaWYgbm8gb3RoZXIgcm9vdHMgd2VyZSBjcmVhdGVkLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Jvb3RlbGVtZW50flJvb3RFbGVtZW50fSBUaGUgZGVmYXVsdCByb290IGZvciB0aGlzIGRvY3VtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXREZWZhdWx0Um9vdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRSb290KCkgewogICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5yb290cyksCiAgICAgICAgICBfc3RlcDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciByb290ID0gX3N0ZXAudmFsdWU7CgogICAgICAgICAgaWYgKHJvb3QgIT09IHRoaXMuZ3JhdmV5YXJkKSB7CiAgICAgICAgICAgIHJldHVybiByb290OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5ncmF2ZXlhcmQ7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgcmFuZ2UgZm9yIHRoaXMgc2VsZWN0aW9uLiBUaGUgZGVmYXVsdCByYW5nZSBpcyBhIGNvbGxhcHNlZCByYW5nZSB0aGF0IHN0YXJ0cyBhbmQgZW5kcwogICAgICogYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNlbGVjdGlvbidzIGRvY3VtZW50IHtAbGluayAjX2dldERlZmF1bHRSb290IGRlZmF1bHQgcm9vdH0uCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldERlZmF1bHRSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRSYW5nZSgpIHsKICAgICAgdmFyIGRlZmF1bHRSb290ID0gdGhpcy5fZ2V0RGVmYXVsdFJvb3QoKTsKCiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7CiAgICAgIHZhciBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7IC8vIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIHdoZXJlIHRoZSBzZWxlY3Rpb24gY2FuIGJlIHB1dC4KCiAgICAgIHZhciBwb3NpdGlvbiA9IG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoZGVmYXVsdFJvb3QsIFswXSk7CiAgICAgIHZhciBuZWFyZXN0UmFuZ2UgPSBzY2hlbWEuZ2V0TmVhcmVzdFNlbGVjdGlvblJhbmdlKHBvc2l0aW9uKTsgLy8gSWYgdmFsaWQgc2VsZWN0aW9uIHJhbmdlIGlzIG5vdCBmb3VuZCAtIHJldHVybiByYW5nZSBjb2xsYXBzZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcm9vdC4KCiAgICAgIHJldHVybiBuZWFyZXN0UmFuZ2UgfHwgbW9kZWwuY3JlYXRlUmFuZ2UocG9zaXRpb24pOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfSBpcyBhIHZhbGlkIHJhbmdlIGZvcgogICAgICogdGhlIHtAbGluayAjc2VsZWN0aW9uIGRvY3VtZW50J3Mgc2VsZWN0aW9ufS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBBIHJhbmdlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBgcmFuZ2VgIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfdmFsaWRhdGVTZWxlY3Rpb25SYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRlU2VsZWN0aW9uUmFuZ2UocmFuZ2UpIHsKICAgICAgcmV0dXJuIHZhbGlkYXRlVGV4dE5vZGVQb3NpdGlvbihyYW5nZS5zdGFydCkgJiYgdmFsaWRhdGVUZXh0Tm9kZVBvc2l0aW9uKHJhbmdlLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIFBlcmZvcm1zIHBvc3QtZml4ZXIgbG9vcHMuIEV4ZWN1dGVzIHBvc3QtZml4ZXIgY2FsbGJhY2tzIGFzIGxvbmcgYXMgbm9uZSBvZiB0aGVtIGhhcyBkb25lIGFueSBjaGFuZ2VzIHRvIHRoZSBtb2RlbC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9IHdyaXRlciBUaGUgd3JpdGVyIG9uIHdoaWNoIHBvc3QtZml4ZXIgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jYWxsUG9zdEZpeGVycyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGxQb3N0Rml4ZXJzKHdyaXRlcikgewogICAgICB2YXIgd2FzRml4ZWQgPSBmYWxzZTsKCiAgICAgIGRvIHsKICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX3Bvc3RGaXhlcnMpLAogICAgICAgICAgICBfc3RlcDI7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykgewogICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgICAgIC8vIEVuc3VyZSBzZWxlY3Rpb24gYXR0cmlidXRlcyBhcmUgdXAgdG8gZGF0ZSBiZWZvcmUgZWFjaCBwb3N0LWZpeGVyLgogICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9pc3N1ZXMvMTY3My4KICAgICAgICAgICAgLy8KICAgICAgICAgICAgLy8gSXQgbWlnaHQgYmUgZ29vZCB0byByZWZyZXNoIHRoZSBzZWxlY3Rpb24gYWZ0ZXIgZWFjaCBvcGVyYXRpb24gYnV0IGF0IHRoZSBtb21lbnQgaXQgbGVhZHMKICAgICAgICAgICAgLy8gdG8gbG9zaW5nIGF0dHJpYnV0ZXMgZm9yIGNvbXBvc2l0aW9uIG9yIGFuZCBzcGVsbCBjaGVja2luZwogICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LXR5cGluZy9pc3N1ZXMvMTg4CiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlZnJlc2goKTsKICAgICAgICAgICAgd2FzRml4ZWQgPSBjYWxsYmFjayh3cml0ZXIpOwoKICAgICAgICAgICAgaWYgKHdhc0ZpeGVkKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTsKICAgICAgICB9CiAgICAgIH0gd2hpbGUgKHdhc0ZpeGVkKTsKICAgIH0KICAgIC8qKgogICAgICogRmlyZWQgYWZ0ZXIgZWFjaCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNlbnF1ZXVlQ2hhbmdlIGBlbnF1ZXVlQ2hhbmdlKClgIGJsb2NrfSBvciB0aGUgb3V0ZXJtb3N0CiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjaGFuZ2UgYGNoYW5nZSgpYCBibG9ja30gd2FzIGV4ZWN1dGVkIGFuZCB0aGUgZG9jdW1lbnQgd2FzIGNoYW5nZWQKICAgICAqIGR1cmluZyB0aGF0IGJsb2NrJ3MgZXhlY3V0aW9uLgogICAgICoKICAgICAqIFRoZSBjaGFuZ2VzIHdoaWNoIHRoaXMgZXZlbnQgd2lsbCBjb3ZlciBpbmNsdWRlOgogICAgICoKICAgICAqICogZG9jdW1lbnQgc3RydWN0dXJlIGNoYW5nZXMsCiAgICAgKiAqIHNlbGVjdGlvbiBjaGFuZ2VzLAogICAgICogKiBtYXJrZXIgY2hhbmdlcy4KICAgICAqCiAgICAgKiBJZiB5b3Ugd2FudCB0byBiZSBub3RpZmllZCBhYm91dCBhbGwgdGhlc2UgY2hhbmdlcywgdGhlbiBzaW1wbHkgbGlzdGVuIHRvIHRoaXMgZXZlbnQgbGlrZSB0aGlzOgogICAgICoKICAgICAqCQltb2RlbC5kb2N1bWVudC5vbiggJ2NoYW5nZScsICgpID0+IHsKICAgICAqCQkJY29uc29sZS5sb2coICdUaGUgZG9jdW1lbnQgaGFzIGNoYW5nZWQhJyApOwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBJZiwgaG93ZXZlciwgeW91IG9ubHkgd2FudCB0byBiZSBub3RpZmllZCBhYm91dCB0aGUgZGF0YSBjaGFuZ2VzLCB0aGVuIHVzZSB0aGUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I2V2ZW50OmNoYW5nZTpkYXRhIGNoYW5nZTpkYXRhfSBldmVudCwKICAgICAqIHdoaWNoIGlzIGZpcmVkIGZvciBkb2N1bWVudCBzdHJ1Y3R1cmUgY2hhbmdlcyBhbmQgbWFya2VyIGNoYW5nZXMgKHdoaWNoIGFmZmVjdHMgdGhlIGRhdGEpLgogICAgICoKICAgICAqCQltb2RlbC5kb2N1bWVudC5vbiggJ2NoYW5nZTpkYXRhJywgKCkgPT4gewogICAgICoJCQljb25zb2xlLmxvZyggJ1RoZSBkYXRhIGhhcyBjaGFuZ2VkIScgKTsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQGV2ZW50IGNoYW5nZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNofSBiYXRjaCBUaGUgYmF0Y2ggdGhhdCB3YXMgdXNlZCBpbiB0aGUgZXhlY3V0ZWQgY2hhbmdlcyBibG9jay4KICAgICAqLwoKICAgIC8qKgogICAgICogSXQgaXMgYSBuYXJyb3dlciB2ZXJzaW9uIG9mIHRoZSB7QGxpbmsgI2V2ZW50OmNoYW5nZX0gZXZlbnQuIEl0IGlzIGZpcmVkIGZvciBjaGFuZ2VzIHdoaWNoCiAgICAgKiBhZmZlY3QgdGhlIGVkaXRvciBkYXRhLiBUaGlzIGlzOgogICAgICoKICAgICAqICogZG9jdW1lbnQgc3RydWN0dXJlIGNoYW5nZXMsCiAgICAgKiAqIG1hcmtlciBjaGFuZ2VzICh3aGljaCBhZmZlY3RzIHRoZSBkYXRhKS4KICAgICAqCiAgICAgKiBJZiB5b3Ugd2FudCB0byBiZSBub3RpZmllZCBhYm91dCB0aGUgZGF0YSBjaGFuZ2VzLCB0aGVuIGxpc3RlbiB0byB0aGlzIGV2ZW50OgogICAgICoKICAgICAqCQltb2RlbC5kb2N1bWVudC5vbiggJ2NoYW5nZTpkYXRhJywgKCkgPT4gewogICAgICoJCQljb25zb2xlLmxvZyggJ1RoZSBkYXRhIGhhcyBjaGFuZ2VkIScgKTsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogSWYgeW91IHdvdWxkIGxpa2UgdG8gbGlzdGVuIHRvIGFsbCBkb2N1bWVudCBjaGFuZ2VzLCB0aGVuIGNoZWNrIG91dCB0aGUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I2V2ZW50OmNoYW5nZSBjaGFuZ2V9IGV2ZW50LgogICAgICoKICAgICAqIEBldmVudCBjaGFuZ2U6ZGF0YQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNofSBiYXRjaCBUaGUgYmF0Y2ggdGhhdCB3YXMgdXNlZCBpbiB0aGUgZXhlY3V0ZWQgY2hhbmdlcyBibG9jay4KICAgICAqLwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2coIHZlcnNpb24gPSBudWxsICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJdmVyc2lvbiA9IHZlcnNpb24gPT09IG51bGwgPyB0aGlzLnZlcnNpb24gOiB2ZXJzaW9uOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJbG9nRG9jdW1lbnQoIHRoaXMsIHZlcnNpb24gKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKICB9XSk7CgogIHJldHVybiBEb2N1bWVudDsKfSgpOwoKZXhwb3J0IHsgRG9jdW1lbnQgYXMgZGVmYXVsdCB9OwptaXgoRG9jdW1lbnQsIEVtaXR0ZXJNaXhpbik7IC8vIENoZWNrcyB3aGV0aGVyIGdpdmVuIHJhbmdlIGJvdW5kYXJ5IHBvc2l0aW9uIGlzIHZhbGlkIGZvciBkb2N1bWVudCBzZWxlY3Rpb24sIG1lYW5pbmcgdGhhdCBpcyBub3QgYmV0d2VlbgovLyB1bmljb2RlIHN1cnJvZ2F0ZSBwYWlycyBvciBiYXNlIGNoYXJhY3RlciBhbmQgY29tYmluaW5nIG1hcmtzLgoKZnVuY3Rpb24gdmFsaWRhdGVUZXh0Tm9kZVBvc2l0aW9uKHJhbmdlQm91bmRhcnkpIHsKICB2YXIgdGV4dE5vZGUgPSByYW5nZUJvdW5kYXJ5LnRleHROb2RlOwoKICBpZiAodGV4dE5vZGUpIHsKICAgIHZhciBkYXRhID0gdGV4dE5vZGUuZGF0YTsKICAgIHZhciBvZmZzZXQgPSByYW5nZUJvdW5kYXJ5Lm9mZnNldCAtIHRleHROb2RlLnN0YXJ0T2Zmc2V0OwogICAgcmV0dXJuICFpc0luc2lkZVN1cnJvZ2F0ZVBhaXIoZGF0YSwgb2Zmc2V0KSAmJiAhaXNJbnNpZGVDb21iaW5lZFN5bWJvbChkYXRhLCBvZmZzZXQpOwogIH0KCiAgcmV0dXJuIHRydWU7Cn0="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/document.js"],"names":["Differ","RootElement","History","DocumentSelection","Collection","EmitterMixin","CKEditorError","mix","isInsideSurrogatePair","isInsideCombinedSymbol","clone","graveyardName","Document","model","version","history","selection","roots","idProperty","differ","markers","_postFixers","Set","_hasSelectionChangedFromTheLastChangeBlock","createRoot","listenTo","evt","args","operation","isDocumentOperation","baseVersion","priority","bufferOperation","addOperation","marker","oldRange","newRange","bufferMarkerChange","name","affectsData","on","getRange","getRoot","elementName","rootName","get","root","add","destroy","stopListening","Array","from","filter","postFixer","json","writer","_hasDocumentChangedFromTheLastChangeBlock","_callPostFixers","refresh","hasDataChanges","fire","batch","reset","isEmpty","graveyard","defaultRoot","_getDefaultRoot","schema","position","createPositionFromPath","nearestRange","getNearestSelectionRange","createRange","range","validateTextNodePosition","start","end","wasFixed","callback","rangeBoundary","textNode","data","offset","startOffset"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/document\n */\n\nimport Differ from './differ';\nimport RootElement from './rootelement';\nimport History from './history';\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es';\n\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\nconst graveyardName = '$graveyard';\n\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots â€“ e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Document {\n\t/**\n\t * Creates an empty document instance with no {@link #roots} (other than\n\t * the {@link #graveyard graveyard root}).\n\t */\n\tconstructor( model ) {\n\t\t/**\n\t\t * The {@link module:engine/model/model~Model model} that the document is a part of.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The document version. It starts from `0` and every operation increases the version number. It is used to ensure that\n\t\t * operations are applied on a proper document version.\n\t\t *\n\t\t * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n\t\t * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * The document's history.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/history~History}\n\t\t */\n\t\tthis.history = new History( this );\n\n\t\t/**\n\t\t * The selection in this document.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = new DocumentSelection( this );\n\n\t\t/**\n\t\t * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n\t\t * {@link #getRoot} to manipulate it.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:utils/collection~Collection}\n\t\t */\n\t\tthis.roots = new Collection( { idProperty: 'rootName' } );\n\n\t\t/**\n\t\t * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/differ~Differ}\n\t\t */\n\t\tthis.differ = new Differ( model.markers );\n\n\t\t/**\n\t\t * Post-fixer callbacks registered to the model document.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<Function>}\n\t\t */\n\t\tthis._postFixers = new Set();\n\n\t\t/**\n\t\t * A boolean indicates whether the selection has changed until\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._hasSelectionChangedFromTheLastChangeBlock = false;\n\n\t\t// Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\t\tthis.createRoot( '$root', graveyardName );\n\n\t\t// First, if the operation is a document operation check if it's base version is correct.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation && operation.baseVersion !== this.version ) {\n\t\t\t\t/**\n\t\t\t\t * Only operations with matching versions can be applied.\n\t\t\t\t *\n\t\t\t\t * @error model-document-applyoperation-wrong-version\n\t\t\t\t * @param {module:engine/model/operation/operation~Operation} operation\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'model-document-applyoperation-wrong-version', this, { operation } );\n\t\t\t}\n\t\t}, { priority: 'highest' } );\n\n\t\t// Then, still before an operation is applied on model, buffer the change in differ.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.differ.bufferOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// After the operation is applied, bump document's version and add the operation to the history.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.version++;\n\t\t\t\tthis.history.addOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// Listen to selection changes. If selection changed, mark it.\n\t\tthis.listenTo( this.selection, 'change', () => {\n\t\t\tthis._hasSelectionChangedFromTheLastChangeBlock = true;\n\t\t} );\n\n\t\t// Buffer marker changes.\n\t\t// This is not covered in buffering operations because markers may change outside of them (when they\n\t\t// are modified using `model.markers` collection, not through `MarkerOperation`).\n\t\tthis.listenTo( model.markers, 'update', ( evt, marker, oldRange, newRange ) => {\n\t\t\t// Whenever marker is updated, buffer that change.\n\t\t\tthis.differ.bufferMarkerChange( marker.name, oldRange, newRange, marker.affectsData );\n\n\t\t\tif ( oldRange === null ) {\n\t\t\t\t// If this is a new marker, add a listener that will buffer change whenever marker changes.\n\t\t\t\tmarker.on( 'change', ( evt, oldRange ) => {\n\t\t\t\t\tthis.differ.bufferMarkerChange( marker.name, oldRange, marker.getRange(), marker.affectsData );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n\t *\n\t * @readonly\n\t * @member {module:engine/model/rootelement~RootElement}\n\t */\n\tget graveyard() {\n\t\treturn this.getRoot( graveyardName );\n\t}\n\n\t/**\n\t * Creates a new root.\n\t *\n\t * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n\t * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n\t * @param {String} [rootName='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement} The created root.\n\t */\n\tcreateRoot( elementName = '$root', rootName = 'main' ) {\n\t\tif ( this.roots.get( rootName ) ) {\n\t\t\t/**\n\t\t\t * A root with the specified name already exists.\n\t\t\t *\n\t\t\t * @error model-document-createroot-name-exists\n\t\t\t * @param {module:engine/model/document~Document} doc\n\t\t\t * @param {String} name\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-document-createroot-name-exists', this, { name: rootName } );\n\t\t}\n\n\t\tconst root = new RootElement( this, elementName, rootName );\n\t\tthis.roots.add( root );\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * Removes all event listeners set by the document instance.\n\t */\n\tdestroy() {\n\t\tthis.selection.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Returns a root by its name.\n\t *\n\t * @param {String} [name='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n\t * there is no root with the given name.\n\t */\n\tgetRoot( name = 'main' ) {\n\t\treturn this.roots.get( name );\n\t}\n\n\t/**\n\t * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n\t *\n\t * @returns {Array.<String>} Roots names.\n\t */\n\tgetRootNames() {\n\t\treturn Array.from( this.roots, root => root.rootName ).filter( name => name != graveyardName );\n\t}\n\n\t/**\n\t * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n\t * will operate on a correct model state.\n\t *\n\t * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n\t * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n\t * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n\t * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n\t * not be fixed in the new document tree state.\n\t *\n\t * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n\t * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n\t * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n\t * for the user.\n\t *\n\t * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n\t * callback should add an empty paragraph so that the editor is never empty:\n\t *\n\t *\t\tdocument.registerPostFixer( writer => {\n\t *\t\t\tconst changes = document.differ.getChanges();\n\t *\n\t *\t\t\t// Check if the changes lead to an empty root in the editor.\n\t *\t\t\tfor ( const entry of changes ) {\n\t *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n\t *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n\t *\n\t *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n\t *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n\t *\t\t\t\t\treturn true;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {Function} postFixer\n\t */\n\tregisterPostFixer( postFixer ) {\n\t\tthis._postFixers.add( postFixer );\n\t}\n\n\t/**\n\t * A custom `toJSON()` method to solve child-parent circular dependencies.\n\t *\n\t * @returns {Object} A clone of this object with the document property changed to a string.\n\t */\n\ttoJSON() {\n\t\tconst json = clone( this );\n\n\t\t// Due to circular references we need to remove parent reference.\n\t\tjson.selection = '[engine.model.DocumentSelection]';\n\t\tjson.model = '[engine.model.Model]';\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Check if there were any changes done on document, and if so, call post-fixers,\n\t * fire `change` event for features and conversion and then reset the differ.\n\t * Fire `change:data` event when at least one operation or buffered marker changes the data.\n\t *\n\t * @protected\n\t * @fires change\n\t * @fires change:data\n\t * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n\t */\n\t_handleChangeBlock( writer ) {\n\t\tif ( this._hasDocumentChangedFromTheLastChangeBlock() ) {\n\t\t\tthis._callPostFixers( writer );\n\n\t\t\t// Refresh selection attributes according to the final position in the model after the change.\n\t\t\tthis.selection.refresh();\n\n\t\t\tif ( this.differ.hasDataChanges() ) {\n\t\t\t\tthis.fire( 'change:data', writer.batch );\n\t\t\t} else {\n\t\t\t\tthis.fire( 'change', writer.batch );\n\t\t\t}\n\n\t\t\t// Theoretically, it is not necessary to refresh selection after change event because\n\t\t\t// post-fixers are the last who should change the model, but just in case...\n\t\t\tthis.selection.refresh();\n\n\t\t\tthis.differ.reset();\n\t\t}\n\n\t\tthis._hasSelectionChangedFromTheLastChangeBlock = false;\n\t}\n\n\t/**\n\t * Returns whether there is a buffered change or if the selection has changed from the last\n\t * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n\t * or {@link module:engine/model/model~Model#change `change()` block}.\n\t *\n\t * @protected\n\t * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n\t */\n\t_hasDocumentChangedFromTheLastChangeBlock() {\n\t\treturn !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n\t}\n\n\t/**\n\t * Returns the default root for this document which is either the first root that was added to the document using\n\t * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n\t */\n\t_getDefaultRoot() {\n\t\tfor ( const root of this.roots ) {\n\t\t\tif ( root !== this.graveyard ) {\n\t\t\t\treturn root;\n\t\t\t}\n\t\t}\n\n\t\treturn this.graveyard;\n\t}\n\n\t/**\n\t * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n\t * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getDefaultRange() {\n\t\tconst defaultRoot = this._getDefaultRoot();\n\t\tconst model = this.model;\n\t\tconst schema = model.schema;\n\n\t\t// Find the first position where the selection can be put.\n\t\tconst position = model.createPositionFromPath( defaultRoot, [ 0 ] );\n\t\tconst nearestRange = schema.getNearestSelectionRange( position );\n\n\t\t// If valid selection range is not found - return range collapsed at the beginning of the root.\n\t\treturn nearestRange || model.createRange( position );\n\t}\n\n\t/**\n\t * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n\t * the {@link #selection document's selection}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range A range to check.\n\t * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n\t */\n\t_validateSelectionRange( range ) {\n\t\treturn validateTextNodePosition( range.start ) && validateTextNodePosition( range.end );\n\t}\n\n\t/**\n\t * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n\t *\n\t * @private\n\t * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n\t */\n\t_callPostFixers( writer ) {\n\t\tlet wasFixed = false;\n\n\t\tdo {\n\t\t\tfor ( const callback of this._postFixers ) {\n\t\t\t\t// Ensure selection attributes are up to date before each post-fixer.\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n\t\t\t\t//\n\t\t\t\t// It might be good to refresh the selection after each operation but at the moment it leads\n\t\t\t\t// to losing attributes for composition or and spell checking\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-typing/issues/188\n\t\t\t\tthis.selection.refresh();\n\n\t\t\t\twasFixed = callback( writer );\n\n\t\t\t\tif ( wasFixed ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( wasFixed );\n\t}\n\n\t/**\n\t * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n\t * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n\t * during that block's execution.\n\t *\n\t * The changes which this event will cover include:\n\t *\n\t * * document structure changes,\n\t * * selection changes,\n\t * * marker changes.\n\t *\n\t * If you want to be notified about all these changes, then simply listen to this event like this:\n\t *\n\t *\t\tmodel.document.on( 'change', () => {\n\t *\t\t\tconsole.log( 'The document has changed!' );\n\t *\t\t} );\n\t *\n\t * If, however, you only want to be notified about the data changes, then use the\n\t * {@link module:engine/model/document~Document#event:change:data change:data} event,\n\t * which is fired for document structure changes and marker changes (which affects the data).\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * @event change\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t/**\n\t * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n\t * affect the editor data. This is:\n\t *\n\t * * document structure changes,\n\t * * marker changes (which affects the data).\n\t *\n\t * If you want to be notified about the data changes, then listen to this event:\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * If you would like to listen to all document changes, then check out the\n\t * {@link module:engine/model/document~Document#event:change change} event.\n\t *\n\t * @event change:data\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t// @if CK_DEBUG_ENGINE // log( version = null ) {\n\t// @if CK_DEBUG_ENGINE // \tversion = version === null ? this.version : version;\n\t// @if CK_DEBUG_ENGINE // \tlogDocument( this, version );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\nmix( Document, EmitterMixin );\n\n// Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\nfunction validateTextNodePosition( rangeBoundary ) {\n\tconst textNode = rangeBoundary.textNode;\n\n\tif ( textNode ) {\n\t\tconst data = textNode.data;\n\t\tconst offset = rangeBoundary.offset - textNode.startOffset;\n\n\t\treturn !isInsideSurrogatePair( data, offset ) && !isInsideCombinedSymbol( data, offset );\n\t}\n\n\treturn true;\n}\n"]}]}