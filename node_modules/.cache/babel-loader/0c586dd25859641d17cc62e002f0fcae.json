{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zZWFyY2guanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9tb2RlbAogKi8KaW1wb3J0IEJhdGNoIGZyb20gJy4vYmF0Y2gnOwppbXBvcnQgV3JpdGVyIGZyb20gJy4vd3JpdGVyJzsKaW1wb3J0IFNjaGVtYSBmcm9tICcuL3NjaGVtYSc7CmltcG9ydCBEb2N1bWVudCBmcm9tICcuL2RvY3VtZW50JzsKaW1wb3J0IE1hcmtlckNvbGxlY3Rpb24gZnJvbSAnLi9tYXJrZXJjb2xsZWN0aW9uJzsKaW1wb3J0IE9ic2VydmFibGVNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9vYnNlcnZhYmxlbWl4aW4nOwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7CmltcG9ydCBNb2RlbEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50JzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi9yYW5nZSc7CmltcG9ydCBNb2RlbFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgTW9kZWxTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nOwppbXBvcnQgT3BlcmF0aW9uRmFjdG9yeSBmcm9tICcuL29wZXJhdGlvbi9vcGVyYXRpb25mYWN0b3J5JzsKaW1wb3J0IF9pbnNlcnRDb250ZW50IGZyb20gJy4vdXRpbHMvaW5zZXJ0Y29udGVudCc7CmltcG9ydCBfZGVsZXRlQ29udGVudCBmcm9tICcuL3V0aWxzL2RlbGV0ZWNvbnRlbnQnOwppbXBvcnQgX21vZGlmeVNlbGVjdGlvbiBmcm9tICcuL3V0aWxzL21vZGlmeXNlbGVjdGlvbic7CmltcG9ydCBfZ2V0U2VsZWN0ZWRDb250ZW50IGZyb20gJy4vdXRpbHMvZ2V0c2VsZWN0ZWRjb250ZW50JzsKaW1wb3J0IHsgaW5qZWN0U2VsZWN0aW9uUG9zdEZpeGVyIH0gZnJvbSAnLi91dGlscy9zZWxlY3Rpb24tcG9zdC1maXhlcic7CmltcG9ydCB7IGF1dG9QYXJhZ3JhcGhFbXB0eVJvb3RzIH0gZnJvbSAnLi91dGlscy9hdXRvcGFyYWdyYXBoaW5nJzsKaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7IC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gY29uc3QgeyBkdW1wVHJlZXMgfSA9IHJlcXVpcmUoICcuLi9kZXYtdXRpbHMvdXRpbHMnICk7Ci8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gY29uc3QgeyBPcGVyYXRpb25SZXBsYXllciB9ID0gcmVxdWlyZSggJy4uL2Rldi11dGlscy9vcGVyYXRpb25yZXBsYXllcicgKS5kZWZhdWx0OwoKLyoqCiAqIEVkaXRvcidzIGRhdGEgbW9kZWwuIFJlYWQgYWJvdXQgdGhlIG1vZGVsIGluIHRoZQogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lIGVuZ2luZSBhcmNoaXRlY3R1cmUgZ3VpZGV9LgogKgogKiBAbWl4ZXMgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4KICovCgp2YXIgTW9kZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIE1vZGVsKCkgewogICAgdmFyIF90aGlzID0gdGhpczsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kZWwpOwoKICAgIC8qKgogICAgICogTW9kZWwncyBtYXJrZXIgY29sbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9ufQogICAgICovCiAgICB0aGlzLm1hcmtlcnMgPSBuZXcgTWFya2VyQ29sbGVjdGlvbigpOwogICAgLyoqCiAgICAgKiBNb2RlbCdzIGRvY3VtZW50LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0KICAgICAqLwoKICAgIHRoaXMuZG9jdW1lbnQgPSBuZXcgRG9jdW1lbnQodGhpcyk7CiAgICAvKioKICAgICAqIE1vZGVsJ3Mgc2NoZW1hLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hfQogICAgICovCgogICAgdGhpcy5zY2hlbWEgPSBuZXcgU2NoZW1hKCk7CiAgICAvKioKICAgICAqIEFsbCBjYWxsYmFja3MgYWRkZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZX0gbWV0aG9kcyB3YWl0aW5nIHRvIGJlIGV4ZWN1dGVkLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7QXJyYXkuPEZ1bmN0aW9uPn0KICAgICAqLwoKICAgIHRoaXMuX3BlbmRpbmdDaGFuZ2VzID0gW107CiAgICAvKioKICAgICAqIFRoZSBsYXN0IGNyZWF0ZWQgYW5kIGN1cnJlbnRseSB1c2VkIHdyaXRlciBpbnN0YW5jZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfQogICAgICovCgogICAgdGhpcy5fY3VycmVudFdyaXRlciA9IG51bGw7CiAgICBbJ2luc2VydENvbnRlbnQnLCAnZGVsZXRlQ29udGVudCcsICdtb2RpZnlTZWxlY3Rpb24nLCAnZ2V0U2VsZWN0ZWRDb250ZW50JywgJ2FwcGx5T3BlcmF0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkgewogICAgICByZXR1cm4gX3RoaXMuZGVjb3JhdGUobWV0aG9kTmFtZSk7CiAgICB9KTsgLy8gQWRkaW5nIG9wZXJhdGlvbiB2YWxpZGF0aW9uIHdpdGggYGhpZ2hlc3RgIHByaW9yaXR5LCBzbyBpdCBpcyBjYWxsZWQgYmVmb3JlIGFueSBvdGhlciBmZWF0dXJlIHdvdWxkIGxpa2UKICAgIC8vIHRvIGRvIGFueXRoaW5nIHdpdGggdGhlIG9wZXJhdGlvbi4gSWYgdGhlIG9wZXJhdGlvbiBoYXMgaW5jb3JyZWN0IHBhcmFtZXRlcnMgaXQgc2hvdWxkIHRocm93IG9uIHRoZSBlYXJsaWVzdCBvY2Nhc2lvbi4KCiAgICB0aGlzLm9uKCdhcHBseU9wZXJhdGlvbicsIGZ1bmN0aW9uIChldnQsIGFyZ3MpIHsKICAgICAgdmFyIG9wZXJhdGlvbiA9IGFyZ3NbMF07CgogICAgICBvcGVyYXRpb24uX3ZhbGlkYXRlKCk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnaGlnaGVzdCcKICAgIH0pOyAvLyBSZWdpc3RlciBzb21lIGRlZmF1bHQgYWJzdHJhY3QgZW50aXRpZXMuCgogICAgdGhpcy5zY2hlbWEucmVnaXN0ZXIoJyRyb290JywgewogICAgICBpc0xpbWl0OiB0cnVlCiAgICB9KTsKICAgIHRoaXMuc2NoZW1hLnJlZ2lzdGVyKCckYmxvY2snLCB7CiAgICAgIGFsbG93SW46ICckcm9vdCcsCiAgICAgIGlzQmxvY2s6IHRydWUKICAgIH0pOwogICAgdGhpcy5zY2hlbWEucmVnaXN0ZXIoJyR0ZXh0JywgewogICAgICBhbGxvd0luOiAnJGJsb2NrJywKICAgICAgaXNJbmxpbmU6IHRydWUsCiAgICAgIGlzQ29udGVudDogdHJ1ZQogICAgfSk7CiAgICB0aGlzLnNjaGVtYS5yZWdpc3RlcignJGNsaXBib2FyZEhvbGRlcicsIHsKICAgICAgYWxsb3dDb250ZW50T2Y6ICckcm9vdCcsCiAgICAgIGlzTGltaXQ6IHRydWUKICAgIH0pOwogICAgdGhpcy5zY2hlbWEuZXh0ZW5kKCckdGV4dCcsIHsKICAgICAgYWxsb3dJbjogJyRjbGlwYm9hcmRIb2xkZXInCiAgICB9KTsKICAgIHRoaXMuc2NoZW1hLnJlZ2lzdGVyKCckZG9jdW1lbnRGcmFnbWVudCcsIHsKICAgICAgYWxsb3dDb250ZW50T2Y6ICckcm9vdCcsCiAgICAgIGlzTGltaXQ6IHRydWUKICAgIH0pOwogICAgdGhpcy5zY2hlbWEuZXh0ZW5kKCckdGV4dCcsIHsKICAgICAgYWxsb3dJbjogJyRkb2N1bWVudEZyYWdtZW50JwogICAgfSk7IC8vIEFuIGVsZW1lbnQgbmVlZGVkIGJ5IHRoZSBgdXBjYXN0RWxlbWVudFRvTWFya2VyYCBjb252ZXJ0ZXIuCiAgICAvLyBUaGlzIGVsZW1lbnQgdGVtcG9yYXJpbHkgcmVwcmVzZW50cyBhIG1hcmtlciBib3VuZGFyeSBkdXJpbmcgdGhlIGNvbnZlcnNpb24gcHJvY2VzcyBhbmQgaXMgcmVtb3ZlZAogICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgY29udmVyc2lvbi4gYFVwY2FzdERpc3BhdGNoZXJgIG9yIGF0IGxlYXN0IGBDb252ZXJzaW9uYCBjbGFzcyBsb29rcyBsaWtlIGEKICAgIC8vIGJldHRlciBwbGFjZSBmb3IgdGhpcyByZWdpc3RyYXRpb24gYnV0IGJvdGgga25vdyBub3RoaW5nIGFib3V0IGBTY2hlbWFgLgoKICAgIHRoaXMuc2NoZW1hLnJlZ2lzdGVyKCckbWFya2VyJyk7CiAgICB0aGlzLnNjaGVtYS5hZGRDaGlsZENoZWNrKGZ1bmN0aW9uIChjb250ZXh0LCBjaGlsZERlZmluaXRpb24pIHsKICAgICAgaWYgKGNoaWxkRGVmaW5pdGlvbi5uYW1lID09PSAnJG1hcmtlcicpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfSk7CiAgICBpbmplY3RTZWxlY3Rpb25Qb3N0Rml4ZXIodGhpcyk7IC8vIFBvc3QtZml4ZXIgd2hpY2ggdGFrZXMgY2FyZSBvZiBhZGRpbmcgZW1wdHkgcGFyYWdyYXBoIGVsZW1lbnRzIHRvIHRoZSBlbXB0eSByb290cy4KCiAgICB0aGlzLmRvY3VtZW50LnJlZ2lzdGVyUG9zdEZpeGVyKGF1dG9QYXJhZ3JhcGhFbXB0eVJvb3RzKTsgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB0aGlzLm9uKCAnYXBwbHlPcGVyYXRpb24nLCAoKSA9PiB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlkdW1wVHJlZXMoIHRoaXMuZG9jdW1lbnQsIHRoaXMuZG9jdW1lbnQudmVyc2lvbiApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9LCB7IHByaW9yaXR5OiAnbG93ZXN0JyB9ICk7CiAgfQogIC8qKgogICAqIFRoZSBgY2hhbmdlKClgIG1ldGhvZCBpcyB0aGUgcHJpbWFyeSB3YXkgb2YgY2hhbmdpbmcgdGhlIG1vZGVsLiBZb3Ugc2hvdWxkIHVzZSBpdCB0byBtb2RpZnkgYWxsIGRvY3VtZW50IG5vZGVzCiAgICogKGluY2x1ZGluZyBkZXRhY2hlZCBub2RlcyDigJMgaS5lLiBub2RlcyBub3QgYWRkZWQgdG8gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2RvY3VtZW50IG1vZGVsIGRvY3VtZW50fSksCiAgICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3NlbGVjdGlvbiBkb2N1bWVudCdzIHNlbGVjdGlvbn0sIGFuZAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI21hcmtlcnMgbW9kZWwgbWFya2Vyc30uCiAgICoKICAgKgkJbW9kZWwuY2hhbmdlKCB3cml0ZXIgPT4gewogICAqCQkJd3JpdGVyLmluc2VydFRleHQoICdmb28nLCBwYXJhZ3JhcGgsICdlbmQnICk7CiAgICoJCX0gKTsKICAgKgogICAqIEFsbCBjaGFuZ2VzIGluc2lkZSB0aGUgY2hhbmdlIGJsb2NrIHVzZSB0aGUgc2FtZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gc28gdGhleSBhcmUgY29tYmluZWQKICAgKiBpbnRvIGEgc2luZ2xlIHVuZG8gc3RlcC4KICAgKgogICAqCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHBhcmFncmFwaCwgJ2VuZCcgKTsgLy8gZm9vLgogICAqCiAgICoJCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQkJd3JpdGVyLmluc2VydFRleHQoICdiYXInLCBwYXJhZ3JhcGgsICdlbmQnICk7IC8vIGZvb2Jhci4KICAgKgkJCX0gKTsKICAgKgogICAqIAkJCXdyaXRlci5pbnNlcnRUZXh0KCAnYm9tJywgcGFyYWdyYXBoLCAnZW5kJyApOyAvLyBmb29iYXJib20uCiAgICoJCX0gKTsKICAgKgogICAqIFRoZSBjYWxsYmFjayBvZiB0aGUgYGNoYW5nZSgpYCBibG9jayBpcyBleGVjdXRlZCBzeW5jaHJvbm91c2x5LgogICAqCiAgICogWW91IGNhbiBhbHNvIHJldHVybiBhIHZhbHVlIGZyb20gdGhlIGNoYW5nZSBibG9jay4KICAgKgogICAqCQljb25zdCBpbWcgPSBtb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQlyZXR1cm4gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdpbWcnICk7CiAgICoJCX0gKTsKICAgKgogICAqIEBzZWUgI2VucXVldWVDaGFuZ2UKICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB3aGljaCBtYXkgbW9kaWZ5IHRoZSBtb2RlbC4KICAgKiBAcmV0dXJucyB7Kn0gVmFsdWUgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKE1vZGVsLCBbewogICAga2V5OiAiY2hhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2UoY2FsbGJhY2spIHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NoYW5nZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgYmxvY2ssIGNyZWF0ZSBhIG5ldyBiYXRjaCBhbmQgc3RhcnQgYF9ydW5QZW5kaW5nQ2hhbmdlc2AgZXhlY3V0aW9uIGZsb3cuCiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2hhbmdlcy5wdXNoKHsKICAgICAgICAgICAgYmF0Y2g6IG5ldyBCYXRjaCgpLAogICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sKICAgICAgICAgIH0pOwoKICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5QZW5kaW5nQ2hhbmdlcygpWzBdOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgb3V0ZXJtb3N0IGJsb2NrLCBqdXN0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrLgogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2N1cnJlbnRXcml0ZXIpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgLy8gQGlmIENLX0RFQlVHIC8vIHRocm93IGVycjsKCiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8KICAgICAgICBDS0VkaXRvckVycm9yLnJldGhyb3dVbmV4cGVjdGVkRXJyb3IoZXJyLCB0aGlzKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBUaGUgYGVucXVldWVDaGFuZ2UoKWAgbWV0aG9kIHBlcmZvcm1zIHNpbWlsYXIgdGFzayBhcyB0aGUge0BsaW5rICNjaGFuZ2UgYGNoYW5nZSgpYCBtZXRob2R9LCB3aXRoIHR3byBtYWpvciBkaWZmZXJlbmNlcy4KICAgICAqCiAgICAgKiBGaXJzdCwgdGhlIGNhbGxiYWNrIG9mIGBlbnF1ZXVlQ2hhbmdlKClgIGlzIGV4ZWN1dGVkIHdoZW4gYWxsIG90aGVyIGVucXVldWVkIGNoYW5nZXMgYXJlIGRvbmUuIEl0IG1pZ2h0IGJlIGV4ZWN1dGVkCiAgICAgKiBpbW1lZGlhdGVseSBpZiBpdCBpcyBub3QgbmVzdGVkIGluIGFueSBvdGhlciBjaGFuZ2UgYmxvY2ssIGJ1dCBpZiBpdCBpcyBuZXN0ZWQgaW4gYW5vdGhlciAoZW5xdWV1ZSljaGFuZ2UgYmxvY2ssCiAgICAgKiBpdCB3aWxsIGJlIGRlbGF5ZWQgYW5kIGV4ZWN1dGVkIGFmdGVyIHRoZSBvdXRlcm1vc3QgYmxvY2suCiAgICAgKgogICAgICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgICAqCQkJY29uc29sZS5sb2coIDEgKTsKICAgICAqCiAgICAgKgkJCW1vZGVsLmVucXVldWVDaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCQljb25zb2xlLmxvZyggMiApOwogICAgICoJCQl9ICk7CiAgICAgKgogICAgICogCQkJY29uc29sZS5sb2coIDMgKTsKICAgICAqCQl9ICk7IC8vIFdpbGwgbG9nOiAxLCAzLCAyLgogICAgICoKICAgICAqIEluIGFkZGl0aW9uIHRvIHRoYXQsIHRoZSBjaGFuZ2VzIGVucXVldWVkIHdpdGggYGVucXVldWVDaGFuZ2UoKWAgd2lsbCBiZSBjb252ZXJ0ZWQgc2VwYXJhdGVseSBmcm9tIHRoZSBjaGFuZ2VzCiAgICAgKiBkb25lIGluIHRoZSBvdXRlciBgY2hhbmdlKClgIGJsb2NrLgogICAgICoKICAgICAqIFNlY29uZCwgaXQgbGV0cyB5b3UgZGVmaW5lIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gaW50byB3aGljaCB5b3Ugd2FudCB0byBhZGQgeW91ciBjaGFuZ2VzLgogICAgICogQnkgZGVmYXVsdCwgYSBuZXcgYmF0Y2ggaXMgY3JlYXRlZC4gSW4gdGhlIHNhbXBsZSBhYm92ZSwgYGNoYW5nZWAgYW5kIGBlbnF1ZXVlQ2hhbmdlYCBibG9ja3MgdXNlIGEgZGlmZmVyZW50CiAgICAgKiBiYXRjaCAoYW5kIGRpZmZlcmVudCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSBzaW5jZSBlYWNoIG9mIHRoZW0gb3BlcmF0ZXMgb24gdGhlIHNlcGFyYXRlIGJhdGNoKS4KICAgICAqCiAgICAgKiBXaGVuIHVzaW5nIHRoZSBgZW5xdWV1ZUNoYW5nZSgpYCBibG9jayB5b3UgY2FuIGFsc28gYWRkIHNvbWUgY2hhbmdlcyB0byB0aGUgYmF0Y2ggeW91IHVzZWQgYmVmb3JlLgogICAgICoKICAgICAqCQltb2RlbC5lbnF1ZXVlQ2hhbmdlKCBiYXRjaCwgd3JpdGVyID0+IHsKICAgICAqCQkJd3JpdGVyLmluc2VydFRleHQoICdmb28nLCBwYXJhZ3JhcGgsICdlbmQnICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIEluIG9yZGVyIHRvIG1ha2UgYSBuZXN0ZWQgYGVucXVldWVDaGFuZ2UoKWAgY3JlYXRlIGEgc2luZ2xlIHVuZG8gc3RlcCB0b2dldGhlciB3aXRoIHRoZSBjaGFuZ2VzIGRvbmUgaW4gdGhlIG91dGVyIGBjaGFuZ2UoKWAKICAgICAqIGJsb2NrLCB5b3UgY2FuIG9idGFpbiB0aGUgYmF0Y2ggaW5zdGFuY2UgZnJvbSB0aGUgIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjYmF0Y2ggd3JpdGVyfSBvZiB0aGUgb3V0ZXIgYmxvY2suCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNofCd0cmFuc3BhcmVudCd8J2RlZmF1bHQnfSBiYXRjaE9yVHlwZSBCYXRjaCBvciBiYXRjaCB0eXBlIHNob3VsZCBiZSB1c2VkIGluIHRoZSBjYWxsYmFjay4KICAgICAqIElmIG5vdCBkZWZpbmVkLCBhIG5ldyBiYXRjaCB3aWxsIGJlIGNyZWF0ZWQuCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB3aGljaCBtYXkgbW9kaWZ5IHRoZSBtb2RlbC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJlbnF1ZXVlQ2hhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBlbnF1ZXVlQ2hhbmdlKGJhdGNoT3JUeXBlLCBjYWxsYmFjaykgewogICAgICB0cnkgewogICAgICAgIGlmICh0eXBlb2YgYmF0Y2hPclR5cGUgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICBiYXRjaE9yVHlwZSA9IG5ldyBCYXRjaChiYXRjaE9yVHlwZSk7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYmF0Y2hPclR5cGUgPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgY2FsbGJhY2sgPSBiYXRjaE9yVHlwZTsKICAgICAgICAgIGJhdGNoT3JUeXBlID0gbmV3IEJhdGNoKCk7CiAgICAgICAgfQoKICAgICAgICB0aGlzLl9wZW5kaW5nQ2hhbmdlcy5wdXNoKHsKICAgICAgICAgIGJhdGNoOiBiYXRjaE9yVHlwZSwKICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjawogICAgICAgIH0pOwoKICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NoYW5nZXMubGVuZ3RoID09IDEpIHsKICAgICAgICAgIHRoaXMuX3J1blBlbmRpbmdDaGFuZ2VzKCk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAvLyBAaWYgQ0tfREVCVUcgLy8gdGhyb3cgZXJyOwoKICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLwogICAgICAgIENLRWRpdG9yRXJyb3IucmV0aHJvd1VuZXhwZWN0ZWRFcnJvcihlcnIsIHRoaXMpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIHtAbGluayBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbiNkZWNvcmF0ZSBEZWNvcmF0ZWR9IGZ1bmN0aW9uIGZvciBhcHBseWluZwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9uc30gdG8gdGhlIG1vZGVsLgogICAgICoKICAgICAqIFRoaXMgaXMgYSBsb3ctbGV2ZWwgd2F5IG9mIGNoYW5naW5nIHRoZSBtb2RlbC4gSXQgaXMgZXhwb3NlZCBmb3IgdmVyeSBzcGVjaWZpYyB1c2UgY2FzZXMgKGxpa2UgdGhlIHVuZG8gZmVhdHVyZSkuCiAgICAgKiBOb3JtYWxseSwgdG8gbW9kaWZ5IHRoZSBtb2RlbCwgeW91IHdpbGwgd2FudCB0byB1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciBgV3JpdGVyYH0uCiAgICAgKiBTZWUgYWxzbyB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI2NoYW5naW5nLXRoZS1tb2RlbCBDaGFuZ2luZyB0aGUgbW9kZWx9IHNlY3Rpb24KICAgICAqIG9mIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lIEVkaXRpbmcgYXJjaGl0ZWN0dXJlfSBndWlkZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5LgogICAgICovCgogIH0sIHsKICAgIGtleTogImFwcGx5T3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseU9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBjb25zb2xlLmxvZyggJ0FwcGx5aW5nICcgKyBvcGVyYXRpb24gKTsKICAgICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBpZiAoICF0aGlzLl9vcGVyYXRpb25Mb2dzICkgewogICAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCXRoaXMuX29wZXJhdGlvbkxvZ3MgPSBbXTsKICAgICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gdGhpcy5fb3BlcmF0aW9uTG9ncy5wdXNoKCBKU09OLnN0cmluZ2lmeSggb3BlcmF0aW9uICkgKTsKICAgICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvL2lmICggIXRoaXMuX2FwcGxpZWRPcGVyYXRpb25zICkgewogICAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCXRoaXMuX2FwcGxpZWRPcGVyYXRpb25zID0gW107CiAgICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy99CiAgICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy90aGlzLl9hcHBsaWVkT3BlcmF0aW9ucy5wdXNoKCBvcGVyYXRpb24gKTsKICAgICAgb3BlcmF0aW9uLl9leGVjdXRlKCk7CiAgICB9IC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gZ2V0QXBwbGllZE9wZXJhdGlvbigpIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JaWYgKCAhdGhpcy5fYXBwbGllZE9wZXJhdGlvbnMgKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQlyZXR1cm4gJyc7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCX0KICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JcmV0dXJuIHRoaXMuX2FwcGxpZWRPcGVyYXRpb25zLm1hcCggSlNPTi5zdHJpbmdpZnkgKS5qb2luKCAnLS0tLS0tLScgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBjcmVhdGVSZXBsYXllciggc3RyaW5naWZpZWRPcGVyYXRpb25zICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwlyZXR1cm4gbmV3IE9wZXJhdGlvblJlcGxheWVyKCB0aGlzLCAnLS0tLS0tLScsIHN0cmluZ2lmaWVkT3BlcmF0aW9ucyApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CgogICAgLyoqCiAgICAgKiBJbnNlcnRzIGNvbnRlbnQgYXQgdGhlIHBvc2l0aW9uIGluIHRoZSBlZGl0b3Igc3BlY2lmaWVkIGJ5IHRoZSBzZWxlY3Rpb24sIGFzIG9uZSB3b3VsZCBleHBlY3QgdGhlIHBhc3RlCiAgICAgKiBmdW5jdGlvbmFsaXR5IHRvIHdvcmsuCiAgICAgKgogICAgICogVGhpcyBpcyBhIGhpZ2gtbGV2ZWwgbWV0aG9kLiBJdCB0YWtlcyB0aGUge0BsaW5rICNzY2hlbWEgc2NoZW1hfSBpbnRvIGNvbnNpZGVyYXRpb24gd2hlbiBpbnNlcnRpbmcKICAgICAqIHRoZSBjb250ZW50LCBjbGVhcnMgdGhlIGdpdmVuIHNlbGVjdGlvbidzIGNvbnRlbnQgYmVmb3JlIGluc2VydGluZyBub2RlcyBhbmQgbW92ZXMgdGhlIHNlbGVjdGlvbgogICAgICogdG8gaXRzIHRhcmdldCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwcm9jZXNzLgogICAgICogSXQgY2FuIHNwbGl0IGVsZW1lbnRzLCBtZXJnZSB0aGVtLCB3cmFwIGJhcmUgdGV4dCBub2RlcyB3aXRoIHBhcmFncmFwaHMsIGV0Yy4gJm1kYXNoOyBqdXN0IGxpa2UgdGhlCiAgICAgKiBwYXN0aW5nIGZlYXR1cmUgc2hvdWxkIGRvLgogICAgICoKICAgICAqIEZvciBsb3dlci1sZXZlbCBtZXRob2RzIHNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyIGBXcml0ZXJgfS4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCwgdW5saWtlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIgYFdyaXRlcmB9J3MgbWV0aG9kcywgZG9lcyBub3QgaGF2ZSB0byBiZSB1c2VkCiAgICAgKiBpbnNpZGUgYSB7QGxpbmsgI2NoYW5nZSBgY2hhbmdlKClgIGJsb2NrfS4KICAgICAqCiAgICAgKiAjIENvbnZlcnNpb24gYW5kIHNjaGVtYQogICAgICoKICAgICAqIEluc2VydGluZyBlbGVtZW50cyBhbmQgdGV4dCBub2RlcyBpbnRvIHRoZSBtb2RlbCBpcyBub3QgZW5vdWdoIHRvIG1ha2UgQ0tFZGl0b3IgNSByZW5kZXIgdGhhdCBjb250ZW50CiAgICAgKiB0byB0aGUgdXNlci4gQ0tFZGl0b3IgNSBpbXBsZW1lbnRzIGEgbW9kZWwtdmlldy1jb250cm9sbGVyIGFyY2hpdGVjdHVyZSBhbmQgd2hhdCBgbW9kZWwuaW5zZXJ0Q29udGVudCgpYCBkb2VzCiAgICAgKiBpcyBvbmx5IGFkZGluZyBub2RlcyB0byB0aGUgbW9kZWwuIEFkZGl0aW9uYWxseSwgeW91IG5lZWQgdG8gZGVmaW5lCiAgICAgKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI2NvbnZlcnNpb24gY29udmVydGVyc30gYmV0d2VlbiB0aGUgbW9kZWwgYW5kIHZpZXcKICAgICAqIGFuZCBkZWZpbmUgdGhvc2Ugbm9kZXMgaW4gdGhlIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUjc2NoZW1hIHNjaGVtYX0uCiAgICAgKgogICAgICogU28sIHdoaWxlIHRoaXMgbWV0aG9kIG1heSBzZWVtIHNpbWlsYXIgdG8gQ0tFZGl0b3IgNCBgZWRpdG9yLmluc2VydEh0bWwoKWAgKGluIGZhY3QsIGJvdGggbWV0aG9kcwogICAgICogYXJlIHVzZWQgZm9yIHBhc3RlLWxpa2UgY29udGVudCBpbnNlcnRpb24pLCB0aGUgQ0tFZGl0b3IgNSBtZXRob2QgY2Fubm90IGJlIHVzZSB0byBpbnNlcnQgYXJiaXRyYXJ5IEhUTUwKICAgICAqIHVubGVzcyBjb252ZXJ0ZXJzIGFyZSBkZWZpbmVkIGZvciBhbGwgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXMgaW4gdGhhdCBIVE1MLgogICAgICoKICAgICAqICMgRXhhbXBsZXMKICAgICAqCiAgICAgKiBVc2luZyBgaW5zZXJ0Q29udGVudCgpYCB3aXRoIGEgbWFudWFsbHkgY3JlYXRlZCBtb2RlbCBzdHJ1Y3R1cmU6CiAgICAgKgogICAgICoJCS8vIExldCdzIGNyZWF0ZSBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgc3VjaCBjb250ZW50IGFzOgogICAgICoJCS8vCiAgICAgKgkJLy8gPHBhcmFncmFwaD5mb288L3BhcmFncmFwaD4KICAgICAqCQkvLyA8YmxvY2tRdW90ZT4KICAgICAqCQkvLyAgICA8cGFyYWdyYXBoPmJhcjwvcGFyYWdyYXBoPgogICAgICoJCS8vIDwvYmxvY2tRdW90ZT4KICAgICAqCQljb25zdCBkb2NGcmFnID0gZWRpdG9yLm1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgICAqCQkJY29uc3QgcDEgPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgICAqCQkJY29uc3QgcDIgPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgICAqCQkJY29uc3QgYmxvY2tRdW90ZSA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAnYmxvY2tRdW90ZScgKTsKICAgICAqCQkJY29uc3QgZG9jRnJhZyA9IHdyaXRlci5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7CiAgICAgKgogICAgICoJCQl3cml0ZXIuYXBwZW5kKCBwMSwgZG9jRnJhZyApOwogICAgICoJCQl3cml0ZXIuYXBwZW5kKCBibG9ja1F1b3RlLCBkb2NGcmFnICk7CiAgICAgKgkJCXdyaXRlci5hcHBlbmQoIHAyLCBibG9ja1F1b3RlICk7CiAgICAgKgkJCXdyaXRlci5pbnNlcnRUZXh0KCAnZm9vJywgcDEgKTsKICAgICAqCQkJd3JpdGVyLmluc2VydFRleHQoICdiYXInLCBwMiApOwogICAgICoKICAgICAqCQkJcmV0dXJuIGRvY0ZyYWc7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBpbnNlcnRDb250ZW50KCkgZG9lcyBub3QgaGF2ZSB0byBiZSB1c2VkIGluIGEgY2hhbmdlKCkgYmxvY2suIEl0IGNhbiwgdGhvdWdoLAogICAgICoJCS8vIHNvIHRoaXMgY29kZSBjb3VsZCBiZSBtb3ZlZCB0byB0aGUgY2FsbGJhY2sgZGVmaW5lZCBhYm92ZS4KICAgICAqCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggZG9jRnJhZyApOwogICAgICoKICAgICAqIFVzaW5nIGBpbnNlcnRDb250ZW50KClgIHdpdGggYW4gSFRNTCBzdHJpbmcgY29udmVydGVkIHRvIGEgbW9kZWwgZG9jdW1lbnQgZnJhZ21lbnQgKHNpbWlsYXIgdG8gdGhlIHBhc3RpbmcgbWVjaGFuaXNtKToKICAgICAqCiAgICAgKgkJLy8gWW91IGNhbiBjcmVhdGUgeW91ciBvd24gSHRtbERhdGFQcm9jZXNzb3IgaW5zdGFuY2Ugb3IgdXNlIGVkaXRvci5kYXRhLnByb2Nlc3NvcgogICAgICoJCS8vIGlmIHlvdSBoYXZlIG5vdCBvdmVycmlkZGVuIHRoZSBkZWZhdWx0IG9uZSAod2hpY2ggaXMgdGhlIEh0bWxEYXRhUHJvY2Vzc29yIGluc3RhbmNlKS4KICAgICAqCQljb25zdCBodG1sRFAgPSBuZXcgSHRtbERhdGFQcm9jZXNzb3IoIHZpZXdEb2N1bWVudCApOwogICAgICoKICAgICAqCQkvLyBDb252ZXJ0IGFuIEhUTUwgc3RyaW5nIHRvIGEgdmlldyBkb2N1bWVudCBmcmFnbWVudDoKICAgICAqCQljb25zdCB2aWV3RnJhZ21lbnQgPSBodG1sRFAudG9WaWV3KCBodG1sU3RyaW5nICk7CiAgICAgKgogICAgICoJCS8vIENvbnZlcnQgdGhlIHZpZXcgZG9jdW1lbnQgZnJhZ21lbnQgdG8gYSBtb2RlbCBkb2N1bWVudCBmcmFnbWVudAogICAgICoJCS8vIGluIHRoZSBjb250ZXh0IG9mICRyb290LiBUaGlzIGNvbnZlcnNpb24gdGFrZXMgdGhlIHNjaGVtYSBpbnRvCiAgICAgKgkJLy8gYWNjb3VudCBzbyBpZiwgZm9yIGV4YW1wbGUsIHRoZSB2aWV3IGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5lZCBhIGJhcmUgdGV4dCBub2RlLAogICAgICoJCS8vIHRoaXMgdGV4dCBub2RlIGNhbm5vdCBiZSBhIGNoaWxkIG9mICRyb290LCBzbyBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkKICAgICAqCQkvLyB3cmFwcGVkIHdpdGggYSA8cGFyYWdyYXBoPi4gWW91IGNhbiBkZWZpbmUgdGhlIGNvbnRleHQgeW91cnNlbGYgKGluIHRoZSBzZWNvbmQgcGFyYW1ldGVyKSwKICAgICAqCQkvLyBhbmQgZS5nLiBjb252ZXJ0IHRoZSBjb250ZW50IGxpa2UgaXQgd291bGQgaGFwcGVuIGluIGEgPHBhcmFncmFwaD4uCiAgICAgKgkJLy8gTm90ZTogVGhlIGNsaXBib2FyZCBmZWF0dXJlIHVzZXMgYSBjdXN0b20gY29udGV4dCBjYWxsZWQgJGNsaXBib2FyZEhvbGRlcgogICAgICoJCS8vIHdoaWNoIGhhcyBhIGxvb3NlbmVkIHNjaGVtYS4KICAgICAqCQljb25zdCBtb2RlbEZyYWdtZW50ID0gZWRpdG9yLmRhdGEudG9Nb2RlbCggdmlld0ZyYWdtZW50ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5tb2RlbC5pbnNlcnRDb250ZW50KCBtb2RlbEZyYWdtZW50ICk7CiAgICAgKgogICAgICogQnkgZGVmYXVsdCB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uIGJ1dCBpdCBjYW4gYWxzbyBiZSB1c2VkIHdpdGggYSBwb3NpdGlvbiwgcmFuZ2Ugb3Igc2VsZWN0aW9uIGluc3RhbmNlLgogICAgICoKICAgICAqCQkvLyBJbnNlcnQgdGV4dCBhdCB0aGUgY3VycmVudCBkb2N1bWVudCBzZWxlY3Rpb24gcG9zaXRpb24uCiAgICAgKgkJZWRpdG9yLm1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgICAqCQkJZWRpdG9yLm1vZGVsLmluc2VydENvbnRlbnQoIHdyaXRlci5jcmVhdGVUZXh0KCAneCcgKSApOwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJLy8gSW5zZXJ0IHRleHQgYXQgYSBnaXZlbiBwb3NpdGlvbiAtIHRoZSBkb2N1bWVudCBzZWxlY3Rpb24gd2lsbCBub3QgYmUgbW9kaWZpZWQuCiAgICAgKgkJZWRpdG9yLm1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgICAqCQkJZWRpdG9yLm1vZGVsLmluc2VydENvbnRlbnQoIHdyaXRlci5jcmVhdGVUZXh0KCAneCcgKSwgZG9jLmdldFJvb3QoKSwgMiApOwogICAgICoKICAgICAqCQkJLy8gV2hpY2ggaXMgYSBzaG9ydGhhbmQgZm9yOgogICAgICoJCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggd3JpdGVyLmNyZWF0ZVRleHQoICd4JyApLCB3cml0ZXIuY3JlYXRlUG9zaXRpb25BdCggZG9jLmdldFJvb3QoKSwgMiApICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIElmIHlvdSB3YW50IHRoZSBkb2N1bWVudCBzZWxlY3Rpb24gdG8gYmUgbW92ZWQgdG8gdGhlIGluc2VydGVkIGNvbnRlbnQsIHVzZSB0aGUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjc2V0U2VsZWN0aW9uIGBzZXRTZWxlY3Rpb24oKWB9IG1ldGhvZCBvZiB0aGUgd3JpdGVyIGFmdGVyIGluc2VydGluZwogICAgICogdGhlIGNvbnRlbnQ6CiAgICAgKgogICAgICoJCWVkaXRvci5tb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCWNvbnN0IHBhcmFncmFwaCA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAncGFyYWdyYXBoJyApOwogICAgICoKICAgICAqCQkJLy8gSW5zZXJ0IGFuIGVtcHR5IHBhcmFncmFwaCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByb290LgogICAgICoJCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggcGFyYWdyYXBoLCB3cml0ZXIuY3JlYXRlUG9zaXRpb25BdCggZWRpdG9yLm1vZGVsLmRvY3VtZW50LmdldFJvb3QoKSwgMCApICk7CiAgICAgKgogICAgICoJCQkvLyBNb3ZlIHRoZSBkb2N1bWVudCBzZWxlY3Rpb24gdG8gdGhlIGluc2VydGVkIHBhcmFncmFwaC4KICAgICAqCQkJd3JpdGVyLnNldFNlbGVjdGlvbiggcGFyYWdyYXBoLCAnaW4nICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIElmIGFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uIG1vZGVsIHNlbGVjdGlvbn0gaXMgcGFzc2VkIGFzIGBzZWxlY3RhYmxlYCwKICAgICAqIHRoZSBuZXcgY29udGVudCB3aWxsIGJlIGluc2VydGVkIGF0IHRoZSBwYXNzZWQgc2VsZWN0aW9uIChpbnN0ZWFkIG9mIGRvY3VtZW50IHNlbGVjdGlvbik6CiAgICAgKgogICAgICoJCWVkaXRvci5tb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCS8vIENyZWF0ZSBhIHNlbGVjdGlvbiBpbiBhIHBhcmFncmFwaCB0aGF0IHdpbGwgYmUgdXNlZCBhcyBhIHBsYWNlIG9mIGluc2VydGlvbi4KICAgICAqCQkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnaW4nICk7CiAgICAgKgogICAgICoJCQkvLyBJbnNlcnQgdGhlIG5ldyB0ZXh0IGF0IHRoZSBjcmVhdGVkIHNlbGVjdGlvbi4KICAgICAqCQkJZWRpdG9yLm1vZGVsLmluc2VydENvbnRlbnQoIHdyaXRlci5jcmVhdGVUZXh0KCAneCcgKSwgc2VsZWN0aW9uICk7CiAgICAgKgogICAgICoJCQkvLyBpbnNlcnRDb250ZW50KCkgbW9kaWZpZXMgdGhlIHBhc3NlZCBzZWxlY3Rpb24gaW5zdGFuY2Ugc28gaXQgY2FuIGJlIHVzZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBzZWxlY3Rpb24uCiAgICAgKgkJCS8vIE5vdGU6IFRoaXMgaXMgbm90IG5lY2Vzc2FyeSB3aGVuIHlvdSBwYXNzZWQgdGhlIGRvY3VtZW50IHNlbGVjdGlvbiB0byBpbnNlcnRDb250ZW50KCkuCiAgICAgKgkJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHNlbGVjdGlvbiApOwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBAZmlyZXMgaW5zZXJ0Q29udGVudAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gY29udGVudCBUaGUgY29udGVudCB0byBpbnNlcnQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGFibGV9IFtzZWxlY3RhYmxlPW1vZGVsLmRvY3VtZW50LnNlbGVjdGlvbl0KICAgICAqIFRoZSBzZWxlY3Rpb24gaW50byB3aGljaCB0aGUgY29udGVudCBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIG5vdCBwcm92aWRlZCB0aGUgY3VycmVudCBtb2RlbCBkb2N1bWVudCBzZWxlY3Rpb24gd2lsbCBiZSB1c2VkLgogICAgICogQHBhcmFtIHtOdW1iZXJ8J2JlZm9yZSd8J2VuZCd8J2FmdGVyJ3wnb24nfCdpbid9IFtwbGFjZU9yT2Zmc2V0XSBUbyBiZSB1c2VkIHdoZW4gYSBtb2RlbCBpdGVtIHdhcyBwYXNzZWQgYXMgYHNlbGVjdGFibGVgLgogICAgICogVGhpcyBwYXJhbSBkZWZpbmVzIGEgcG9zaXRpb24gaW4gcmVsYXRpb24gdG8gdGhhdCBpdGVtLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IFJhbmdlIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgcGVyZm9ybWVkIGNoYW5nZXMuIFRoaXMgaXMgYSByYW5nZSB0aGF0LCBpZiByZW1vdmVkLAogICAgICogd291bGQgcmV0dXJuIHRoZSBtb2RlbCB0byB0aGUgc3RhdGUgYmVmb3JlIHRoZSBpbnNlcnRpb24uIElmIG5vIGNoYW5nZXMgd2VyZSBwcmVmb3JtZWQgYnkgYGluc2VydENvbnRlbnRgLCByZXR1cm5zIGEgcmFuZ2UgY29sbGFwc2VkCiAgICAgKiBhdCB0aGUgaW5zZXJ0aW9uIHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogImluc2VydENvbnRlbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydENvbnRlbnQoY29udGVudCwgc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCkgewogICAgICByZXR1cm4gX2luc2VydENvbnRlbnQodGhpcywgY29udGVudCwgc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCk7CiAgICB9CiAgICAvKioKICAgICAqIERlbGV0ZXMgY29udGVudCBvZiB0aGUgc2VsZWN0aW9uIGFuZCBtZXJnZSBzaWJsaW5ncy4gVGhlIHJlc3VsdGluZyBzZWxlY3Rpb24gaXMgYWx3YXlzIGNvbGxhcHNlZC4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogRm9yIHRoZSBzYWtlIG9mIHByZWRpY3RhYmlsaXR5LCB0aGUgcmVzdWx0aW5nIHNlbGVjdGlvbiBzaG91bGQgYWx3YXlzIGJlIGNvbGxhcHNlZC4KICAgICAqIEluIGNhc2VzIHdoZXJlIGEgZmVhdHVyZSB3YW50cyB0byBtb2RpZnkgZGVsZXRpbmcgYmVoYXZpb3Igc28gc2VsZWN0aW9uIGlzbid0IGNvbGxhcHNlZAogICAgICogKGUuZy4gYSB0YWJsZSBmZWF0dXJlIG1heSB3YW50IHRvIGtlZXAgcm93IHNlbGVjdGlvbiBhZnRlciBwcmVzc2luZyA8a2JkPkJhY2tzcGFjZTwva2JkPiksCiAgICAgKiB0aGVuIHRoYXQgYmVoYXZpb3Igc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHRoZSB2aWV3J3MgbGlzdGVuZXIuIEF0IHRoZSBzYW1lIHRpbWUsIHRoZSB0YWJsZSBmZWF0dXJlCiAgICAgKiB3aWxsIG5lZWQgdG8gbW9kaWZ5IHRoaXMgbWV0aG9kJ3MgYmVoYXZpb3IgdG9vLCBlLmcuIHRvICJkZWxldGUgY29udGVudHMgYW5kIHRoZW4gY29sbGFwc2UKICAgICAqIHRoZSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBsYXN0IHNlbGVjdGVkIGNlbGwiIG9yICJkZWxldGUgdGhlIHJvdyBhbmQgY29sbGFwc2Ugc2VsZWN0aW9uIHNvbWV3aGVyZSBuZWFyIi4KICAgICAqIFRoYXQgbmVlZHMgdG8gYmUgZG9uZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBvdGhlciBmZWF0dXJlcyB3aGljaCB1c2UgYGRlbGV0ZUNvbnRlbnQoKWAgd2lsbCB3b3JrIHdlbGwgd2l0aCB0YWJsZXMuCiAgICAgKgogICAgICogQGZpcmVzIGRlbGV0ZUNvbnRlbnQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb259IHNlbGVjdGlvbgogICAgICogU2VsZWN0aW9uIG9mIHdoaWNoIHRoZSBjb250ZW50IHNob3VsZCBiZSBkZWxldGVkLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sZWF2ZVVubWVyZ2VkPWZhbHNlXSBXaGV0aGVyIHRvIG1lcmdlIGVsZW1lbnRzIGFmdGVyIHJlbW92aW5nIHRoZSBjb250ZW50IG9mIHRoZSBzZWxlY3Rpb24uCiAgICAgKgogICAgICogRm9yIGV4YW1wbGUgYDxoZWFkaW5nMT54W3g8L2hlYWRpbmcxPjxwYXJhZ3JhcGg+eV15PC9wYXJhZ3JhcGg+YCB3aWxsIGJlY29tZToKICAgICAqCiAgICAgKiAqIGA8aGVhZGluZzE+eF55PC9oZWFkaW5nMT5gIHdpdGggdGhlIG9wdGlvbiBkaXNhYmxlZCAoYGxlYXZlVW5tZXJnZWQgPT0gZmFsc2VgKQogICAgICogKiBgPGhlYWRpbmcxPnhePC9oZWFkaW5nMT48cGFyYWdyYXBoPnk8L3BhcmFncmFwaD5gIHdpdGggZW5hYmxlZCAoYGxlYXZlVW5tZXJnZWQgPT0gdHJ1ZWApLgogICAgICoKICAgICAqIE5vdGU6IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjaXNPYmplY3Qgb2JqZWN0fSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc0xpbWl0IGxpbWl0fQogICAgICogZWxlbWVudHMgd2lsbCBub3QgYmUgbWVyZ2VkLgogICAgICoKICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG9Ob3RSZXNldEVudGlyZUNvbnRlbnQ9ZmFsc2VdIFdoZXRoZXIgdG8gc2tpcCByZXBsYWNpbmcgdGhlIGVudGlyZSBjb250ZW50IHdpdGggYQogICAgICogcGFyYWdyYXBoIHdoZW4gdGhlIGVudGlyZSBjb250ZW50IHdhcyBzZWxlY3RlZC4KICAgICAqCiAgICAgKiBGb3IgZXhhbXBsZSBgPGhlYWRpbmcxPlt4PC9oZWFkaW5nMT48cGFyYWdyYXBoPnldPC9wYXJhZ3JhcGg+YCB3aWxsIGJlY29tZToKICAgICAqCiAgICAgKiAqIGA8cGFyYWdyYXBoPl48L3BhcmFncmFwaD5gIHdpdGggdGhlIG9wdGlvbiBkaXNhYmxlZCAoYGRvTm90UmVzZXRFbnRpcmVDb250ZW50ID09IGZhbHNlYCkKICAgICAqICogYDxoZWFkaW5nMT5ePC9oZWFkaW5nMT5gIHdpdGggZW5hYmxlZCAoYGRvTm90UmVzZXRFbnRpcmVDb250ZW50ID09IHRydWVgKQogICAgICoKICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG9Ob3RBdXRvcGFyYWdyYXBoPWZhbHNlXSBXaGV0aGVyIHRvIGNyZWF0ZSBhIHBhcmFncmFwaCBpZiBhZnRlciBjb250ZW50IGRlbGV0aW9uIHNlbGVjdGlvbiBpcyBtb3ZlZAogICAgICogdG8gYSBwbGFjZSB3aGVyZSB0ZXh0IGNhbm5vdCBiZSBpbnNlcnRlZC4KICAgICAqCiAgICAgKiBGb3IgZXhhbXBsZSBgPHBhcmFncmFwaD54PC9wYXJhZ3JhcGg+WzxpbWFnZSBzcmM9ImZvby5qcGciPjwvaW1hZ2U+XWAgd2lsbCBiZWNvbWU6CiAgICAgKgogICAgICogKiBgPHBhcmFncmFwaD54PC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5bXTwvcGFyYWdyYXBoPmAgd2l0aCB0aGUgb3B0aW9uIGRpc2FibGVkIChgZG9Ob3RBdXRvcGFyYWdyYXBoID09IGZhbHNlYCkKICAgICAqICogYDxwYXJhZ3JhcGg+eFtdPC9wYXJhZ3JhcGg+YCB3aXRoIHRoZSBvcHRpb24gZW5hYmxlZCAoYGRvTm90QXV0b3BhcmFncmFwaCA9PSB0cnVlYCkuCiAgICAgKgogICAgICogKipOb3RlOioqIGlmIHRoZXJlIGlzIG5vIHZhbGlkIHBvc2l0aW9uIGZvciB0aGUgc2VsZWN0aW9uLCB0aGUgcGFyYWdyYXBoIHdpbGwgYWx3YXlzIGJlIGNyZWF0ZWQ6CiAgICAgKgogICAgICogYFs8aW1hZ2Ugc3JjPSJmb28uanBnIj48L2ltYWdlPl1gIC0+IGA8cGFyYWdyYXBoPltdPC9wYXJhZ3JhcGg+YC4KICAgICAqCiAgICAgKiBAcGFyYW0geydmb3J3YXJkJ3wnYmFja3dhcmQnfSBbb3B0aW9ucy5kaXJlY3Rpb249J2JhY2t3YXJkJ10gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgY29udGVudCBpcyBiZWluZyBjb25zdW1lZC4KICAgICAqIERlbGV0aW5nIGJhY2t3YXJkIGNvcnJlc3BvbmRzIHRvIHVzaW5nIHRoZSA8a2JkPkJhY2tzcGFjZTwva2JkPiBrZXksIHdoaWxlIGRlbGV0aW5nIGNvbnRlbnQgZm9yd2FyZCBjb3JyZXNwb25kcyB0bwogICAgICogdGhlIDxrYmQ+U2hpZnQ8L2tiZD4rPGtiZD5CYWNrc3BhY2U8L2tiZD4ga2V5c3Ryb2tlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImRlbGV0ZUNvbnRlbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUNvbnRlbnQoc2VsZWN0aW9uLCBvcHRpb25zKSB7CiAgICAgIF9kZWxldGVDb250ZW50KHRoaXMsIHNlbGVjdGlvbiwgb3B0aW9ucyk7CiAgICB9CiAgICAvKioKICAgICAqIE1vZGlmaWVzIHRoZSBzZWxlY3Rpb24uIEN1cnJlbnRseSwgdGhlIHN1cHBvcnRlZCBtb2RpZmljYXRpb25zIGFyZToKICAgICAqCiAgICAgKiAqIEV4dGVuZGluZy4gVGhlIHNlbGVjdGlvbiBmb2N1cyBpcyBtb3ZlZCBpbiB0aGUgc3BlY2lmaWVkIGBvcHRpb25zLmRpcmVjdGlvbmAgd2l0aCBhIHN0ZXAgc3BlY2lmaWVkIGluIGBvcHRpb25zLnVuaXRgLgogICAgICogUG9zc2libGUgdmFsdWVzIGZvciBgdW5pdGAgYXJlOgogICAgICogICogYCdjaGFyYWN0ZXInYCAoZGVmYXVsdCkgLSBtb3ZlcyBzZWxlY3Rpb24gYnkgb25lIHVzZXItcGVyY2VpdmVkIGNoYXJhY3Rlci4gSW4gbW9zdCBjYXNlcyB0aGlzIG1lYW5zIG1vdmluZyBieSBvbmUKICAgICAqICBjaGFyYWN0ZXIgaW4gYFN0cmluZ2Agc2Vuc2UuIEhvd2V2ZXIsIHVuaWNvZGUgYWxzbyBkZWZpbmVzICJjb21iaW5nIG1hcmtzIi4gVGhlc2UgYXJlIHNwZWNpYWwgc3ltYm9scywgdGhhdCBjb21iaW5lcwogICAgICogIHdpdGggYSBzeW1ib2wgYmVmb3JlIGl0ICgiYmFzZSBjaGFyYWN0ZXIiKSB0byBjcmVhdGUgb25lIHVzZXItcGVyY2VpdmVkIGNoYXJhY3Rlci4gRm9yIGV4YW1wbGUsIGBxzIfMo2AgaXMgYSBub3JtYWwKICAgICAqICBsZXR0ZXIgYHFgIHdpdGggdHdvICJjb21iaW5pbmcgbWFya3MiOiB1cHBlciBkb3QgKGBVeDAzMDdgKSBhbmQgbG93ZXIgZG90IChgVXgwMzIzYCkuIEZvciBtb3N0IGFjdGlvbnMsIGkuZS4gZXh0ZW5kaW5nCiAgICAgKiAgc2VsZWN0aW9uIGJ5IG9uZSBwb3NpdGlvbiwgaXQgaXMgY29ycmVjdCB0byBpbmNsdWRlIGJvdGggImJhc2UgY2hhcmFjdGVyIiBhbmQgYWxsIG9mIGl0J3MgImNvbWJpbmluZyBtYXJrcyIuIFRoYXQgaXMKICAgICAqICB3aHkgYCdjaGFyYWN0ZXInYCB2YWx1ZSBpcyBtb3N0IG5hdHVyYWwgYW5kIGNvbW1vbiBtZXRob2Qgb2YgbW9kaWZ5aW5nIHNlbGVjdGlvbi4KICAgICAqICAqIGAnY29kZVBvaW50J2AgLSBtb3ZlcyBzZWxlY3Rpb24gYnkgb25lIHVuaWNvZGUgY29kZSBwb2ludC4gSW4gY29udHJhcnkgdG8sIGAnY2hhcmFjdGVyJ2AgdW5pdCwgdGhpcyB3aWxsIGluc2VydAogICAgICogIHNlbGVjdGlvbiBiZXR3ZWVuICJiYXNlIGNoYXJhY3RlciIgYW5kICJjb21iaW5pbmcgbWFyayIsIGJlY2F1c2UgImNvbWJpbmluZyBtYXJrcyIgaGF2ZSB0aGVpciBvd24gdW5pY29kZSBjb2RlIHBvaW50cy4KICAgICAqICBIb3dldmVyLCBmb3IgdGVjaG5pY2FsIHJlYXNvbnMsIHVuaWNvZGUgY29kZSBwb2ludHMgd2l0aCB2YWx1ZXMgYWJvdmUgYFV4RkZGRmAgYXJlIHJlcHJlc2VudGVkIGluIG5hdGl2ZSBgU3RyaW5nYCBieQogICAgICogIHR3byBjaGFyYWN0ZXJzLCBjYWxsZWQgInN1cnJvZ2F0ZSBwYWlycyIuIEhhbHZlcyBvZiAic3Vycm9nYXRlIHBhaXJzIiBoYXZlIGEgbWVhbmluZyBvbmx5IHdoZW4gcGxhY2VkIG5leHQgdG8gZWFjaCBvdGhlci4KICAgICAqICBGb3IgZXhhbXBsZSBg8KitjmAgaXMgcmVwcmVzZW50ZWQgaW4gYFN0cmluZ2AgYnkgYFx1RDg2Mlx1REY0RWAuIEJvdGggYFx1RDg2MmAgYW5kIGBcdURGNEVgIGRvIG5vdCBoYXZlIGFueSBtZWFuaW5nCiAgICAgKiAgb3V0c2lkZSB0aGUgcGFpciAoYXJlIHJlbmRlcmVkIGFzID8gd2hlbiBhbG9uZSkuIFBvc2l0aW9uIGJldHdlZW4gdGhlbSB3b3VsZCBiZSBpbmNvcnJlY3QuIEluIHRoaXMgY2FzZSwgc2VsZWN0aW9uCiAgICAgKiAgZXh0ZW5zaW9uIHdpbGwgaW5jbHVkZSB3aG9sZSAic3Vycm9nYXRlIHBhaXIiLgogICAgICogICogYCd3b3JkJ2AgLSBtb3ZlcyBzZWxlY3Rpb24gYnkgYSB3aG9sZSB3b3JkLgogICAgICoKICAgICAqICoqTm90ZToqKiBpZiB5b3UgZXh0ZW5kIGEgZm9yd2FyZCBzZWxlY3Rpb24gaW4gYSBiYWNrd2FyZCBkaXJlY3Rpb24geW91IHdpbGwgaW4gZmFjdCBzaHJpbmsgaXQuCiAgICAgKgogICAgICogQGZpcmVzIG1vZGlmeVNlbGVjdGlvbgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0gc2VsZWN0aW9uCiAgICAgKiBUaGUgc2VsZWN0aW9uIHRvIG1vZGlmeS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10KICAgICAqIEBwYXJhbSB7J2ZvcndhcmQnfCdiYWNrd2FyZCd9IFtvcHRpb25zLmRpcmVjdGlvbj0nZm9yd2FyZCddIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgbW9kaWZpZWQuCiAgICAgKiBAcGFyYW0geydjaGFyYWN0ZXInfCdjb2RlUG9pbnQnfCd3b3JkJ30gW29wdGlvbnMudW5pdD0nY2hhcmFjdGVyJ10gVGhlIHVuaXQgYnkgd2hpY2ggc2VsZWN0aW9uIHNob3VsZCBiZSBtb2RpZmllZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJtb2RpZnlTZWxlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIG1vZGlmeVNlbGVjdGlvbihzZWxlY3Rpb24sIG9wdGlvbnMpIHsKICAgICAgX21vZGlmeVNlbGVjdGlvbih0aGlzLCBzZWxlY3Rpb24sIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIGEgY2xvbmUgb2YgdGhlIHNlbGVjdGVkIGNvbnRlbnQuCiAgICAgKgogICAgICogRm9yIGV4YW1wbGUsIGZvciB0aGUgZm9sbG93aW5nIHNlbGVjdGlvbjoKICAgICAqCiAgICAgKiBgYGBodG1sCiAgICAgKiA8cGFyYWdyYXBoPng8L3BhcmFncmFwaD4KICAgICAqIDxibG9ja1F1b3RlPgogICAgICoJPHBhcmFncmFwaD55PC9wYXJhZ3JhcGg+CiAgICAgKgk8aGVhZGluZzE+ZmlyW3N0PC9oZWFkaW5nMT4KICAgICAqIDwvYmxvY2tRdW90ZT4KICAgICAqIDxwYXJhZ3JhcGg+c2VdY29uZDwvcGFyYWdyYXBoPgogICAgICogPHBhcmFncmFwaD56PC9wYXJhZ3JhcGg+CiAgICAgKiBgYGAKICAgICAqCiAgICAgKiBJdCB3aWxsIHJldHVybiBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggc3VjaCBhIGNvbnRlbnQ6CiAgICAgKgogICAgICogYGBgaHRtbAogICAgICogPGJsb2NrUXVvdGU+CiAgICAgKgk8aGVhZGluZzE+c3Q8L2hlYWRpbmcxPgogICAgICogPC9ibG9ja1F1b3RlPgogICAgICogPHBhcmFncmFwaD5zZTwvcGFyYWdyYXBoPgogICAgICogYGBgCiAgICAgKgogICAgICogQGZpcmVzIGdldFNlbGVjdGVkQ29udGVudAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0gc2VsZWN0aW9uCiAgICAgKiBUaGUgc2VsZWN0aW9uIG9mIHdoaWNoIGNvbnRlbnQgd2lsbCBiZSByZXR1cm5lZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRTZWxlY3RlZENvbnRlbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkQ29udGVudChzZWxlY3Rpb24pIHsKICAgICAgcmV0dXJuIF9nZXRTZWxlY3RlZENvbnRlbnQodGhpcywgc2VsZWN0aW9uKTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IGhhcyBhbnkgbWVhbmluZ2Z1bCBjb250ZW50LgogICAgICoKICAgICAqIE1lYW5pbmdmdWwgY29udGVudCBpczoKICAgICAqCiAgICAgKiAqIGFueSB0ZXh0IG5vZGUgKGBvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2VzYCBhbGxvd3MgY29udHJvbGxpbmcgd2hldGhlciB0aGlzIHRleHQgbm9kZSBtdXN0IGFsc28gY29udGFpbgogICAgICogYW55IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMpLAogICAgICogKiBvciBhbnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc0NvbnRlbnQgY29udGVudCBlbGVtZW50fSwKICAgICAqICogb3IgYW55IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyIG1hcmtlcn0gd2hpY2gKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyI19hZmZlY3RzRGF0YSBhZmZlY3RzIGRhdGF9LgogICAgICoKICAgICAqIFRoaXMgbWVhbnMgdGhhdCBhIHJhbmdlIGNvbnRhaW5pbmcgYW4gZW1wdHkgYDxwYXJhZ3JhcGg+PC9wYXJhZ3JhcGg+YCBpcyBub3QgY29uc2lkZXJlZCB0byBoYXZlIGEgbWVhbmluZ2Z1bCBjb250ZW50LgogICAgICogSG93ZXZlciwgYSByYW5nZSBjb250YWluaW5nIGFuIGA8aW1hZ2U+PC9pbWFnZT5gICh3aGljaCB3b3VsZCBub3JtYWxseSBiZSBtYXJrZWQgaW4gdGhlIHNjaGVtYSBhcyBhbiBvYmplY3QgZWxlbWVudCkKICAgICAqIGlzIGNvbnNpZGVyZWQgbm9uLWVtcHR5LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gcmFuZ2VPckVsZW1lbnQgUmFuZ2Ugb3IgZWxlbWVudCB0byBjaGVjay4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlV2hpdGVzcGFjZXNdIFdoZXRoZXIgdGV4dCBub2RlIHdpdGggd2hpdGVzcGFjZXMgb25seSBzaG91bGQgYmUgY29uc2lkZXJlZCBlbXB0eS4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlTWFya2Vyc10gV2hldGhlciBtYXJrZXJzIHNob3VsZCBiZSBpZ25vcmVkLgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaGFzQ29udGVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ29udGVudChyYW5nZU9yRWxlbWVudCkgewogICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307CiAgICAgIHZhciByYW5nZSA9IHJhbmdlT3JFbGVtZW50IGluc3RhbmNlb2YgTW9kZWxFbGVtZW50ID8gTW9kZWxSYW5nZS5fY3JlYXRlSW4ocmFuZ2VPckVsZW1lbnQpIDogcmFuZ2VPckVsZW1lbnQ7CgogICAgICBpZiAocmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciBfb3B0aW9ucyRpZ25vcmVXaGl0ZXMgPSBvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2VzLAogICAgICAgICAgaWdub3JlV2hpdGVzcGFjZXMgPSBfb3B0aW9ucyRpZ25vcmVXaGl0ZXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkaWdub3JlV2hpdGVzLAogICAgICAgICAgX29wdGlvbnMkaWdub3JlTWFya2VyID0gb3B0aW9ucy5pZ25vcmVNYXJrZXJzLAogICAgICAgICAgaWdub3JlTWFya2VycyA9IF9vcHRpb25zJGlnbm9yZU1hcmtlciA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRpZ25vcmVNYXJrZXI7IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbWFya2VycyB3aGljaCBhZmZlY3RzIGRhdGEgaW4gdGhpcyBnaXZlbiByYW5nZS4KCiAgICAgIGlmICghaWdub3JlTWFya2VycykgewogICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLm1hcmtlcnMuZ2V0TWFya2Vyc0ludGVyc2VjdGluZ1JhbmdlKHJhbmdlKSksCiAgICAgICAgICAgIF9zdGVwOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIGludGVyc2VjdGluZ01hcmtlciA9IF9zdGVwLnZhbHVlOwoKICAgICAgICAgICAgaWYgKGludGVyc2VjdGluZ01hcmtlci5hZmZlY3RzRGF0YSkgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyYW5nZS5nZXRJdGVtcygpKSwKICAgICAgICAgIF9zdGVwMjsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAyLnZhbHVlOwoKICAgICAgICAgIGlmICh0aGlzLnNjaGVtYS5pc0NvbnRlbnQoaXRlbSkpIHsKICAgICAgICAgICAgaWYgKGl0ZW0uaXMoJyR0ZXh0UHJveHknKSkgewogICAgICAgICAgICAgIGlmICghaWdub3JlV2hpdGVzcGFjZXMpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5kYXRhLnNlYXJjaCgvXFMvKSAhPT0gLTEpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHBvc2l0aW9uIGZyb20gdGhlIGdpdmVuIHJvb3QgYW5kIHBhdGggaW4gdGhhdCByb290LgogICAgICoKICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlIGFzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVBvc2l0aW9uRnJvbVBhdGggYFdyaXRlciNjcmVhdGVQb3NpdGlvbkZyb21QYXRoKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSByb290IFJvb3Qgb2YgdGhlIHBvc2l0aW9uLgogICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gcGF0aCBQb3NpdGlvbiBwYXRoLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aH0uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfSBbc3RpY2tpbmVzcz0ndG9Ob25lJ10gUG9zaXRpb24gc3RpY2tpbmVzcy4KICAgICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblN0aWNraW5lc3N9LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25Gcm9tUGF0aChyb290LCBwYXRoLCBzdGlja2luZXNzKSB7CiAgICAgIHJldHVybiBuZXcgTW9kZWxQb3NpdGlvbihyb290LCBwYXRoLCBzdGlja2luZXNzKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uIFRoZSBsb2NhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzOgogICAgICoKICAgICAqICogYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0sCiAgICAgKiAqIGEgcGFyZW50IGVsZW1lbnQgYW5kIG9mZnNldCBpbiB0aGF0IGVsZW1lbnQsCiAgICAgKiAqIGEgcGFyZW50IGVsZW1lbnQgYW5kIGAnZW5kJ2AgKHRoZSBwb3NpdGlvbiB3aWxsIGJlIHNldCBhdCB0aGUgZW5kIG9mIHRoYXQgZWxlbWVudCksCiAgICAgKiAqIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19IGFuZCBgJ2JlZm9yZSdgIG9yIGAnYWZ0ZXInYAogICAgICogKHRoZSBwb3NpdGlvbiB3aWxsIGJlIHNldCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGdpdmVuIG1vZGVsIGl0ZW0pLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc2hvcnRjdXQgdG8gb3RoZXIgZmFjdG9yeSBtZXRob2RzIHN1Y2ggYXM6CiAgICAgKgogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkJlZm9yZSBgY3JlYXRlUG9zaXRpb25CZWZvcmUoKWB9LAogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkFmdGVyIGBjcmVhdGVQb3NpdGlvbkFmdGVyKClgfS4KICAgICAqCiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVQb3NpdGlvbkF0IGBXcml0ZXIjY3JlYXRlUG9zaXRpb25BdCgpYH0sCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBpdGVtT3JQb3NpdGlvbgogICAgICogQHBhcmFtIHtOdW1iZXJ8J2VuZCd8J2JlZm9yZSd8J2FmdGVyJ30gW29mZnNldF0gT2Zmc2V0IG9yIG9uZSBvZiB0aGUgZmxhZ3MuIFVzZWQgb25seSB3aGVuCiAgICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25BdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25BdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIHJldHVybiBNb2RlbFBvc2l0aW9uLl9jcmVhdGVBdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyBwb3NpdGlvbiBhZnRlciB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICoKICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlIGFzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVBvc2l0aW9uQWZ0ZXIgYFdyaXRlciNjcmVhdGVQb3NpdGlvbkFmdGVyKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtIEl0ZW0gYWZ0ZXIgd2hpY2ggdGhlIHBvc2l0aW9uIHNob3VsZCBiZSBwbGFjZWQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVQb3NpdGlvbkFmdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkFmdGVyKGl0ZW0pIHsKICAgICAgcmV0dXJuIE1vZGVsUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHBvc2l0aW9uIGJlZm9yZSB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICoKICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlIGFzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVBvc2l0aW9uQmVmb3JlIGBXcml0ZXIjY3JlYXRlUG9zaXRpb25CZWZvcmUoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IGl0ZW0gSXRlbSBiZWZvcmUgd2hpY2ggdGhlIHBvc2l0aW9uIHNob3VsZCBiZSBwbGFjZWQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVQb3NpdGlvbkJlZm9yZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25CZWZvcmUoaXRlbSkgewogICAgICByZXR1cm4gTW9kZWxQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2Ugc3Bhbm5pbmcgZnJvbSB0aGUgYHN0YXJ0YCBwb3NpdGlvbiB0byB0aGUgYGVuZGAgcG9zaXRpb24uCiAgICAgKgogICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgYXMKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY3JlYXRlUmFuZ2UgYFdyaXRlciNjcmVhdGVSYW5nZSgpYH06CiAgICAgKgogICAgICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgICAqCQkJY29uc3QgcmFuZ2UgPSB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0LCBlbmQgKTsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBzdGFydCBTdGFydCBwb3NpdGlvbi4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gW2VuZF0gRW5kIHBvc2l0aW9uLiBJZiBub3Qgc2V0LCB0aGUgcmFuZ2Ugd2lsbCBiZSBjb2xsYXBzZWQKICAgICAqIHRvIHRoZSBgc3RhcnRgIHBvc2l0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKHN0YXJ0LCBlbmQpIHsKICAgICAgcmV0dXJuIG5ldyBNb2RlbFJhbmdlKHN0YXJ0LCBlbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mCiAgICAgKiB0aGF0IGVsZW1lbnQgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50LgogICAgICoKICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlIGFzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVJhbmdlSW4gYFdyaXRlciNjcmVhdGVSYW5nZUluKClgfToKICAgICAqCiAgICAgKgkJbW9kZWwuY2hhbmdlKCB3cml0ZXIgPT4gewogICAgICoJCQljb25zdCByYW5nZSA9IHdyaXRlci5jcmVhdGVSYW5nZUluKCBwYXJhZ3JhcGggKTsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHdoaWNoIGlzIGEgcGFyZW50IGZvciB0aGUgcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVSYW5nZUluIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYW5nZUluKGVsZW1lbnQpIHsKICAgICAgcmV0dXJuIE1vZGVsUmFuZ2UuX2NyZWF0ZUluKGVsZW1lbnQpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgdGhhdCBzdGFydHMgYmVmb3JlIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0gYW5kIGVuZHMgYWZ0ZXIgaXQuCiAgICAgKgogICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgb24gYHdyaXRlcmAgaW5zdGFuY2UgYXMKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY3JlYXRlUmFuZ2VPbiBgV3JpdGVyLmNyZWF0ZVJhbmdlT24oKWB9OgogICAgICoKICAgICAqCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlT24oIHBhcmFncmFwaCApOwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVSYW5nZU9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYW5nZU9uKGl0ZW0pIHsKICAgICAgcmV0dXJuIE1vZGVsUmFuZ2UuX2NyZWF0ZU9uKGl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHNlbGVjdGlvbiBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGFibGUgc2VsZWN0YWJsZX0KICAgICAqIG9yIGNyZWF0ZXMgYW4gZW1wdHkgc2VsZWN0aW9uIGlmIG5vIGFyZ3VtZW50cyB3ZXJlIHBhc3NlZC4KICAgICAqCiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVTZWxlY3Rpb24gYFdyaXRlciNjcmVhdGVTZWxlY3Rpb24oKWB9LgogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIGVtcHR5IHNlbGVjdGlvbiB3aXRob3V0IHJhbmdlcy4KICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiByYW5nZS4KICAgICAqCQljb25zdCByYW5nZSA9IHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQsIGVuZCApOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiByYW5nZXMKICAgICAqCQljb25zdCByYW5nZXMgPSBbIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQxLCBlbmQyICksIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcjIsIGVuZDIgKSBdOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlcyApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHRoZSBvdGhlciBzZWxlY3Rpb24uCiAgICAgKgkJLy8gTm90ZTogSXQgZG9lc24ndCBjb3BpZXMgc2VsZWN0aW9uIGF0dHJpYnV0ZXMuCiAgICAgKgkJY29uc3Qgb3RoZXJTZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCk7CiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggb3RoZXJTZWxlY3Rpb24gKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSB0aGUgZ2l2ZW4gZG9jdW1lbnQgc2VsZWN0aW9uLgogICAgICoJCS8vIE5vdGU6IEl0IGRvZXNuJ3QgY29waWVzIHNlbGVjdGlvbiBhdHRyaWJ1dGVzLgogICAgICoJCWNvbnN0IGRvY3VtZW50U2VsZWN0aW9uID0gbW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIGRvY3VtZW50U2VsZWN0aW9uICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4KICAgICAqCQljb25zdCBwb3NpdGlvbiA9IHdyaXRlci5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBwYXRoICk7CiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcG9zaXRpb24gKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gYXQgdGhlIGdpdmVuIG9mZnNldCBpbiB0aGUgZ2l2ZW4gZWxlbWVudC4KICAgICAqCQljb25zdCBwYXJhZ3JhcGggPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBwYXJhZ3JhcGgsIG9mZnNldCApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZQogICAgICoJCS8vIGZpcnN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudCBhbmQgZW5kcyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQuCiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnaW4nICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgYSByYW5nZSBvbiBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gaXRlbX0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgaXRlbSBhbmQgZW5kcwogICAgICoJCS8vIGp1c3QgYWZ0ZXIgdGhlIGl0ZW0uCiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnb24nICk7CiAgICAgKgogICAgICoJCS8vIEFkZGl0aW9uYWwgb3B0aW9ucyAoYCdiYWNrd2FyZCdgKSBjYW4gYmUgc3BlY2lmaWVkIGFzIHRoZSBsYXN0IGFyZ3VtZW50LgogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIGJhY2t3YXJkIHNlbGVjdGlvbi4KICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZSwgeyBiYWNrd2FyZDogdHJ1ZSB9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3RhYmxlfSBzZWxlY3RhYmxlCiAgICAgKiBAcGFyYW0ge051bWJlcnwnYmVmb3JlJ3wnZW5kJ3wnYWZ0ZXInfCdvbid8J2luJ30gW3BsYWNlT3JPZmZzZXRdIFNldHMgcGxhY2Ugb3Igb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb24uCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJhY2t3YXJkXSBTZXRzIHRoaXMgc2VsZWN0aW9uIGluc3RhbmNlIHRvIGJlIGJhY2t3YXJkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVTZWxlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGlvbihzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKSB7CiAgICAgIHJldHVybiBuZXcgTW9kZWxTZWxlY3Rpb24oc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCwgb3B0aW9ucyk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gaW5zdGFuY2UuCiAgICAgKgogICAgICogKipOb3RlOioqIEluIG1vc3QgY2FzZXMgY3JlYXRpbmcgYSBiYXRjaCBpbnN0YW5jZSBpcyBub3QgbmVjZXNzYXJ5IGFzIHRoZXkgYXJlIGNyZWF0ZWQgd2hlbiB1c2luZzoKICAgICAqCiAgICAgKiAqIHtAbGluayAjY2hhbmdlIGBjaGFuZ2UoKWB9LAogICAgICogKiB7QGxpbmsgI2VucXVldWVDaGFuZ2UgYGVucXVldWVDaGFuZ2UoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7J3RyYW5zcGFyZW50J3wnZGVmYXVsdCd9IFt0eXBlPSdkZWZhdWx0J10gVGhlIHR5cGUgb2YgdGhlIGJhdGNoLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvYmF0Y2h+QmF0Y2h9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlQmF0Y2giLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUJhdGNoKHR5cGUpIHsKICAgICAgcmV0dXJuIG5ldyBCYXRjaCh0eXBlKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhbiBvcGVyYXRpb24gaW5zdGFuY2UgZnJvbSBhIEpTT04gb2JqZWN0IChwYXJzZWQgSlNPTiBzdHJpbmcpLgogICAgICoKICAgICAqIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25mYWN0b3J5fk9wZXJhdGlvbkZhY3RvcnkuZnJvbUpTT04gYE9wZXJhdGlvbkZhY3RvcnkuZnJvbUpTT04oKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIERlc2VyaWFsaXplZCBKU09OIG9iamVjdC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZU9wZXJhdGlvbkZyb21KU09OIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVPcGVyYXRpb25Gcm9tSlNPTihqc29uKSB7CiAgICAgIHJldHVybiBPcGVyYXRpb25GYWN0b3J5LmZyb21KU09OKGpzb24sIHRoaXMuZG9jdW1lbnQpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGFsbCBldmVudHMgbGlzdGVuZXJzIHNldCBieSBtb2RlbCBpbnN0YW5jZSBhbmQgZGVzdHJveXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9LgogICAgICovCgogIH0sIHsKICAgIGtleTogImRlc3Ryb3kiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7CiAgICAgIHRoaXMuZG9jdW1lbnQuZGVzdHJveSgpOwogICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTsKICAgIH0KICAgIC8qKgogICAgICogQ29tbW9uIHBhcnQgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlfSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZX0KICAgICAqIHdoaWNoIGNhbGxzIGNhbGxiYWNrcyBhbmQgcmV0dXJucyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlc2UgY2FsbGJhY2tzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPCo+fSBBcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgY2FsbGJhY2tzLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9ydW5QZW5kaW5nQ2hhbmdlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1blBlbmRpbmdDaGFuZ2VzKCkgewogICAgICB2YXIgcmV0ID0gW107CiAgICAgIHRoaXMuZmlyZSgnX2JlZm9yZUNoYW5nZXMnKTsKCiAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nQ2hhbmdlcy5sZW5ndGgpIHsKICAgICAgICAvLyBDcmVhdGUgYSBuZXcgd3JpdGVyIHVzaW5nIGJhdGNoIGluc3RhbmNlIGNyZWF0ZWQgZm9yIHRoaXMgY2hhaW4gb2YgY2hhbmdlcy4KICAgICAgICB2YXIgY3VycmVudEJhdGNoID0gdGhpcy5fcGVuZGluZ0NoYW5nZXNbMF0uYmF0Y2g7CiAgICAgICAgdGhpcy5fY3VycmVudFdyaXRlciA9IG5ldyBXcml0ZXIodGhpcywgY3VycmVudEJhdGNoKTsgLy8gRXhlY3V0ZSBjaGFuZ2VzIGNhbGxiYWNrIGFuZCBnYXRoZXIgdGhlIHJldHVybmVkIHZhbHVlLgoKICAgICAgICB2YXIgY2FsbGJhY2tSZXR1cm5WYWx1ZSA9IHRoaXMuX3BlbmRpbmdDaGFuZ2VzWzBdLmNhbGxiYWNrKHRoaXMuX2N1cnJlbnRXcml0ZXIpOwoKICAgICAgICByZXQucHVzaChjYWxsYmFja1JldHVyblZhbHVlKTsKCiAgICAgICAgdGhpcy5kb2N1bWVudC5faGFuZGxlQ2hhbmdlQmxvY2sodGhpcy5fY3VycmVudFdyaXRlcik7CgogICAgICAgIHRoaXMuX3BlbmRpbmdDaGFuZ2VzLnNoaWZ0KCk7CgogICAgICAgIHRoaXMuX2N1cnJlbnRXcml0ZXIgPSBudWxsOwogICAgICB9CgogICAgICB0aGlzLmZpcmUoJ19hZnRlckNoYW5nZXMnKTsKICAgICAgcmV0dXJuIHJldDsKICAgIH0KICAgIC8qKgogICAgICogRmlyZWQgd2hlbiBlbnRlcmluZyB0aGUgb3V0ZXJtb3N0IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2VucXVldWVDaGFuZ2V9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjaGFuZ2V9IGJsb2NrLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBldmVudCBfYmVmb3JlQ2hhbmdlcwogICAgICovCgogICAgLyoqCiAgICAgKiBGaXJlZCB3aGVuIGxlYXZpbmcgdGhlIG91dGVybW9zdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNlbnF1ZXVlQ2hhbmdlfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlfSBibG9jay4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAZXZlbnQgX2FmdGVyQ2hhbmdlcwogICAgICovCgogICAgLyoqCiAgICAgKiBGaXJlZCBldmVyeSB0aW1lIGFueSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbiBvcGVyYXRpb259IGlzIGFwcGxpZWQgb24gdGhlIG1vZGVsCiAgICAgKiB1c2luZyB7QGxpbmsgI2FwcGx5T3BlcmF0aW9ufS4KICAgICAqCiAgICAgKiBOb3RlIHRoYXQgdGhpcyBldmVudCBpcyBzdWl0YWJsZSBvbmx5IGZvciB2ZXJ5IHNwZWNpZmljIHVzZS1jYXNlcy4gVXNlIGl0IGlmIHlvdSBuZWVkIHRvIGxpc3RlbiB0byBldmVyeSBzaW5nbGUgb3BlcmF0aW9uCiAgICAgKiBhcHBsaWVkIG9uIHRoZSBkb2N1bWVudC4gSG93ZXZlciwgaW4gbW9zdCBjYXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpjaGFuZ2V9IHNob3VsZAogICAgICogYmUgdXNlZC4KICAgICAqCiAgICAgKiBBIGZldyBjYWxsYmFja3MgYXJlIGFscmVhZHkgYWRkZWQgdG8gdGhpcyBldmVudCBieSBlbmdpbmUgaW50ZXJuYWwgY2xhc3NlczoKICAgICAqCiAgICAgKiAqIHdpdGggYGhpZ2hlc3RgIHByaW9yaXR5IG9wZXJhdGlvbiBpcyB2YWxpZGF0ZWQsCiAgICAgKiAqIHdpdGggYG5vcm1hbGAgcHJpb3JpdHkgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkLAogICAgICogKiB3aXRoIGBsb3dgIHByaW9yaXR5IHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0gdXBkYXRlcyBpdHMgdmVyc2lvbiwKICAgICAqICogd2l0aCBgbG93YCBwcmlvcml0eSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9saXZlcG9zaXRpb25+TGl2ZVBvc2l0aW9ufSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXJhbmdlfkxpdmVSYW5nZX0KICAgICAqIHVwZGF0ZSB0aGVtc2VsdmVzLgogICAgICoKICAgICAqIEBldmVudCBhcHBseU9wZXJhdGlvbgogICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBcmd1bWVudHMgb2YgdGhlIGBhcHBseU9wZXJhdGlvbmAgd2hpY2ggaXMgYW4gYXJyYXkgd2l0aCBhIHNpbmdsZSBlbGVtZW50IC0gYXBwbGllZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9ufS4KICAgICAqLwoKICAgIC8qKgogICAgICogRXZlbnQgZmlyZWQgd2hlbiB7QGxpbmsgI2luc2VydENvbnRlbnR9IG1ldGhvZCBpcyBjYWxsZWQuCiAgICAgKgogICAgICogVGhlIHtAbGluayAjaW5zZXJ0Q29udGVudCBkZWZhdWx0IGFjdGlvbiBvZiB0aGF0IG1ldGhvZH0gaXMgaW1wbGVtZW50ZWQgYXMgYQogICAgICogbGlzdGVuZXIgdG8gdGhpcyBldmVudCBzbyBpdCBjYW4gYmUgZnVsbHkgY3VzdG9taXplZCBieSB0aGUgZmVhdHVyZXMuCiAgICAgKgogICAgICogKipOb3RlKiogVGhlIGBzZWxlY3RhYmxlYCBwYXJhbWV0ZXIgZm9yIHRoZSB7QGxpbmsgI2luc2VydENvbnRlbnR9IGlzIG9wdGlvbmFsLiBXaGVuIGB1bmRlZmluZWRgIHZhbHVlIGlzIHBhc3NlZCB0aGUgbWV0aG9kIHVzZXMKICAgICAqIGBtb2RlbC5kb2N1bWVudC5zZWxlY3Rpb25gLgogICAgICoKICAgICAqIEBldmVudCBpbnNlcnRDb250ZW50CiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEV2ZW50IGZpcmVkIHdoZW4ge0BsaW5rICNkZWxldGVDb250ZW50fSBtZXRob2QgaXMgY2FsbGVkLgogICAgICoKICAgICAqIFRoZSB7QGxpbmsgI2RlbGV0ZUNvbnRlbnQgZGVmYXVsdCBhY3Rpb24gb2YgdGhhdCBtZXRob2R9IGlzIGltcGxlbWVudGVkIGFzIGEKICAgICAqIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgc28gaXQgY2FuIGJlIGZ1bGx5IGN1c3RvbWl6ZWQgYnkgdGhlIGZlYXR1cmVzLgogICAgICoKICAgICAqIEBldmVudCBkZWxldGVDb250ZW50CiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEV2ZW50IGZpcmVkIHdoZW4ge0BsaW5rICNtb2RpZnlTZWxlY3Rpb259IG1ldGhvZCBpcyBjYWxsZWQuCiAgICAgKgogICAgICogVGhlIHtAbGluayAjbW9kaWZ5U2VsZWN0aW9uIGRlZmF1bHQgYWN0aW9uIG9mIHRoYXQgbWV0aG9kfSBpcyBpbXBsZW1lbnRlZCBhcyBhCiAgICAgKiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHNvIGl0IGNhbiBiZSBmdWxseSBjdXN0b21pemVkIGJ5IHRoZSBmZWF0dXJlcy4KICAgICAqCiAgICAgKiBAZXZlbnQgbW9kaWZ5U2VsZWN0aW9uCiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEV2ZW50IGZpcmVkIHdoZW4ge0BsaW5rICNnZXRTZWxlY3RlZENvbnRlbnR9IG1ldGhvZCBpcyBjYWxsZWQuCiAgICAgKgogICAgICogVGhlIHtAbGluayAjZ2V0U2VsZWN0ZWRDb250ZW50IGRlZmF1bHQgYWN0aW9uIG9mIHRoYXQgbWV0aG9kfSBpcyBpbXBsZW1lbnRlZCBhcyBhCiAgICAgKiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHNvIGl0IGNhbiBiZSBmdWxseSBjdXN0b21pemVkIGJ5IHRoZSBmZWF0dXJlcy4KICAgICAqCiAgICAgKiBAZXZlbnQgZ2V0U2VsZWN0ZWRDb250ZW50CiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QuCiAgICAgKi8KCiAgfV0pOwoKICByZXR1cm4gTW9kZWw7Cn0oKTsKCmV4cG9ydCB7IE1vZGVsIGFzIGRlZmF1bHQgfTsKbWl4KE1vZGVsLCBPYnNlcnZhYmxlTWl4aW4pOw=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js"],"names":["Batch","Writer","Schema","Document","MarkerCollection","ObservableMixin","mix","ModelElement","ModelRange","ModelPosition","ModelSelection","OperationFactory","insertContent","deleteContent","modifySelection","getSelectedContent","injectSelectionPostFixer","autoParagraphEmptyRoots","CKEditorError","Model","markers","document","schema","_pendingChanges","_currentWriter","forEach","methodName","decorate","on","evt","args","operation","_validate","priority","register","isLimit","allowIn","isBlock","isInline","isContent","allowContentOf","extend","addChildCheck","context","childDefinition","name","registerPostFixer","callback","length","push","batch","_runPendingChanges","err","rethrowUnexpectedError","batchOrType","_execute","content","selectable","placeOrOffset","selection","options","rangeOrElement","range","_createIn","isCollapsed","ignoreWhitespaces","ignoreMarkers","getMarkersIntersectingRange","intersectingMarker","affectsData","getItems","item","is","data","search","root","path","stickiness","itemOrPosition","offset","_createAt","_createAfter","_createBefore","start","end","element","_createOn","type","json","fromJSON","destroy","stopListening","ret","fire","currentBatch","callbackReturnValue","_handleChangeBlock","shift"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,KAAP,MAAkB,SAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,eAAP,MAA4B,+CAA5B;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,OAAOC,YAAP,MAAyB,WAAzB;AACA,OAAOC,UAAP,MAAuB,SAAvB;AACA,OAAOC,aAAP,MAA0B,YAA1B;AACA,OAAOC,cAAP,MAA2B,aAA3B;AACA,OAAOC,gBAAP,MAA6B,8BAA7B;AAEA,OAAOC,cAAP,MAA0B,uBAA1B;AACA,OAAOC,cAAP,MAA0B,uBAA1B;AACA,OAAOC,gBAAP,MAA4B,yBAA5B;AACA,OAAOC,mBAAP,MAA+B,4BAA/B;AACA,SAASC,wBAAT,QAAyC,8BAAzC;AACA,SAASC,uBAAT,QAAwC,0BAAxC;AACA,OAAOC,aAAP,MAA0B,6CAA1B,C,CAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;IACqBC,K;AACpB,mBAAc;AAAA;;AAAA;;AACb;AACF;AACA;AACA;AACA;AACA;AACE,SAAKC,OAAL,GAAe,IAAIhB,gBAAJ,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKiB,QAAL,GAAgB,IAAIlB,QAAJ,CAAc,IAAd,CAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKmB,MAAL,GAAc,IAAIpB,MAAJ,EAAd;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKqB,eAAL,GAAuB,EAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,cAAL,GAAsB,IAAtB;AAEA,KAAE,eAAF,EAAmB,eAAnB,EAAoC,iBAApC,EAAuD,oBAAvD,EAA6E,gBAA7E,EACEC,OADF,CACW,UAAAC,UAAU;AAAA,aAAI,KAAI,CAACC,QAAL,CAAeD,UAAf,CAAJ;AAAA,KADrB,EA1Ca,CA6Cb;AACA;;AACA,SAAKE,EAAL,CAAS,gBAAT,EAA2B,UAAEC,GAAF,EAAOC,IAAP,EAAiB;AAC3C,UAAMC,SAAS,GAAGD,IAAI,CAAE,CAAF,CAAtB;;AAEAC,MAAAA,SAAS,CAACC,SAAV;AACA,KAJD,EAIG;AAAEC,MAAAA,QAAQ,EAAE;AAAZ,KAJH,EA/Ca,CAqDb;;AACA,SAAKX,MAAL,CAAYY,QAAZ,CAAsB,OAAtB,EAA+B;AAC9BC,MAAAA,OAAO,EAAE;AADqB,KAA/B;AAIA,SAAKb,MAAL,CAAYY,QAAZ,CAAsB,QAAtB,EAAgC;AAC/BE,MAAAA,OAAO,EAAE,OADsB;AAE/BC,MAAAA,OAAO,EAAE;AAFsB,KAAhC;AAKA,SAAKf,MAAL,CAAYY,QAAZ,CAAsB,OAAtB,EAA+B;AAC9BE,MAAAA,OAAO,EAAE,QADqB;AAE9BE,MAAAA,QAAQ,EAAE,IAFoB;AAG9BC,MAAAA,SAAS,EAAE;AAHmB,KAA/B;AAMA,SAAKjB,MAAL,CAAYY,QAAZ,CAAsB,kBAAtB,EAA0C;AACzCM,MAAAA,cAAc,EAAE,OADyB;AAEzCL,MAAAA,OAAO,EAAE;AAFgC,KAA1C;AAIA,SAAKb,MAAL,CAAYmB,MAAZ,CAAoB,OAApB,EAA6B;AAAEL,MAAAA,OAAO,EAAE;AAAX,KAA7B;AAEA,SAAKd,MAAL,CAAYY,QAAZ,CAAsB,mBAAtB,EAA2C;AAC1CM,MAAAA,cAAc,EAAE,OAD0B;AAE1CL,MAAAA,OAAO,EAAE;AAFiC,KAA3C;AAIA,SAAKb,MAAL,CAAYmB,MAAZ,CAAoB,OAApB,EAA6B;AAAEL,MAAAA,OAAO,EAAE;AAAX,KAA7B,EA/Ea,CAiFb;AACA;AACA;AACA;;AACA,SAAKd,MAAL,CAAYY,QAAZ,CAAsB,SAAtB;AACA,SAAKZ,MAAL,CAAYoB,aAAZ,CAA2B,UAAEC,OAAF,EAAWC,eAAX,EAAgC;AAC1D,UAAKA,eAAe,CAACC,IAAhB,KAAyB,SAA9B,EAA0C;AACzC,eAAO,IAAP;AACA;AACD,KAJD;AAMA7B,IAAAA,wBAAwB,CAAE,IAAF,CAAxB,CA5Fa,CA8Fb;;AACA,SAAKK,QAAL,CAAcyB,iBAAd,CAAiC7B,uBAAjC,EA/Fa,CAiGb;AACA;AACA;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACC,gBAAQ8B,QAAR,EAAmB;AAClB,UAAI;AACH,YAAK,KAAKxB,eAAL,CAAqByB,MAArB,KAAgC,CAArC,EAAyC;AACxC;AACA,eAAKzB,eAAL,CAAqB0B,IAArB,CAA2B;AAAEC,YAAAA,KAAK,EAAE,IAAIlD,KAAJ,EAAT;AAAsB+C,YAAAA,QAAQ,EAARA;AAAtB,WAA3B;;AAEA,iBAAO,KAAKI,kBAAL,GAA2B,CAA3B,CAAP;AACA,SALD,MAKO;AACN;AACA,iBAAOJ,QAAQ,CAAE,KAAKvB,cAAP,CAAf;AACA;AACD,OAVD,CAUE,OAAQ4B,GAAR,EAAc;AACf;;AACA;AACAlC,QAAAA,aAAa,CAACmC,sBAAd,CAAsCD,GAAtC,EAA2C,IAA3C;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeE,WAAf,EAA4BP,QAA5B,EAAuC;AACtC,UAAI;AACH,YAAK,OAAOO,WAAP,KAAuB,QAA5B,EAAuC;AACtCA,UAAAA,WAAW,GAAG,IAAItD,KAAJ,CAAWsD,WAAX,CAAd;AACA,SAFD,MAEO,IAAK,OAAOA,WAAP,IAAsB,UAA3B,EAAwC;AAC9CP,UAAAA,QAAQ,GAAGO,WAAX;AACAA,UAAAA,WAAW,GAAG,IAAItD,KAAJ,EAAd;AACA;;AAED,aAAKuB,eAAL,CAAqB0B,IAArB,CAA2B;AAAEC,UAAAA,KAAK,EAAEI,WAAT;AAAsBP,UAAAA,QAAQ,EAARA;AAAtB,SAA3B;;AAEA,YAAK,KAAKxB,eAAL,CAAqByB,MAArB,IAA+B,CAApC,EAAwC;AACvC,eAAKG,kBAAL;AACA;AACD,OAbD,CAaE,OAAQC,GAAR,EAAc;AACf;;AACA;AACAlC,QAAAA,aAAa,CAACmC,sBAAd,CAAsCD,GAAtC,EAA2C,IAA3C;AACA;AACD;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,wBAAgBrB,SAAhB,EAA4B;AAC3B;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEAA,MAAAA,SAAS,CAACwB,QAAV;AACA,K,CAED;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeC,OAAf,EAAwBC,UAAxB,EAAoCC,aAApC,EAAoD;AACnD,aAAO9C,cAAa,CAAE,IAAF,EAAQ4C,OAAR,EAAiBC,UAAjB,EAA6BC,aAA7B,CAApB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeC,SAAf,EAA0BC,OAA1B,EAAoC;AACnC/C,MAAAA,cAAa,CAAE,IAAF,EAAQ8C,SAAR,EAAmBC,OAAnB,CAAb;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAiBD,SAAjB,EAA4BC,OAA5B,EAAsC;AACrC9C,MAAAA,gBAAe,CAAE,IAAF,EAAQ6C,SAAR,EAAmBC,OAAnB,CAAf;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,4BAAoBD,SAApB,EAAgC;AAC/B,aAAO5C,mBAAkB,CAAE,IAAF,EAAQ4C,SAAR,CAAzB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,oBAAYE,cAAZ,EAA2C;AAAA,UAAfD,OAAe,uEAAL,EAAK;AAC1C,UAAME,KAAK,GAAGD,cAAc,YAAYtD,YAA1B,GAAyCC,UAAU,CAACuD,SAAX,CAAsBF,cAAtB,CAAzC,GAAkFA,cAAhG;;AAEA,UAAKC,KAAK,CAACE,WAAX,EAAyB;AACxB,eAAO,KAAP;AACA;;AALyC,kCAOmBJ,OAPnB,CAOlCK,iBAPkC;AAAA,UAOlCA,iBAPkC,sCAOd,KAPc;AAAA,kCAOmBL,OAPnB,CAOPM,aAPO;AAAA,UAOPA,aAPO,sCAOS,KAPT,0BAS1C;;AACA,UAAK,CAACA,aAAN,EAAsB;AAAA,mDACa,KAAK9C,OAAL,CAAa+C,2BAAb,CAA0CL,KAA1C,CADb;AAAA;;AAAA;AACrB,8DAAsF;AAAA,gBAA1EM,kBAA0E;;AACrF,gBAAKA,kBAAkB,CAACC,WAAxB,EAAsC;AACrC,qBAAO,IAAP;AACA;AACD;AALoB;AAAA;AAAA;AAAA;AAAA;AAMrB;;AAhByC,kDAkBtBP,KAAK,CAACQ,QAAN,EAlBsB;AAAA;;AAAA;AAkB1C,+DAAuC;AAAA,cAA3BC,IAA2B;;AACtC,cAAK,KAAKjD,MAAL,CAAYiB,SAAZ,CAAuBgC,IAAvB,CAAL,EAAqC;AACpC,gBAAKA,IAAI,CAACC,EAAL,CAAS,YAAT,CAAL,EAA+B;AAC9B,kBAAK,CAACP,iBAAN,EAA0B;AACzB,uBAAO,IAAP;AACA,eAFD,MAEO,IAAKM,IAAI,CAACE,IAAL,CAAUC,MAAV,CAAkB,IAAlB,MAA6B,CAAC,CAAnC,EAAuC;AAC7C,uBAAO,IAAP;AACA;AACD,aAND,MAMO;AACN,qBAAO,IAAP;AACA;AACD;AACD;AA9ByC;AAAA;AAAA;AAAA;AAAA;;AAgC1C,aAAO,KAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,gCAAwBC,IAAxB,EAA8BC,IAA9B,EAAoCC,UAApC,EAAiD;AAChD,aAAO,IAAIpE,aAAJ,CAAmBkE,IAAnB,EAAyBC,IAAzB,EAA+BC,UAA/B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,0BAAkBC,cAAlB,EAAkCC,MAAlC,EAA2C;AAC1C,aAAOtE,aAAa,CAACuE,SAAd,CAAyBF,cAAzB,EAAyCC,MAAzC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,6BAAqBR,IAArB,EAA4B;AAC3B,aAAO9D,aAAa,CAACwE,YAAd,CAA4BV,IAA5B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,8BAAsBA,IAAtB,EAA6B;AAC5B,aAAO9D,aAAa,CAACyE,aAAd,CAA6BX,IAA7B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,qBAAaY,KAAb,EAAoBC,GAApB,EAA0B;AACzB,aAAO,IAAI5E,UAAJ,CAAgB2E,KAAhB,EAAuBC,GAAvB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAeC,OAAf,EAAyB;AACxB,aAAO7E,UAAU,CAACuD,SAAX,CAAsBsB,OAAtB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,uBAAed,IAAf,EAAsB;AACrB,aAAO/D,UAAU,CAAC8E,SAAX,CAAsBf,IAAtB,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAiBd,UAAjB,EAA6BC,aAA7B,EAA4CE,OAA5C,EAAsD;AACrD,aAAO,IAAIlD,cAAJ,CAAoB+C,UAApB,EAAgCC,aAAhC,EAA+CE,OAA/C,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,qBAAa2B,IAAb,EAAoB;AACnB,aAAO,IAAIvF,KAAJ,CAAWuF,IAAX,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,iCAAyBC,IAAzB,EAAgC;AAC/B,aAAO7E,gBAAgB,CAAC8E,QAAjB,CAA2BD,IAA3B,EAAiC,KAAKnE,QAAtC,CAAP;AACA;AAED;AACD;AACA;;;;WACC,mBAAU;AACT,WAAKA,QAAL,CAAcqE,OAAd;AACA,WAAKC,aAAL;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;;WACC,8BAAqB;AACpB,UAAMC,GAAG,GAAG,EAAZ;AAEA,WAAKC,IAAL,CAAW,gBAAX;;AAEA,aAAQ,KAAKtE,eAAL,CAAqByB,MAA7B,EAAsC;AACrC;AACA,YAAM8C,YAAY,GAAG,KAAKvE,eAAL,CAAsB,CAAtB,EAA0B2B,KAA/C;AACA,aAAK1B,cAAL,GAAsB,IAAIvB,MAAJ,CAAY,IAAZ,EAAkB6F,YAAlB,CAAtB,CAHqC,CAKrC;;AACA,YAAMC,mBAAmB,GAAG,KAAKxE,eAAL,CAAsB,CAAtB,EAA0BwB,QAA1B,CAAoC,KAAKvB,cAAzC,CAA5B;;AACAoE,QAAAA,GAAG,CAAC3C,IAAJ,CAAU8C,mBAAV;;AAEA,aAAK1E,QAAL,CAAc2E,kBAAd,CAAkC,KAAKxE,cAAvC;;AAEA,aAAKD,eAAL,CAAqB0E,KAArB;;AACA,aAAKzE,cAAL,GAAsB,IAAtB;AACA;;AAED,WAAKqE,IAAL,CAAW,eAAX;AAEA,aAAOD,GAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;SA33BqBzE,K;AA83BrBb,GAAG,CAAEa,KAAF,EAASd,eAAT,CAAH","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/model\n */\n\nimport Batch from './batch';\nimport Writer from './writer';\nimport Schema from './schema';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ModelElement from './element';\nimport ModelRange from './range';\nimport ModelPosition from './position';\nimport ModelSelection from './selection';\nimport OperationFactory from './operation/operationfactory';\n\nimport insertContent from './utils/insertcontent';\nimport deleteContent from './utils/deletecontent';\nimport modifySelection from './utils/modifyselection';\nimport getSelectedContent from './utils/getselectedcontent';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\nimport { autoParagraphEmptyRoots } from './utils/autoparagraphing';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n// @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );\n// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;\n\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Model {\n\tconstructor() {\n\t\t/**\n\t\t * Model's marker collection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis.markers = new MarkerCollection();\n\n\t\t/**\n\t\t * Model's document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/document~Document}\n\t\t */\n\t\tthis.document = new Document( this );\n\n\t\t/**\n\t\t * Model's schema.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/schema~Schema}\n\t\t */\n\t\tthis.schema = new Schema();\n\n\t\t/**\n\t\t * All callbacks added by {@link module:engine/model/model~Model#change} or\n\t\t * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Function>}\n\t\t */\n\t\tthis._pendingChanges = [];\n\n\t\t/**\n\t\t * The last created and currently used writer instance.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/writer~Writer}\n\t\t */\n\t\tthis._currentWriter = null;\n\n\t\t[ 'insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation' ]\n\t\t\t.forEach( methodName => this.decorate( methodName ) );\n\n\t\t// Adding operation validation with `highest` priority, so it is called before any other feature would like\n\t\t// to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n\t\tthis.on( 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\toperation._validate();\n\t\t}, { priority: 'highest' } );\n\n\t\t// Register some default abstract entities.\n\t\tthis.schema.register( '$root', {\n\t\t\tisLimit: true\n\t\t} );\n\n\t\tthis.schema.register( '$block', {\n\t\t\tallowIn: '$root',\n\t\t\tisBlock: true\n\t\t} );\n\n\t\tthis.schema.register( '$text', {\n\t\t\tallowIn: '$block',\n\t\t\tisInline: true,\n\t\t\tisContent: true\n\t\t} );\n\n\t\tthis.schema.register( '$clipboardHolder', {\n\t\t\tallowContentOf: '$root',\n\t\t\tisLimit: true\n\t\t} );\n\t\tthis.schema.extend( '$text', { allowIn: '$clipboardHolder' } );\n\n\t\tthis.schema.register( '$documentFragment', {\n\t\t\tallowContentOf: '$root',\n\t\t\tisLimit: true\n\t\t} );\n\t\tthis.schema.extend( '$text', { allowIn: '$documentFragment' } );\n\n\t\t// An element needed by the `upcastElementToMarker` converter.\n\t\t// This element temporarily represents a marker boundary during the conversion process and is removed\n\t\t// at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n\t\t// better place for this registration but both know nothing about `Schema`.\n\t\tthis.schema.register( '$marker' );\n\t\tthis.schema.addChildCheck( ( context, childDefinition ) => {\n\t\t\tif ( childDefinition.name === '$marker' ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\t\tinjectSelectionPostFixer( this );\n\n\t\t// Post-fixer which takes care of adding empty paragraph elements to the empty roots.\n\t\tthis.document.registerPostFixer( autoParagraphEmptyRoots );\n\n\t\t// @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {\n\t\t// @if CK_DEBUG_ENGINE // \tdumpTrees( this.document, this.document.version );\n\t\t// @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n\t * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n\t * the {@link module:engine/model/document~Document#selection document's selection}, and\n\t * {@link module:engine/model/model~Model#markers model markers}.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n\t * into a single undo step.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n\t *\n\t *\t\t\tmodel.change( writer => {\n\t *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n\t *\t\t\t} );\n\t *\n\t * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n\t *\t\t} );\n\t *\n\t * The callback of the `change()` block is executed synchronously.\n\t *\n\t * You can also return a value from the change block.\n\t *\n\t *\t\tconst img = model.change( writer => {\n\t *\t\t\treturn writer.createElement( 'img' );\n\t *\t\t} );\n\t *\n\t * @see #enqueueChange\n\t * @param {Function} callback Callback function which may modify the model.\n\t * @returns {*} Value returned by the callback.\n\t */\n\tchange( callback ) {\n\t\ttry {\n\t\t\tif ( this._pendingChanges.length === 0 ) {\n\t\t\t\t// If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n\t\t\t\tthis._pendingChanges.push( { batch: new Batch(), callback } );\n\n\t\t\t\treturn this._runPendingChanges()[ 0 ];\n\t\t\t} else {\n\t\t\t\t// If this is not the outermost block, just execute the callback.\n\t\t\t\treturn callback( this._currentWriter );\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t}\n\n\t/**\n\t * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n\t *\n\t * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n\t * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n\t * it will be delayed and executed after the outermost block.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconsole.log( 1 );\n\t *\n\t *\t\t\tmodel.enqueueChange( writer => {\n\t *\t\t\t\tconsole.log( 2 );\n\t *\t\t\t} );\n\t *\n\t * \t\t\tconsole.log( 3 );\n\t *\t\t} ); // Will log: 1, 3, 2.\n\t *\n\t * In addition to that, the changes enqueued with `enqueueChange()` will be converted separately from the changes\n\t * done in the outer `change()` block.\n\t *\n\t * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n\t * By default, a new batch is created. In the sample above, `change` and `enqueueChange` blocks use a different\n\t * batch (and different {@link module:engine/model/writer~Writer} since each of them operates on the separate batch).\n\t *\n\t * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n\t *\n\t *\t\tmodel.enqueueChange( batch, writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * In order to make a nested `enqueueChange()` create a single undo step together with the changes done in the outer `change()`\n\t * block, you can obtain the batch instance from the  {@link module:engine/model/writer~Writer#batch writer} of the outer block.\n\t *\n\t * @param {module:engine/model/batch~Batch|'transparent'|'default'} batchOrType Batch or batch type should be used in the callback.\n\t * If not defined, a new batch will be created.\n\t * @param {Function} callback Callback function which may modify the model.\n\t */\n\tenqueueChange( batchOrType, callback ) {\n\t\ttry {\n\t\t\tif ( typeof batchOrType === 'string' ) {\n\t\t\t\tbatchOrType = new Batch( batchOrType );\n\t\t\t} else if ( typeof batchOrType == 'function' ) {\n\t\t\t\tcallback = batchOrType;\n\t\t\t\tbatchOrType = new Batch();\n\t\t\t}\n\n\t\t\tthis._pendingChanges.push( { batch: batchOrType, callback } );\n\n\t\t\tif ( this._pendingChanges.length == 1 ) {\n\t\t\t\tthis._runPendingChanges();\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t}\n\n\t/**\n\t * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n\t * {@link module:engine/model/operation/operation~Operation operations} to the model.\n\t *\n\t * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n\t * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n\t * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n\t * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n\t */\n\tapplyOperation( operation ) {\n\t\t// @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );\n\n\t\t// @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {\n\t\t// @if CK_DEBUG_ENGINE //\tthis._operationLogs = [];\n\t\t// @if CK_DEBUG_ENGINE // }\n\n\t\t// @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );\n\n\t\t// @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {\n\t\t// @if CK_DEBUG_ENGINE //\tthis._appliedOperations = [];\n\t\t// @if CK_DEBUG_ENGINE //}\n\n\t\t// @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );\n\n\t\toperation._execute();\n\t}\n\n\t// @if CK_DEBUG_ENGINE // getAppliedOperation() {\n\t// @if CK_DEBUG_ENGINE //\tif ( !this._appliedOperations ) {\n\t// @if CK_DEBUG_ENGINE //\t\treturn '';\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\treturn this._appliedOperations.map( JSON.stringify ).join( '-------' );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {\n\t// @if CK_DEBUG_ENGINE //\treturn new OperationReplayer( this, '-------', stringifiedOperations );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t/**\n\t * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n\t * functionality to work.\n\t *\n\t * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n\t * the content, clears the given selection's content before inserting nodes and moves the selection\n\t * to its target position at the end of the process.\n\t * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n\t * pasting feature should do.\n\t *\n\t * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n\t *\n\t * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n\t * inside a {@link #change `change()` block}.\n\t *\n\t * # Conversion and schema\n\t *\n\t * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n\t * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n\t * is only adding nodes to the model. Additionally, you need to define\n\t * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n\t * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n\t *\n\t * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n\t * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n\t * unless converters are defined for all elements and attributes in that HTML.\n\t *\n\t * # Examples\n\t *\n\t * Using `insertContent()` with a manually created model structure:\n\t *\n\t *\t\t// Let's create a document fragment containing such content as:\n\t *\t\t//\n\t *\t\t// <paragraph>foo</paragraph>\n\t *\t\t// <blockQuote>\n\t *\t\t//    <paragraph>bar</paragraph>\n\t *\t\t// </blockQuote>\n\t *\t\tconst docFrag = editor.model.change( writer => {\n\t *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n\t *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n\t *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n\t *\t\t\tconst docFrag = writer.createDocumentFragment();\n\t *\n\t *\t\t\twriter.append( p1, docFrag );\n\t *\t\t\twriter.append( blockQuote, docFrag );\n\t *\t\t\twriter.append( p2, blockQuote );\n\t *\t\t\twriter.insertText( 'foo', p1 );\n\t *\t\t\twriter.insertText( 'bar', p2 );\n\t *\n\t *\t\t\treturn docFrag;\n\t *\t\t} );\n\t *\n\t *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n\t *\t\t// so this code could be moved to the callback defined above.\n\t *\t\teditor.model.insertContent( docFrag );\n\t *\n\t * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n\t *\n\t *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n\t *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n\t *\t\tconst htmlDP = new HtmlDataProcessor( viewDocument );\n\t *\n\t *\t\t// Convert an HTML string to a view document fragment:\n\t *\t\tconst viewFragment = htmlDP.toView( htmlString );\n\t *\n\t *\t\t// Convert the view document fragment to a model document fragment\n\t *\t\t// in the context of $root. This conversion takes the schema into\n\t *\t\t// account so if, for example, the view document fragment contained a bare text node,\n\t *\t\t// this text node cannot be a child of $root, so it will be automatically\n\t *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n\t *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n\t *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n\t *\t\t// which has a loosened schema.\n\t *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n\t *\n\t *\t\teditor.model.insertContent( modelFragment );\n\t *\n\t * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n\t *\n\t *\t\t// Insert text at the current document selection position.\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n\t *\t\t} );\n\t *\n\t *\t\t// Insert text at a given position - the document selection will not be modified.\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n\t *\n\t *\t\t\t// Which is a shorthand for:\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n\t *\t\t} );\n\t *\n\t * If you want the document selection to be moved to the inserted content, use the\n\t * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting\n\t * the content:\n\t *\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\n\t *\t\t\t// Insert an empty paragraph at the beginning of the root.\n\t *\t\t\teditor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );\n\t *\n\t *\t\t\t// Move the document selection to the inserted paragraph.\n\t *\t\t\twriter.setSelection( paragraph, 'in' );\n\t *\t\t} );\n\t *\n\t * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,\n\t * the new content will be inserted at the passed selection (instead of document selection):\n\t *\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\t// Create a selection in a paragraph that will be used as a place of insertion.\n\t *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t\t// Insert the new text at the created selection.\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n\t *\n\t *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n\t *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n\t *\t\t\twriter.setSelection( selection );\n\t *\t\t} );\n\t *\n\t * @fires insertContent\n\t * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n\t * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n\t * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n\t * This param defines a position in relation to that item.\n\t * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n\t * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n\t * at the insertion position.\n\t */\n\tinsertContent( content, selectable, placeOrOffset ) {\n\t\treturn insertContent( this, content, selectable, placeOrOffset );\n\t}\n\n\t/**\n\t * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n\t *\n\t * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n\t * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n\t * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n\t * then that behavior should be implemented in the view's listener. At the same time, the table feature\n\t * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n\t * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n\t * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n\t *\n\t * @fires deleteContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection of which the content should be deleted.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n\t *\n\t * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n\t *\n\t * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n\t * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n\t *\n\t * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n\t * elements will not be merged.\n\t *\n\t * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n\t * paragraph when the entire content was selected.\n\t *\n\t * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n\t *\n\t * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n\t * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n\t *\n\t * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n\t * to a place where text cannot be inserted.\n\t *\n\t * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n\t *\n\t * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n\t * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n\t *\n\t * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n\t *\n\t * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n\t *\n\t * @param {'forward'|'backward'} [options.direction='backward'] The direction in which the content is being consumed.\n\t * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to\n\t * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.\n\t */\n\tdeleteContent( selection, options ) {\n\t\tdeleteContent( this, selection, options );\n\t}\n\n\t/**\n\t * Modifies the selection. Currently, the supported modifications are:\n\t *\n\t * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n\t * Possible values for `unit` are:\n\t *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n\t *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n\t *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n\t *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n\t *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n\t *  why `'character'` value is most natural and common method of modifying selection.\n\t *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n\t *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n\t *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n\t *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n\t *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n\t *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n\t *  extension will include whole \"surrogate pair\".\n\t *  * `'word'` - moves selection by a whole word.\n\t *\n\t * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n\t *\n\t * @fires modifySelection\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection to modify.\n\t * @param {Object} [options]\n\t * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n\t * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n\t */\n\tmodifySelection( selection, options ) {\n\t\tmodifySelection( this, selection, options );\n\t}\n\n\t/**\n\t * Gets a clone of the selected content.\n\t *\n\t * For example, for the following selection:\n\t *\n\t * ```html\n\t * <paragraph>x</paragraph>\n\t * <blockQuote>\n\t *\t<paragraph>y</paragraph>\n\t *\t<heading1>fir[st</heading1>\n\t * </blockQuote>\n\t * <paragraph>se]cond</paragraph>\n\t * <paragraph>z</paragraph>\n\t * ```\n\t *\n\t * It will return a document fragment with such a content:\n\t *\n\t * ```html\n\t * <blockQuote>\n\t *\t<heading1>st</heading1>\n\t * </blockQuote>\n\t * <paragraph>se</paragraph>\n\t * ```\n\t *\n\t * @fires getSelectedContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection of which content will be returned.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetSelectedContent( selection ) {\n\t\treturn getSelectedContent( this, selection );\n\t}\n\n\t/**\n\t * Checks whether the given {@link module:engine/model/range~Range range} or\n\t * {@link module:engine/model/element~Element element} has any meaningful content.\n\t *\n\t * Meaningful content is:\n\t *\n\t * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n\t * any non-whitespace characters),\n\t * * or any {@link module:engine/model/schema~Schema#isContent content element},\n\t * * or any {@link module:engine/model/markercollection~Marker marker} which\n\t * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n\t *\n\t * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n\t * However, a range containing an `<image></image>` (which would normally be marked in the schema as an object element)\n\t * is considered non-empty.\n\t *\n\t * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n\t * @param {Boolean} [options.ignoreMarkers] Whether markers should be ignored.\n\t * @returns {Boolean}\n\t */\n\thasContent( rangeOrElement, options = {} ) {\n\t\tconst range = rangeOrElement instanceof ModelElement ? ModelRange._createIn( rangeOrElement ) : rangeOrElement;\n\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { ignoreWhitespaces = false, ignoreMarkers = false } = options;\n\n\t\t// Check if there are any markers which affects data in this given range.\n\t\tif ( !ignoreMarkers ) {\n\t\t\tfor ( const intersectingMarker of this.markers.getMarkersIntersectingRange( range ) ) {\n\t\t\t\tif ( intersectingMarker.affectsData ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor ( const item of range.getItems() ) {\n\t\t\tif ( this.schema.isContent( item ) ) {\n\t\t\t\tif ( item.is( '$textProxy' ) ) {\n\t\t\t\t\tif ( !ignoreWhitespaces ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if ( item.data.search( /\\S/ ) !== -1 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Creates a position from the given root and path in that root.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionFromPath( root, path, stickiness ) {\n\t\treturn new ModelPosition( root, path, stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * a parent element and offset in that element,\n\t * * a parent element and `'end'` (the position will be set at the end of that element),\n\t * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n\t * (the position will be set before or after the given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n\t * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn ModelPosition._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn ModelPosition._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn ModelPosition._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from the `start` position to the `end` position.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRange( start, end );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n\t * to the `start` position.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new ModelRange( start, end );\n\t}\n\n\t/**\n\t * Creates a range inside the given element which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRangeIn( paragraph );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn ModelRange._createIn( element );\n\t}\n\n\t/**\n\t * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * Note: This method is also available on `writer` instance as\n\t * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRangeOn( paragraph );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn ModelRange._createOn( item );\n\t}\n\n\t/**\n\t * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n\t * or creates an empty selection if no arguments were passed.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n\t *\n\t *\t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\tconst selection = writer.createSelection( documentSelection );\n\t *\n\t *\t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates selection at the given offset in the given element.\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @returns {module:engine/model/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new ModelSelection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/batch~Batch} instance.\n\t *\n\t * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n\t *\n\t * * {@link #change `change()`},\n\t * * {@link #enqueueChange `enqueueChange()`}.\n\t *\n\t * @param {'transparent'|'default'} [type='default'] The type of the batch.\n\t * @returns {module:engine/model/batch~Batch}\n\t */\n\tcreateBatch( type ) {\n\t\treturn new Batch( type );\n\t}\n\n\t/**\n\t * Creates an operation instance from a JSON object (parsed JSON string).\n\t *\n\t * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @returns {module:engine/model/operation/operation~Operation}\n\t */\n\tcreateOperationFromJSON( json ) {\n\t\treturn OperationFactory.fromJSON( json, this.document );\n\t}\n\n\t/**\n\t * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n\t */\n\tdestroy() {\n\t\tthis.document.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n\t * which calls callbacks and returns array of values returned by these callbacks.\n\t *\n\t * @private\n\t * @returns {Array.<*>} Array of values returned by callbacks.\n\t */\n\t_runPendingChanges() {\n\t\tconst ret = [];\n\n\t\tthis.fire( '_beforeChanges' );\n\n\t\twhile ( this._pendingChanges.length ) {\n\t\t\t// Create a new writer using batch instance created for this chain of changes.\n\t\t\tconst currentBatch = this._pendingChanges[ 0 ].batch;\n\t\t\tthis._currentWriter = new Writer( this, currentBatch );\n\n\t\t\t// Execute changes callback and gather the returned value.\n\t\t\tconst callbackReturnValue = this._pendingChanges[ 0 ].callback( this._currentWriter );\n\t\t\tret.push( callbackReturnValue );\n\n\t\t\tthis.document._handleChangeBlock( this._currentWriter );\n\n\t\t\tthis._pendingChanges.shift();\n\t\t\tthis._currentWriter = null;\n\t\t}\n\n\t\tthis.fire( '_afterChanges' );\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Fired when entering the outermost {@link module:engine/model/model~Model#enqueueChange} or\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * @protected\n\t * @event _beforeChanges\n\t */\n\n\t/**\n\t * Fired when leaving the outermost {@link module:engine/model/model~Model#enqueueChange} or\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * @protected\n\t * @event _afterChanges\n\t */\n\n\t/**\n\t * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model\n\t * using {@link #applyOperation}.\n\t *\n\t * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation\n\t * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should\n\t * be used.\n\t *\n\t * A few callbacks are already added to this event by engine internal classes:\n\t *\n\t * * with `highest` priority operation is validated,\n\t * * with `normal` priority operation is executed,\n\t * * with `low` priority the {@link module:engine/model/document~Document} updates its version,\n\t * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}\n\t * update themselves.\n\t *\n\t * @event applyOperation\n\t * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied\n\t * {@link module:engine/model/operation/operation~Operation operation}.\n\t */\n\n\t/**\n\t * Event fired when {@link #insertContent} method is called.\n\t *\n\t * The {@link #insertContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * **Note** The `selectable` parameter for the {@link #insertContent} is optional. When `undefined` value is passed the method uses\n\t * `model.document.selection`.\n\t *\n\t * @event insertContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #deleteContent} method is called.\n\t *\n\t * The {@link #deleteContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event deleteContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #modifySelection} method is called.\n\t *\n\t * The {@link #modifySelection default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event modifySelection\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #getSelectedContent} method is called.\n\t *\n\t * The {@link #getSelectedContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event getSelectedContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n}\n\nmix( Model, ObservableMixin );\n"]}]}