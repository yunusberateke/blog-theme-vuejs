{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLnVybC50by1qc29uLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIxLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudAogKi8KaW1wb3J0IE5vZGVMaXN0IGZyb20gJy4vbm9kZWxpc3QnOwppbXBvcnQgRWxlbWVudCBmcm9tICcuL2VsZW1lbnQnOwppbXBvcnQgVGV4dCBmcm9tICcuL3RleHQnOwppbXBvcnQgVGV4dFByb3h5IGZyb20gJy4vdGV4dHByb3h5JzsKaW1wb3J0IGlzSXRlcmFibGUgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvaXNpdGVyYWJsZSc7IC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gY29uc3QgeyBzdHJpbmdpZnlNYXAgfSA9IHJlcXVpcmUoICcuLi9kZXYtdXRpbHMvdXRpbHMnICk7CgovKioKICogRG9jdW1lbnRGcmFnbWVudCByZXByZXNlbnRzIGEgcGFydCBvZiBtb2RlbCB3aGljaCBkb2VzIG5vdCBoYXZlIGEgY29tbW9uIHJvb3QgYnV0IGl0cyB0b3AtbGV2ZWwgbm9kZXMKICogY2FuIGJlIHNlZW4gYXMgc2libGluZ3MuIEluIG90aGVyIHdvcmRzLCBpdCBpcyBhIGRldGFjaGVkIHBhcnQgb2YgbW9kZWwgdHJlZSwgd2l0aG91dCBhIHJvb3QuCiAqCiAqIERvY3VtZW50RnJhZ21lbnQgaGFzIG93biB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlckNvbGxlY3Rpb259LiBNYXJrZXJzIGZyb20gdGhpcyBjb2xsZWN0aW9uCiAqIHdpbGwgYmUgc2V0IHRvIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNtYXJrZXJzIG1vZGVsIG1hcmtlcnN9IGJ5IGEKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNpbnNlcnR9IGZ1bmN0aW9uLgogKi8KCnZhciBEb2N1bWVudEZyYWdtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGFuIGVtcHR5IGBEb2N1bWVudEZyYWdtZW50YC4KICAgKgogICAqICoqTm90ZToqKiBDb25zdHJ1Y3RvciBvZiB0aGlzIGNsYXNzIHNob3VsZG4ndCBiZSB1c2VkIGRpcmVjdGx5IGluIHRoZSBjb2RlLgogICAqIFVzZSB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVEb2N1bWVudEZyYWdtZW50fSBtZXRob2QgaW5zdGVhZC4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfEl0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59IFtjaGlsZHJlbl0KICAgKiBOb2RlcyB0byBiZSBjb250YWluZWQgaW5zaWRlIHRoZSBgRG9jdW1lbnRGcmFnbWVudGAuCiAgICovCiAgZnVuY3Rpb24gRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvY3VtZW50RnJhZ21lbnQpOwoKICAgIC8qKgogICAgICogRG9jdW1lbnRGcmFnbWVudCBzdGF0aWMgbWFya2VycyBtYXAuIFRoaXMgaXMgYSBsaXN0IG9mIG5hbWVzIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZXN9CiAgICAgKiB3aGljaCB3aWxsIGJlIHNldCBhcyBNYXJrZXJzIHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI21hcmtlcnMgbW9kZWwgbWFya2VycyBjb2xsZWN0aW9ufQogICAgICogd2hlbiBEb2N1bWVudEZyYWdtZW50IHdpbGwgYmUgaW5zZXJ0ZWQgdG8gdGhlIGRvY3VtZW50LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7TWFwPFN0cmluZyxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQjbWFya2VycwogICAgICovCiAgICB0aGlzLm1hcmtlcnMgPSBuZXcgTWFwKCk7CiAgICAvKioKICAgICAqIExpc3Qgb2Ygbm9kZXMgY29udGFpbmVkIGluc2lkZSB0aGUgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZWxpc3R+Tm9kZUxpc3R9IG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50I19jaGlsZHJlbgogICAgICovCgogICAgdGhpcy5fY2hpbGRyZW4gPSBuZXcgTm9kZUxpc3QoKTsKCiAgICBpZiAoY2hpbGRyZW4pIHsKICAgICAgdGhpcy5faW5zZXJ0Q2hpbGQoMCwgY2hpbGRyZW4pOwogICAgfQogIH0KICAvKioKICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwgbm9kZXMgY29udGFpbmVkIGluc2lkZSB0aGlzIGRvY3VtZW50IGZyYWdtZW50LgogICAqCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoRG9jdW1lbnRGcmFnbWVudCwgW3sKICAgIGtleTogU3ltYm9sLml0ZXJhdG9yLAogICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkgewogICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpOwogICAgfQogICAgLyoqCiAgICAgKiBOdW1iZXIgb2YgdGhpcyBkb2N1bWVudCBmcmFnbWVudCdzIGNoaWxkcmVuLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge051bWJlcn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjaGlsZENvdW50IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOwogICAgfQogICAgLyoqCiAgICAgKiBTdW0gb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI29mZnNldFNpemUgb2Zmc2V0IHNpemVzfSBvZiBhbGwgb2YgdGhpcyBkb2N1bWVudCBmcmFnbWVudCdzIGNoaWxkcmVuLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge051bWJlcn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJtYXhPZmZzZXQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5tYXhPZmZzZXQ7CiAgICB9CiAgICAvKioKICAgICAqIElzIGB0cnVlYCBpZiB0aGVyZSBhcmUgbm8gbm9kZXMgaW5zaWRlIHRoaXMgZG9jdW1lbnQgZnJhZ21lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNFbXB0eSIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDb3VudCA9PT0gMDsKICAgIH0KICAgIC8qKgogICAgICogQXJ0aWZpY2lhbCByb290IG9mIGBEb2N1bWVudEZyYWdtZW50YC4gUmV0dXJucyBpdHNlbGYuIEFkZGVkIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnMuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicm9vdCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICAvKioKICAgICAqIEFydGlmaWNpYWwgcGFyZW50IG9mIGBEb2N1bWVudEZyYWdtZW50YC4gUmV0dXJucyBgbnVsbGAuIEFkZGVkIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnMuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJwYXJlbnQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIG9iamVjdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4KICAgICAqCiAgICAgKgkJZG9jRnJhZy5pcyggJ2RvY3VtZW50RnJhZ21lbnQnICk7IC8vIC0+IHRydWUKICAgICAqCQlkb2NGcmFnLmlzKCAnbW9kZWw6ZG9jdW1lbnRGcmFnbWVudCcgKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqCQlkb2NGcmFnLmlzKCAndmlldzpkb2N1bWVudEZyYWdtZW50JyApOyAvLyAtPiBmYWxzZQogICAgICoJCWRvY0ZyYWcuaXMoICdlbGVtZW50JyApOyAvLyAtPiBmYWxzZQogICAgICoJCWRvY0ZyYWcuaXMoICdub2RlJyApOyAvLyAtPiBmYWxzZQogICAgICoKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNpcyBDaGVjayB0aGUgZW50aXJlIGxpc3Qgb2YgbW9kZWwgb2JqZWN0c30gd2hpY2ggaW1wbGVtZW50IHRoZSBgaXMoKWAgbWV0aG9kLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXModHlwZSkgewogICAgICByZXR1cm4gdHlwZSA9PT0gJ2RvY3VtZW50RnJhZ21lbnQnIHx8IHR5cGUgPT09ICdtb2RlbDpkb2N1bWVudEZyYWdtZW50JzsKICAgIH0KICAgIC8qKgogICAgICogR2V0cyB0aGUgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4LiBSZXR1cm5zIGBudWxsYCBpZiBpbmNvcnJlY3QgaW5kZXggd2FzIHBhc3NlZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2YgY2hpbGQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8bnVsbH0gQ2hpbGQgbm9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDaGlsZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hpbGQoaW5kZXgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldE5vZGUoaW5kZXgpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwgb2YgdGhpcyBkb2N1bWVudCBmcmFnbWVudCdzIGNoaWxkcmVuLgogICAgICoKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENoaWxkcmVuIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZHJlbigpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBpbmRleCBvZiB0aGUgZ2l2ZW4gY2hpbGQgbm9kZS4gUmV0dXJucyBgbnVsbGAgaWYgZ2l2ZW4gbm9kZSBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IG5vZGUgQ2hpbGQgbm9kZSB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVsbH0gQ2hpbGQgbm9kZSdzIGluZGV4LgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENoaWxkSW5kZXgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkSW5kZXgobm9kZSkgewogICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZ2V0Tm9kZUluZGV4KG5vZGUpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydGluZyBvZmZzZXQgb2YgZ2l2ZW4gY2hpbGQuIFN0YXJ0aW5nIG9mZnNldCBpcyBlcXVhbCB0byB0aGUgc3VtIG9mCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjb2Zmc2V0U2l6ZSBvZmZzZXQgc2l6ZXN9IG9mIGFsbCBub2RlJ3Mgc2libGluZ3MgdGhhdCBhcmUgYmVmb3JlIGl0LiBSZXR1cm5zIGBudWxsYCBpZgogICAgICogZ2l2ZW4gbm9kZSBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IG5vZGUgQ2hpbGQgbm9kZSB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVsbH0gQ2hpbGQgbm9kZSdzIHN0YXJ0aW5nIG9mZnNldC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDaGlsZFN0YXJ0T2Zmc2V0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZFN0YXJ0T2Zmc2V0KG5vZGUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldE5vZGVTdGFydE9mZnNldChub2RlKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBwYXRoIHRvIGEgYERvY3VtZW50RnJhZ21lbnRgLCB3aGljaCBpcyBhbiBlbXB0eSBhcnJheS4gQWRkZWQgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXl9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0UGF0aCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aCgpIHsKICAgICAgcmV0dXJuIFtdOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgZGVzY2VuZGFudCBub2RlIGJ5IGl0cyBwYXRoIHJlbGF0aXZlIHRvIHRoaXMgZWxlbWVudC4KICAgICAqCiAgICAgKgkJLy8gPHRoaXM+YTxiPmM8L2I+PC90aGlzPgogICAgICoJCXRoaXMuZ2V0Tm9kZUJ5UGF0aCggWyAwIF0gKTsgICAgIC8vIC0+ICJhIgogICAgICoJCXRoaXMuZ2V0Tm9kZUJ5UGF0aCggWyAxIF0gKTsgICAgIC8vIC0+IDxiPgogICAgICoJCXRoaXMuZ2V0Tm9kZUJ5UGF0aCggWyAxLCAwIF0gKTsgIC8vIC0+ICJjIgogICAgICoKICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj59IHJlbGF0aXZlUGF0aCBQYXRoIG9mIHRoZSBub2RlIHRvIGZpbmQsIHJlbGF0aXZlIHRvIHRoaXMgZWxlbWVudC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXROb2RlQnlQYXRoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlQnlQYXRoKHJlbGF0aXZlUGF0aCkgewogICAgICB2YXIgbm9kZSA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzCgogICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocmVsYXRpdmVQYXRoKSwKICAgICAgICAgIF9zdGVwOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGluZGV4ID0gX3N0ZXAudmFsdWU7CiAgICAgICAgICBub2RlID0gbm9kZS5nZXRDaGlsZChub2RlLm9mZnNldFRvSW5kZXgoaW5kZXgpKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvci5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yLmYoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5vZGU7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIG9mZnNldCAicG9zaXRpb24iIHRvIGluZGV4ICJwb3NpdGlvbiIuCiAgICAgKgogICAgICogUmV0dXJucyBpbmRleCBvZiBhIG5vZGUgdGhhdCBvY2N1cGllcyBnaXZlbiBvZmZzZXQuIElmIGdpdmVuIG9mZnNldCBpcyB0b28gbG93LCByZXR1cm5zIGAwYC4gSWYgZ2l2ZW4gb2Zmc2V0IGlzCiAgICAgKiB0b28gaGlnaCwgcmV0dXJucyBpbmRleCBhZnRlciBsYXN0IGNoaWxkfS4KICAgICAqCiAgICAgKgkJY29uc3QgdGV4dE5vZGUgPSBuZXcgVGV4dCggJ2ZvbycgKTsKICAgICAqCQljb25zdCBwRWxlbWVudCA9IG5ldyBFbGVtZW50KCAncCcgKTsKICAgICAqCQljb25zdCBkb2NGcmFnID0gbmV3IERvY3VtZW50RnJhZ21lbnQoIFsgdGV4dE5vZGUsIHBFbGVtZW50IF0gKTsKICAgICAqCQlkb2NGcmFnLm9mZnNldFRvSW5kZXgoIC0xICk7IC8vIFJldHVybnMgMCwgYmVjYXVzZSBvZmZzZXQgaXMgdG9vIGxvdy4KICAgICAqCQlkb2NGcmFnLm9mZnNldFRvSW5kZXgoIDAgKTsgLy8gUmV0dXJucyAwLCBiZWNhdXNlIG9mZnNldCAwIGlzIHRha2VuIGJ5IGB0ZXh0Tm9kZWAgd2hpY2ggaXMgYXQgaW5kZXggMC4KICAgICAqCQlkb2NGcmFnLm9mZnNldFRvSW5kZXgoIDEgKTsgLy8gUmV0dXJucyAwLCBiZWNhdXNlIGB0ZXh0Tm9kZWAgaGFzIGBvZmZzZXRTaXplYCBlcXVhbCB0byAzLCBzbyBpdCBvY2N1cGllcyBvZmZzZXQgMSB0b28uCiAgICAgKgkJZG9jRnJhZy5vZmZzZXRUb0luZGV4KCAyICk7IC8vIFJldHVybnMgMC4KICAgICAqCQlkb2NGcmFnLm9mZnNldFRvSW5kZXgoIDMgKTsgLy8gUmV0dXJucyAxLgogICAgICoJCWRvY0ZyYWcub2Zmc2V0VG9JbmRleCggNCApOyAvLyBSZXR1cm5zIDIuIFRoZXJlIGFyZSBubyBub2RlcyBhdCBvZmZzZXQgNCwgc28gbGFzdCBhdmFpbGFibGUgaW5kZXggaXMgcmV0dXJuZWQuCiAgICAgKgogICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBPZmZzZXQgdG8gbG9vayBmb3IuCiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBJbmRleCBvZiBhIG5vZGUgdGhhdCBvY2N1cGllcyBnaXZlbiBvZmZzZXQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAib2Zmc2V0VG9JbmRleCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gb2Zmc2V0VG9JbmRleChvZmZzZXQpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLm9mZnNldFRvSW5kZXgob2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgYERvY3VtZW50RnJhZ21lbnRgIGluc3RhbmNlIHRvIHBsYWluIG9iamVjdCBhbmQgcmV0dXJucyBpdC4KICAgICAqIFRha2VzIGNhcmUgb2YgY29udmVydGluZyBhbGwgb2YgdGhpcyBkb2N1bWVudCBmcmFnbWVudCdzIGNoaWxkcmVuLgogICAgICoKICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGBEb2N1bWVudEZyYWdtZW50YCBpbnN0YW5jZSBjb252ZXJ0ZWQgdG8gcGxhaW4gb2JqZWN0LgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvSlNPTiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkgewogICAgICB2YXIganNvbiA9IFtdOwoKICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLl9jaGlsZHJlbiksCiAgICAgICAgICBfc3RlcDI7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgIGpzb24ucHVzaChub2RlLnRvSlNPTigpKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjIuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjIuZigpOwogICAgICB9CgogICAgICByZXR1cm4ganNvbjsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGBEb2N1bWVudEZyYWdtZW50YCBpbnN0YW5jZSBmcm9tIGdpdmVuIHBsYWluIG9iamVjdCAoaS5lLiBwYXJzZWQgSlNPTiBzdHJpbmcpLgogICAgICogQ29udmVydHMgYERvY3VtZW50RnJhZ21lbnRgIGNoaWxkcmVuIHRvIHByb3BlciBub2Rlcy4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBQbGFpbiBvYmplY3QgdG8gYmUgY29udmVydGVkIHRvIGBEb2N1bWVudEZyYWdtZW50YC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gYERvY3VtZW50RnJhZ21lbnRgIGluc3RhbmNlIGNyZWF0ZWQgdXNpbmcgZ2l2ZW4gcGxhaW4gb2JqZWN0LgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9hcHBlbmRDaGlsZCIsCiAgICB2YWx1ZToKICAgIC8qKgogICAgICoge0BsaW5rICNfaW5zZXJ0Q2hpbGQgSW5zZXJ0c30gb25lIG9yIG1vcmUgbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGlzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtPn0gaXRlbXMgSXRlbXMgdG8gYmUgaW5zZXJ0ZWQuCiAgICAgKi8KICAgIGZ1bmN0aW9uIF9hcHBlbmRDaGlsZChpdGVtcykgewogICAgICB0aGlzLl9pbnNlcnRDaGlsZCh0aGlzLmNoaWxkQ291bnQsIGl0ZW1zKTsKICAgIH0KICAgIC8qKgogICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSBub2RlcyBhdCB0aGUgZ2l2ZW4gaW5kZXggYW5kIHNldHMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI3BhcmVudCBwYXJlbnR9IG9mIHRoZXNlIG5vZGVzCiAgICAgKiB0byB0aGlzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfEl0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbT59IGl0ZW1zIEl0ZW1zIHRvIGJlIGluc2VydGVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9pbnNlcnRDaGlsZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydENoaWxkKGluZGV4LCBpdGVtcykgewogICAgICB2YXIgbm9kZXMgPSBub3JtYWxpemUoaXRlbXMpOwoKICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihub2RlcyksCiAgICAgICAgICBfc3RlcDM7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwMy52YWx1ZTsKCiAgICAgICAgICAvLyBJZiBub2RlIHRoYXQgaXMgYmVpbmcgYWRkZWQgdG8gdGhpcyBlbGVtZW50IGlzIGFscmVhZHkgaW5zaWRlIGFub3RoZXIgZWxlbWVudCwgZmlyc3QgcmVtb3ZlIGl0IGZyb20gdGhlIG9sZCBwYXJlbnQuCiAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgIT09IG51bGwpIHsKICAgICAgICAgICAgbm9kZS5fcmVtb3ZlKCk7CiAgICAgICAgICB9CgogICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7CiAgICAgIH0KCiAgICAgIHRoaXMuX2NoaWxkcmVuLl9pbnNlcnROb2RlcyhpbmRleCwgbm9kZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIG5vZGVzIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBpbmRleAogICAgICogYW5kIHNldHMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI3BhcmVudCBwYXJlbnR9IG9mIHRoZXNlIG5vZGVzIHRvIGBudWxsYC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGZpcnN0IG5vZGUgdG8gcmVtb3ZlLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IFtob3dNYW55PTFdIE51bWJlciBvZiBub2RlcyB0byByZW1vdmUuCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlPn0gQXJyYXkgY29udGFpbmluZyByZW1vdmVkIG5vZGVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmVDaGlsZHJlbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUNoaWxkcmVuKGluZGV4KSB7CiAgICAgIHZhciBob3dNYW55ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxOwoKICAgICAgdmFyIG5vZGVzID0gdGhpcy5fY2hpbGRyZW4uX3JlbW92ZU5vZGVzKGluZGV4LCBob3dNYW55KTsKCiAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobm9kZXMpLAogICAgICAgICAgX3N0ZXA0OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykgewogICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDQudmFsdWU7CiAgICAgICAgICBub2RlLnBhcmVudCA9IG51bGw7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I0LmYoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5vZGVzOwogICAgfSAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRvU3RyaW5nKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJcmV0dXJuICdkb2N1bWVudEZyYWdtZW50JzsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2coKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAljb25zb2xlLmxvZyggJ01vZGVsRG9jdW1lbnRGcmFnbWVudDogJyArIHRoaXMgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBwcmludFRyZWUoKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCWxldCBzdHJpbmcgPSAnTW9kZWxEb2N1bWVudEZyYWdtZW50OiBbJzsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JZm9yICggY29uc3QgY2hpbGQgb2YgdGhpcy5nZXRDaGlsZHJlbigpICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJc3RyaW5nICs9ICdcbic7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQlpZiAoIGNoaWxkLmlzKCAnJHRleHQnICkgKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQkJY29uc3QgdGV4dEF0dHJzID0gc3RyaW5naWZ5TWFwKCBjaGlsZC5fYXR0cnMgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JCQlzdHJpbmcgKz0gJ1x0Jy5yZXBlYXQoIDEgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JCQlpZiAoIHRleHRBdHRycyAhPT0gJycgKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQkJCXN0cmluZyArPSBgPCR0ZXh0JHsgdGV4dEF0dHJzIH0+YCArIGNoaWxkLmRhdGEgKyAnPC8kdGV4dD4nOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJCX0gZWxzZSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQkJCXN0cmluZyArPSBjaGlsZC5kYXRhOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJCX0KICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JCX0gZWxzZSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQkJc3RyaW5nICs9IGNoaWxkLnByaW50VHJlZSggMSApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwl9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCXN0cmluZyArPSAnXG5dJzsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JcmV0dXJuIHN0cmluZzsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2dUcmVlKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJY29uc29sZS5sb2coIHRoaXMucHJpbnRUcmVlKCkgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKICB9XSwgW3sKICAgIGtleTogImZyb21KU09OIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihqc29uKSB7CiAgICAgIHZhciBjaGlsZHJlbiA9IFtdOwoKICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihqc29uKSwKICAgICAgICAgIF9zdGVwNTsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwNS52YWx1ZTsKCiAgICAgICAgICBpZiAoY2hpbGQubmFtZSkgewogICAgICAgICAgICAvLyBJZiBjaGlsZCBoYXMgbmFtZSBwcm9wZXJ0eSwgaXQgaXMgYW4gRWxlbWVudC4KICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChFbGVtZW50LmZyb21KU09OKGNoaWxkKSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgVGV4dCBub2RlLgogICAgICAgICAgICBjaGlsZHJlbi5wdXNoKFRleHQuZnJvbUpTT04oY2hpbGQpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9pdGVyYXRvcjUuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjUuZigpOwogICAgICB9CgogICAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pOwogICAgfQogIH1dKTsKCiAgcmV0dXJuIERvY3VtZW50RnJhZ21lbnQ7Cn0oKTsgLy8gQ29udmVydHMgc3RyaW5ncyB0byBUZXh0IGFuZCBub24taXRlcmFibGVzIHRvIGFycmF5cy4KLy8KLy8gQHBhcmFtIHtTdHJpbmd8bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtPn0KLy8gQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59CgoKZXhwb3J0IHsgRG9jdW1lbnRGcmFnbWVudCBhcyBkZWZhdWx0IH07CgpmdW5jdGlvbiBub3JtYWxpemUobm9kZXMpIHsKICAvLyBTZXBhcmF0ZSBjb25kaXRpb24gYmVjYXVzZSBzdHJpbmcgaXMgaXRlcmFibGUuCiAgaWYgKHR5cGVvZiBub2RlcyA9PSAnc3RyaW5nJykgewogICAgcmV0dXJuIFtuZXcgVGV4dChub2RlcyldOwogIH0KCiAgaWYgKCFpc0l0ZXJhYmxlKG5vZGVzKSkgewogICAgbm9kZXMgPSBbbm9kZXNdOwogIH0gLy8gQXJyYXkuZnJvbSB0byBlbmFibGUgLm1hcCgpIG9uIG5vbi1hcnJheXMuCgoKICByZXR1cm4gQXJyYXkuZnJvbShub2RlcykubWFwKGZ1bmN0aW9uIChub2RlKSB7CiAgICBpZiAodHlwZW9mIG5vZGUgPT0gJ3N0cmluZycpIHsKICAgICAgcmV0dXJuIG5ldyBUZXh0KG5vZGUpOwogICAgfQoKICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGV4dFByb3h5KSB7CiAgICAgIHJldHVybiBuZXcgVGV4dChub2RlLmRhdGEsIG5vZGUuZ2V0QXR0cmlidXRlcygpKTsKICAgIH0KCiAgICByZXR1cm4gbm9kZTsKICB9KTsKfQ=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js"],"names":["NodeList","Element","Text","TextProxy","isIterable","DocumentFragment","children","markers","Map","_children","_insertChild","Symbol","iterator","getChildren","length","maxOffset","childCount","type","index","getNode","node","getNodeIndex","getNodeStartOffset","relativePath","getChild","offsetToIndex","offset","json","push","toJSON","items","nodes","normalize","parent","_remove","_insertNodes","howMany","_removeNodes","child","name","fromJSON","Array","from","map","data","getAttributes"],"mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,UAAP,MAAuB,0CAAvB,C,CAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,gB;AACpB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,4BAAaC,QAAb,EAAwB;AAAA;;AACvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,OAAL,GAAe,IAAIC,GAAJ,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,SAAL,GAAiB,IAAIT,QAAJ,EAAjB;;AAEA,QAAKM,QAAL,EAAgB;AACf,WAAKI,YAAL,CAAmB,CAAnB,EAAsBJ,QAAtB;AACA;AACD;AAED;AACD;AACA;AACA;AACA;;;;SACGK,MAAM,CAACC,Q;WAAT,iBAAsB;AACrB,aAAO,KAAKC,WAAL,EAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAiB;AAChB,aAAO,KAAKJ,SAAL,CAAeK,MAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAgB;AACf,aAAO,KAAKL,SAAL,CAAeM,SAAtB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAc;AACb,aAAO,KAAKC,UAAL,KAAoB,CAA3B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAW;AACV,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;;SACC,eAAa;AACZ,aAAO,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,YAAIC,IAAJ,EAAW;AACV,aAAOA,IAAI,KAAK,kBAAT,IAA+BA,IAAI,KAAK,wBAA/C;AACA;AAED;AACD;AACA;AACA;AACA;AACA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/model/documentfragment\n */\n\nimport NodeList from './nodelist';\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n// @if CK_DEBUG_ENGINE // const { stringifyMap } = require( '../dev-utils/utils' );\n\n/**\n * DocumentFragment represents a part of model which does not have a common root but its top-level nodes\n * can be seen as siblings. In other words, it is a detached part of model tree, without a root.\n *\n * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection\n * will be set to the {@link module:engine/model/model~Model#markers model markers} by a\n * {@link module:engine/model/writer~Writer#insert} function.\n */\nexport default class DocumentFragment {\n\t/**\n\t * Creates an empty `DocumentFragment`.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n\t * Nodes to be contained inside the `DocumentFragment`.\n\t */\n\tconstructor( children ) {\n\t\t/**\n\t\t * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}\n\t\t * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}\n\t\t * when DocumentFragment will be inserted to the document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers\n\t\t */\n\t\tthis.markers = new Map();\n\n\t\t/**\n\t\t * List of nodes contained inside the document fragment.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children\n\t\t */\n\t\tthis._children = new NodeList();\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all nodes contained inside this document fragment.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this.getChildren();\n\t}\n\n\t/**\n\t * Number of this document fragment's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._children.maxOffset;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {null}\n\t */\n\tget parent() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\tdocFrag.is( 'documentFragment' ); // -> true\n\t *\t\tdocFrag.is( 'model:documentFragment' ); // -> true\n\t *\n\t *\t\tdocFrag.is( 'view:documentFragment' ); // -> false\n\t *\t\tdocFrag.is( 'element' ); // -> false\n\t *\t\tdocFrag.is( 'node' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'documentFragment' || type === 'model:documentFragment';\n\t}\n\n\t/**\n\t * Gets the child at the given index. Returns `null` if incorrect index was passed.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/model/node~Node|null} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children.getNode( index );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all of this document fragment's children.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's index.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.getNodeIndex( node );\n\t}\n\n\t/**\n\t * Returns the starting offset of given child. Starting offset is equal to the sum of\n\t * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n\t * given node is not a child of this document fragment.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's starting offset.\n\t */\n\tgetChildStartOffset( node ) {\n\t\treturn this._children.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.\n\t *\n\t * @returns {Array}\n\t */\n\tgetPath() {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Returns a descendant node by its path relative to this element.\n\t *\n\t *\t\t// <this>a<b>c</b></this>\n\t *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n\t *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n\t *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n\t *\n\t * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n\t * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetNodeByPath( relativePath ) {\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\tfor ( const index of relativePath ) {\n\t\t\tnode = node.getChild( node.offsetToIndex( index ) );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Converts offset \"position\" to index \"position\".\n\t *\n\t * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n\t * too high, returns index after last child}.\n\t *\n\t *\t\tconst textNode = new Text( 'foo' );\n\t *\t\tconst pElement = new Element( 'p' );\n\t *\t\tconst docFrag = new DocumentFragment( [ textNode, pElement ] );\n\t *\t\tdocFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n\t *\t\tdocFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n\t *\t\tdocFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n\t *\t\tdocFrag.offsetToIndex( 2 ); // Returns 0.\n\t *\t\tdocFrag.offsetToIndex( 3 ); // Returns 1.\n\t *\t\tdocFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number} Index of a node that occupies given offset.\n\t */\n\toffsetToIndex( offset ) {\n\t\treturn this._children.offsetToIndex( offset );\n\t}\n\n\t/**\n\t * Converts `DocumentFragment` instance to plain object and returns it.\n\t * Takes care of converting all of this document fragment's children.\n\t *\n\t * @returns {Object} `DocumentFragment` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = [];\n\n\t\tfor ( const node of this._children ) {\n\t\t\tjson.push( node.toJSON() );\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).\n\t * Converts `DocumentFragment` children to proper nodes.\n\t *\n\t * @param {Object} json Plain object to be converted to `DocumentFragment`.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\tconst children = [];\n\n\t\tfor ( const child of json ) {\n\t\t\tif ( child.name ) {\n\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t} else {\n\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t}\n\t\t}\n\n\t\treturn new DocumentFragment( children );\n\t}\n\n\t/**\n\t * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_appendChild( items ) {\n\t\tthis._insertChild( this.childCount, items );\n\t}\n\n\t/**\n\t * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n\t * to this document fragment.\n\t *\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_insertChild( index, items ) {\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t}\n\n\t\tthis._children._insertNodes( index, nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index\n\t * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n\t *\n\t * @protected\n\t * @param {Number} index Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tconst nodes = this._children._removeNodes( index, howMany );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn 'documentFragment';\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelDocumentFragment: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // printTree() {\n\t// @if CK_DEBUG_ENGINE //\tlet string = 'ModelDocumentFragment: [';\n\n\t// @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE //\t\tstring += '\\n';\n\n\t// @if CK_DEBUG_ENGINE //\t\tif ( child.is( '$text' ) ) {\n\t// @if CK_DEBUG_ENGINE //\t\t\tconst textAttrs = stringifyMap( child._attrs );\n\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += '\\t'.repeat( 1 );\n\n\t// @if CK_DEBUG_ENGINE //\t\t\tif ( textAttrs !== '' ) {\n\t// @if CK_DEBUG_ENGINE //\t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n\t// @if CK_DEBUG_ENGINE //\t\t\t} else {\n\t// @if CK_DEBUG_ENGINE //\t\t\t\tstring += child.data;\n\t// @if CK_DEBUG_ENGINE //\t\t\t}\n\t// @if CK_DEBUG_ENGINE //\t\t} else {\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += child.printTree( 1 );\n\t// @if CK_DEBUG_ENGINE //\t\t}\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\tstring += '\\n]';\n\n\t// @if CK_DEBUG_ENGINE //\treturn string;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logTree() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data, node.getAttributes() );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n"]}]}