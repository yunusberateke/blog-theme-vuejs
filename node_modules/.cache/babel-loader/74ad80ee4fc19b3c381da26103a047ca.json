{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmZyb20tZW50cmllcy5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL3V0aWxzL2RlbGV0ZWNvbnRlbnQKICovCmltcG9ydCBMaXZlUG9zaXRpb24gZnJvbSAnLi4vbGl2ZXBvc2l0aW9uJzsKaW1wb3J0IFJhbmdlIGZyb20gJy4uL3JhbmdlJzsKaW1wb3J0IERvY3VtZW50U2VsZWN0aW9uIGZyb20gJy4uL2RvY3VtZW50c2VsZWN0aW9uJzsKLyoqCiAqIERlbGV0ZXMgY29udGVudCBvZiB0aGUgc2VsZWN0aW9uIGFuZCBtZXJnZSBzaWJsaW5ncy4gVGhlIHJlc3VsdGluZyBzZWxlY3Rpb24gaXMgYWx3YXlzIGNvbGxhcHNlZC4KICoKICogKipOb3RlOioqIFVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNkZWxldGVDb250ZW50fSBpbnN0ZWFkIG9mIHRoaXMgZnVuY3Rpb24uCiAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSBleHBvc2VkIHRvIGJlIHJldXNhYmxlIGluIGFsZ29yaXRobXMKICogd2hpY2ggY2hhbmdlIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNkZWxldGVDb250ZW50fQogKiBtZXRob2QncyBiZWhhdmlvci4KICoKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgaW4gY29udGV4dCBvZiB3aGljaCB0aGUgaW5zZXJ0aW9uCiAqIHNob3VsZCBiZSBwZXJmb3JtZWQuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb259IHNlbGVjdGlvbgogKiBTZWxlY3Rpb24gb2Ygd2hpY2ggdGhlIGNvbnRlbnQgc2hvdWxkIGJlIGRlbGV0ZWQuCiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10KICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sZWF2ZVVubWVyZ2VkPWZhbHNlXSBXaGV0aGVyIHRvIG1lcmdlIGVsZW1lbnRzIGFmdGVyIHJlbW92aW5nIHRoZSBjb250ZW50IG9mIHRoZSBzZWxlY3Rpb24uCiAqCiAqIEZvciBleGFtcGxlIGA8aGVhZGluZz54W3g8L2hlYWRpbmc+PHBhcmFncmFwaD55XXk8L3BhcmFncmFwaD5gIHdpbGwgYmVjb21lOgogKgogKiAqIGA8aGVhZGluZz54Xnk8L2hlYWRpbmc+YCB3aXRoIHRoZSBvcHRpb24gZGlzYWJsZWQgKGBsZWF2ZVVubWVyZ2VkID09IGZhbHNlYCkKICogKiBgPGhlYWRpbmc+eF48L2hlYWRpbmc+PHBhcmFncmFwaD55PC9wYXJhZ3JhcGg+YCB3aXRoIGVuYWJsZWQgKGBsZWF2ZVVubWVyZ2VkID09IHRydWVgKS4KICoKICogTm90ZToge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc09iamVjdCBvYmplY3R9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzTGltaXQgbGltaXR9CiAqIGVsZW1lbnRzIHdpbGwgbm90IGJlIG1lcmdlZC4KICoKICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb05vdFJlc2V0RW50aXJlQ29udGVudD1mYWxzZV0gV2hldGhlciB0byBza2lwIHJlcGxhY2luZyB0aGUgZW50aXJlIGNvbnRlbnQgd2l0aCBhCiAqIHBhcmFncmFwaCB3aGVuIHRoZSBlbnRpcmUgY29udGVudCB3YXMgc2VsZWN0ZWQuCiAqCiAqIEZvciBleGFtcGxlIGA8aGVhZGluZz5beDwvaGVhZGluZz48cGFyYWdyYXBoPnldPC9wYXJhZ3JhcGg+YCB3aWxsIGJlY29tZToKICoKICogKiBgPHBhcmFncmFwaD5ePC9wYXJhZ3JhcGg+YCB3aXRoIHRoZSBvcHRpb24gZGlzYWJsZWQgKGBkb05vdFJlc2V0RW50aXJlQ29udGVudCA9PSBmYWxzZWApCiAqICogYDxoZWFkaW5nPl48L2hlYWRpbmc+YCB3aXRoIGVuYWJsZWQgKGBkb05vdFJlc2V0RW50aXJlQ29udGVudCA9PSB0cnVlYCkuCiAqCiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG9Ob3RBdXRvcGFyYWdyYXBoPWZhbHNlXSBXaGV0aGVyIHRvIGNyZWF0ZSBhIHBhcmFncmFwaCBpZiBhZnRlciBjb250ZW50IGRlbGV0aW9uIHNlbGVjdGlvbiBpcyBtb3ZlZAogKiB0byBhIHBsYWNlIHdoZXJlIHRleHQgY2Fubm90IGJlIGluc2VydGVkLgogKgogKiBGb3IgZXhhbXBsZSBgPHBhcmFncmFwaD54PC9wYXJhZ3JhcGg+WzxpbWFnZSBzcmM9ImZvby5qcGciPjwvaW1hZ2U+XWAgd2lsbCBiZWNvbWU6CiAqCiAqICogYDxwYXJhZ3JhcGg+eDwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+W108L3BhcmFncmFwaD5gIHdpdGggdGhlIG9wdGlvbiBkaXNhYmxlZCAoYGRvTm90QXV0b3BhcmFncmFwaCA9PSBmYWxzZWApCiAqICogYDxwYXJhZ3JhcGg+eDwvcGFyYWdyYXBoPltdYCB3aXRoIHRoZSBvcHRpb24gZW5hYmxlZCAoYGRvTm90QXV0b3BhcmFncmFwaCA9PSB0cnVlYCkuCiAqCiAqIElmIHlvdSB1c2UgdGhpcyBvcHRpb24geW91IG5lZWQgdG8gbWFrZSBzdXJlIHRvIGhhbmRsZSBpbnZhbGlkIHNlbGVjdGlvbnMgeW91cnNlbGYgb3IgbGVhdmUKICogdGhlbSB0byB0aGUgc2VsZWN0aW9uIHBvc3QtZml4ZXIgKG1heSBub3QgYWx3YXlzIHdvcmspLgogKgogKiAqKk5vdGU6KiogaWYgdGhlcmUgaXMgbm8gdmFsaWQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb24sIHRoZSBwYXJhZ3JhcGggd2lsbCBhbHdheXMgYmUgY3JlYXRlZDoKICoKICogYFs8aW1hZ2Ugc3JjPSJmb28uanBnIj48L2ltYWdlPl1gIC0+IGA8cGFyYWdyYXBoPltdPC9wYXJhZ3JhcGg+YC4KICovCgpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWxldGVDb250ZW50KG1vZGVsLCBzZWxlY3Rpb24pIHsKICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307CgogIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHsKICAgIHJldHVybjsKICB9CgogIHZhciBzZWxSYW5nZSA9IHNlbGVjdGlvbi5nZXRGaXJzdFJhbmdlKCk7IC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSByZW1vdmVkLCBkb24ndCBkbyBhbnl0aGluZy4KCiAgaWYgKHNlbFJhbmdlLnJvb3Qucm9vdE5hbWUgPT0gJyRncmF2ZXlhcmQnKSB7CiAgICByZXR1cm47CiAgfQoKICB2YXIgc2NoZW1hID0gbW9kZWwuc2NoZW1hOwogIG1vZGVsLmNoYW5nZShmdW5jdGlvbiAod3JpdGVyKSB7CiAgICAvLyAxLiBSZXBsYWNlIHRoZSBlbnRpcmUgY29udGVudCB3aXRoIHBhcmFncmFwaC4KICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzEwMTIjaXNzdWVjb21tZW50LTMxNTAxNzU5NC4KICAgIGlmICghb3B0aW9ucy5kb05vdFJlc2V0RW50aXJlQ29udGVudCAmJiBzaG91bGRFbnRpcmVDb250ZW50QmVSZXBsYWNlZFdpdGhQYXJhZ3JhcGgoc2NoZW1hLCBzZWxlY3Rpb24pKSB7CiAgICAgIHJlcGxhY2VFbnRpcmVDb250ZW50V2l0aFBhcmFncmFwaCh3cml0ZXIsIHNlbGVjdGlvbiwgc2NoZW1hKTsKICAgICAgcmV0dXJuOwogICAgfSAvLyBHZXQgdGhlIGxpdmUgcG9zaXRpb25zIGZvciB0aGUgcmFuZ2UgYWRqdXN0ZWQgdG8gc3BhbiBvbmx5IGJsb2NrcyBzZWxlY3RlZCBmcm9tIHRoZSB1c2VyIHBlcnNwZWN0aXZlLgoKCiAgICB2YXIgX2dldExpdmVQb3NpdGlvbnNGb3JTID0gZ2V0TGl2ZVBvc2l0aW9uc0ZvclNlbGVjdGVkQmxvY2tzKHNlbFJhbmdlKSwKICAgICAgICBfZ2V0TGl2ZVBvc2l0aW9uc0ZvclMyID0gX3NsaWNlZFRvQXJyYXkoX2dldExpdmVQb3NpdGlvbnNGb3JTLCAyKSwKICAgICAgICBzdGFydFBvc2l0aW9uID0gX2dldExpdmVQb3NpdGlvbnNGb3JTMlswXSwKICAgICAgICBlbmRQb3NpdGlvbiA9IF9nZXRMaXZlUG9zaXRpb25zRm9yUzJbMV07IC8vIDIuIFJlbW92ZSB0aGUgY29udGVudCBpZiB0aGVyZSBpcyBhbnkuCgoKICAgIGlmICghc3RhcnRQb3NpdGlvbi5pc1RvdWNoaW5nKGVuZFBvc2l0aW9uKSkgewogICAgICB3cml0ZXIucmVtb3ZlKHdyaXRlci5jcmVhdGVSYW5nZShzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikpOwogICAgfSAvLyAzLiBNZXJnZSBlbGVtZW50cyBpbiB0aGUgcmlnaHQgYnJhbmNoIHRvIHRoZSBlbGVtZW50cyBpbiB0aGUgbGVmdCBicmFuY2guCiAgICAvLyBUaGUgb25seSByZWFzb25hYmxlIChpbiB0ZXJtcyBvZiBkYXRhIGFuZCBzZWxlY3Rpb24gY29ycmVjdG5lc3MpIGNhc2UgaW4gd2hpY2ggd2UgbmVlZCB0byBkbyB0aGF0IGlzOgogICAgLy8KICAgIC8vIDxoZWFkaW5nIHR5cGU9MT5Gb1s8L2hlYWRpbmc+PHBhcmFncmFwaD5dYXI8L3BhcmFncmFwaD4gPT4gPGhlYWRpbmcgdHlwZT0xPkZvXmFyPC9oZWFkaW5nPgogICAgLy8KICAgIC8vIEhvd2V2ZXIsIHRoZSBhbGdvcml0aG0gc3VwcG9ydHMgYWxzbyBtZXJnaW5nIGRlZXBlciBzdHJ1Y3R1cmVzICh1cCB0byB0aGUgZGVwdGggb2YgdGhlIHNoYWxsb3dlciBicmFuY2gpLAogICAgLy8gYXMgaXQncyBoYXJkIHRvIGltYWdpbmUgd2hhdCBzaG91bGQgYWN0dWFsbHkgYmUgdGhlIGRlZmF1bHQgYmVoYXZpb3IuIFVzdWFsbHksIHNwZWNpZmljIGZlYXR1cmVzIHdpbGwKICAgIC8vIHdhbnQgdG8gb3ZlcnJpZGUgdGhhdCBiZWhhdmlvciBhbnl3YXkuCgoKICAgIGlmICghb3B0aW9ucy5sZWF2ZVVubWVyZ2VkKSB7CiAgICAgIG1lcmdlQnJhbmNoZXMod3JpdGVyLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbik7IC8vIFRNUCB0aGlzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIHBvc3RmaXhlci4KICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbmQgc3RyaXAgZGlzYWxsb3dlZCBhdHRyaWJ1dGVzIGluIGFsbCBuZXN0ZWQgbm9kZXMgYmVjYXVzZSBhZnRlciBtZXJnZQogICAgICAvLyBzb21lIGF0dHJpYnV0ZXMgY291bGQgZW5kIHVwIGluIGEgcGF0aCB3aGVyZSBhcmUgZGlzYWxsb3dlZC4KICAgICAgLy8KICAgICAgLy8gZS5nLiBib2xkIGlzIGRpc2FsbG93ZWQgZm9yIDxIMT4KICAgICAgLy8gPGgxPkZve288L2gxPjxwPmJ9YTxiPnI8L2I+PHA+IC0+IDxoMT5Gb3t9YTxiPnI8L2I+PGgxPiAtPiA8aDE+Rm97fWFyPGgxPi4KCiAgICAgIHNjaGVtYS5yZW1vdmVEaXNhbGxvd2VkQXR0cmlidXRlcyhzdGFydFBvc2l0aW9uLnBhcmVudC5nZXRDaGlsZHJlbigpLCB3cml0ZXIpOwogICAgfQoKICAgIGNvbGxhcHNlU2VsZWN0aW9uQXQod3JpdGVyLCBzZWxlY3Rpb24sIHN0YXJ0UG9zaXRpb24pOyAvLyA0LiBBZGQgYSBwYXJhZ3JhcGggdG8gc2V0IHNlbGVjdGlvbiBpbiBpdC4KICAgIC8vIENoZWNrIGlmIGEgdGV4dCBpcyBhbGxvd2VkIGluIHRoZSBuZXcgY29udGFpbmVyLiBJZiBub3QsIHRyeSB0byBjcmVhdGUgYSBuZXcgcGFyYWdyYXBoIChpZiBpdCdzIGFsbG93ZWQgaGVyZSkuCiAgICAvLyBJZiBhdXRvcGFyYWdyYXBoaW5nIGlzIG9mZiwgd2UgYXNzdW1lIHRoYXQgeW91IGtub3cgd2hhdCB5b3UgZG8gc28gd2UgbGVhdmUgdGhlIHNlbGVjdGlvbiB3aGVyZXZlciBpdCB3YXMuCgogICAgaWYgKCFvcHRpb25zLmRvTm90QXV0b3BhcmFncmFwaCAmJiBzaG91bGRBdXRvcGFyYWdyYXBoKHNjaGVtYSwgc3RhcnRQb3NpdGlvbikpIHsKICAgICAgaW5zZXJ0UGFyYWdyYXBoKHdyaXRlciwgc3RhcnRQb3NpdGlvbiwgc2VsZWN0aW9uKTsKICAgIH0KCiAgICBzdGFydFBvc2l0aW9uLmRldGFjaCgpOwogICAgZW5kUG9zaXRpb24uZGV0YWNoKCk7CiAgfSk7Cn0gLy8gUmV0dXJucyB0aGUgbGl2ZSBwb3NpdGlvbnMgZm9yIHRoZSByYW5nZSBhZGp1c3RlZCB0byBzcGFuIG9ubHkgYmxvY2tzIHNlbGVjdGVkIGZyb20gdGhlIHVzZXIgcGVyc3BlY3RpdmUuIEV4YW1wbGU6Ci8vCi8vICAgICA8aGVhZGluZzE+W2ZvbzwvaGVhZGluZzE+Ci8vICAgICA8cGFyYWdyYXBoPmJhcjwvcGFyYWdyYXBoPgovLyAgICAgPGhlYWRpbmcxPl1hYmM8L2hlYWRpbmcxPiAgPC0tIHRoaXMgYmxvY2sgaXMgbm90IGNvbnNpZGVyZWQgYXMgc2VsZWN0ZWQKLy8KLy8gVGhpcyBpcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBpbiBTZWxlY3Rpb24jZ2V0U2VsZWN0ZWRCbG9ja3MoKSAic3BlY2lhbCBjYXNlIi4KCmZ1bmN0aW9uIGdldExpdmVQb3NpdGlvbnNGb3JTZWxlY3RlZEJsb2NrcyhyYW5nZSkgewogIHZhciBtb2RlbCA9IHJhbmdlLnJvb3QuZG9jdW1lbnQubW9kZWw7CiAgdmFyIHN0YXJ0UG9zaXRpb24gPSByYW5nZS5zdGFydDsKICB2YXIgZW5kUG9zaXRpb24gPSByYW5nZS5lbmQ7IC8vIElmIHRoZSBlbmQgb2Ygc2VsZWN0aW9uIGlzIGF0IHRoZSBzdGFydCBwb3NpdGlvbiBvZiBsYXN0IGJsb2NrIGluIHRoZSBzZWxlY3Rpb24sIHRoZW4KICAvLyBzaHJpbmsgaXQgdG8gbm90IGluY2x1ZGUgdGhhdCB0cmFpbGluZyBibG9jay4gTm90ZSB0aGF0IHRoaXMgc2hvdWxkIGhhcHBlbiBvbmx5IGZvciBub3QgZW1wdHkgc2VsZWN0aW9uLgoKICBpZiAobW9kZWwuaGFzQ29udGVudChyYW5nZSwgewogICAgaWdub3JlTWFya2VyczogdHJ1ZQogIH0pKSB7CiAgICB2YXIgZW5kQmxvY2sgPSBnZXRQYXJlbnRCbG9jayhlbmRQb3NpdGlvbik7CgogICAgaWYgKGVuZEJsb2NrICYmIGVuZFBvc2l0aW9uLmlzVG91Y2hpbmcobW9kZWwuY3JlYXRlUG9zaXRpb25BdChlbmRCbG9jaywgMCkpKSB7CiAgICAgIC8vIENyZWF0ZSBmb3J3YXJkIHNlbGVjdGlvbiBhcyBhIHByb2JlIHRvIGZpbmQgYSB2YWxpZCBwb3NpdGlvbiBhZnRlciBleGNsdWRpbmcgbGFzdCBibG9jayBmcm9tIHRoZSByYW5nZS4KICAgICAgdmFyIHNlbGVjdGlvbiA9IG1vZGVsLmNyZWF0ZVNlbGVjdGlvbihyYW5nZSk7IC8vIE1vZGlmeSB0aGUgZm9yd2FyZCBzZWxlY3Rpb24gaW4gYmFja3dhcmQgZGlyZWN0aW9uIHRvIHNocmluayBpdCBhbmQgcmVtb3ZlIGZpcnN0IHBvc2l0aW9uIG9mIGZvbGxvd2luZyBibG9jayBmcm9tIGl0LgogICAgICAvLyBUaGlzIGlzIGhvdyBtb2RpZnlTZWxlY3Rpb24gd29ya3MgYW5kIGhlcmUgd2UgYXJlIG1ha2luZyB1c2Ugb2YgaXQuCgogICAgICBtb2RlbC5tb2RpZnlTZWxlY3Rpb24oc2VsZWN0aW9uLCB7CiAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnCiAgICAgIH0pOwogICAgICBlbmRQb3NpdGlvbiA9IHNlbGVjdGlvbi5nZXRMYXN0UG9zaXRpb24oKTsKICAgIH0KICB9CgogIHJldHVybiBbTGl2ZVBvc2l0aW9uLmZyb21Qb3NpdGlvbihzdGFydFBvc2l0aW9uLCAndG9QcmV2aW91cycpLCBMaXZlUG9zaXRpb24uZnJvbVBvc2l0aW9uKGVuZFBvc2l0aW9uLCAndG9OZXh0JyldOwp9IC8vIEZpbmRzIHRoZSBsb3dlc3QgZWxlbWVudCBpbiBwb3NpdGlvbidzIGFuY2VzdG9ycyB3aGljaCBpcyBhIGJsb2NrLgovLyBSZXR1cm5zIG51bGwgaWYgYSBsaW1pdCBlbGVtZW50IGlzIGVuY291bnRlcmVkIGJlZm9yZSByZWFjaGluZyBhIGJsb2NrIGVsZW1lbnQuCgoKZnVuY3Rpb24gZ2V0UGFyZW50QmxvY2socG9zaXRpb24pIHsKICB2YXIgZWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudDsKICB2YXIgc2NoZW1hID0gZWxlbWVudC5yb290LmRvY3VtZW50Lm1vZGVsLnNjaGVtYTsKICB2YXIgYW5jZXN0b3JzID0gZWxlbWVudC5nZXRBbmNlc3RvcnMoewogICAgcGFyZW50Rmlyc3Q6IHRydWUsCiAgICBpbmNsdWRlU2VsZjogdHJ1ZQogIH0pOwoKICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYW5jZXN0b3JzKSwKICAgICAgX3N0ZXA7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykgewogICAgICB2YXIgX2VsZW1lbnQgPSBfc3RlcC52YWx1ZTsKCiAgICAgIGlmIChzY2hlbWEuaXNMaW1pdChfZWxlbWVudCkpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgaWYgKHNjaGVtYS5pc0Jsb2NrKF9lbGVtZW50KSkgewogICAgICAgIHJldHVybiBfZWxlbWVudDsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yLmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yLmYoKTsKICB9Cn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBhIHJlc3VsdCBvZiByZWFjaGluZyB0aGUgQmFsbG1lcidzIHBlYWsgZm9yIGp1c3QgdGhlIHJpZ2h0IGFtb3VudCBvZiB0aW1lLgovLyBFdmVuIEkgaGFkIHRyb3VibGVzIGRvY3VtZW50aW5nIGl0IGFmdGVyIGEgd2hpbGUgYW5kIGFmdGVyIHJlYWRpbmcgaXQgYWdhaW4gSSBjb3VsZG4ndCBiZWxpZXZlIHRoYXQgaXQgcmVhbGx5IHdvcmtzLgoKCmZ1bmN0aW9uIG1lcmdlQnJhbmNoZXMod3JpdGVyLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikgewogIHZhciBtb2RlbCA9IHdyaXRlci5tb2RlbDsgLy8gVmVyaWZ5IGlmIHRoZXJlIGlzIGEgbmVlZCBhbmQgcG9zc2liaWxpdHkgdG8gbWVyZ2UuCgogIGlmICghY2hlY2tTaG91bGRNZXJnZSh3cml0ZXIubW9kZWwuc2NoZW1hLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikpIHsKICAgIHJldHVybjsKICB9IC8vIElmIHRoZSBzdGFydCBlbGVtZW50IG9uIHRoZSBjb21tb24gYW5jZXN0b3IgbGV2ZWwgaXMgZW1wdHksIGFuZCB0aGUgZW5kIGVsZW1lbnQgb24gdGhlIHNhbWUgbGV2ZWwgaXMgbm90IGVtcHR5CiAgLy8gdGhlbiBtZXJnZSB0aG9zZSB0byB0aGUgcmlnaHQgZWxlbWVudCBzbyB0aGF0IGl0J3MgcHJvcGVydGllcyBhcmUgcHJlc2VydmVkIChuYW1lLCBhdHRyaWJ1dGVzKS4KICAvLyBCZWNhdXNlIG9mIE9UIG1lcmdpbmcgaXMgdXNlZCBpbnN0ZWFkIG9mIHJlbW92aW5nIGVsZW1lbnRzLgogIC8vCiAgLy8gTWVyZ2UgbGVmdDoKICAvLyAgICAgPGhlYWRpbmcxPmZvb1s8L2hlYWRpbmcxPiAgICAtPiAgPGhlYWRpbmcxPmZvb1tdYmFyPC9oZWFkaW5nMT4KICAvLyAgICAgPHBhcmFncmFwaD5dYmFyPC9wYXJhZ3JhcGg+ICAtPiAgICAgICAgICAgICAgIC0tXgogIC8vCiAgLy8gTWVyZ2UgcmlnaHQ6CiAgLy8gICAgIDxoZWFkaW5nMT5bPC9oZWFkaW5nMT4gICAgICAgLT4KICAvLyAgICAgPHBhcmFncmFwaD5dYmFyPC9wYXJhZ3JhcGg+ICAtPiAgPHBhcmFncmFwaD5bXWJhcjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gTWVyZ2UgbGVmdDoKICAvLyAgICAgPGJsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAgLT4gIDxibG9ja1F1b3RlPgogIC8vICAgICAgICAgPGhlYWRpbmcxPmZvb1s8L2hlYWRpbmcxPiAgICAtPiAgICAgIDxoZWFkaW5nMT5mb29bXWJhcjwvaGVhZGluZzE+CiAgLy8gICAgICAgICA8cGFyYWdyYXBoPl1iYXI8L3BhcmFncmFwaD4gIC0+ICAgICAgICAgICAgICAgICAgIC0tXgogIC8vICAgICA8L2Jsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAtPiAgPC9ibG9ja1F1b3RlPgogIC8vCiAgLy8gTWVyZ2UgcmlnaHQ6CiAgLy8gICAgIDxibG9ja1F1b3RlPiAgICAgICAgICAgICAgICAgICAgIC0+ICA8YmxvY2tRdW90ZT4KICAvLyAgICAgICAgIDxoZWFkaW5nMT5bPC9oZWFkaW5nMT4gICAgICAgLT4KICAvLyAgICAgICAgIDxwYXJhZ3JhcGg+XWJhcjwvcGFyYWdyYXBoPiAgLT4gICAgICA8cGFyYWdyYXBoPltdYmFyPC9wYXJhZ3JhcGg+CiAgLy8gICAgIDwvYmxvY2tRdW90ZT4gICAgICAgICAgICAgICAgICAgIC0+ICA8L2Jsb2NrUXVvdGU+CiAgLy8gTWVyZ2luZyBzaG91bGQgbm90IGdvIGRlZXBlciB0aGFuIGNvbW1vbiBhbmNlc3Rvci4KCgogIHZhciBfZ2V0QW5jZXN0b3JzSnVzdEJlbG8gPSBnZXRBbmNlc3RvcnNKdXN0QmVsb3dDb21tb25BbmNlc3RvcihzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiksCiAgICAgIF9nZXRBbmNlc3RvcnNKdXN0QmVsbzIgPSBfc2xpY2VkVG9BcnJheShfZ2V0QW5jZXN0b3JzSnVzdEJlbG8sIDIpLAogICAgICBzdGFydEFuY2VzdG9yID0gX2dldEFuY2VzdG9yc0p1c3RCZWxvMlswXSwKICAgICAgZW5kQW5jZXN0b3IgPSBfZ2V0QW5jZXN0b3JzSnVzdEJlbG8yWzFdOyAvLyBCcmFuY2hlcyBjYW4ndCBiZSBtZXJnZWQgaWYgb25lIG9mIHRoZSBwb3NpdGlvbnMgaXMgZGlyZWN0bHkgaW5zaWRlIGEgY29tbW9uIGFuY2VzdG9yLgogIC8vCiAgLy8gRXhhbXBsZToKICAvLyAgICAgPGJsb2NrUXVvdGU+CiAgLy8gICAgICAgICA8cGFyYWdyYXBoPltmb288L3BhcmFncmFwaD5dCiAgLy8gICAgICAgICA8dGFibGU+IC4uLiA8L3RhYmxlPgogIC8vICAgICA8YmxvY2tRdW90ZT4KICAvLwoKCiAgaWYgKCFzdGFydEFuY2VzdG9yIHx8ICFlbmRBbmNlc3RvcikgewogICAgcmV0dXJuOwogIH0KCiAgaWYgKCFtb2RlbC5oYXNDb250ZW50KHN0YXJ0QW5jZXN0b3IsIHsKICAgIGlnbm9yZU1hcmtlcnM6IHRydWUKICB9KSAmJiBtb2RlbC5oYXNDb250ZW50KGVuZEFuY2VzdG9yLCB7CiAgICBpZ25vcmVNYXJrZXJzOiB0cnVlCiAgfSkpIHsKICAgIG1lcmdlQnJhbmNoZXNSaWdodCh3cml0ZXIsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBzdGFydEFuY2VzdG9yLnBhcmVudCk7CiAgfSBlbHNlIHsKICAgIG1lcmdlQnJhbmNoZXNMZWZ0KHdyaXRlciwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIHN0YXJ0QW5jZXN0b3IucGFyZW50KTsKICB9Cn0gLy8gTWVyZ2luZyBibG9ja3MgdG8gdGhlIGxlZnQgKHByb3BlcnRpZXMgb2YgdGhlIGxlZnQgYmxvY2sgYXJlIHByZXNlcnZlZCkuCi8vIFNpbXBsZSBleGFtcGxlOgovLyAgICAgPGhlYWRpbmcxPmZvb1s8L2hlYWRpbmcxPiAgICAtPiAgPGhlYWRpbmcxPmZvb1tiYXI8L2hlYWRpbmcxPl0KLy8gICAgIDxwYXJhZ3JhcGg+XWJhcjwvcGFyYWdyYXBoPiAgLT4gICAgICAgICAgICAgIC0tXgovLwovLyBOZXN0ZWQgZXhhbXBsZToKLy8gICAgIDxibG9ja1F1b3RlPiAgICAgICAgICAgICAgICAgICAgIC0+ICA8YmxvY2tRdW90ZT4KLy8gICAgICAgICA8aGVhZGluZzE+Zm9vWzwvaGVhZGluZzE+ICAgIC0+ICAgICAgPGhlYWRpbmcxPmZvb1tiYXI8L2hlYWRpbmcxPgovLyAgICAgPC9ibG9ja1F1b3RlPiAgICAgICAgICAgICAgICAgICAgLT4gIDwvYmxvY2tRdW90ZT5dICAgIF4KLy8gICAgIDxibG9ja0Jsb2NrPiAgICAgICAgICAgICAgICAgICAgIC0+ICAgICAgICAgICAgICAgICAgICB8Ci8vICAgICAgICAgPHBhcmFncmFwaD5dYmFyPC9wYXJhZ3JhcGg+ICAtPiAgICAgICAgICAgICAgICAgLS0tCi8vICAgICA8L2Jsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAtPgovLwoKCmZ1bmN0aW9uIG1lcmdlQnJhbmNoZXNMZWZ0KHdyaXRlciwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIGNvbW1vbkFuY2VzdG9yKSB7CiAgdmFyIHN0YXJ0RWxlbWVudCA9IHN0YXJ0UG9zaXRpb24ucGFyZW50OwogIHZhciBlbmRFbGVtZW50ID0gZW5kUG9zaXRpb24ucGFyZW50OyAvLyBNZXJnaW5nIHJlYWNoZWQgdGhlIGNvbW1vbiBhbmNlc3RvciBlbGVtZW50LCBzdG9wIGhlcmUuCgogIGlmIChzdGFydEVsZW1lbnQgPT0gY29tbW9uQW5jZXN0b3IgfHwgZW5kRWxlbWVudCA9PSBjb21tb25BbmNlc3RvcikgewogICAgcmV0dXJuOwogIH0gLy8gUmVtZW1iZXIgbmV4dCBwb3NpdGlvbnMgdG8gbWVyZ2UgaW4gbmV4dCByZWN1cnNpdmUgc3RlcCAoYWxzbyB1c2VkIGFzIG1vZGlmaWNhdGlvbiBwb2ludHMgcG9pbnRlcnMpLgoKCiAgc3RhcnRQb3NpdGlvbiA9IHdyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKHN0YXJ0RWxlbWVudCk7CiAgZW5kUG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb25CZWZvcmUoZW5kRWxlbWVudCk7IC8vIE1vdmUgZW5kRWxlbWVudCBqdXN0IGFmdGVyIHN0YXJ0RWxlbWVudCBpZiB0aGV5IGFyZW4ndCBzaWJsaW5ncy4KCiAgaWYgKCFlbmRQb3NpdGlvbi5pc0VxdWFsKHN0YXJ0UG9zaXRpb24pKSB7CiAgICAvLwogICAgLy8gICAgIDxibG9ja1F1b3RlPiAgICAgICAgICAgICAgICAgICAgIC0+ICA8YmxvY2tRdW90ZT4KICAgIC8vICAgICAgICAgPGhlYWRpbmcxPmZvb1s8L2hlYWRpbmcxPiAgICAtPiAgICAgIDxoZWFkaW5nMT5mb288L2hlYWRpbmcxPls8cGFyYWdyYXBoPmJhcjwvcGFyYWdyYXBoPgogICAgLy8gICAgIDwvYmxvY2tRdW90ZT4gICAgICAgICAgICAgICAgICAgIC0+ICA8L2Jsb2NrUXVvdGU+ICAgICAgICAgICAgICAgIF4KICAgIC8vICAgICA8YmxvY2tCbG9jaz4gICAgICAgICAgICAgICAgICAgICAtPiAgPGJsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICB8CiAgICAvLyAgICAgICAgIDxwYXJhZ3JhcGg+XWJhcjwvcGFyYWdyYXBoPiAgLT4gICAgICBdICAgICAgICAgICAgICAgICAgICAgLS0tCiAgICAvLyAgICAgPC9ibG9ja0Jsb2NrPiAgICAgICAgICAgICAgICAgICAgLT4gIDwvYmxvY2tCbG9jaz4KICAgIC8vCiAgICB3cml0ZXIuaW5zZXJ0KGVuZEVsZW1lbnQsIHN0YXJ0UG9zaXRpb24pOwogIH0gLy8gTWVyZ2UgdHdvIHNpYmxpbmdzIChub2RlcyBvbiBzaWRlcyBvZiBzdGFydFBvc2l0aW9uKToKICAvLwogIC8vICAgICA8YmxvY2tRdW90ZT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAgPGJsb2NrUXVvdGU+CiAgLy8gICAgICAgICA8aGVhZGluZzE+Zm9vPC9oZWFkaW5nMT5bPHBhcmFncmFwaD5iYXI8L3BhcmFncmFwaD4gIC0+ICAgICAgPGhlYWRpbmcxPmZvb1tiYXI8L2hlYWRpbmcxPgogIC8vICAgICA8L2Jsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAgPC9ibG9ja1F1b3RlPgogIC8vICAgICA8YmxvY2tCbG9jaz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAgPGJsb2NrQmxvY2s+CiAgLy8gICAgICAgICBdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+ICAgICAgXQogIC8vICAgICA8L2Jsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAgPC9ibG9ja0Jsb2NrPgogIC8vCiAgLy8gT3IgaW4gc2ltcGxlIGNhc2UgKHdpdGhvdXQgbW92aW5nIGVsZW1lbnRzIGluIGFib3ZlIGlmKToKICAvLyAgICAgPGhlYWRpbmcxPmZvbzwvaGVhZGluZzE+WzxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+XSAgLT4gIDxoZWFkaW5nMT5mb29bYmFyPC9oZWFkaW5nMT5dCiAgLy8KCgogIHdyaXRlci5tZXJnZShzdGFydFBvc2l0aW9uKTsgLy8gUmVtb3ZlIGVtcHR5IGVuZCBhbmNlc3RvcnM6CiAgLy8KICAvLyAgICAgPGJsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAgIC0+ICA8YmxvY2tRdW90ZT4KICAvLyAgICAgICAgIDxoZWFkaW5nMT5mb29bYmFyPC9oZWFkaW5nMT4gIC0+ICAgICAgPGhlYWRpbmcxPmZvb1tiYXI8L2hlYWRpbmcxPgogIC8vICAgICA8L2Jsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAgLT4gIDwvYmxvY2tRdW90ZT4KICAvLyAgICAgPGJsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAgIC0+CiAgLy8gICAgICAgICBdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAgXQogIC8vICAgICA8L2Jsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAgLT4KICAvLwoKICB3aGlsZSAoZW5kUG9zaXRpb24ucGFyZW50LmlzRW1wdHkpIHsKICAgIHZhciBwYXJlbnRUb1JlbW92ZSA9IGVuZFBvc2l0aW9uLnBhcmVudDsKICAgIGVuZFBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKHBhcmVudFRvUmVtb3ZlKTsKICAgIHdyaXRlci5yZW1vdmUocGFyZW50VG9SZW1vdmUpOwogIH0gLy8gVmVyaWZ5IGlmIHRoZXJlIGlzIGEgbmVlZCBhbmQgcG9zc2liaWxpdHkgdG8gbWVyZ2UgbmV4dCBsZXZlbC4KCgogIGlmICghY2hlY2tTaG91bGRNZXJnZSh3cml0ZXIubW9kZWwuc2NoZW1hLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbikpIHsKICAgIHJldHVybjsKICB9IC8vIENvbnRpbnVlIG1lcmdpbmcgbmV4dCBsZXZlbCAoYmxvY2tRdW90ZSB3aXRoIGJsb2NrQmxvY2sgaW4gdGhlIGV4YW1wbGVzIGFib3ZlIGlmIGl0IHdvdWxkIG5vdCBiZSBlbXB0eSBhbmQgZ290IHJlbW92ZWQpLgoKCiAgbWVyZ2VCcmFuY2hlc0xlZnQod3JpdGVyLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgY29tbW9uQW5jZXN0b3IpOwp9IC8vIE1lcmdpbmcgYmxvY2tzIHRvIHRoZSByaWdodCAocHJvcGVydGllcyBvZiB0aGUgcmlnaHQgYmxvY2sgYXJlIHByZXNlcnZlZCkuCi8vIFNpbXBsZSBleGFtcGxlOgovLyAgICAgPGhlYWRpbmcxPmZvb1s8L2hlYWRpbmcxPiAgICAtPiAgICAgICAgICAgIC0tdgovLyAgICAgPHBhcmFncmFwaD5dYmFyPC9wYXJhZ3JhcGg+ICAtPiAgWzxwYXJhZ3JhcGg+Zm9vXWJhcjwvcGFyYWdyYXBoPgovLwovLyBOZXN0ZWQgZXhhbXBsZToKLy8gICAgIDxibG9ja1F1b3RlPiAgICAgICAgICAgICAgICAgICAgIC0+Ci8vICAgICAgICAgPGhlYWRpbmcxPmZvb1s8L2hlYWRpbmcxPiAgICAtPiAgICAgICAgICAgICAgLS0tCi8vICAgICA8L2Jsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAtPiAgICAgICAgICAgICAgICAgfAovLyAgICAgPGJsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAgLT4gIFs8YmxvY2tCbG9jaz4gIHYKLy8gICAgICAgICA8cGFyYWdyYXBoPl1iYXI8L3BhcmFncmFwaD4gIC0+ICAgICAgPHBhcmFncmFwaD5mb29dYmFyPC9wYXJhZ3JhcGg+Ci8vICAgICA8L2Jsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAtPiAgPC9ibG9ja0Jsb2NrPgovLwoKCmZ1bmN0aW9uIG1lcmdlQnJhbmNoZXNSaWdodCh3cml0ZXIsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBjb21tb25BbmNlc3RvcikgewogIHZhciBzdGFydEVsZW1lbnQgPSBzdGFydFBvc2l0aW9uLnBhcmVudDsKICB2YXIgZW5kRWxlbWVudCA9IGVuZFBvc2l0aW9uLnBhcmVudDsgLy8gTWVyZ2luZyByZWFjaGVkIHRoZSBjb21tb24gYW5jZXN0b3IgZWxlbWVudCwgc3RvcCBoZXJlLgoKICBpZiAoc3RhcnRFbGVtZW50ID09IGNvbW1vbkFuY2VzdG9yIHx8IGVuZEVsZW1lbnQgPT0gY29tbW9uQW5jZXN0b3IpIHsKICAgIHJldHVybjsKICB9IC8vIFJlbWVtYmVyIG5leHQgcG9zaXRpb25zIHRvIG1lcmdlIGluIG5leHQgcmVjdXJzaXZlIHN0ZXAgKGFsc28gdXNlZCBhcyBtb2RpZmljYXRpb24gcG9pbnRzIHBvaW50ZXJzKS4KCgogIHN0YXJ0UG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb25BZnRlcihzdGFydEVsZW1lbnQpOwogIGVuZFBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKGVuZEVsZW1lbnQpOyAvLyBNb3ZlIHN0YXJ0RWxlbWVudCBqdXN0IGJlZm9yZSBlbmRFbGVtZW50IGlmIHRoZXkgYXJlbid0IHNpYmxpbmdzLgoKICBpZiAoIWVuZFBvc2l0aW9uLmlzRXF1YWwoc3RhcnRQb3NpdGlvbikpIHsKICAgIC8vCiAgICAvLyAgICAgPGJsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAgLT4gIDxibG9ja1F1b3RlPgogICAgLy8gICAgICAgICA8aGVhZGluZzE+Zm9vWzwvaGVhZGluZzE+ICAgIC0+ICAgICAgWyAgICAgICAgICAgICAgICAgICAtLS0KICAgIC8vICAgICA8L2Jsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAtPiAgPC9ibG9ja1F1b3RlPiAgICAgICAgICAgICAgfAogICAgLy8gICAgIDxibG9ja0Jsb2NrPiAgICAgICAgICAgICAgICAgICAgIC0+ICA8YmxvY2tCbG9jaz4gICAgICAgICAgICAgICB2CiAgICAvLyAgICAgICAgIDxwYXJhZ3JhcGg+XWJhcjwvcGFyYWdyYXBoPiAgLT4gICAgICA8aGVhZGluZzE+Zm9vPC9oZWFkaW5nMT5dPHBhcmFncmFwaD5iYXI8L3BhcmFncmFwaD4KICAgIC8vICAgICA8L2Jsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAtPiAgPC9ibG9ja0Jsb2NrPgogICAgLy8KICAgIHdyaXRlci5pbnNlcnQoc3RhcnRFbGVtZW50LCBlbmRQb3NpdGlvbik7CiAgfSAvLyBSZW1vdmUgZW1wdHkgZW5kIGFuY2VzdG9yczoKICAvLwogIC8vICAgICA8YmxvY2tRdW90ZT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPgogIC8vICAgICAgICAgWyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAgWwogIC8vICAgICA8L2Jsb2NrUXVvdGU+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPgogIC8vICAgICA8YmxvY2tCbG9jaz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAgPGJsb2NrQmxvY2s+CiAgLy8gICAgICAgICA8aGVhZGluZzE+Zm9vPC9oZWFkaW5nMT5dPHBhcmFncmFwaD5iYXI8L3BhcmFncmFwaD4gIC0+ICAgICAgPGhlYWRpbmcxPmZvbzwvaGVhZGluZzE+XTxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+CiAgLy8gICAgIDwvYmxvY2tCbG9jaz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+ICA8L2Jsb2NrQmxvY2s+CiAgLy8KCgogIHdoaWxlIChzdGFydFBvc2l0aW9uLnBhcmVudC5pc0VtcHR5KSB7CiAgICB2YXIgcGFyZW50VG9SZW1vdmUgPSBzdGFydFBvc2l0aW9uLnBhcmVudDsKICAgIHN0YXJ0UG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb25CZWZvcmUocGFyZW50VG9SZW1vdmUpOwogICAgd3JpdGVyLnJlbW92ZShwYXJlbnRUb1JlbW92ZSk7CiAgfSAvLyBVcGRhdGUgZW5kUG9zaXRpb24gYWZ0ZXIgaW5zZXJ0aW5nIGFuZCByZW1vdmluZyBlbGVtZW50cy4KCgogIGVuZFBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKGVuZEVsZW1lbnQpOyAvLyBNZXJnZSByaWdodCB0d28gc2libGluZ3MgKG5vZGVzIG9uIHNpZGVzIG9mIGVuZFBvc2l0aW9uKToKICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLT4KICAvLyAgICAgWyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLT4gIFsKICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLT4KICAvLyAgICAgPGJsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLT4gIDxibG9ja0Jsb2NrPgogIC8vICAgICAgICAgPGhlYWRpbmcxPmZvbzwvaGVhZGluZzE+XTxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+ICAtPiAgICAgIDxwYXJhZ3JhcGg+Zm9vXWJhcjwvcGFyYWdyYXBoPgogIC8vICAgICA8L2Jsb2NrQmxvY2s+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAgPC9ibG9ja0Jsb2NrPgogIC8vCiAgLy8gT3IgaW4gc2ltcGxlIGNhc2UgKHdpdGhvdXQgbW92aW5nIGVsZW1lbnRzIGluIGFib3ZlIGlmKToKICAvLyAgICAgWzxoZWFkaW5nMT5mb288L2hlYWRpbmcxPl08cGFyYWdyYXBoPmJhcjwvcGFyYWdyYXBoPiAgLT4gIFs8aGVhZGluZzE+Zm9vXWJhcjwvaGVhZGluZzE+CiAgLy8KCiAgbWVyZ2VSaWdodCh3cml0ZXIsIGVuZFBvc2l0aW9uKTsgLy8gVmVyaWZ5IGlmIHRoZXJlIGlzIGEgbmVlZCBhbmQgcG9zc2liaWxpdHkgdG8gbWVyZ2UgbmV4dCBsZXZlbC4KCiAgaWYgKCFjaGVja1Nob3VsZE1lcmdlKHdyaXRlci5tb2RlbC5zY2hlbWEsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSkgewogICAgcmV0dXJuOwogIH0gLy8gQ29udGludWUgbWVyZ2luZyBuZXh0IGxldmVsIChibG9ja1F1b3RlIHdpdGggYmxvY2tCbG9jayBpbiB0aGUgZXhhbXBsZXMgYWJvdmUgaWYgaXQgd291bGQgbm90IGJlIGVtcHR5IGFuZCBnb3QgcmVtb3ZlZCkuCgoKICBtZXJnZUJyYW5jaGVzUmlnaHQod3JpdGVyLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgY29tbW9uQW5jZXN0b3IpOwp9IC8vIFRoZXJlIGlzIG5vIHJpZ2h0IG1lcmdlIG9wZXJhdGlvbiBzbyB3ZSBuZWVkIHRvIHNpbXVsYXRlIGl0LgoKCmZ1bmN0aW9uIG1lcmdlUmlnaHQod3JpdGVyLCBwb3NpdGlvbikgewogIHZhciBzdGFydEVsZW1lbnQgPSBwb3NpdGlvbi5ub2RlQmVmb3JlOwogIHZhciBlbmRFbGVtZW50ID0gcG9zaXRpb24ubm9kZUFmdGVyOwoKICBpZiAoc3RhcnRFbGVtZW50Lm5hbWUgIT0gZW5kRWxlbWVudC5uYW1lKSB7CiAgICB3cml0ZXIucmVuYW1lKHN0YXJ0RWxlbWVudCwgZW5kRWxlbWVudC5uYW1lKTsKICB9CgogIHdyaXRlci5jbGVhckF0dHJpYnV0ZXMoc3RhcnRFbGVtZW50KTsKICB3cml0ZXIuc2V0QXR0cmlidXRlcyhPYmplY3QuZnJvbUVudHJpZXMoZW5kRWxlbWVudC5nZXRBdHRyaWJ1dGVzKCkpLCBzdGFydEVsZW1lbnQpOwogIHdyaXRlci5tZXJnZShwb3NpdGlvbik7Cn0gLy8gVmVyaWZpZXMgaWYgbWVyZ2luZyBpcyBuZWVkZWQgYW5kIHBvc3NpYmxlLiBJdCdzIG5vdCBuZWVkZWQgaWYgYm90aCBwb3NpdGlvbnMgYXJlIGluIHRoZSBzYW1lIGVsZW1lbnQKLy8gYW5kIGl0J3Mgbm90IHBvc3NpYmxlIGlmIHNvbWUgZWxlbWVudCBpcyBhIGxpbWl0IG9yIHRoZSByYW5nZSBjcm9zc2VzIGEgbGltaXQgZWxlbWVudC4KCgpmdW5jdGlvbiBjaGVja1Nob3VsZE1lcmdlKHNjaGVtYSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pIHsKICB2YXIgc3RhcnRFbGVtZW50ID0gc3RhcnRQb3NpdGlvbi5wYXJlbnQ7CiAgdmFyIGVuZEVsZW1lbnQgPSBlbmRQb3NpdGlvbi5wYXJlbnQ7IC8vIElmIGJvdGggcG9zaXRpb25zIGVuZGVkIHVwIGluIHRoZSBzYW1lIHBhcmVudCwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbW9yZSB0byBtZXJnZToKICAvLyA8JHJvb3Q+PHA+eFs8L3A+PHA+XXk8L3A+PC8kcm9vdD4gPT4gPCRyb290PjxwPnh5PC9wPltdPC8kcm9vdD4KCiAgaWYgKHN0YXJ0RWxlbWVudCA9PSBlbmRFbGVtZW50KSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfSAvLyBJZiBvbmUgb2YgdGhlIHBvc2l0aW9ucyBpcyBhIGxpbWl0IGVsZW1lbnQsIHRoZW4gdGhlcmUncyBub3RoaW5nIHRvIG1lcmdlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBjcm9zcyB0aGUgbGltaXQgYm91bmRhcmllcy4KCgogIGlmIChzY2hlbWEuaXNMaW1pdChzdGFydEVsZW1lbnQpIHx8IHNjaGVtYS5pc0xpbWl0KGVuZEVsZW1lbnQpKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfSAvLyBDaGVjayBpZiBvcGVyYXRpb25zIHdlJ2xsIG5lZWQgdG8gZG8gd29uJ3QgbmVlZCB0byBjcm9zcyBvYmplY3Qgb3IgbGltaXQgYm91bmRhcmllcy4KICAvLyBFLmcuLCB3ZSBjYW4ndCBtZXJnZSBlbmRFbGVtZW50IGludG8gc3RhcnRFbGVtZW50IGluIHRoaXMgY2FzZToKICAvLyA8bGltaXQ+PHN0YXJ0RWxlbWVudD54Wzwvc3RhcnRFbGVtZW50PjwvbGltaXQ+PGVuZEVsZW1lbnQ+XTwvZW5kRWxlbWVudD4KCgogIHJldHVybiBpc0Nyb3NzaW5nTGltaXRFbGVtZW50KHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBzY2hlbWEpOwp9IC8vIFJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIHRoZSBhbmNlc3RvcnMgb2YgdGhlIHByb3ZpZGVkIHBvc2l0aW9ucyB0aGF0IGFyZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhlIGNvbW1vbiBhbmNlc3Rvci4KCgpmdW5jdGlvbiBnZXRBbmNlc3RvcnNKdXN0QmVsb3dDb21tb25BbmNlc3Rvcihwb3NpdGlvbkEsIHBvc2l0aW9uQikgewogIHZhciBhbmNlc3RvcnNBID0gcG9zaXRpb25BLmdldEFuY2VzdG9ycygpOwogIHZhciBhbmNlc3RvcnNCID0gcG9zaXRpb25CLmdldEFuY2VzdG9ycygpOwogIHZhciBpID0gMDsKCiAgd2hpbGUgKGFuY2VzdG9yc0FbaV0gJiYgYW5jZXN0b3JzQVtpXSA9PSBhbmNlc3RvcnNCW2ldKSB7CiAgICBpKys7CiAgfQoKICByZXR1cm4gW2FuY2VzdG9yc0FbaV0sIGFuY2VzdG9yc0JbaV1dOwp9CgpmdW5jdGlvbiBzaG91bGRBdXRvcGFyYWdyYXBoKHNjaGVtYSwgcG9zaXRpb24pIHsKICB2YXIgaXNUZXh0QWxsb3dlZCA9IHNjaGVtYS5jaGVja0NoaWxkKHBvc2l0aW9uLCAnJHRleHQnKTsKICB2YXIgaXNQYXJhZ3JhcGhBbGxvd2VkID0gc2NoZW1hLmNoZWNrQ2hpbGQocG9zaXRpb24sICdwYXJhZ3JhcGgnKTsKICByZXR1cm4gIWlzVGV4dEFsbG93ZWQgJiYgaXNQYXJhZ3JhcGhBbGxvd2VkOwp9IC8vIENoZWNrIGlmIHBhcmVudHMgb2YgdHdvIHBvc2l0aW9ucyBjYW4gYmUgbWVyZ2VkIGJ5IGNoZWNraW5nIGlmIHRoZXJlIGFyZSBubyBsaW1pdC9vYmplY3QKLy8gYm91bmRhcmllcyBiZXR3ZWVuIHRob3NlIHR3byBwb3NpdGlvbnMuCi8vCi8vIEUuZy4gaW4gPGJRPjxwPnhbXTwvcD48L2JRPjx3aWRnZXQ+PGNhcHRpb24+e308L2NhcHRpb24+PC93aWRnZXQ+Ci8vIHdlJ2xsIGNoZWNrIDxwPiwgPGJRPiwgPHdpZGdldD4gYW5kIDxjYXB0aW9uPi4KLy8gVXN1YWxseSwgd2lkZ2V0IGFuZCBjYXB0aW9uIGFyZSBtYXJrZWQgYXMgb2JqZWN0cy9saW1pdHMgaW4gdGhlIHNjaGVtYSwgc28gaW4gdGhpcyBjYXNlIG1lcmdpbmcgd2lsbCBiZSBibG9ja2VkLgoKCmZ1bmN0aW9uIGlzQ3Jvc3NpbmdMaW1pdEVsZW1lbnQobGVmdFBvcywgcmlnaHRQb3MsIHNjaGVtYSkgewogIHZhciByYW5nZVRvQ2hlY2sgPSBuZXcgUmFuZ2UobGVmdFBvcywgcmlnaHRQb3MpOwoKICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJhbmdlVG9DaGVjay5nZXRXYWxrZXIoKSksCiAgICAgIF9zdGVwMjsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciB2YWx1ZSA9IF9zdGVwMi52YWx1ZTsKCiAgICAgIGlmIChzY2hlbWEuaXNMaW1pdCh2YWx1ZS5pdGVtKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjIuZigpOwogIH0KCiAgcmV0dXJuIHRydWU7Cn0KCmZ1bmN0aW9uIGluc2VydFBhcmFncmFwaCh3cml0ZXIsIHBvc2l0aW9uLCBzZWxlY3Rpb24pIHsKICB2YXIgcGFyYWdyYXBoID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoJ3BhcmFncmFwaCcpOwogIHdyaXRlci5pbnNlcnQocGFyYWdyYXBoLCBwb3NpdGlvbik7CiAgY29sbGFwc2VTZWxlY3Rpb25BdCh3cml0ZXIsIHNlbGVjdGlvbiwgd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQocGFyYWdyYXBoLCAwKSk7Cn0KCmZ1bmN0aW9uIHJlcGxhY2VFbnRpcmVDb250ZW50V2l0aFBhcmFncmFwaCh3cml0ZXIsIHNlbGVjdGlvbikgewogIHZhciBsaW1pdEVsZW1lbnQgPSB3cml0ZXIubW9kZWwuc2NoZW1hLmdldExpbWl0RWxlbWVudChzZWxlY3Rpb24pOwogIHdyaXRlci5yZW1vdmUod3JpdGVyLmNyZWF0ZVJhbmdlSW4obGltaXRFbGVtZW50KSk7CiAgaW5zZXJ0UGFyYWdyYXBoKHdyaXRlciwgd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQobGltaXRFbGVtZW50LCAwKSwgc2VsZWN0aW9uKTsKfSAvLyBXZSB3YW50IHRvIHJlcGxhY2UgdGhlIGVudGlyZSBjb250ZW50IHdpdGggYSBwYXJhZ3JhcGggd2hlbjoKLy8gKiB0aGUgZW50aXJlIGNvbnRlbnQgaXMgc2VsZWN0ZWQsCi8vICogc2VsZWN0aW9uIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBlbGVtZW50cywKLy8gKiB3aGV0aGVyIHRoZSBwYXJhZ3JhcGggaXMgYWxsb3dlZCBpbiBzY2hlbWEgaW4gdGhlIGNvbW1vbiBhbmNlc3Rvci4KCgpmdW5jdGlvbiBzaG91bGRFbnRpcmVDb250ZW50QmVSZXBsYWNlZFdpdGhQYXJhZ3JhcGgoc2NoZW1hLCBzZWxlY3Rpb24pIHsKICB2YXIgbGltaXRFbGVtZW50ID0gc2NoZW1hLmdldExpbWl0RWxlbWVudChzZWxlY3Rpb24pOwoKICBpZiAoIXNlbGVjdGlvbi5jb250YWluc0VudGlyZUNvbnRlbnQobGltaXRFbGVtZW50KSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KCiAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldEZpcnN0UmFuZ2UoKTsKCiAgaWYgKHJhbmdlLnN0YXJ0LnBhcmVudCA9PSByYW5nZS5lbmQucGFyZW50KSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQoKICByZXR1cm4gc2NoZW1hLmNoZWNrQ2hpbGQobGltaXRFbGVtZW50LCAncGFyYWdyYXBoJyk7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgc2V0cyB0aGUgc2VsZWN0aW9uLiBEZXBlbmRpbmcgd2hldGhlciBnaXZlbiBgc2VsZWN0aW9uYCBpcyBhIGRvY3VtZW50IHNlbGVjdGlvbiBvciBub3QsCi8vIHVzZXMgYSBkaWZmZXJlbnQgbWV0aG9kIHRvIHNldCBpdC4KCgpmdW5jdGlvbiBjb2xsYXBzZVNlbGVjdGlvbkF0KHdyaXRlciwgc2VsZWN0aW9uLCBwb3NpdGlvbk9yUmFuZ2UpIHsKICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgRG9jdW1lbnRTZWxlY3Rpb24pIHsKICAgIHdyaXRlci5zZXRTZWxlY3Rpb24ocG9zaXRpb25PclJhbmdlKTsKICB9IGVsc2UgewogICAgc2VsZWN0aW9uLnNldFRvKHBvc2l0aW9uT3JSYW5nZSk7CiAgfQp9"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js"],"names":["LivePosition","Range","DocumentSelection","deleteContent","model","selection","options","isCollapsed","selRange","getFirstRange","root","rootName","schema","change","writer","doNotResetEntireContent","shouldEntireContentBeReplacedWithParagraph","replaceEntireContentWithParagraph","getLivePositionsForSelectedBlocks","startPosition","endPosition","isTouching","remove","createRange","leaveUnmerged","mergeBranches","removeDisallowedAttributes","parent","getChildren","collapseSelectionAt","doNotAutoparagraph","shouldAutoparagraph","insertParagraph","detach","range","document","start","end","hasContent","ignoreMarkers","endBlock","getParentBlock","createPositionAt","createSelection","modifySelection","direction","getLastPosition","fromPosition","position","element","ancestors","getAncestors","parentFirst","includeSelf","isLimit","isBlock","checkShouldMerge","getAncestorsJustBelowCommonAncestor","startAncestor","endAncestor","mergeBranchesRight","mergeBranchesLeft","commonAncestor","startElement","endElement","createPositionAfter","createPositionBefore","isEqual","insert","merge","isEmpty","parentToRemove","mergeRight","nodeBefore","nodeAfter","name","rename","clearAttributes","setAttributes","Object","fromEntries","getAttributes","isCrossingLimitElement","positionA","positionB","ancestorsA","ancestorsB","i","isTextAllowed","checkChild","isParagraphAllowed","leftPos","rightPos","rangeToCheck","getWalker","value","item","paragraph","createElement","limitElement","getLimitElement","createRangeIn","containsEntireContent","positionOrRange","setSelection","setTo"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\n\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n */\nexport default function deleteContent( model, selection, options = {} ) {\n\tif ( selection.isCollapsed ) {\n\t\treturn;\n\t}\n\n\tconst selRange = selection.getFirstRange();\n\n\t// If the selection is already removed, don't do anything.\n\tif ( selRange.root.rootName == '$graveyard' ) {\n\t\treturn;\n\t}\n\n\tconst schema = model.schema;\n\n\tmodel.change( writer => {\n\t\t// 1. Replace the entire content with paragraph.\n\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n\t\tif ( !options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph( schema, selection ) ) {\n\t\t\treplaceEntireContentWithParagraph( writer, selection, schema );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n\t\tconst [ startPosition, endPosition ] = getLivePositionsForSelectedBlocks( selRange );\n\n\t\t// 2. Remove the content if there is any.\n\t\tif ( !startPosition.isTouching( endPosition ) ) {\n\t\t\twriter.remove( writer.createRange( startPosition, endPosition ) );\n\t\t}\n\n\t\t// 3. Merge elements in the right branch to the elements in the left branch.\n\t\t// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n\t\t//\n\t\t// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n\t\t//\n\t\t// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n\t\t// as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n\t\t// want to override that behavior anyway.\n\t\tif ( !options.leaveUnmerged ) {\n\t\t\tmergeBranches( writer, startPosition, endPosition );\n\n\t\t\t// TMP this will be replaced with a postfixer.\n\t\t\t// We need to check and strip disallowed attributes in all nested nodes because after merge\n\t\t\t// some attributes could end up in a path where are disallowed.\n\t\t\t//\n\t\t\t// e.g. bold is disallowed for <H1>\n\t\t\t// <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\t\t\tschema.removeDisallowedAttributes( startPosition.parent.getChildren(), writer );\n\t\t}\n\n\t\tcollapseSelectionAt( writer, selection, startPosition );\n\n\t\t// 4. Add a paragraph to set selection in it.\n\t\t// Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n\t\t// If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n\t\tif ( !options.doNotAutoparagraph && shouldAutoparagraph( schema, startPosition ) ) {\n\t\t\tinsertParagraph( writer, startPosition, selection );\n\t\t}\n\n\t\tstartPosition.detach();\n\t\tendPosition.detach();\n\t} );\n}\n\n// Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\nfunction getLivePositionsForSelectedBlocks( range ) {\n\tconst model = range.root.document.model;\n\n\tconst startPosition = range.start;\n\tlet endPosition = range.end;\n\n\t// If the end of selection is at the start position of last block in the selection, then\n\t// shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n\tif ( model.hasContent( range, { ignoreMarkers: true } ) ) {\n\t\tconst endBlock = getParentBlock( endPosition );\n\n\t\tif ( endBlock && endPosition.isTouching( model.createPositionAt( endBlock, 0 ) ) ) {\n\t\t\t// Create forward selection as a probe to find a valid position after excluding last block from the range.\n\t\t\tconst selection = model.createSelection( range );\n\n\t\t\t// Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n\t\t\t// This is how modifySelection works and here we are making use of it.\n\t\t\tmodel.modifySelection( selection, { direction: 'backward' } );\n\n\t\t\tendPosition = selection.getLastPosition();\n\t\t}\n\t}\n\n\treturn [\n\t\tLivePosition.fromPosition( startPosition, 'toPrevious' ),\n\t\tLivePosition.fromPosition( endPosition, 'toNext' )\n\t];\n}\n\n// Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\nfunction getParentBlock( position ) {\n\tconst element = position.parent;\n\tconst schema = element.root.document.model.schema;\n\tconst ancestors = element.getAncestors( { parentFirst: true, includeSelf: true } );\n\n\tfor ( const element of ancestors ) {\n\t\tif ( schema.isLimit( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( schema.isBlock( element ) ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n\n// This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\nfunction mergeBranches( writer, startPosition, endPosition ) {\n\tconst model = writer.model;\n\n\t// Verify if there is a need and possibility to merge.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n\t// then merge those to the right element so that it's properties are preserved (name, attributes).\n\t// Because of OT merging is used instead of removing elements.\n\t//\n\t// Merge left:\n\t//     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n\t//     <paragraph>]bar</paragraph>  ->               --^\n\t//\n\t// Merge right:\n\t//     <heading1>[</heading1>       ->\n\t//     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n\t//\n\t// Merge left:\n\t//     <blockQuote>                     ->  <blockQuote>\n\t//         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n\t//         <paragraph>]bar</paragraph>  ->                   --^\n\t//     </blockQuote>                    ->  </blockQuote>\n\t//\n\t// Merge right:\n\t//     <blockQuote>                     ->  <blockQuote>\n\t//         <heading1>[</heading1>       ->\n\t//         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n\t//     </blockQuote>                    ->  </blockQuote>\n\n\t// Merging should not go deeper than common ancestor.\n\tconst [ startAncestor, endAncestor ] = getAncestorsJustBelowCommonAncestor( startPosition, endPosition );\n\n\t// Branches can't be merged if one of the positions is directly inside a common ancestor.\n\t//\n\t// Example:\n\t//     <blockQuote>\n\t//         <paragraph>[foo</paragraph>]\n\t//         <table> ... </table>\n\t//     <blockQuote>\n\t//\n\tif ( !startAncestor || !endAncestor ) {\n\t\treturn;\n\t}\n\n\tif ( !model.hasContent( startAncestor, { ignoreMarkers: true } ) && model.hasContent( endAncestor, { ignoreMarkers: true } ) ) {\n\t\tmergeBranchesRight( writer, startPosition, endPosition, startAncestor.parent );\n\t} else {\n\t\tmergeBranchesLeft( writer, startPosition, endPosition, startAncestor.parent );\n\t}\n}\n\n// Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\nfunction mergeBranchesLeft( writer, startPosition, endPosition, commonAncestor ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// Merging reached the common ancestor element, stop here.\n\tif ( startElement == commonAncestor || endElement == commonAncestor ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge in next recursive step (also used as modification points pointers).\n\tstartPosition = writer.createPositionAfter( startElement );\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Move endElement just after startElement if they aren't siblings.\n\tif ( !endPosition.isEqual( startPosition ) ) {\n\t\t//\n\t\t//     <blockQuote>                     ->  <blockQuote>\n\t\t//         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n\t\t//     </blockQuote>                    ->  </blockQuote>                ^\n\t\t//     <blockBlock>                     ->  <blockBlock>                 |\n\t\t//         <paragraph>]bar</paragraph>  ->      ]                     ---\n\t\t//     </blockBlock>                    ->  </blockBlock>\n\t\t//\n\t\twriter.insert( endElement, startPosition );\n\t}\n\n\t// Merge two siblings (nodes on sides of startPosition):\n\t//\n\t//     <blockQuote>                                             ->  <blockQuote>\n\t//         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n\t//     </blockQuote>                                            ->  </blockQuote>\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         ]                                                    ->      ]\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\t// Or in simple case (without moving elements in above if):\n\t//     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n\t//\n\twriter.merge( startPosition );\n\n\t// Remove empty end ancestors:\n\t//\n\t//     <blockQuote>                      ->  <blockQuote>\n\t//         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n\t//     </blockQuote>                     ->  </blockQuote>\n\t//     <blockBlock>                      ->\n\t//         ]                             ->  ]\n\t//     </blockBlock>                     ->\n\t//\n\twhile ( endPosition.parent.isEmpty ) {\n\t\tconst parentToRemove = endPosition.parent;\n\n\t\tendPosition = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Verify if there is a need and possibility to merge next level.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\tmergeBranchesLeft( writer, startPosition, endPosition, commonAncestor );\n}\n\n// Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\nfunction mergeBranchesRight( writer, startPosition, endPosition, commonAncestor ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// Merging reached the common ancestor element, stop here.\n\tif ( startElement == commonAncestor || endElement == commonAncestor ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge in next recursive step (also used as modification points pointers).\n\tstartPosition = writer.createPositionAfter( startElement );\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Move startElement just before endElement if they aren't siblings.\n\tif ( !endPosition.isEqual( startPosition ) ) {\n\t\t//\n\t\t//     <blockQuote>                     ->  <blockQuote>\n\t\t//         <heading1>foo[</heading1>    ->      [                   ---\n\t\t//     </blockQuote>                    ->  </blockQuote>              |\n\t\t//     <blockBlock>                     ->  <blockBlock>               v\n\t\t//         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n\t\t//     </blockBlock>                    ->  </blockBlock>\n\t\t//\n\t\twriter.insert( startElement, endPosition );\n\t}\n\n\t// Remove empty end ancestors:\n\t//\n\t//     <blockQuote>                                             ->\n\t//         [                                                    ->  [\n\t//     </blockQuote>                                            ->\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\twhile ( startPosition.parent.isEmpty ) {\n\t\tconst parentToRemove = startPosition.parent;\n\n\t\tstartPosition = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Update endPosition after inserting and removing elements.\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Merge right two siblings (nodes on sides of endPosition):\n\t//                                                              ->\n\t//     [                                                        ->  [\n\t//                                                              ->\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\t// Or in simple case (without moving elements in above if):\n\t//     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n\t//\n\tmergeRight( writer, endPosition );\n\n\t// Verify if there is a need and possibility to merge next level.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\tmergeBranchesRight( writer, startPosition, endPosition, commonAncestor );\n}\n\n// There is no right merge operation so we need to simulate it.\nfunction mergeRight( writer, position ) {\n\tconst startElement = position.nodeBefore;\n\tconst endElement = position.nodeAfter;\n\n\tif ( startElement.name != endElement.name ) {\n\t\twriter.rename( startElement, endElement.name );\n\t}\n\n\twriter.clearAttributes( startElement );\n\twriter.setAttributes( Object.fromEntries( endElement.getAttributes() ), startElement );\n\n\twriter.merge( position );\n}\n\n// Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\nfunction checkShouldMerge( schema, startPosition, endPosition ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// If both positions ended up in the same parent, then there's nothing more to merge:\n\t// <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n\tif ( startElement == endElement ) {\n\t\treturn false;\n\t}\n\n\t// If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\tif ( schema.isLimit( startElement ) || schema.isLimit( endElement ) ) {\n\t\treturn false;\n\t}\n\n\t// Check if operations we'll need to do won't need to cross object or limit boundaries.\n\t// E.g., we can't merge endElement into startElement in this case:\n\t// <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n\treturn isCrossingLimitElement( startPosition, endPosition, schema );\n}\n\n// Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\nfunction getAncestorsJustBelowCommonAncestor( positionA, positionB ) {\n\tconst ancestorsA = positionA.getAncestors();\n\tconst ancestorsB = positionB.getAncestors();\n\n\tlet i = 0;\n\n\twhile ( ancestorsA[ i ] && ancestorsA[ i ] == ancestorsB[ i ] ) {\n\t\ti++;\n\t}\n\n\treturn [ ancestorsA[ i ], ancestorsB[ i ] ];\n}\n\nfunction shouldAutoparagraph( schema, position ) {\n\tconst isTextAllowed = schema.checkChild( position, '$text' );\n\tconst isParagraphAllowed = schema.checkChild( position, 'paragraph' );\n\n\treturn !isTextAllowed && isParagraphAllowed;\n}\n\n// Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\nfunction isCrossingLimitElement( leftPos, rightPos, schema ) {\n\tconst rangeToCheck = new Range( leftPos, rightPos );\n\n\tfor ( const value of rangeToCheck.getWalker() ) {\n\t\tif ( schema.isLimit( value.item ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction insertParagraph( writer, position, selection ) {\n\tconst paragraph = writer.createElement( 'paragraph' );\n\n\twriter.insert( paragraph, position );\n\n\tcollapseSelectionAt( writer, selection, writer.createPositionAt( paragraph, 0 ) );\n}\n\nfunction replaceEntireContentWithParagraph( writer, selection ) {\n\tconst limitElement = writer.model.schema.getLimitElement( selection );\n\n\twriter.remove( writer.createRangeIn( limitElement ) );\n\tinsertParagraph( writer, writer.createPositionAt( limitElement, 0 ), selection );\n}\n\n// We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\nfunction shouldEntireContentBeReplacedWithParagraph( schema, selection ) {\n\tconst limitElement = schema.getLimitElement( selection );\n\n\tif ( !selection.containsEntireContent( limitElement ) ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getFirstRange();\n\n\tif ( range.start.parent == range.end.parent ) {\n\t\treturn false;\n\t}\n\n\treturn schema.checkChild( limitElement, 'paragraph' );\n}\n\n// Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\nfunction collapseSelectionAt( writer, selection, positionOrRange ) {\n\tif ( selection instanceof DocumentSelection ) {\n\t\twriter.setSelection( positionOrRange );\n\t} else {\n\t\tselection.setTo( positionOrRange );\n\t}\n}\n"]}]}