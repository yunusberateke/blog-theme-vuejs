{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5IjsKaW1wb3J0IF90eXBlb2YgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YiOwppbXBvcnQgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKaW1wb3J0IF9pbmhlcml0cyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzIjsKaW1wb3J0IF9jcmVhdGVTdXBlciBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZVN1cGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwppbXBvcnQgTWF0Y2hlciBmcm9tICcuLi92aWV3L21hdGNoZXInOwppbXBvcnQgQ29udmVyc2lvbkhlbHBlcnMgZnJvbSAnLi9jb252ZXJzaW9uaGVscGVycyc7CmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaC1lcyc7CmltcG9ydCB7IGxvZ1dhcm5pbmcgfSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IHByaW9yaXRpZXMgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvcHJpb3JpdGllcyc7CmltcG9ydCB7IGlzUGFyYWdyYXBoYWJsZSwgd3JhcEluUGFyYWdyYXBoIH0gZnJvbSAnLi4vbW9kZWwvdXRpbHMvYXV0b3BhcmFncmFwaGluZyc7Ci8qKgogKiBDb250YWlucyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3ZpZXcgdmlld30gdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWwgbW9kZWx9IGNvbnZlcnRlcnMgZm9yCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyfS4KICoKICogQG1vZHVsZSBlbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzCiAqLwoKLyoqCiAqIFVwY2FzdCBjb252ZXJzaW9uIGhlbHBlciBmdW5jdGlvbnMuCiAqCiAqIEBleHRlbmRzIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9uaGVscGVyc35Db252ZXJzaW9uSGVscGVycwogKi8KCnZhciBVcGNhc3RIZWxwZXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29udmVyc2lvbkhlbHBlcnMpIHsKICBfaW5oZXJpdHMoVXBjYXN0SGVscGVycywgX0NvbnZlcnNpb25IZWxwZXJzKTsKCiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihVcGNhc3RIZWxwZXJzKTsKCiAgZnVuY3Rpb24gVXBjYXN0SGVscGVycygpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVcGNhc3RIZWxwZXJzKTsKCiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgfQoKICBfY3JlYXRlQ2xhc3MoVXBjYXN0SGVscGVycywgW3sKICAgIGtleTogImVsZW1lbnRUb0VsZW1lbnQiLAogICAgdmFsdWU6CiAgICAvKioKICAgICAqIFZpZXcgZWxlbWVudCB0byBtb2RlbCBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIGNyZWF0aW5nIGEgbW9kZWwgZWxlbWVudC4gRm9yIGV4YW1wbGUsCiAgICAgKiB2aWV3IGA8cD5Gb288L3A+YCBiZWNvbWVzIGA8cGFyYWdyYXBoPkZvbzwvcGFyYWdyYXBoPmAgaW4gdGhlIG1vZGVsLgogICAgICoKICAgICAqIEtlZXAgaW4gbWluZCB0aGF0IHRoZSBlbGVtZW50IHdpbGwgYmUgaW5zZXJ0ZWQgb25seSBpZiBpdCBpcyBhbGxvd2VkCiAgICAgKiBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hIHNjaGVtYX0gY29uZmlndXJhdGlvbi4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0VsZW1lbnQoIHsKICAgICAqCQkJdmlldzogJ3AnLAogICAgICoJCQltb2RlbDogJ3BhcmFncmFwaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9FbGVtZW50KCB7CiAgICAgKgkJCXZpZXc6ICdwJywKICAgICAqCQkJbW9kZWw6ICdwYXJhZ3JhcGgnLAogICAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAncCcsCiAgICAgKgkJCQljbGFzc2VzOiAnZmFuY3knCiAgICAgKgkJCX0sCiAgICAgKgkJCW1vZGVsOiAnZmFuY3lQYXJhZ3JhcGgnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAgICogCQkJdmlldzogewogICAgICoJCQkJbmFtZTogJ3AnLAogICAgICoJCQkJY2xhc3NlczogJ2hlYWRpbmcnCiAgICAgKiAJCQl9LAogICAgICogCQkJbW9kZWw6ICggdmlld0VsZW1lbnQsIGNvbnZlcnNpb25BcGkgKSA9PiB7CiAgICAgKiAJCQkJY29uc3QgbW9kZWxXcml0ZXIgPSBjb252ZXJzaW9uQXBpLndyaXRlcjsKICAgICAqCiAgICAgKiAJCQkJcmV0dXJuIG1vZGVsV3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdoZWFkaW5nJywgeyBsZXZlbDogdmlld0VsZW1lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1sZXZlbCcgKSB9ICk7CiAgICAgKiAJCQl9CiAgICAgKiAJCX0gKTsKICAgICAqCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqCiAgICAgKiBAbWV0aG9kICNlbGVtZW50VG9FbGVtZW50CiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59IFtjb25maWcudmlld10gUGF0dGVybiBtYXRjaGluZyBhbGwgdmlldyBlbGVtZW50cyB3aGljaCBzaG91bGQgYmUgY29udmVydGVkLiBJZiBub3QKICAgICAqIHNldCwgdGhlIGNvbnZlcnRlciB3aWxsIGZpcmUgZm9yIGV2ZXJ5IHZpZXcgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fEZ1bmN0aW9ufSBjb25maWcubW9kZWwgTmFtZSBvZiB0aGUgbW9kZWwgZWxlbWVudCwgYSBtb2RlbCBlbGVtZW50IGluc3RhbmNlIG9yIGEKICAgICAqIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2aWV3IGVsZW1lbnQgYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpIHVwY2FzdCBjb252ZXJzaW9uIEFQSX0KICAgICAqIGFuZCByZXR1cm5zIGEgbW9kZWwgZWxlbWVudC4gVGhlIG1vZGVsIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZCBpbiB0aGUgbW9kZWwuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVyc30KICAgICAqLwogICAgZnVuY3Rpb24gZWxlbWVudFRvRWxlbWVudChjb25maWcpIHsKICAgICAgcmV0dXJuIHRoaXMuYWRkKHVwY2FzdEVsZW1lbnRUb0VsZW1lbnQoY29uZmlnKSk7CiAgICB9CiAgICAvKioKICAgICAqIFZpZXcgZWxlbWVudCB0byBtb2RlbCBhdHRyaWJ1dGUgY29udmVyc2lvbiBoZWxwZXIuCiAgICAgKgogICAgICogVGhpcyBjb252ZXJzaW9uIHJlc3VsdHMgaW4gc2V0dGluZyBhbiBhdHRyaWJ1dGUgb24gYSBtb2RlbCBub2RlLiBGb3IgZXhhbXBsZSwgdmlldyBgPHN0cm9uZz5Gb288L3N0cm9uZz5gIGJlY29tZXMKICAgICAqIGBGb29gIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCBtb2RlbCB0ZXh0IG5vZGV9IHdpdGggYGJvbGRgIGF0dHJpYnV0ZSBzZXQgdG8gYHRydWVgLgogICAgICoKICAgICAqIFRoaXMgaGVscGVyIGlzIG1lYW50IHRvIHNldCBhIG1vZGVsIGF0dHJpYnV0ZSBvbiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGluc2lkZSB0aGUgY29udmVydGVkIGVsZW1lbnQ6CiAgICAgKgogICAgICoJCTxzdHJvbmc+Rm9vPC9zdHJvbmc+ICAgLS0+ICAgPHN0cm9uZz48cD5Gb288L3A+PC9zdHJvbmc+ICAgLS0+ICAgPHBhcmFncmFwaD48JHRleHQgYm9sZD0idHJ1ZSI+Rm9vPC8kdGV4dD48L3BhcmFncmFwaD4KICAgICAqCiAgICAgKiBBYm92ZSBpcyBhIHNhbXBsZSBvZiBIVE1MIGNvZGUsIHRoYXQgZ29lcyB0aHJvdWdoIGF1dG9wYXJhZ3JhcGhpbmcgKGZpcnN0IHN0ZXApIGFuZCB0aGVuIGlzIGNvbnZlcnRlZCAoc2Vjb25kIHN0ZXApLgogICAgICogRXZlbiB0aG91Z2ggYDxzdHJvbmc+YCBpcyBvdmVyIGA8cD5gIGVsZW1lbnQsIGBib2xkPSJ0cnVlImAgd2FzIGFkZGVkIHRvIHRoZSB0ZXh0LiBTZWUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2F0dHJpYnV0ZVRvQXR0cmlidXRlfSBmb3IgY29tcGFyaXNvbi4KICAgICAqCiAgICAgKiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgYXR0cmlidXRlIHdpbGwgYmUgc2V0IG9ubHkgaWYgaXQgaXMgYWxsb3dlZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hIHNjaGVtYX0gY29uZmlndXJhdGlvbi4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiAnc3Ryb25nJywKICAgICAqCQkJbW9kZWw6ICdib2xkJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiAnc3Ryb25nJywKICAgICAqCQkJbW9kZWw6ICdib2xkJywKICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQljbGFzc2VzOiAnYm9sZCcKICAgICAqCQkJfSwKICAgICAqCQkJbW9kZWw6ICdib2xkJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQljbGFzc2VzOiBbICdzdHlsZWQnLCAnc3R5bGVkLWRhcmsnIF0KICAgICAqCQkJfSwKICAgICAqCQkJbW9kZWw6IHsKICAgICAqCQkJCWtleTogJ3N0eWxlZCcsCiAgICAgKgkJCQl2YWx1ZTogJ2RhcmsnCiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvQXR0cmlidXRlKCB7CiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCXN0eWxlczogewogICAgICoJCQkJCSdmb250LXNpemUnOiAvW1xzXFNdKy8KICAgICAqCQkJCX0KICAgICAqCQkJfSwKICAgICAqCQkJbW9kZWw6IHsKICAgICAqCQkJCWtleTogJ2ZvbnRTaXplJywKICAgICAqCQkJCXZhbHVlOiAoIHZpZXdFbGVtZW50LCBjb252ZXJzaW9uQXBpICkgPT4gewogICAgICoJCQkJCWNvbnN0IGZvbnRTaXplID0gdmlld0VsZW1lbnQuZ2V0U3R5bGUoICdmb250LXNpemUnICk7CiAgICAgKgkJCQkJY29uc3QgdmFsdWUgPSBmb250U2l6ZS5zdWJzdHIoIDAsIGZvbnRTaXplLmxlbmd0aCAtIDIgKTsKICAgICAqCiAgICAgKgkJCQkJaWYgKCB2YWx1ZSA8PSAxMCApIHsKICAgICAqCQkJCQkJcmV0dXJuICdzbWFsbCc7CiAgICAgKgkJCQkJfSBlbHNlIGlmICggdmFsdWUgPiAxMiApIHsKICAgICAqCQkJCQkJcmV0dXJuICdiaWcnOwogICAgICoJCQkJCX0KICAgICAqCiAgICAgKgkJCQkJcmV0dXJuIG51bGw7CiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjZWxlbWVudFRvQXR0cmlidXRlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59IGNvbmZpZy52aWV3IFBhdHRlcm4gbWF0Y2hpbmcgYWxsIHZpZXcgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGNvbnZlcnRlZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnLm1vZGVsIE1vZGVsIGF0dHJpYnV0ZSBrZXkgb3IgYW4gb2JqZWN0IHdpdGggYGtleWAgYW5kIGB2YWx1ZWAgcHJvcGVydGllcywgZGVzY3JpYmluZwogICAgICogdGhlIG1vZGVsIGF0dHJpYnV0ZS4gYHZhbHVlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZpZXcgZWxlbWVudCBhbmQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpIHVwY2FzdCBjb252ZXJzaW9uIEFQSX0gYW5kIHJldHVybnMgdGhlIHZhbHVlLgogICAgICogSWYgYFN0cmluZ2AgaXMgZ2l2ZW4sIHRoZSBtb2RlbCBhdHRyaWJ1dGUgdmFsdWUgd2lsbCBiZSBzZXQgdG8gYHRydWVgLgogICAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbG93J10gQ29udmVydGVyIHByaW9yaXR5LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnN9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZWxlbWVudFRvQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50VG9BdHRyaWJ1dGUoY29uZmlnKSB7CiAgICAgIHJldHVybiB0aGlzLmFkZCh1cGNhc3RFbGVtZW50VG9BdHRyaWJ1dGUoY29uZmlnKSk7CiAgICB9CiAgICAvKioKICAgICAqIFZpZXcgYXR0cmlidXRlIHRvIG1vZGVsIGF0dHJpYnV0ZSBjb252ZXJzaW9uIGhlbHBlci4KICAgICAqCiAgICAgKiBUaGlzIGNvbnZlcnNpb24gcmVzdWx0cyBpbiBzZXR0aW5nIGFuIGF0dHJpYnV0ZSBvbiBhIG1vZGVsIG5vZGUuIEZvciBleGFtcGxlLCB2aWV3IGA8aW1nIHNyYz0iZm9vLmpwZyI+PC9pbWc+YCBiZWNvbWVzCiAgICAgKiBgPGltYWdlIHNvdXJjZT0iZm9vLmpwZyI+PC9pbWFnZT5gIGluIHRoZSBtb2RlbC4KICAgICAqCiAgICAgKiBUaGlzIGhlbHBlciBpcyBtZWFudCB0byBjb252ZXJ0IHZpZXcgYXR0cmlidXRlcyBmcm9tIHZpZXcgZWxlbWVudHMgd2hpY2ggZ290IGNvbnZlcnRlZCB0byB0aGUgbW9kZWwsIHNvIHRoZSB2aWV3IGF0dHJpYnV0ZQogICAgICogaXMgc2V0IG9ubHkgb24gdGhlIGNvcnJlc3BvbmRpbmcgbW9kZWwgbm9kZToKICAgICAqCiAgICAgKgkJPGRpdiBjbGFzcz0iZGFyayI+PGRpdj5mb288L2Rpdj48L2Rpdj4gICAgLS0+ICAgIDxkaXYgZGFyaz0idHJ1ZSI+PGRpdj5mb288L2Rpdj48L2Rpdj4KICAgICAqCiAgICAgKiBBYm92ZSwgYGNsYXNzPSJkYXJrImAgYXR0cmlidXRlIGlzIGFkZGVkIG9ubHkgdG8gdGhlIGA8ZGl2PmAgZWxlbWVudHMgdGhhdCBoYXMgaXQuIFRoaXMgaXMgaW4gY29udHJhcnkgdG8KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb0F0dHJpYnV0ZX0gd2hpY2ggc2V0cyBhdHRyaWJ1dGVzIGZvcgogICAgICogYWxsIHRoZSBjaGlsZHJlbiBpbiB0aGUgbW9kZWw6CiAgICAgKgogICAgICoJCTxzdHJvbmc+Rm9vPC9zdHJvbmc+ICAgLS0+ICAgPHN0cm9uZz48cD5Gb288L3A+PC9zdHJvbmc+ICAgLS0+ICAgPHBhcmFncmFwaD48JHRleHQgYm9sZD0idHJ1ZSI+Rm9vPC8kdGV4dD48L3BhcmFncmFwaD4KICAgICAqCiAgICAgKiBBYm92ZSBpcyBhIHNhbXBsZSBvZiBIVE1MIGNvZGUsIHRoYXQgZ29lcyB0aHJvdWdoIGF1dG9wYXJhZ3JhcGhpbmcgKGZpcnN0IHN0ZXApIGFuZCB0aGVuIGlzIGNvbnZlcnRlZCAoc2Vjb25kIHN0ZXApLgogICAgICogRXZlbiB0aG91Z2ggYDxzdHJvbmc+YCBpcyBvdmVyIGA8cD5gIGVsZW1lbnQsIGBib2xkPSJ0cnVlImAgd2FzIGFkZGVkIHRvIHRoZSB0ZXh0LgogICAgICoKICAgICAqIEtlZXAgaW4gbWluZCB0aGF0IHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQgb25seSBpZiBpdCBpcyBhbGxvd2VkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfSBjb25maWd1cmF0aW9uLgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogJ3NyYycsCiAgICAgKgkJCW1vZGVsOiAnc291cmNlJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCXZpZXc6IHsga2V5OiAnc3JjJyB9LAogICAgICoJCQltb2RlbDogJ3NvdXJjZScKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiB7IGtleTogJ3NyYycgfSwKICAgICAqCQkJbW9kZWw6ICdzb3VyY2UnLAogICAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ25vcm1hbCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQlrZXk6ICdkYXRhLXN0eWxlJywKICAgICAqCQkJCXZhbHVlOiAvW1xzXFNdKy8KICAgICAqCQkJfSwKICAgICAqCQkJbW9kZWw6ICdzdHlsZWQnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogewogICAgICoJCQkJbmFtZTogJ2ltZycsCiAgICAgKgkJCQlrZXk6ICdjbGFzcycsCiAgICAgKgkJCQl2YWx1ZTogJ3N0eWxlZC1kYXJrJwogICAgICoJCQl9LAogICAgICoJCQltb2RlbDogewogICAgICoJCQkJa2V5OiAnc3R5bGVkJywKICAgICAqCQkJCXZhbHVlOiAnZGFyaycKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCWtleTogJ2NsYXNzJywKICAgICAqCQkJCXZhbHVlOiAvc3R5bGVkLVtcU10rLwogICAgICoJCQl9LAogICAgICoJCQltb2RlbDogewogICAgICoJCQkJa2V5OiAnc3R5bGVkJwogICAgICoJCQkJdmFsdWU6ICggdmlld0VsZW1lbnQsIGNvbnZlcnNpb25BcGkgKSA9PiB7CiAgICAgKgkJCQkJY29uc3QgcmVnZXhwID0gL3N0eWxlZC0oW1xTXSspLzsKICAgICAqCQkJCQljb25zdCBtYXRjaCA9IHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NsYXNzJyApLm1hdGNoKCByZWdleHAgKTsKICAgICAqCiAgICAgKgkJCQkJcmV0dXJuIG1hdGNoWyAxIF07CiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQ29udmVydGluZyBzdHlsZXMgd29ya3MgYSBiaXQgZGlmZmVyZW50bHkgYXMgaXQgcmVxdWlyZXMgYHZpZXcuc3R5bGVzYCB0byBiZSBhbiBvYmplY3QgYW5kIGJ5IGRlZmF1bHQKICAgICAqIGEgbW9kZWwgYXR0cmlidXRlIHdpbGwgYmUgc2V0IHRvIGB0cnVlYCBieSBzdWNoIGEgY29udmVydGVyLiBZb3UgY2FuIHNldCB0aGUgbW9kZWwgYXR0cmlidXRlIHRvIGFueSB2YWx1ZSBieSBwcm92aWRpbmcgdGhlIGB2YWx1ZWAKICAgICAqIGNhbGxiYWNrIHRoYXQgcmV0dXJucyB0aGUgZGVzaXJlZCB2YWx1ZS4KICAgICAqCiAgICAgKgkJLy8gRGVmYXVsdCBjb252ZXJzaW9uIG9mIGZvbnQtd2VpZ2h0IHN0eWxlIHdpbGwgcmVzdWx0IGluIHNldHRpbmcgYm9sZCBhdHRyaWJ1dGUgdG8gdHJ1ZS4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogewogICAgICoJCQkJc3R5bGVzOiB7CiAgICAgKgkJCQkJJ2ZvbnQtd2VpZ2h0JzogJ2JvbGQnCiAgICAgKgkJCQl9CiAgICAgKgkJCX0sCiAgICAgKgkJCW1vZGVsOiAnYm9sZCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIFRoaXMgY29udmVydGVyIHdpbGwgcGFzcyBhbnkgc3R5bGUgdmFsdWUgdG8gdGhlIGBsaW5lSGVpZ2h0YCBtb2RlbCBhdHRyaWJ1dGUuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCXN0eWxlczogewogICAgICoJCQkJCSdsaW5lLWhlaWdodCc6IC9bXHNcU10rLwogICAgICoJCQkJfQogICAgICoJCQl9LAogICAgICoJCQltb2RlbDogewogICAgICoJCQkJa2V5OiAnbGluZUhlaWdodCcsCiAgICAgKgkJCQl2YWx1ZTogKCB2aWV3RWxlbWVudCwgY29udmVyc2lvbkFwaSApID0+IHZpZXdFbGVtZW50LmdldFN0eWxlKCAnbGluZS1oZWlnaHQnICkKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqCiAgICAgKiBAbWV0aG9kICNhdHRyaWJ1dGVUb0F0dHJpYnV0ZQogICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy52aWV3IFNwZWNpZmllcyB3aGljaCB2aWV3IGF0dHJpYnV0ZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgYSBgU3RyaW5nYCBpcyBwYXNzZWQsCiAgICAgKiBhdHRyaWJ1dGVzIHdpdGggZ2l2ZW4ga2V5IHdpbGwgYmUgY29udmVydGVkLiBJZiBhbiBgT2JqZWN0YCBpcyBwYXNzZWQsIGl0IG11c3QgaGF2ZSBhIHJlcXVpcmVkIGBrZXlgIHByb3BlcnR5LAogICAgICogc3BlY2lmeWluZyB2aWV3IGF0dHJpYnV0ZSBrZXksIGFuZCBtYXkgaGF2ZSBhbiBvcHRpb25hbCBgdmFsdWVgIHByb3BlcnR5LCBzcGVjaWZ5aW5nIHZpZXcgYXR0cmlidXRlIHZhbHVlIGFuZCBvcHRpb25hbCBgbmFtZWAKICAgICAqIHByb3BlcnR5IHNwZWNpZnlpbmcgYSB2aWV3IGVsZW1lbnQgbmFtZSBmcm9tL29uIHdoaWNoIHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnZlcnRlZC4gYHZhbHVlYCBjYW4gYmUgZ2l2ZW4gYXMgYSBgU3RyaW5nYCwKICAgICAqIGEgYFJlZ0V4cGAgb3IgYSBmdW5jdGlvbiBjYWxsYmFjaywgdGhhdCB0YWtlcyB2aWV3IGF0dHJpYnV0ZSB2YWx1ZSBhcyB0aGUgb25seSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYEJvb2xlYW5gLgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcubW9kZWwgTW9kZWwgYXR0cmlidXRlIGtleSBvciBhbiBvYmplY3Qgd2l0aCBga2V5YCBhbmQgYHZhbHVlYCBwcm9wZXJ0aWVzLCBkZXNjcmliaW5nCiAgICAgKiB0aGUgbW9kZWwgYXR0cmlidXRlLiBgdmFsdWVgIHByb3BlcnR5IG1heSBiZSBzZXQgYXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGkgdXBjYXN0IGNvbnZlcnNpb24gQVBJfSBhbmQgcmV0dXJucyB0aGUgdmFsdWUuCiAgICAgKiBJZiBgU3RyaW5nYCBpcyBnaXZlbiwgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlIHNhbWUgYXMgdmlldyBhdHRyaWJ1dGUgdmFsdWUuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdsb3cnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVyc30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJhdHRyaWJ1dGVUb0F0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlVG9BdHRyaWJ1dGUoY29uZmlnKSB7CiAgICAgIHJldHVybiB0aGlzLmFkZCh1cGNhc3RBdHRyaWJ1dGVUb0F0dHJpYnV0ZShjb25maWcpKTsKICAgIH0KICAgIC8qKgogICAgICogVmlldyBlbGVtZW50IHRvIG1vZGVsIG1hcmtlciBjb252ZXJzaW9uIGhlbHBlci4KICAgICAqCiAgICAgKiAqKk5vdGUqKjogVGhpcyBtZXRob2Qgd2FzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2Uge0BsaW5rICNkYXRhVG9NYXJrZXJ9IGluc3RlYWQuCiAgICAgKgogICAgICogVGhpcyBjb252ZXJzaW9uIHJlc3VsdHMgaW4gY3JlYXRpbmcgYSBtb2RlbCBtYXJrZXIuIEZvciBleGFtcGxlLCBpZiB0aGUgbWFya2VyIHdhcyBzdG9yZWQgaW4gYSB2aWV3IGFzIGFuIGVsZW1lbnQ6CiAgICAgKiBgPHA+Rm88c3BhbiBkYXRhLW1hcmtlcj0iY29tbWVudCIgZGF0YS1jb21tZW50LWlkPSI3Ij48L3NwYW4+bzwvcD48cD5CPHNwYW4gZGF0YS1tYXJrZXI9ImNvbW1lbnQiIGRhdGEtY29tbWVudC1pZD0iNyI+PC9zcGFuPmFyPC9wPmAsCiAgICAgKiBhZnRlciB0aGUgY29udmVyc2lvbiBpcyBkb25lLCB0aGUgbWFya2VyIHdpbGwgYmUgYXZhaWxhYmxlIGluCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNtYXJrZXJzIG1vZGVsIGRvY3VtZW50IG1hcmtlcnN9LgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvTWFya2VyKCB7CiAgICAgKgkJCXZpZXc6ICdtYXJrZXItc2VhcmNoJywKICAgICAqCQkJbW9kZWw6ICdzZWFyY2gnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvTWFya2VyKCB7CiAgICAgKgkJCXZpZXc6ICdtYXJrZXItc2VhcmNoJywKICAgICAqCQkJbW9kZWw6ICdzZWFyY2gnLAogICAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvTWFya2VyKCB7CiAgICAgKgkJCXZpZXc6ICdtYXJrZXItc2VhcmNoJywKICAgICAqCQkJbW9kZWw6ICggdmlld0VsZW1lbnQsIGNvbnZlcnNpb25BcGkgKSA9PiAnY29tbWVudDonICsgdmlld0VsZW1lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1jb21tZW50LWlkJyApCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvTWFya2VyKCB7CiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCWF0dHJpYnV0ZXM6IHsKICAgICAqCQkJCQknZGF0YS1tYXJrZXInOiAnc2VhcmNoJwogICAgICoJCQkJfQogICAgICoJCQl9LAogICAgICoJCQltb2RlbDogJ3NlYXJjaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQGRlcHJlY2F0ZWQKICAgICAqIEBtZXRob2QgI2VsZW1lbnRUb01hcmtlcgogICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBjb25maWcudmlldyBQYXR0ZXJuIG1hdGNoaW5nIGFsbCB2aWV3IGVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBjb252ZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gY29uZmlnLm1vZGVsIE5hbWUgb2YgdGhlIG1vZGVsIG1hcmtlciwgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zCiAgICAgKiBhIG1vZGVsIG1hcmtlciBuYW1lLgogICAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnN9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZWxlbWVudFRvTWFya2VyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50VG9NYXJrZXIoY29uZmlnKSB7CiAgICAgIC8qKgogICAgICAgKiBUaGUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnMjZWxlbWVudFRvTWFya2VyIGBVcGNhc3RIZWxwZXJzI2VsZW1lbnRUb01hcmtlcigpYH0KICAgICAgICogbWV0aG9kIHdhcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlLgogICAgICAgKiBQbGVhc2UgdXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2RhdGFUb01hcmtlciBgVXBjYXN0SGVscGVycyNkYXRhVG9NYXJrZXIoKWB9IGluc3RlYWQuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciB1cGNhc3QtaGVscGVycy1lbGVtZW50LXRvLW1hcmtlci1kZXByZWNhdGVkCiAgICAgICAqLwogICAgICBsb2dXYXJuaW5nKCd1cGNhc3QtaGVscGVycy1lbGVtZW50LXRvLW1hcmtlci1kZXByZWNhdGVkJyk7CiAgICAgIHJldHVybiB0aGlzLmFkZCh1cGNhc3RFbGVtZW50VG9NYXJrZXIoY29uZmlnKSk7CiAgICB9CiAgICAvKioKICAgICAqIFZpZXctdG8tbW9kZWwgbWFya2VyIGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIENvbnZlcnRzIHZpZXcgZGF0YSBjcmVhdGVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVycyNtYXJrZXJUb0RhdGEgYCNtYXJrZXJUb0RhdGEoKWB9CiAgICAgKiBiYWNrIHRvIGEgbW9kZWwgbWFya2VyLgogICAgICoKICAgICAqIFRoaXMgY29udmVydGVyIGxvb2tzIGZvciBzcGVjaWZpYyB2aWV3IGVsZW1lbnRzIGFuZCB2aWV3IGF0dHJpYnV0ZXMgdGhhdCBtYXJrIG1hcmtlciBib3VuZGFyaWVzLiBTZWUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVycyNtYXJrZXJUb0RhdGEgYCNtYXJrZXJUb0RhdGEoKWB9IHRvIGxlYXJuIHdoYXQgdmlldyBkYXRhCiAgICAgKiBpcyBleHBlY3RlZCBieSB0aGlzIGNvbnZlcnRlci4KICAgICAqCiAgICAgKiBUaGUgYGNvbmZpZy52aWV3YCBwcm9wZXJ0eSBpcyBlcXVhbCB0byB0aGUgbWFya2VyIGdyb3VwIG5hbWUgdG8gY29udmVydC4KICAgICAqCiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGNvbnZlcnRlciBjcmVhdGVzIG1hcmtlcnMgd2l0aCB0aGUgYGdyb3VwOm5hbWVgIG5hbWUgY29udmVudGlvbiAodG8gbWF0Y2ggdGhlIGRlZmF1bHQgYG1hcmtlclRvRGF0YWAgY29udmVyc2lvbikuCiAgICAgKgogICAgICogVGhlIGNvbnZlcnNpb24gY29uZmlndXJhdGlvbiBjYW4gdGFrZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBnZW5lcmF0ZSBhIG1hcmtlciBuYW1lLgogICAgICogSWYgc3VjaCBmdW5jdGlvbiBpcyBzZXQgYXMgdGhlIGBjb25maWcubW9kZWxgIHBhcmFtZXRlciwgaXQgaXMgcGFzc2VkIHRoZSBgbmFtZWAgcGFydCBmcm9tIHRoZSB2aWV3IGVsZW1lbnQgb3IgYXR0cmlidXRlIGFuZCBpdCBpcwogICAgICogZXhwZWN0ZWQgdG8gcmV0dXJuIGEgc3RyaW5nIHdpdGggdGhlIG1hcmtlciBuYW1lLgogICAgICoKICAgICAqIEJhc2ljIHVzYWdlOgogICAgICoKICAgICAqCQkvLyBVc2luZyB0aGUgZGVmYXVsdCBjb252ZXJzaW9uLgogICAgICoJCS8vIEluIHRoaXMgY2FzZSwgYWxsIG1hcmtlcnMgZnJvbSB0aGUgYGNvbW1lbnRgIGdyb3VwIHdpbGwgYmUgY29udmVydGVkLgogICAgICoJCS8vIFRoZSBjb252ZXJzaW9uIHdpbGwgbG9vayBmb3IgYDxjb21tZW50LXN0YXJ0PmAgYW5kIGA8Y29tbWVudC1lbmQ+YCB0YWdzIGFuZAogICAgICoJCS8vIGBkYXRhLWNvbW1lbnQtc3RhcnQtYmVmb3JlYCwgYGRhdGEtY29tbWVudC1zdGFydC1hZnRlcmAsCiAgICAgKgkJLy8gYGRhdGEtY29tbWVudC1lbmQtYmVmb3JlYCBhbmQgYGRhdGEtY29tbWVudC1lbmQtYWZ0ZXJgIGF0dHJpYnV0ZXMuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmRhdGFUb01hcmtlciggewogICAgICoJCQl2aWV3OiAnY29tbWVudCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQW4gZXhhbXBsZSBvZiBhIG1vZGVsIHRoYXQgbWF5IGJlIGdlbmVyYXRlZCBieSB0aGlzIGNvbnZlcnNpb246CiAgICAgKgogICAgICoJCS8vIFZpZXc6CiAgICAgKgkJPHA+Rm9vPGNvbW1lbnQtc3RhcnQgbmFtZT0iY29tbWVudElkOnVpZCI+PC9jb21tZW50LXN0YXJ0PmJhcjwvcD4KICAgICAqCQk8ZmlndXJlIGRhdGEtY29tbWVudC1lbmQtYWZ0ZXI9ImNvbW1lbnRJZDp1aWQiIGNsYXNzPSJpbWFnZSI+PGltZyBzcmM9ImFiYy5qcGciIC8+PC9maWd1cmU+CiAgICAgKgogICAgICoJCS8vIE1vZGVsOgogICAgICoJCTxwYXJhZ3JhcGg+Rm9vW2JhcjwvcGFyYWdyYXBoPgogICAgICoJCTxpbWFnZSBzcmM9ImFiYy5qcGciPjwvaW1hZ2U+XQogICAgICoKICAgICAqIFdoZXJlIGBbXWAgYXJlIGJvdW5kYXJpZXMgb2YgYSBtYXJrZXIgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGBjb21tZW50OmNvbW1lbnRJZDp1aWRgIG5hbWUuCiAgICAgKgogICAgICogT3RoZXIgZXhhbXBsZXMgb2YgdXNhZ2U6CiAgICAgKgogICAgICoJCS8vIFVzaW5nIGEgY3VzdG9tIGZ1bmN0aW9uIHdoaWNoIGlzIHRoZSBzYW1lIGFzIHRoZSBkZWZhdWx0IGNvbnZlcnNpb246CiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmRhdGFUb01hcmtlciggewogICAgICoJCQl2aWV3OiAnY29tbWVudCcsCiAgICAgKgkJCW1vZGVsOiAoIG5hbWUsIGNvbnZlcnNpb25BcGkgKSA9PiAnY29tbWVudDonICsgbmFtZSwKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIFVzaW5nIHRoZSBjb252ZXJ0ZXIgcHJpb3JpdHk6CiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmRhdGFUb01hcmtlciggewogICAgICoJCQl2aWV3OiAnY29tbWVudCcsCiAgICAgKgkJCW1vZGVsOiAoIG5hbWUsIGNvbnZlcnNpb25BcGkgKSA9PiAnY29tbWVudDonICsgbmFtZSwKICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqCiAgICAgKiBAbWV0aG9kICNkYXRhVG9NYXJrZXIKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgogICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy52aWV3IFRoZSBtYXJrZXIgZ3JvdXAgbmFtZSB0byBjb252ZXJ0LgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5tb2RlbF0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBgbmFtZWAgcGFydCBmcm9tIHRoZSB2aWV3IGVsZW1lbnQgb3IgYXR0cmlidXRlIGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGkgdXBjYXN0IGNvbnZlcnNpb24gQVBJfSBhbmQgcmV0dXJucyB0aGUgbWFya2VyIG5hbWUuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVyc30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJkYXRhVG9NYXJrZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFUb01hcmtlcihjb25maWcpIHsKICAgICAgcmV0dXJuIHRoaXMuYWRkKHVwY2FzdERhdGFUb01hcmtlcihjb25maWcpKTsKICAgIH0KICB9XSk7CgogIHJldHVybiBVcGNhc3RIZWxwZXJzOwp9KENvbnZlcnNpb25IZWxwZXJzKTsKLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnksIGNyZWF0ZXMgYSBjb252ZXJ0ZXIgdGhhdCBjb252ZXJ0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCB2aWV3IGRvY3VtZW50IGZyYWdtZW50fQogKiBvciBhbGwgY2hpbGRyZW4gb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGludG8KICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGRvY3VtZW50IGZyYWdtZW50fS4KICogVGhpcyBpcyB0aGUgImVudHJ5LXBvaW50IiBjb252ZXJ0ZXIgZm9yIHVwY2FzdCAodmlldyB0byBtb2RlbCBjb252ZXJzaW9uKS4gVGhpcyBjb252ZXJ0ZXIgc3RhcnRzIHRoZSBjb252ZXJzaW9uIG9mIGFsbCBjaGlsZHJlbgogKiBvZiBwYXNzZWQgdmlldyBkb2N1bWVudCBmcmFnbWVudC4gVGhvc2UgY2hpbGRyZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgdmlldyBub2Rlc30gYXJlIHRoZW4gaGFuZGxlZCBieSBvdGhlciBjb252ZXJ0ZXJzLgogKgogKiBUaGlzIGFsc28gYSAiZGVmYXVsdCIsIGxhc3QgcmVzb3J0IGNvbnZlcnRlciBmb3IgYWxsIHZpZXcgZWxlbWVudHMgdGhhdCBoYXMgbm90IGJlZW4gY29udmVydGVkIGJ5IG90aGVyIGNvbnZlcnRlcnMuCiAqIFdoZW4gYSB2aWV3IGVsZW1lbnQgaXMgYmVpbmcgY29udmVydGVkIHRvIHRoZSBtb2RlbCBidXQgaXQgZG9lcyBub3QgaGF2ZSBjb252ZXJ0ZXIgc3BlY2lmaWVkLCB0aGF0IHZpZXcgZWxlbWVudAogKiB3aWxsIGJlIGNvbnZlcnRlZCB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgbW9kZWwgZG9jdW1lbnQgZnJhZ21lbnR9IGFuZCByZXR1cm5lZC4KICoKICogQHJldHVybnMge0Z1bmN0aW9ufSBVbml2ZXJzYWwgY29udmVydGVyIGZvciB2aWV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IGZyYWdtZW50c30gYW5kCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IGVsZW1lbnRzfSB0aGF0IHJldHVybnMKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGZyYWdtZW50fSB3aXRoIGNoaWxkcmVuIG9mIGNvbnZlcnRlZCB2aWV3IGl0ZW0uCiAqLwoKCmV4cG9ydCB7IFVwY2FzdEhlbHBlcnMgYXMgZGVmYXVsdCB9OwpleHBvcnQgZnVuY3Rpb24gY29udmVydFRvTW9kZWxGcmFnbWVudCgpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgLy8gU2Vjb25kIGFyZ3VtZW50IGluIGBjb25zdW1hYmxlLmNvbnN1bWVgIGlzIGRpc2NhcmRlZCBmb3IgVmlld0RvY3VtZW50RnJhZ21lbnQgYnV0IGlzIG5lZWRlZCBmb3IgVmlld0VsZW1lbnQuCiAgICBpZiAoIWRhdGEubW9kZWxSYW5nZSAmJiBjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLnZpZXdJdGVtLCB7CiAgICAgIG5hbWU6IHRydWUKICAgIH0pKSB7CiAgICAgIHZhciBfY29udmVyc2lvbkFwaSRjb252ZXIgPSBjb252ZXJzaW9uQXBpLmNvbnZlcnRDaGlsZHJlbihkYXRhLnZpZXdJdGVtLCBkYXRhLm1vZGVsQ3Vyc29yKSwKICAgICAgICAgIG1vZGVsUmFuZ2UgPSBfY29udmVyc2lvbkFwaSRjb252ZXIubW9kZWxSYW5nZSwKICAgICAgICAgIG1vZGVsQ3Vyc29yID0gX2NvbnZlcnNpb25BcGkkY29udmVyLm1vZGVsQ3Vyc29yOwoKICAgICAgZGF0YS5tb2RlbFJhbmdlID0gbW9kZWxSYW5nZTsKICAgICAgZGF0YS5tb2RlbEN1cnNvciA9IG1vZGVsQ3Vyc29yOwogICAgfQogIH07Cn0KLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnksIGNyZWF0ZXMgYSBjb252ZXJ0ZXIgdGhhdCBjb252ZXJ0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0fS4KICoKICogQHJldHVybnMge0Z1bmN0aW9ufSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCBWaWV3IHRleHR9IGNvbnZlcnRlci4KICovCgpleHBvcnQgZnVuY3Rpb24gY29udmVydFRleHQoKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChldnQsIGRhdGEsIF9yZWYpIHsKICAgIHZhciBzY2hlbWEgPSBfcmVmLnNjaGVtYSwKICAgICAgICBjb25zdW1hYmxlID0gX3JlZi5jb25zdW1hYmxlLAogICAgICAgIHdyaXRlciA9IF9yZWYud3JpdGVyOwogICAgdmFyIHBvc2l0aW9uID0gZGF0YS5tb2RlbEN1cnNvcjsgLy8gV2hlbiBub2RlIGlzIGFscmVhZHkgY29udmVydGVkIHRoZW4gZG8gbm90aGluZy4KCiAgICBpZiAoIWNvbnN1bWFibGUudGVzdChkYXRhLnZpZXdJdGVtKSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKCFzY2hlbWEuY2hlY2tDaGlsZChwb3NpdGlvbiwgJyR0ZXh0JykpIHsKICAgICAgaWYgKCFpc1BhcmFncmFwaGFibGUocG9zaXRpb24sICckdGV4dCcsIHNjaGVtYSkpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHBvc2l0aW9uID0gd3JhcEluUGFyYWdyYXBoKHBvc2l0aW9uLCB3cml0ZXIpOwogICAgfQoKICAgIGNvbnN1bWFibGUuY29uc3VtZShkYXRhLnZpZXdJdGVtKTsKICAgIHZhciB0ZXh0ID0gd3JpdGVyLmNyZWF0ZVRleHQoZGF0YS52aWV3SXRlbS5kYXRhKTsKICAgIHdyaXRlci5pbnNlcnQodGV4dCwgcG9zaXRpb24pOwogICAgZGF0YS5tb2RlbFJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKHBvc2l0aW9uLCBwb3NpdGlvbi5nZXRTaGlmdGVkQnkodGV4dC5vZmZzZXRTaXplKSk7CiAgICBkYXRhLm1vZGVsQ3Vyc29yID0gZGF0YS5tb2RlbFJhbmdlLmVuZDsKICB9Owp9Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5LCBjcmVhdGVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY29udmVydHMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3NlbGVjdGlvbn5TZWxlY3Rpb24KICogdmlldyBzZWxlY3Rpb259IHRha2VuIGZyb20gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnR+RG9jdW1lbnQjZXZlbnQ6c2VsZWN0aW9uQ2hhbmdlfSBldmVudAogKiBhbmQgc2V0cyBpbiBvbiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjc2VsZWN0aW9uIG1vZGVsfS4KICoKICogKipOb3RlKio6IGJlY2F1c2UgdGhlcmUgaXMgbm8gdmlldyBzZWxlY3Rpb24gY2hhbmdlIGRpc3BhdGNoZXIgbm9yIGFueSBvdGhlciBhZHZhbmNlZCB2aWV3IHNlbGVjdGlvbiB0byBtb2RlbAogKiBjb252ZXJzaW9uIG1lY2hhbmlzbSwgdGhlIGNhbGxiYWNrIHNob3VsZCBiZSBzZXQgZGlyZWN0bHkgb24gdmlldyBkb2N1bWVudC4KICoKICoJCXZpZXcuZG9jdW1lbnQub24oICdzZWxlY3Rpb25DaGFuZ2UnLCBjb252ZXJ0U2VsZWN0aW9uQ2hhbmdlKCBtb2RlbERvY3VtZW50LCBtYXBwZXIgKSApOwogKgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9IG1vZGVsIERhdGEgbW9kZWwuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXJ9IG1hcHBlciBDb252ZXJzaW9uIG1hcHBlci4KICogQHJldHVybnMge0Z1bmN0aW9ufSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50fkRvY3VtZW50I2V2ZW50OnNlbGVjdGlvbkNoYW5nZX0gY2FsbGJhY2sgZnVuY3Rpb24uCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTZWxlY3Rpb25DaGFuZ2UobW9kZWwsIG1hcHBlcikgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhKSB7CiAgICB2YXIgdmlld1NlbGVjdGlvbiA9IGRhdGEubmV3U2VsZWN0aW9uOwogICAgdmFyIHJhbmdlcyA9IFtdOwoKICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih2aWV3U2VsZWN0aW9uLmdldFJhbmdlcygpKSwKICAgICAgICBfc3RlcDsKCiAgICB0cnkgewogICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykgewogICAgICAgIHZhciB2aWV3UmFuZ2UgPSBfc3RlcC52YWx1ZTsKICAgICAgICByYW5nZXMucHVzaChtYXBwZXIudG9Nb2RlbFJhbmdlKHZpZXdSYW5nZSkpOwogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgIH0gZmluYWxseSB7CiAgICAgIF9pdGVyYXRvci5mKCk7CiAgICB9CgogICAgdmFyIG1vZGVsU2VsZWN0aW9uID0gbW9kZWwuY3JlYXRlU2VsZWN0aW9uKHJhbmdlcywgewogICAgICBiYWNrd2FyZDogdmlld1NlbGVjdGlvbi5pc0JhY2t3YXJkCiAgICB9KTsKCiAgICBpZiAoIW1vZGVsU2VsZWN0aW9uLmlzRXF1YWwobW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uKSkgewogICAgICBtb2RlbC5jaGFuZ2UoZnVuY3Rpb24gKHdyaXRlcikgewogICAgICAgIHdyaXRlci5zZXRTZWxlY3Rpb24obW9kZWxTZWxlY3Rpb24pOwogICAgICB9KTsKICAgIH0KICB9Owp9IC8vIFZpZXcgZWxlbWVudCB0byBtb2RlbCBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb0VsZW1lbnQgYC5lbGVtZW50VG9FbGVtZW50KClgIHVwY2FzdCBoZWxwZXJ9IGZvciBleGFtcGxlcy4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59IFtjb25maWcudmlld10gUGF0dGVybiBtYXRjaGluZyBhbGwgdmlldyBlbGVtZW50cyB3aGljaCBzaG91bGQgYmUgY29udmVydGVkLiBJZiBub3QKLy8gc2V0LCB0aGUgY29udmVydGVyIHdpbGwgZmlyZSBmb3IgZXZlcnkgdmlldyBlbGVtZW50LgovLyBAcGFyYW0ge1N0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxGdW5jdGlvbn0gY29uZmlnLm1vZGVsIE5hbWUgb2YgdGhlIG1vZGVsIGVsZW1lbnQsIGEgbW9kZWwgZWxlbWVudAovLyBpbnN0YW5jZSBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2aWV3IGVsZW1lbnQgYW5kIHJldHVybnMgYSBtb2RlbCBlbGVtZW50LiBUaGUgbW9kZWwgZWxlbWVudCB3aWxsIGJlIGluc2VydGVkIGluIHRoZSBtb2RlbC4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKZnVuY3Rpb24gdXBjYXN0RWxlbWVudFRvRWxlbWVudChjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICB2YXIgY29udmVydGVyID0gcHJlcGFyZVRvRWxlbWVudENvbnZlcnRlcihjb25maWcpOwogIHZhciBlbGVtZW50TmFtZSA9IGdldFZpZXdFbGVtZW50TmFtZUZyb21Db25maWcoY29uZmlnLnZpZXcpOwogIHZhciBldmVudE5hbWUgPSBlbGVtZW50TmFtZSA/ICdlbGVtZW50OicgKyBlbGVtZW50TmFtZSA6ICdlbGVtZW50JzsKICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsKICAgIGRpc3BhdGNoZXIub24oZXZlbnROYW1lLCBjb252ZXJ0ZXIsIHsKICAgICAgcHJpb3JpdHk6IGNvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eSB8fCAnbm9ybWFsJwogICAgfSk7CiAgfTsKfSAvLyBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgYXR0cmlidXRlIGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb0F0dHJpYnV0ZSBgLmVsZW1lbnRUb0F0dHJpYnV0ZSgpYCB1cGNhc3QgaGVscGVyfSBmb3IgZXhhbXBsZXMuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBjb25maWcudmlldyBQYXR0ZXJuIG1hdGNoaW5nIGFsbCB2aWV3IGVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBjb252ZXJ0ZWQuCi8vIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnLm1vZGVsIE1vZGVsIGF0dHJpYnV0ZSBrZXkgb3IgYW4gb2JqZWN0IHdpdGggYGtleWAgYW5kIGB2YWx1ZWAgcHJvcGVydGllcywgZGVzY3JpYmluZwovLyB0aGUgbW9kZWwgYXR0cmlidXRlLiBgdmFsdWVgIHByb3BlcnR5IG1heSBiZSBzZXQgYXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zIHRoZSB2YWx1ZS4KLy8gSWYgYFN0cmluZ2AgaXMgZ2l2ZW4sIHRoZSBtb2RlbCBhdHRyaWJ1dGUgdmFsdWUgd2lsbCBiZSBzZXQgdG8gYHRydWVgLgovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdsb3cnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gdXBjYXN0RWxlbWVudFRvQXR0cmlidXRlKGNvbmZpZykgewogIGNvbmZpZyA9IGNsb25lRGVlcChjb25maWcpOwogIG5vcm1hbGl6ZU1vZGVsQXR0cmlidXRlQ29uZmlnKGNvbmZpZyk7CiAgdmFyIGNvbnZlcnRlciA9IHByZXBhcmVUb0F0dHJpYnV0ZUNvbnZlcnRlcihjb25maWcsIGZhbHNlKTsKICB2YXIgZWxlbWVudE5hbWUgPSBnZXRWaWV3RWxlbWVudE5hbWVGcm9tQ29uZmlnKGNvbmZpZy52aWV3KTsKICB2YXIgZXZlbnROYW1lID0gZWxlbWVudE5hbWUgPyAnZWxlbWVudDonICsgZWxlbWVudE5hbWUgOiAnZWxlbWVudCc7CiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7CiAgICBkaXNwYXRjaGVyLm9uKGV2ZW50TmFtZSwgY29udmVydGVyLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ2xvdycKICAgIH0pOwogIH07Cn0gLy8gVmlldyBhdHRyaWJ1dGUgdG8gbW9kZWwgYXR0cmlidXRlIGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5VcGNhc3RIZWxwZXJzI2F0dHJpYnV0ZVRvQXR0cmlidXRlIGAuYXR0cmlidXRlVG9BdHRyaWJ1dGUoKWAgdXBjYXN0IGhlbHBlcn0gZm9yIGV4YW1wbGVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcudmlldyBTcGVjaWZpZXMgd2hpY2ggdmlldyBhdHRyaWJ1dGUgd2lsbCBiZSBjb252ZXJ0ZWQuIElmIGEgYFN0cmluZ2AgaXMgcGFzc2VkLAovLyBhdHRyaWJ1dGVzIHdpdGggZ2l2ZW4ga2V5IHdpbGwgYmUgY29udmVydGVkLiBJZiBhbiBgT2JqZWN0YCBpcyBwYXNzZWQsIGl0IG11c3QgaGF2ZSBhIHJlcXVpcmVkIGBrZXlgIHByb3BlcnR5LAovLyBzcGVjaWZ5aW5nIHZpZXcgYXR0cmlidXRlIGtleSwgYW5kIG1heSBoYXZlIGFuIG9wdGlvbmFsIGB2YWx1ZWAgcHJvcGVydHksIHNwZWNpZnlpbmcgdmlldyBhdHRyaWJ1dGUgdmFsdWUgYW5kIG9wdGlvbmFsIGBuYW1lYAovLyBwcm9wZXJ0eSBzcGVjaWZ5aW5nIGEgdmlldyBlbGVtZW50IG5hbWUgZnJvbS9vbiB3aGljaCB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSBjb252ZXJ0ZWQuIGB2YWx1ZWAgY2FuIGJlIGdpdmVuIGFzIGEgYFN0cmluZ2AsCi8vIGEgYFJlZ0V4cGAgb3IgYSBmdW5jdGlvbiBjYWxsYmFjaywgdGhhdCB0YWtlcyB2aWV3IGF0dHJpYnV0ZSB2YWx1ZSBhcyB0aGUgb25seSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYEJvb2xlYW5gLgovLyBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy5tb2RlbCBNb2RlbCBhdHRyaWJ1dGUga2V5IG9yIGFuIG9iamVjdCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMsIGRlc2NyaWJpbmcKLy8gdGhlIG1vZGVsIGF0dHJpYnV0ZS4gYHZhbHVlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZpZXcgZWxlbWVudCBhbmQgcmV0dXJucyB0aGUgdmFsdWUuCi8vIElmIGBTdHJpbmdgIGlzIGdpdmVuLCB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIHdpbGwgYmUgc2FtZSBhcyB2aWV3IGF0dHJpYnV0ZSB2YWx1ZS4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbG93J10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIHVwY2FzdEF0dHJpYnV0ZVRvQXR0cmlidXRlKGNvbmZpZykgewogIGNvbmZpZyA9IGNsb25lRGVlcChjb25maWcpOwogIHZhciB2aWV3S2V5ID0gbnVsbDsKCiAgaWYgKHR5cGVvZiBjb25maWcudmlldyA9PSAnc3RyaW5nJyB8fCBjb25maWcudmlldy5rZXkpIHsKICAgIHZpZXdLZXkgPSBub3JtYWxpemVWaWV3QXR0cmlidXRlS2V5VmFsdWVDb25maWcoY29uZmlnKTsKICB9CgogIG5vcm1hbGl6ZU1vZGVsQXR0cmlidXRlQ29uZmlnKGNvbmZpZywgdmlld0tleSk7CiAgdmFyIGNvbnZlcnRlciA9IHByZXBhcmVUb0F0dHJpYnV0ZUNvbnZlcnRlcihjb25maWcsIHRydWUpOwogIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2hlcikgewogICAgZGlzcGF0Y2hlci5vbignZWxlbWVudCcsIGNvbnZlcnRlciwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdsb3cnCiAgICB9KTsKICB9Owp9IC8vIFZpZXcgZWxlbWVudCB0byBtb2RlbCBtYXJrZXIgY29udmVyc2lvbiBoZWxwZXIuCi8vCi8vIFNlZSB7QGxpbmsgflVwY2FzdEhlbHBlcnMjZWxlbWVudFRvTWFya2VyIGAuZWxlbWVudFRvTWFya2VyKClgIHVwY2FzdCBoZWxwZXJ9IGZvciBleGFtcGxlcy4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59IGNvbmZpZy52aWV3IFBhdHRlcm4gbWF0Y2hpbmcgYWxsIHZpZXcgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGNvbnZlcnRlZC4KLy8gQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGNvbmZpZy5tb2RlbCBOYW1lIG9mIHRoZSBtb2RlbCBtYXJrZXIsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZpZXcgZWxlbWVudCBhbmQgcmV0dXJucwovLyBhIG1vZGVsIG1hcmtlciBuYW1lLgovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gdXBjYXN0RWxlbWVudFRvTWFya2VyKGNvbmZpZykgewogIGNvbmZpZyA9IGNsb25lRGVlcChjb25maWcpOwogIG5vcm1hbGl6ZUVsZW1lbnRUb01hcmtlckNvbmZpZyhjb25maWcpOwogIHJldHVybiB1cGNhc3RFbGVtZW50VG9FbGVtZW50KGNvbmZpZyk7Cn0gLy8gVmlldyBkYXRhIHRvIG1vZGVsIG1hcmtlciBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+VXBjYXN0SGVscGVycyNkYXRhVG9NYXJrZXJ9IHRvIGxlYXJuIG1vcmUuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcKLy8gQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy52aWV3Ci8vIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcubW9kZWxdCi8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb25maWcuY29udmVydGVyUHJpb3JpdHk9J25vcm1hbCddCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gdXBjYXN0RGF0YVRvTWFya2VyKGNvbmZpZykgewogIGNvbmZpZyA9IGNsb25lRGVlcChjb25maWcpOyAvLyBEZWZhdWx0IGNvbnZlcnNpb24uCgogIGlmICghY29uZmlnLm1vZGVsKSB7CiAgICBjb25maWcubW9kZWwgPSBmdW5jdGlvbiAobmFtZSkgewogICAgICByZXR1cm4gbmFtZSA/IGNvbmZpZy52aWV3ICsgJzonICsgbmFtZSA6IGNvbmZpZy52aWV3OwogICAgfTsKICB9CgogIHZhciBjb252ZXJ0ZXJTdGFydCA9IHByZXBhcmVUb0VsZW1lbnRDb252ZXJ0ZXIobm9ybWFsaXplRGF0YVRvTWFya2VyQ29uZmlnKGNvbmZpZywgJ3N0YXJ0JykpOwogIHZhciBjb252ZXJ0ZXJFbmQgPSBwcmVwYXJlVG9FbGVtZW50Q29udmVydGVyKG5vcm1hbGl6ZURhdGFUb01hcmtlckNvbmZpZyhjb25maWcsICdlbmQnKSk7CiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7CiAgICBkaXNwYXRjaGVyLm9uKCdlbGVtZW50OicgKyBjb25maWcudmlldyArICctc3RhcnQnLCBjb252ZXJ0ZXJTdGFydCwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdub3JtYWwnCiAgICB9KTsKICAgIGRpc3BhdGNoZXIub24oJ2VsZW1lbnQ6JyArIGNvbmZpZy52aWV3ICsgJy1lbmQnLCBjb252ZXJ0ZXJFbmQsIHsKICAgICAgcHJpb3JpdHk6IGNvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eSB8fCAnbm9ybWFsJwogICAgfSk7IC8vIEJlbG93IGlzIGEgaGFjayB0aGF0IGlzIG5lZWRlZCB0byBwcm9wZXJseSBoYW5kbGUgYGNvbnZlcnRlclByaW9yaXR5YCBmb3IgYm90aCBlbGVtZW50cyBhbmQgYXR0cmlidXRlcy4KICAgIC8vIEF0dHJpYnV0ZSBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCAqYWZ0ZXIqIGVsZW1lbnQgY29udmVyc2lvbi4KICAgIC8vIFRoaXMgY29udmVydGVyIGhhbmRsZXMgYm90aCBlbGVtZW50IGNvbnZlcnNpb24gYW5kIGF0dHJpYnV0ZSBjb252ZXJzaW9uLCB3aGljaCBtZWFucyB0aGF0IGlmIGEgc2luZ2xlCiAgICAvLyBgY29uZmlnLmNvbnZlcnRlclByaW9yaXR5YCBpcyB1c2VkLCBpdCB3aWxsIGxlYWQgdG8gcHJvYmxlbXMuIEZvciBleGFtcGxlLCBpZiBgJ2hpZ2gnYCBwcmlvcml0eSBpcyB1c2VkLAogICAgLy8gdGhlbiBhdHRyaWJ1dGUgY29udmVyc2lvbiB3aWxsIGJlIHBlcmZvcm1lZCBiZWZvcmUgYSBsb3Qgb2YgZWxlbWVudCB1cGNhc3QgY29udmVydGVycy4KICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kIHdlIHdhbnQgdG8gc3VwcG9ydCBgY29uZmlnLmNvbnZlcnRlclByaW9yaXR5YCBhbmQgb3ZlcndyaXRpbmcgY29udmV0ZXJzLgogICAgLy8KICAgIC8vIFRvIGhhdmUgaXQgd29yaywgd2UgbmVlZCB0byBkbyBzb21lIGV4dHJhIHByb2Nlc3NpbmcgZm9yIHByaW9yaXR5IGZvciBhdHRyaWJ1dGUgY29udmVydGVyLgogICAgLy8gUHJpb3JpdHkgYCdsb3cnYCB2YWx1ZSBzaG91bGQgYmUgdGhlIGJhc2UgdmFsdWUgYW5kIHRoZW4gd2Ugd2lsbCBjaGFuZ2UgaXQgZGVwZW5kaW5nIG9uIGBjb25maWcuY29udmVydGVyUHJpb3JpdHlgIHZhbHVlLgogICAgLy8KICAgIC8vIFRoaXMgaGFjayBwcm9iYWJseSB3b3VsZCBub3QgYmUgbmVlZGVkIGlmIGF0dHJpYnV0ZXMgYXJlIHVwY2FzdGVkIHNlcGFyYXRlbHkuCiAgICAvLwoKICAgIHZhciBiYXNlUHJpb3JpdHkgPSBwcmlvcml0aWVzLmdldCgnbG93Jyk7CiAgICB2YXIgbWF4UHJpb3JpdHkgPSBwcmlvcml0aWVzLmdldCgnaGlnaGVzdCcpOwogICAgdmFyIHByaW9yaXR5RmFjdG9yID0gcHJpb3JpdGllcy5nZXQoY29uZmlnLmNvbnZlcnRlclByaW9yaXR5KSAvIG1heFByaW9yaXR5OyAvLyBOdW1iZXIgaW4gcmFuZ2UgWyAtMSwgMSBdLgoKICAgIGRpc3BhdGNoZXIub24oJ2VsZW1lbnQnLCB1cGNhc3RBdHRyaWJ1dGVUb01hcmtlcihjb25maWcpLCB7CiAgICAgIHByaW9yaXR5OiBiYXNlUHJpb3JpdHkgKyBwcmlvcml0eUZhY3RvcgogICAgfSk7CiAgfTsKfSAvLyBGdW5jdGlvbiBmYWN0b3J5LCByZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY29udmVydHMgdmlldyBhdHRyaWJ1dGVzIHRvIGEgbW9kZWwgbWFya2VyLgovLwovLyBUaGUgY29udmVydGVyIGxvb2tzIGZvciBlbGVtZW50cyB3aXRoIGBkYXRhLWdyb3VwLXN0YXJ0LWJlZm9yZWAsIGBkYXRhLWdyb3VwLXN0YXJ0LWFmdGVyYCwgYGRhdGEtZ3JvdXAtZW5kLWJlZm9yZWAKLy8gYW5kIGBkYXRhLWdyb3VwLWVuZC1hZnRlcmAgYXR0cmlidXRlcyBhbmQgaW5zZXJ0cyBgJG1hcmtlcmAgbW9kZWwgZWxlbWVudHMgYmVmb3JlL2FmdGVyIHRob3NlIGVsZW1lbnRzLgovLyBgZ3JvdXBgIHBhcnQgaXMgc3BlY2lmaWVkIGluIGBjb25maWcudmlld2AuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcKLy8gQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy52aWV3Ci8vIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcubW9kZWxdCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gTWFya2VyIGNvbnZlcnRlci4KCgpmdW5jdGlvbiB1cGNhc3RBdHRyaWJ1dGVUb01hcmtlcihjb25maWcpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIGF0dHJOYW1lID0gImRhdGEtIi5jb25jYXQoY29uZmlnLnZpZXcpOyAvLyBUaGlzIGNvbnZlcnRlciB3YW50cyB0byBhZGQgYSBtb2RlbCBlbGVtZW50LCBtYXJraW5nIGEgbWFya2VyLCBiZWZvcmUvYWZ0ZXIgYW4gZWxlbWVudCAob3IgbWF5YmUgZXZlbiBncm91cCBvZiBlbGVtZW50cykuCiAgICAvLyBUbyBkbyB0aGF0LCB3ZSBjYW4gdXNlIGBkYXRhLm1vZGVsUmFuZ2VgIHdoaWNoIGlzIHNldCBvbiBhbiBlbGVtZW50IChvciBhIGdyb3VwIG9mIGVsZW1lbnRzKSB0aGF0IGhhcyBiZWVuIHVwY2FzdGVkLgogICAgLy8gQnV0LCBpZiB0aGUgcHJvY2Vzc2VkIHZpZXcgZWxlbWVudCBoYXMgbm90IGJlZW4gdXBjYXN0ZWQgeWV0IChpdCBkb2VzIG5vdCBoYXZlIGJlZW4gY29udmVydGVkKSwgd2UgbmVlZCB0bwogICAgLy8gZmlyZSBjb252ZXJzaW9uIGZvciBpdHMgY2hpbGRyZW4gZmlyc3QsIHRoZW4gd2Ugd2lsbCBoYXZlIGBkYXRhLm1vZGVsUmFuZ2VgIGF2YWlsYWJsZS4KCiAgICBpZiAoIWRhdGEubW9kZWxSYW5nZSkgewogICAgICBkYXRhID0gT2JqZWN0LmFzc2lnbihkYXRhLCBjb252ZXJzaW9uQXBpLmNvbnZlcnRDaGlsZHJlbihkYXRhLnZpZXdJdGVtLCBkYXRhLm1vZGVsQ3Vyc29yKSk7CiAgICB9CgogICAgaWYgKGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEudmlld0l0ZW0sIHsKICAgICAgYXR0cmlidXRlczogYXR0ck5hbWUgKyAnLWVuZC1hZnRlcicKICAgIH0pKSB7CiAgICAgIGFkZE1hcmtlckVsZW1lbnRzKGRhdGEubW9kZWxSYW5nZS5lbmQsIGRhdGEudmlld0l0ZW0uZ2V0QXR0cmlidXRlKGF0dHJOYW1lICsgJy1lbmQtYWZ0ZXInKS5zcGxpdCgnLCcpKTsKICAgIH0KCiAgICBpZiAoY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS52aWV3SXRlbSwgewogICAgICBhdHRyaWJ1dGVzOiBhdHRyTmFtZSArICctc3RhcnQtYWZ0ZXInCiAgICB9KSkgewogICAgICBhZGRNYXJrZXJFbGVtZW50cyhkYXRhLm1vZGVsUmFuZ2UuZW5kLCBkYXRhLnZpZXdJdGVtLmdldEF0dHJpYnV0ZShhdHRyTmFtZSArICctc3RhcnQtYWZ0ZXInKS5zcGxpdCgnLCcpKTsKICAgIH0KCiAgICBpZiAoY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS52aWV3SXRlbSwgewogICAgICBhdHRyaWJ1dGVzOiBhdHRyTmFtZSArICctZW5kLWJlZm9yZScKICAgIH0pKSB7CiAgICAgIGFkZE1hcmtlckVsZW1lbnRzKGRhdGEubW9kZWxSYW5nZS5zdGFydCwgZGF0YS52aWV3SXRlbS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUgKyAnLWVuZC1iZWZvcmUnKS5zcGxpdCgnLCcpKTsKICAgIH0KCiAgICBpZiAoY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS52aWV3SXRlbSwgewogICAgICBhdHRyaWJ1dGVzOiBhdHRyTmFtZSArICctc3RhcnQtYmVmb3JlJwogICAgfSkpIHsKICAgICAgYWRkTWFya2VyRWxlbWVudHMoZGF0YS5tb2RlbFJhbmdlLnN0YXJ0LCBkYXRhLnZpZXdJdGVtLmdldEF0dHJpYnV0ZShhdHRyTmFtZSArICctc3RhcnQtYmVmb3JlJykuc3BsaXQoJywnKSk7CiAgICB9CgogICAgZnVuY3Rpb24gYWRkTWFya2VyRWxlbWVudHMocG9zaXRpb24sIG1hcmtlclZpZXdOYW1lcykgewogICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG1hcmtlclZpZXdOYW1lcyksCiAgICAgICAgICBfc3RlcDI7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgbWFya2VyVmlld05hbWUgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgICB2YXIgbWFya2VyTmFtZSA9IGNvbmZpZy5tb2RlbChtYXJrZXJWaWV3TmFtZSwgY29udmVyc2lvbkFwaSk7CiAgICAgICAgICB2YXIgZWxlbWVudCA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZUVsZW1lbnQoJyRtYXJrZXInLCB7CiAgICAgICAgICAgICdkYXRhLW5hbWUnOiBtYXJrZXJOYW1lCiAgICAgICAgICB9KTsKICAgICAgICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLmluc2VydChlbGVtZW50LCBwb3NpdGlvbik7CgogICAgICAgICAgaWYgKGRhdGEubW9kZWxDdXJzb3IuaXNFcXVhbChwb3NpdGlvbikpIHsKICAgICAgICAgICAgZGF0YS5tb2RlbEN1cnNvciA9IGRhdGEubW9kZWxDdXJzb3IuZ2V0U2hpZnRlZEJ5KDEpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZGF0YS5tb2RlbEN1cnNvciA9IGRhdGEubW9kZWxDdXJzb3IuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24ocG9zaXRpb24sIDEpOwogICAgICAgICAgfQoKICAgICAgICAgIGRhdGEubW9kZWxSYW5nZSA9IGRhdGEubW9kZWxSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihwb3NpdGlvbiwgMSlbMF07CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IyLmYoKTsKICAgICAgfQogICAgfQogIH07Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBmcm9tLXZpZXctZWxlbWVudCBjb252ZXJzaW9uLiBDaGVja3MgaWYgYGNvbmZpZy52aWV3YCBkaXJlY3RseSBzcGVjaWZpZXMgY29udmVydGVkIHZpZXcgZWxlbWVudCdzIG5hbWUKLy8gYW5kIGlmIHNvLCByZXR1cm5zIGl0LgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gdmlldyBjb25maWcuCi8vIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gVmlldyBlbGVtZW50IG5hbWUgb3IgYG51bGxgIGlmIG5hbWUgaXMgbm90IGRpcmVjdGx5IHNldC4KCgpmdW5jdGlvbiBnZXRWaWV3RWxlbWVudE5hbWVGcm9tQ29uZmlnKHZpZXdDb25maWcpIHsKICBpZiAodHlwZW9mIHZpZXdDb25maWcgPT0gJ3N0cmluZycpIHsKICAgIHJldHVybiB2aWV3Q29uZmlnOwogIH0KCiAgaWYgKF90eXBlb2Yodmlld0NvbmZpZykgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZpZXdDb25maWcubmFtZSA9PSAnc3RyaW5nJykgewogICAgcmV0dXJuIHZpZXdDb25maWcubmFtZTsKICB9CgogIHJldHVybiBudWxsOwp9IC8vIEhlbHBlciBmb3IgdG8tbW9kZWwtZWxlbWVudCBjb252ZXJzaW9uLiBUYWtlcyBhIGNvbmZpZyBvYmplY3QgYW5kIHJldHVybnMgYSBwcm9wZXIgY29udmVydGVyIGZ1bmN0aW9uLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHJldHVybnMge0Z1bmN0aW9ufSBWaWV3IHRvIG1vZGVsIGNvbnZlcnRlci4KCgpmdW5jdGlvbiBwcmVwYXJlVG9FbGVtZW50Q29udmVydGVyKGNvbmZpZykgewogIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIoY29uZmlnLnZpZXcpOwogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICB2YXIgbWF0Y2hlclJlc3VsdCA9IG1hdGNoZXIubWF0Y2goZGF0YS52aWV3SXRlbSk7CgogICAgaWYgKCFtYXRjaGVyUmVzdWx0KSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgbWF0Y2ggPSBtYXRjaGVyUmVzdWx0Lm1hdGNoOyAvLyBGb3JjZSBjb25zdW1pbmcgZWxlbWVudCdzIG5hbWUuCgogICAgbWF0Y2gubmFtZSA9IHRydWU7CgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUudGVzdChkYXRhLnZpZXdJdGVtLCBtYXRjaCkpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciBtb2RlbEVsZW1lbnQgPSBnZXRNb2RlbEVsZW1lbnQoY29uZmlnLm1vZGVsLCBkYXRhLnZpZXdJdGVtLCBjb252ZXJzaW9uQXBpKTsKCiAgICBpZiAoIW1vZGVsRWxlbWVudCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKCFjb252ZXJzaW9uQXBpLnNhZmVJbnNlcnQobW9kZWxFbGVtZW50LCBkYXRhLm1vZGVsQ3Vyc29yKSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS52aWV3SXRlbSwgbWF0Y2gpOwogICAgY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4oZGF0YS52aWV3SXRlbSwgbW9kZWxFbGVtZW50KTsKICAgIGNvbnZlcnNpb25BcGkudXBkYXRlQ29udmVyc2lvblJlc3VsdChtb2RlbEVsZW1lbnQsIGRhdGEpOwogIH07Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciB1cGNhc3RpbmctdG8tZWxlbWVudCBjb252ZXJ0ZXIuIFRha2VzIHRoZSBtb2RlbCBjb25maWd1cmF0aW9uLCB0aGUgY29udmVydGVkIHZpZXcgZWxlbWVudAovLyBhbmQgYSB3cml0ZXIgaW5zdGFuY2UgYW5kIHJldHVybnMgYSBtb2RlbCBlbGVtZW50IGluc3RhbmNlIHRvIGJlIGluc2VydGVkIGluIHRoZSBtb2RlbC4KLy8KLy8gQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IG1vZGVsIE1vZGVsIGNvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfSBpbnB1dCBUaGUgY29udmVydGVkIHZpZXcgbm9kZS4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpfSBjb252ZXJzaW9uQXBpIFRoZSB1cGNhc3QgY29udmVyc2lvbiBBUEkuCgoKZnVuY3Rpb24gZ2V0TW9kZWxFbGVtZW50KG1vZGVsLCBpbnB1dCwgY29udmVyc2lvbkFwaSkgewogIGlmIChtb2RlbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7CiAgICByZXR1cm4gbW9kZWwoaW5wdXQsIGNvbnZlcnNpb25BcGkpOwogIH0gZWxzZSB7CiAgICByZXR1cm4gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlRWxlbWVudChtb2RlbCk7CiAgfQp9IC8vIEhlbHBlciBmdW5jdGlvbiB2aWV3LWF0dHJpYnV0ZS10by1tb2RlbC1hdHRyaWJ1dGUgaGVscGVyLiBOb3JtYWxpemVzIGBjb25maWcudmlld2Agd2hpY2ggd2FzIHNldCBhcyBgU3RyaW5nYCBvcgovLyBhcyBhbiBgT2JqZWN0YCB3aXRoIGBrZXlgLCBgdmFsdWVgIGFuZCBgbmFtZWAgcHJvcGVydGllcy4gTm9ybWFsaXplZCBgY29uZmlnLnZpZXdgIGhhcyBpcyBjb21wYXRpYmxlIHdpdGgKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufS4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZy4KLy8gQHJldHVybnMge1N0cmluZ30gS2V5IG9mIHRoZSBjb252ZXJ0ZWQgdmlldyBhdHRyaWJ1dGUuCgoKZnVuY3Rpb24gbm9ybWFsaXplVmlld0F0dHJpYnV0ZUtleVZhbHVlQ29uZmlnKGNvbmZpZykgewogIGlmICh0eXBlb2YgY29uZmlnLnZpZXcgPT0gJ3N0cmluZycpIHsKICAgIGNvbmZpZy52aWV3ID0gewogICAgICBrZXk6IGNvbmZpZy52aWV3CiAgICB9OwogIH0KCiAgdmFyIGtleSA9IGNvbmZpZy52aWV3LmtleTsKICB2YXIgbm9ybWFsaXplZDsKCiAgaWYgKGtleSA9PSAnY2xhc3MnIHx8IGtleSA9PSAnc3R5bGUnKSB7CiAgICB2YXIga2V5TmFtZSA9IGtleSA9PSAnY2xhc3MnID8gJ2NsYXNzZXMnIDogJ3N0eWxlcyc7CiAgICBub3JtYWxpemVkID0gX2RlZmluZVByb3BlcnR5KHt9LCBrZXlOYW1lLCBjb25maWcudmlldy52YWx1ZSk7CiAgfSBlbHNlIHsKICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBjb25maWcudmlldy52YWx1ZSA9PSAndW5kZWZpbmVkJyA/IC9bXHNcU10qLyA6IGNvbmZpZy52aWV3LnZhbHVlOwogICAgbm9ybWFsaXplZCA9IHsKICAgICAgYXR0cmlidXRlczogX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKQogICAgfTsKICB9CgogIGlmIChjb25maWcudmlldy5uYW1lKSB7CiAgICBub3JtYWxpemVkLm5hbWUgPSBjb25maWcudmlldy5uYW1lOwogIH0KCiAgY29uZmlnLnZpZXcgPSBub3JtYWxpemVkOwogIHJldHVybiBrZXk7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgbm9ybWFsaXplcyBgY29uZmlnLm1vZGVsYCBpbiBmcm9tLW1vZGVsLWF0dHJpYnV0ZSBjb252ZXJzaW9uLiBgY29uZmlnLm1vZGVsYCBjYW4gYmUgc2V0Ci8vIGFzIGEgYFN0cmluZ2AsIGFuIGBPYmplY3RgIHdpdGggb25seSBga2V5YCBwcm9wZXJ0eSBvciBhbiBgT2JqZWN0YCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMuIE5vcm1hbGl6ZWQKLy8gYGNvbmZpZy5tb2RlbGAgaXMgYW4gYE9iamVjdGAgd2l0aCBga2V5YCBhbmQgYHZhbHVlYCBwcm9wZXJ0aWVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlnLgovLyBAcGFyYW0ge1N0cmluZ30gdmlld0F0dHJpYnV0ZUtleVRvQ29weSBLZXkgb2YgdGhlIGNvbnZlcnRlZCB2aWV3IGF0dHJpYnV0ZS4gSWYgaXQgaXMgc2V0LCBtb2RlbCBhdHRyaWJ1dGUgdmFsdWUKLy8gd2lsbCBiZSBlcXVhbCB0byB2aWV3IGF0dHJpYnV0ZSB2YWx1ZS4KCgpmdW5jdGlvbiBub3JtYWxpemVNb2RlbEF0dHJpYnV0ZUNvbmZpZyhjb25maWcpIHsKICB2YXIgdmlld0F0dHJpYnV0ZUtleVRvQ29weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDsKICB2YXIgZGVmYXVsdE1vZGVsVmFsdWUgPSB2aWV3QXR0cmlidXRlS2V5VG9Db3B5ID09PSBudWxsID8gdHJ1ZSA6IGZ1bmN0aW9uICh2aWV3RWxlbWVudCkgewogICAgcmV0dXJuIHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZSh2aWV3QXR0cmlidXRlS2V5VG9Db3B5KTsKICB9OwogIHZhciBrZXkgPSBfdHlwZW9mKGNvbmZpZy5tb2RlbCkgIT0gJ29iamVjdCcgPyBjb25maWcubW9kZWwgOiBjb25maWcubW9kZWwua2V5OwogIHZhciB2YWx1ZSA9IF90eXBlb2YoY29uZmlnLm1vZGVsKSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgY29uZmlnLm1vZGVsLnZhbHVlID09ICd1bmRlZmluZWQnID8gZGVmYXVsdE1vZGVsVmFsdWUgOiBjb25maWcubW9kZWwudmFsdWU7CiAgY29uZmlnLm1vZGVsID0gewogICAga2V5OiBrZXksCiAgICB2YWx1ZTogdmFsdWUKICB9Owp9IC8vIEhlbHBlciBmb3IgdG8tbW9kZWwtYXR0cmlidXRlIGNvbnZlcnNpb24uIFRha2VzIHRoZSBtb2RlbCBhdHRyaWJ1dGUgbmFtZSBhbmQgY29udmVyc2lvbiBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zCi8vIGEgcHJvcGVyIGNvbnZlcnRlciBmdW5jdGlvbi4KLy8KLy8gQHBhcmFtIHtTdHJpbmd9IG1vZGVsQXR0cmlidXRlS2V5IFRoZSBrZXkgb2YgdGhlIG1vZGVsIGF0dHJpYnV0ZSB0byBzZXQgb24gYSBtb2RlbCBub2RlLgovLyBAcGFyYW0ge09iamVjdHxBcnJheS48T2JqZWN0Pn0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4gSXQgaXMgcG9zc2libGUgdG8gcHJvdmlkZSBtdWx0aXBsZSBjb25maWd1cmF0aW9ucyBpbiBhbiBhcnJheS4KLy8gQHBhcmFtIHtCb29sZWFufSBzaGFsbG93IElmIHNldCB0byBgdHJ1ZWAgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldCBvbmx5IG9uIHRvcC1sZXZlbCBub2Rlcy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIHNldAovLyBvbiBhbGwgZWxlbWVudHMgaW4gdGhlIHJhbmdlLgoKCmZ1bmN0aW9uIHByZXBhcmVUb0F0dHJpYnV0ZUNvbnZlcnRlcihjb25maWcsIHNoYWxsb3cpIHsKICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKGNvbmZpZy52aWV3KTsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIG1hdGNoID0gbWF0Y2hlci5tYXRjaChkYXRhLnZpZXdJdGVtKTsgLy8gSWYgdGhlcmUgaXMgbm8gbWF0Y2gsIHRoaXMgY2FsbGJhY2sgc2hvdWxkIG5vdCBkbyBhbnl0aGluZy4KCiAgICBpZiAoIW1hdGNoKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgbW9kZWxLZXkgPSBjb25maWcubW9kZWwua2V5OwogICAgdmFyIG1vZGVsVmFsdWUgPSB0eXBlb2YgY29uZmlnLm1vZGVsLnZhbHVlID09ICdmdW5jdGlvbicgPyBjb25maWcubW9kZWwudmFsdWUoZGF0YS52aWV3SXRlbSwgY29udmVyc2lvbkFwaSkgOiBjb25maWcubW9kZWwudmFsdWU7IC8vIERvIG5vdCBjb252ZXJ0IGlmIGF0dHJpYnV0ZSBidWlsZGluZyBmdW5jdGlvbiByZXR1cm5lZCBmYWxzeSB2YWx1ZS4KCiAgICBpZiAobW9kZWxWYWx1ZSA9PT0gbnVsbCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKG9ubHlWaWV3TmFtZUlzRGVmaW5lZChjb25maWcudmlldywgZGF0YS52aWV3SXRlbSkpIHsKICAgICAgbWF0Y2gubWF0Y2gubmFtZSA9IHRydWU7CiAgICB9IGVsc2UgewogICAgICAvLyBEbyBub3QgdGVzdCBvciBjb25zdW1lIGBuYW1lYCBjb25zdW1hYmxlLgogICAgICBkZWxldGUgbWF0Y2gubWF0Y2gubmFtZTsKICAgIH0gLy8gVHJ5IHRvIGNvbnN1bWUgYXBwcm9wcmlhdGUgdmFsdWVzIGZyb20gY29uc3VtYWJsZSB2YWx1ZXMgbGlzdC4KCgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUudGVzdChkYXRhLnZpZXdJdGVtLCBtYXRjaC5tYXRjaCkpIHsKICAgICAgcmV0dXJuOwogICAgfSAvLyBTaW5jZSB3ZSBhcmUgY29udmVydGluZyB0byBhdHRyaWJ1dGUgd2UgbmVlZCBhIHJhbmdlIG9uIHdoaWNoIHdlIHdpbGwgc2V0IHRoZSBhdHRyaWJ1dGUuCiAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgbm90IGNyZWF0ZWQgeWV0LCBsZXQncyBjcmVhdGUgaXQgYnkgY29udmVydGluZyBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBub2RlIGZpcnN0LgoKCiAgICBpZiAoIWRhdGEubW9kZWxSYW5nZSkgewogICAgICAvLyBDb252ZXJ0IGNoaWxkcmVuIGFuZCBzZXQgY29udmVyc2lvbiByZXN1bHQgYXMgYSBjdXJyZW50IGRhdGEuCiAgICAgIGRhdGEgPSBPYmplY3QuYXNzaWduKGRhdGEsIGNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKGRhdGEudmlld0l0ZW0sIGRhdGEubW9kZWxDdXJzb3IpKTsKICAgIH0gLy8gU2V0IGF0dHJpYnV0ZSBvbiBjdXJyZW50IGBvdXRwdXRgLiBgU2NoZW1hYCBpcyBjaGVja2VkIGluc2lkZSB0aGlzIGhlbHBlciBmdW5jdGlvbi4KCgogICAgdmFyIGF0dHJpYnV0ZVdhc1NldCA9IHNldEF0dHJpYnV0ZU9uKGRhdGEubW9kZWxSYW5nZSwgewogICAgICBrZXk6IG1vZGVsS2V5LAogICAgICB2YWx1ZTogbW9kZWxWYWx1ZQogICAgfSwgc2hhbGxvdywgY29udmVyc2lvbkFwaSk7IC8vIEl0IG1heSBoYXBwZW4gdGhhdCBhIGNvbnZlcnRlciB3aWxsIHRyeSB0byBzZXQgYW4gYXR0cmlidXRlIHRoYXQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGdpdmVuIGNvbnRleHQuCiAgICAvLyBJbiBzdWNoIGEgc2l0dWF0aW9uIHdlIGNhbm5vdCBjb25zdW1lIHRoZSBhdHRyaWJ1dGUuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS9wdWxsLzkyNDkjaXNzdWVjb21tZW50LTgxNTY1ODQ1OS4KCiAgICBpZiAoYXR0cmlidXRlV2FzU2V0KSB7CiAgICAgIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEudmlld0l0ZW0sIG1hdGNoLm1hdGNoKTsKICAgIH0KICB9Owp9IC8vIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBlbGVtZW50IG5hbWUgc2hvdWxkIGJlIGNvbnN1bWVkIGluIGF0dHJpYnV0ZSBjb252ZXJ0ZXJzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gdmlldyBjb25maWcuCi8vIEByZXR1cm5zIHtCb29sZWFufQoKCmZ1bmN0aW9uIG9ubHlWaWV3TmFtZUlzRGVmaW5lZCh2aWV3Q29uZmlnLCB2aWV3SXRlbSkgewogIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy8xNzg2CiAgdmFyIGNvbmZpZ1RvVGVzdCA9IHR5cGVvZiB2aWV3Q29uZmlnID09ICdmdW5jdGlvbicgPyB2aWV3Q29uZmlnKHZpZXdJdGVtKSA6IHZpZXdDb25maWc7CgogIGlmIChfdHlwZW9mKGNvbmZpZ1RvVGVzdCkgPT0gJ29iamVjdCcgJiYgIWdldFZpZXdFbGVtZW50TmFtZUZyb21Db25maWcoY29uZmlnVG9UZXN0KSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KCiAgcmV0dXJuICFjb25maWdUb1Rlc3QuY2xhc3NlcyAmJiAhY29uZmlnVG9UZXN0LmF0dHJpYnV0ZXMgJiYgIWNvbmZpZ1RvVGVzdC5zdHlsZXM7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciB0by1tb2RlbC1hdHRyaWJ1dGUgY29udmVydGVyLiBTZXRzIG1vZGVsIGF0dHJpYnV0ZSBvbiBnaXZlbiByYW5nZS4gQ2hlY2tzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWF9Ci8vIHRvIGVuc3VyZSBwcm9wZXIgbW9kZWwgc3RydWN0dXJlLgovLwovLyBJZiBhbnkgbm9kZSBvbiB0aGUgZ2l2ZW4gcmFuZ2UgaGFzIGFscmVhZHkgZGVmaW5lZCBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FtZSBuYW1lLCBpdHMgdmFsdWUgd2lsbCBub3QgYmUgdXBkYXRlZC4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBtb2RlbFJhbmdlIE1vZGVsIHJhbmdlIG9uIHdoaWNoIGF0dHJpYnV0ZSBzaG91bGQgYmUgc2V0LgovLyBAcGFyYW0ge09iamVjdH0gbW9kZWxBdHRyaWJ1dGUgTW9kZWwgYXR0cmlidXRlIHRvIHNldC4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpfSBjb252ZXJzaW9uQXBpIENvbnZlcnNpb24gQVBJLgovLyBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3cgSWYgc2V0IHRvIGB0cnVlYCB0aGUgYXR0cmlidXRlIHdpbGwgYmUgc2V0IG9ubHkgb24gdG9wLWxldmVsIG5vZGVzLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgc2V0Ci8vIG9uIGFsbCBlbGVtZW50cyBpbiB0aGUgcmFuZ2UuCi8vIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgYXR0cmlidXRlIHdhcyBzZXQgb24gYXQgbGVhc3Qgb25lIG5vZGUgZnJvbSBnaXZlbiBgbW9kZWxSYW5nZWAuCgoKZnVuY3Rpb24gc2V0QXR0cmlidXRlT24obW9kZWxSYW5nZSwgbW9kZWxBdHRyaWJ1dGUsIHNoYWxsb3csIGNvbnZlcnNpb25BcGkpIHsKICB2YXIgcmVzdWx0ID0gZmFsc2U7IC8vIFNldCBhdHRyaWJ1dGUgb24gZWFjaCBpdGVtIGluIHJhbmdlIGFjY29yZGluZyB0byBTY2hlbWEuCgogIGZvciAodmFyIF9pID0gMCwgX0FycmF5JGZyb20gPSBBcnJheS5mcm9tKG1vZGVsUmFuZ2UuZ2V0SXRlbXMoewogICAgc2hhbGxvdzogc2hhbGxvdwogIH0pKTsgX2kgPCBfQXJyYXkkZnJvbS5sZW5ndGg7IF9pKyspIHsKICAgIHZhciBub2RlID0gX0FycmF5JGZyb21bX2ldOwoKICAgIC8vIFNraXAgaWYgbm90IGFsbG93ZWQuCiAgICBpZiAoIWNvbnZlcnNpb25BcGkuc2NoZW1hLmNoZWNrQXR0cmlidXRlKG5vZGUsIG1vZGVsQXR0cmlidXRlLmtleSkpIHsKICAgICAgY29udGludWU7CiAgICB9IC8vIE1hcmsgdGhlIG5vZGUgYXMgY29uc3VtZWQgZXZlbiBpZiB0aGUgYXR0cmlidXRlIHdpbGwgbm90IGJlIHVwZGF0ZWQgYmVjYXVzZSBpdCdzIGluIGEgdmFsaWQgY29udGV4dCAoc2NoZW1hKQogICAgLy8gYW5kIHdvdWxkIGJlIGNvbnZlcnRlZCBpZiB0aGUgYXR0cmlidXRlIHdvdWxkbid0IGJlIHByZXNlbnQuIFNlZSAjODkyMS4KCgogICAgcmVzdWx0ID0gdHJ1ZTsgLy8gRG8gbm90IG92ZXJyaWRlIHRoZSBhdHRyaWJ1dGUgaWYgaXQncyBhbHJlYWR5IHByZXNlbnQuCgogICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKG1vZGVsQXR0cmlidXRlLmtleSkpIHsKICAgICAgY29udGludWU7CiAgICB9CgogICAgY29udmVyc2lvbkFwaS53cml0ZXIuc2V0QXR0cmlidXRlKG1vZGVsQXR0cmlidXRlLmtleSwgbW9kZWxBdHRyaWJ1dGUudmFsdWUsIG5vZGUpOwogIH0KCiAgcmV0dXJuIHJlc3VsdDsKfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHVwY2FzdGluZy10by1tYXJrZXIgY29udmVyc2lvbi4gVGFrZXMgdGhlIGNvbmZpZyBpbiBhIGZvcm1hdCByZXF1ZXN0ZWQgYnkgYHVwY2FzdEVsZW1lbnRUb01hcmtlcigpYAovLyBmdW5jdGlvbiBhbmQgY29udmVydHMgaXQgdG8gYSBmb3JtYXQgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgYHVwY2FzdEVsZW1lbnRUb0VsZW1lbnQoKWAgZnVuY3Rpb24uCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgoKCmZ1bmN0aW9uIG5vcm1hbGl6ZUVsZW1lbnRUb01hcmtlckNvbmZpZyhjb25maWcpIHsKICB2YXIgb2xkTW9kZWwgPSBjb25maWcubW9kZWw7CgogIGNvbmZpZy5tb2RlbCA9IGZ1bmN0aW9uICh2aWV3RWxlbWVudCwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIG1hcmtlck5hbWUgPSB0eXBlb2Ygb2xkTW9kZWwgPT0gJ3N0cmluZycgPyBvbGRNb2RlbCA6IG9sZE1vZGVsKHZpZXdFbGVtZW50LCBjb252ZXJzaW9uQXBpKTsKICAgIHJldHVybiBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVFbGVtZW50KCckbWFya2VyJywgewogICAgICAnZGF0YS1uYW1lJzogbWFya2VyTmFtZQogICAgfSk7CiAgfTsKfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHVwY2FzdGluZy10by1tYXJrZXIgY29udmVyc2lvbi4gVGFrZXMgdGhlIGNvbmZpZyBpbiBhIGZvcm1hdCByZXF1ZXN0ZWQgYnkgYHVwY2FzdERhdGFUb01hcmtlcigpYAovLyBmdW5jdGlvbiBhbmQgY29udmVydHMgaXQgdG8gYSBmb3JtYXQgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgYHVwY2FzdEVsZW1lbnRUb0VsZW1lbnQoKWAgZnVuY3Rpb24uCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgoKCmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGFUb01hcmtlckNvbmZpZyhjb25maWcsIHR5cGUpIHsKICB2YXIgY29uZmlnRm9yRWxlbWVudHMgPSB7fTsgLy8gVXBjYXN0IDxtYXJrZXJHcm91cC1zdGFydD4gYW5kIDxtYXJrZXJHcm91cC1lbmQ+IGVsZW1lbnRzLgoKICBjb25maWdGb3JFbGVtZW50cy52aWV3ID0gY29uZmlnLnZpZXcgKyAnLScgKyB0eXBlOwoKICBjb25maWdGb3JFbGVtZW50cy5tb2RlbCA9IGZ1bmN0aW9uICh2aWV3RWxlbWVudCwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIHZpZXdOYW1lID0gdmlld0VsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJyk7CiAgICB2YXIgbWFya2VyTmFtZSA9IGNvbmZpZy5tb2RlbCh2aWV3TmFtZSwgY29udmVyc2lvbkFwaSk7CiAgICByZXR1cm4gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlRWxlbWVudCgnJG1hcmtlcicsIHsKICAgICAgJ2RhdGEtbmFtZSc6IG1hcmtlck5hbWUKICAgIH0pOwogIH07CgogIHJldHVybiBjb25maWdGb3JFbGVtZW50czsKfQ=="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js"],"names":["Matcher","ConversionHelpers","cloneDeep","logWarning","priorities","isParagraphable","wrapInParagraph","UpcastHelpers","config","add","upcastElementToElement","upcastElementToAttribute","upcastAttributeToAttribute","upcastElementToMarker","upcastDataToMarker","convertToModelFragment","evt","data","conversionApi","modelRange","consumable","consume","viewItem","name","convertChildren","modelCursor","convertText","schema","writer","position","test","checkChild","text","createText","insert","createRange","getShiftedBy","offsetSize","end","convertSelectionChange","model","mapper","viewSelection","newSelection","ranges","getRanges","viewRange","push","toModelRange","modelSelection","createSelection","backward","isBackward","isEqual","document","selection","change","setSelection","converter","prepareToElementConverter","elementName","getViewElementNameFromConfig","view","eventName","dispatcher","on","priority","converterPriority","normalizeModelAttributeConfig","prepareToAttributeConverter","viewKey","key","normalizeViewAttributeKeyValueConfig","normalizeElementToMarkerConfig","converterStart","normalizeDataToMarkerConfig","converterEnd","basePriority","get","maxPriority","priorityFactor","upcastAttributeToMarker","attrName","Object","assign","attributes","addMarkerElements","getAttribute","split","start","markerViewNames","markerViewName","markerName","element","createElement","_getTransformedByInsertion","viewConfig","matcher","matcherResult","match","modelElement","getModelElement","safeInsert","updateConversionResult","input","Function","normalized","keyName","value","viewAttributeKeyToCopy","defaultModelValue","viewElement","shallow","modelKey","modelValue","onlyViewNameIsDefined","attributeWasSet","setAttributeOn","configToTest","classes","styles","modelAttribute","result","Array","from","getItems","node","checkAttribute","hasAttribute","setAttribute","oldModel","type","configForElements","viewName"],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA,OAAOA,OAAP,MAAoB,iBAApB;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;AAEA,SAASC,SAAT,QAA0B,WAA1B;AACA,SAASC,UAAT,QAA2B,6CAA3B;AAEA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,SAASC,eAAT,EAA0BC,eAA1B,QAAiD,iCAAjD;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;IACqBC,a;;;;;;;;;;;;;;AACpB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,8BAAkBC,MAAlB,EAA2B;AAC1B,aAAO,KAAKC,GAAL,CAAUC,sBAAsB,CAAEF,MAAF,CAAhC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,4BAAoBA,MAApB,EAA6B;AAC5B,aAAO,KAAKC,GAAL,CAAUE,wBAAwB,CAAEH,MAAF,CAAlC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,8BAAsBA,MAAtB,EAA+B;AAC9B,aAAO,KAAKC,GAAL,CAAUG,0BAA0B,CAAEJ,MAAF,CAApC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAiBA,MAAjB,EAA0B;AACzB;AACF;AACA;AACA;AACA;AACA;AACA;AACEL,MAAAA,UAAU,CAAE,6CAAF,CAAV;AAEA,aAAO,KAAKM,GAAL,CAAUI,qBAAqB,CAAEL,MAAF,CAA/B,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport Matcher from '../view/matcher';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\n\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class UpcastHelpers extends ConversionHelpers {\n\t/**\n\t * View element to model element conversion helper.\n\t *\n\t * This conversion results in creating a model element. For example,\n\t * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n\t *\n\t * Keep in mind that the element will be inserted only if it is allowed\n\t * by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'fancyParagraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t * \t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'heading'\n\t * \t\t\t},\n\t * \t\t\tmodel: ( viewElement, conversionApi ) => {\n\t * \t\t\t\tconst modelWriter = conversionApi.writer;\n\t *\n\t * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n\t * \t\t\t}\n\t * \t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n\t * set, the converter will fire for every view element.\n\t * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element instance or a\n\t * function that takes a view element and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}\n\t * and returns a model element. The model element will be inserted in the model.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( upcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * View element to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n\t * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n\t *\n\t * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-size': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalue: ( viewElement, conversionApi ) => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n\t *\n\t *\t\t\t\t\tif ( value <= 10 ) {\n\t *\t\t\t\t\t\treturn 'small';\n\t *\t\t\t\t\t} else if ( value > 12 ) {\n\t *\t\t\t\t\t\treturn 'big';\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and\n\t * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.\n\t * If `String` is given, the model attribute value will be set to `true`.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToAttribute( config ) {\n\t\treturn this.add( upcastElementToAttribute( config ) );\n\t}\n\n\t/**\n\t * View attribute to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n\t * `<image source=\"foo.jpg\"></image>` in the model.\n\t *\n\t * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n\t * is set only on the corresponding model node:\n\t *\n\t *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n\t *\n\t * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n\t * all the children in the model:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: 'src',\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tconverterPriority: 'normal'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'data-style',\n\t *\t\t\t\tvalue: /[\\s\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: 'styled'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'img',\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: 'styled-dark'\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: /styled-[\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled'\n\t *\t\t\t\tvalue: ( viewElement, conversionApi ) => {\n\t *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n\t *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n\t *\n\t *\t\t\t\t\treturn match[ 1 ];\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Converting styles works a bit differently as it requires `view.styles` to be an object and by default\n\t * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`\n\t * callback that returns the desired value.\n\t *\n\t *\t\t// Default conversion of font-weight style will result in setting bold attribute to true.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\t// This converter will pass any style value to the `lineHeight` model attribute.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'line-height': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'lineHeight',\n\t *\t\t\t\tvalue: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n\t * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n\t * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n\t * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n\t * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and\n\t * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.\n\t * If `String` is given, the model attribute value will be same as view attribute value.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( upcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * View element to model marker conversion helper.\n\t *\n\t * **Note**: This method was deprecated. Please use {@link #dataToMarker} instead.\n\t *\n\t * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n\t * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n\t * after the conversion is done, the marker will be available in\n\t * {@link module:engine/model/model~Model#markers model document markers}.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @deprecated\n\t * @method #elementToMarker\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n\t * a model marker name.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToMarker( config ) {\n\t\t/**\n\t\t * The {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `UpcastHelpers#elementToMarker()`}\n\t\t * method was deprecated and will be removed in the near future.\n\t\t * Please use {@link module:engine/conversion/upcasthelpers~UpcastHelpers#dataToMarker `UpcastHelpers#dataToMarker()`} instead.\n\t\t *\n\t\t * @error upcast-helpers-element-to-marker-deprecated\n\t\t */\n\t\tlogWarning( 'upcast-helpers-element-to-marker-deprecated' );\n\n\t\treturn this.add( upcastElementToMarker( config ) );\n\t}\n\n\t/**\n\t * View-to-model marker conversion helper.\n\t *\n\t * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}\n\t * back to a model marker.\n\t *\n\t * This converter looks for specific view elements and view attributes that mark marker boundaries. See\n\t * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data\n\t * is expected by this converter.\n\t *\n\t * The `config.view` property is equal to the marker group name to convert.\n\t *\n\t * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).\n\t *\n\t * The conversion configuration can take a function that will generate a marker name.\n\t * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is\n\t * expected to return a string with the marker name.\n\t *\n\t * Basic usage:\n\t *\n\t *\t\t// Using the default conversion.\n\t *\t\t// In this case, all markers from the `comment` group will be converted.\n\t *\t\t// The conversion will look for `<comment-start>` and `<comment-end>` tags and\n\t *\t\t// `data-comment-start-before`, `data-comment-start-after`,\n\t *\t\t// `data-comment-end-before` and `data-comment-end-after` attributes.\n\t *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n\t *\t\t\tview: 'comment'\n\t *\t\t} );\n\t *\n\t * An example of a model that may be generated by this conversion:\n\t *\n\t *\t\t// View:\n\t *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n\t *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n\t *\n\t *\t\t// Model:\n\t *\t\t<paragraph>Foo[bar</paragraph>\n\t *\t\t<image src=\"abc.jpg\"></image>]\n\t *\n\t * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.\n\t *\n\t * Other examples of usage:\n\t *\n\t *\t\t// Using a custom function which is the same as the default conversion:\n\t *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n\t *\t\t\tview: 'comment',\n\t *\t\t\tmodel: ( name, conversionApi ) => 'comment:' + name,\n\t *\t\t} );\n\t *\n\t *\t\t// Using the converter priority:\n\t *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n\t *\t\t\tview: 'comment',\n\t *\t\t\tmodel: ( name, conversionApi ) => 'comment:' + name,\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #dataToMarker\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.view The marker group name to convert.\n\t * @param {Function} [config.model] A function that takes the `name` part from the view element or attribute and\n\t * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tdataToMarker( config ) {\n\t\treturn this.add( upcastDataToMarker( config ) );\n\t}\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\nexport function convertToModelFragment() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n\t\tif ( !data.modelRange && conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\t\tconst { modelRange, modelCursor } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n\n\t\t\tdata.modelRange = modelRange;\n\t\t\tdata.modelCursor = modelCursor;\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\nexport function convertText() {\n\treturn ( evt, data, { schema, consumable, writer } ) => {\n\t\tlet position = data.modelCursor;\n\n\t\t// When node is already converted then do nothing.\n\t\tif ( !consumable.test( data.viewItem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !schema.checkChild( position, '$text' ) ) {\n\t\t\tif ( !isParagraphable( position, '$text', schema ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tposition = wrapInParagraph( position, writer );\n\t\t}\n\n\t\tconsumable.consume( data.viewItem );\n\n\t\tconst text = writer.createText( data.viewItem.data );\n\n\t\twriter.insert( text, position );\n\n\t\tdata.modelRange = writer.createRange(\n\t\t\tposition,\n\t\t\tposition.getShiftedBy( text.offsetSize )\n\t\t);\n\t\tdata.modelCursor = data.modelRange.end;\n\t};\n}\n\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\nexport function convertSelectionChange( model, mapper ) {\n\treturn ( evt, data ) => {\n\t\tconst viewSelection = data.newSelection;\n\n\t\tconst ranges = [];\n\n\t\tfor ( const viewRange of viewSelection.getRanges() ) {\n\t\t\tranges.push( mapper.toModelRange( viewRange ) );\n\t\t}\n\n\t\tconst modelSelection = model.createSelection( ranges, { backward: viewSelection.isBackward } );\n\n\t\tif ( !modelSelection.isEqual( model.document.selection ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( modelSelection );\n\t\t\t} );\n\t\t}\n\t};\n}\n\n// View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst converter = prepareToElementConverter( config );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeModelAttributeConfig( config );\n\n\tconst converter = prepareToAttributeConverter( config, false );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tlet viewKey = null;\n\n\tif ( typeof config.view == 'string' || config.view.key ) {\n\t\tviewKey = normalizeViewAttributeKeyValueConfig( config );\n\t}\n\n\tnormalizeModelAttributeConfig( config, viewKey );\n\n\tconst converter = prepareToAttributeConverter( config, true );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element', converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToMarker( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeElementToMarkerConfig( config );\n\n\treturn upcastElementToElement( config );\n}\n\n// View data to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#dataToMarker} to learn more.\n//\n// @param {Object} config\n// @param {String} config.view\n// @param {Function} [config.model]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\nfunction upcastDataToMarker( config ) {\n\tconfig = cloneDeep( config );\n\n\t// Default conversion.\n\tif ( !config.model ) {\n\t\tconfig.model = name => {\n\t\t\treturn name ? config.view + ':' + name : config.view;\n\t\t};\n\t}\n\n\tconst converterStart = prepareToElementConverter( normalizeDataToMarkerConfig( config, 'start' ) );\n\tconst converterEnd = prepareToElementConverter( normalizeDataToMarkerConfig( config, 'end' ) );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:' + config.view + '-start', converterStart, { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'element:' + config.view + '-end', converterEnd, { priority: config.converterPriority || 'normal' } );\n\n\t\t// Below is a hack that is needed to properly handle `converterPriority` for both elements and attributes.\n\t\t// Attribute conversion needs to be performed *after* element conversion.\n\t\t// This converter handles both element conversion and attribute conversion, which means that if a single\n\t\t// `config.converterPriority` is used, it will lead to problems. For example, if `'high'` priority is used,\n\t\t// then attribute conversion will be performed before a lot of element upcast converters.\n\t\t// On the other hand we want to support `config.converterPriority` and overwriting conveters.\n\t\t//\n\t\t// To have it work, we need to do some extra processing for priority for attribute converter.\n\t\t// Priority `'low'` value should be the base value and then we will change it depending on `config.converterPriority` value.\n\t\t//\n\t\t// This hack probably would not be needed if attributes are upcasted separately.\n\t\t//\n\t\tconst basePriority = priorities.get( 'low' );\n\t\tconst maxPriority = priorities.get( 'highest' );\n\t\tconst priorityFactor = priorities.get( config.converterPriority ) / maxPriority; // Number in range [ -1, 1 ].\n\n\t\tdispatcher.on( 'element', upcastAttributeToMarker( config ), { priority: basePriority + priorityFactor } );\n\t};\n}\n\n// Function factory, returns a callback function which converts view attributes to a model marker.\n//\n// The converter looks for elements with `data-group-start-before`, `data-group-start-after`, `data-group-end-before`\n// and `data-group-end-after` attributes and inserts `$marker` model elements before/after those elements.\n// `group` part is specified in `config.view`.\n//\n// @param {Object} config\n// @param {String} config.view\n// @param {Function} [config.model]\n// @returns {Function} Marker converter.\nfunction upcastAttributeToMarker( config ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst attrName = `data-${ config.view }`;\n\n\t\t// This converter wants to add a model element, marking a marker, before/after an element (or maybe even group of elements).\n\t\t// To do that, we can use `data.modelRange` which is set on an element (or a group of elements) that has been upcasted.\n\t\t// But, if the processed view element has not been upcasted yet (it does not have been converted), we need to\n\t\t// fire conversion for its children first, then we will have `data.modelRange` available.\n\t\tif ( !data.modelRange ) {\n\t\t\tdata = Object.assign( data, conversionApi.convertChildren( data.viewItem, data.modelCursor ) );\n\t\t}\n\n\t\tif ( conversionApi.consumable.consume( data.viewItem, { attributes: attrName + '-end-after' } ) ) {\n\t\t\taddMarkerElements( data.modelRange.end, data.viewItem.getAttribute( attrName + '-end-after' ).split( ',' ) );\n\t\t}\n\n\t\tif ( conversionApi.consumable.consume( data.viewItem, { attributes: attrName + '-start-after' } ) ) {\n\t\t\taddMarkerElements( data.modelRange.end, data.viewItem.getAttribute( attrName + '-start-after' ).split( ',' ) );\n\t\t}\n\n\t\tif ( conversionApi.consumable.consume( data.viewItem, { attributes: attrName + '-end-before' } ) ) {\n\t\t\taddMarkerElements( data.modelRange.start, data.viewItem.getAttribute( attrName + '-end-before' ).split( ',' ) );\n\t\t}\n\n\t\tif ( conversionApi.consumable.consume( data.viewItem, { attributes: attrName + '-start-before' } ) ) {\n\t\t\taddMarkerElements( data.modelRange.start, data.viewItem.getAttribute( attrName + '-start-before' ).split( ',' ) );\n\t\t}\n\n\t\tfunction addMarkerElements( position, markerViewNames ) {\n\t\t\tfor ( const markerViewName of markerViewNames ) {\n\t\t\t\tconst markerName = config.model( markerViewName, conversionApi );\n\t\t\t\tconst element = conversionApi.writer.createElement( '$marker', { 'data-name': markerName } );\n\n\t\t\t\tconversionApi.writer.insert( element, position );\n\n\t\t\t\tif ( data.modelCursor.isEqual( position ) ) {\n\t\t\t\t\tdata.modelCursor = data.modelCursor.getShiftedBy( 1 );\n\t\t\t\t} else {\n\t\t\t\t\tdata.modelCursor = data.modelCursor._getTransformedByInsertion( position, 1 );\n\t\t\t\t}\n\n\t\t\t\tdata.modelRange = data.modelRange._getTransformedByInsertion( position, 1 )[ 0 ];\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion view config.\n// @returns {String|null} View element name or `null` if name is not directly set.\nfunction getViewElementNameFromConfig( viewConfig ) {\n\tif ( typeof viewConfig == 'string' ) {\n\t\treturn viewConfig;\n\t}\n\n\tif ( typeof viewConfig == 'object' && typeof viewConfig.name == 'string' ) {\n\t\treturn viewConfig.name;\n\t}\n\n\treturn null;\n}\n\n// Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\nfunction prepareToElementConverter( config ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst matcherResult = matcher.match( data.viewItem );\n\n\t\tif ( !matcherResult ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = matcherResult.match;\n\n\t\t// Force consuming element's name.\n\t\tmatch.name = true;\n\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelElement = getModelElement( config.model, data.viewItem, conversionApi );\n\n\t\tif ( !modelElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.safeInsert( modelElement, data.modelCursor ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconversionApi.consumable.consume( data.viewItem, match );\n\t\tconversionApi.convertChildren( data.viewItem, modelElement );\n\t\tconversionApi.updateConversionResult( modelElement, data );\n\t};\n}\n\n// Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi The upcast conversion API.\nfunction getModelElement( model, input, conversionApi ) {\n\tif ( model instanceof Function ) {\n\t\treturn model( input, conversionApi );\n\t} else {\n\t\treturn conversionApi.writer.createElement( model );\n\t}\n}\n\n// Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\nfunction normalizeViewAttributeKeyValueConfig( config ) {\n\tif ( typeof config.view == 'string' ) {\n\t\tconfig.view = { key: config.view };\n\t}\n\n\tconst key = config.view.key;\n\tlet normalized;\n\n\tif ( key == 'class' || key == 'style' ) {\n\t\tconst keyName = key == 'class' ? 'classes' : 'styles';\n\n\t\tnormalized = {\n\t\t\t[ keyName ]: config.view.value\n\t\t};\n\t} else {\n\t\tconst value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n\n\t\tnormalized = {\n\t\t\tattributes: {\n\t\t\t\t[ key ]: value\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( config.view.name ) {\n\t\tnormalized.name = config.view.name;\n\t}\n\n\tconfig.view = normalized;\n\n\treturn key;\n}\n\n// Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\nfunction normalizeModelAttributeConfig( config, viewAttributeKeyToCopy = null ) {\n\tconst defaultModelValue = viewAttributeKeyToCopy === null ? true : viewElement => viewElement.getAttribute( viewAttributeKeyToCopy );\n\n\tconst key = typeof config.model != 'object' ? config.model : config.model.key;\n\tconst value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n\n\tconfig.model = { key, value };\n}\n\n// Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\nfunction prepareToAttributeConverter( config, shallow ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst match = matcher.match( data.viewItem );\n\n\t\t// If there is no match, this callback should not do anything.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelKey = config.model.key;\n\t\tconst modelValue = typeof config.model.value == 'function' ?\n\t\t\tconfig.model.value( data.viewItem, conversionApi ) : config.model.value;\n\n\t\t// Do not convert if attribute building function returned falsy value.\n\t\tif ( modelValue === null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( onlyViewNameIsDefined( config.view, data.viewItem ) ) {\n\t\t\tmatch.match.name = true;\n\t\t} else {\n\t\t\t// Do not test or consume `name` consumable.\n\t\t\tdelete match.match.name;\n\t\t}\n\n\t\t// Try to consume appropriate values from consumable values list.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match.match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Since we are converting to attribute we need a range on which we will set the attribute.\n\t\t// If the range is not created yet, let's create it by converting children of the current node first.\n\t\tif ( !data.modelRange ) {\n\t\t\t// Convert children and set conversion result as a current data.\n\t\t\tdata = Object.assign( data, conversionApi.convertChildren( data.viewItem, data.modelCursor ) );\n\t\t}\n\n\t\t// Set attribute on current `output`. `Schema` is checked inside this helper function.\n\t\tconst attributeWasSet = setAttributeOn( data.modelRange, { key: modelKey, value: modelValue }, shallow, conversionApi );\n\n\t\t// It may happen that a converter will try to set an attribute that is not allowed in the given context.\n\t\t// In such a situation we cannot consume the attribute. See: https://github.com/ckeditor/ckeditor5/pull/9249#issuecomment-815658459.\n\t\tif ( attributeWasSet ) {\n\t\t\tconversionApi.consumable.consume( data.viewItem, match.match );\n\t\t}\n\t};\n}\n\n// Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion view config.\n// @returns {Boolean}\nfunction onlyViewNameIsDefined( viewConfig, viewItem ) {\n\t// https://github.com/ckeditor/ckeditor5-engine/issues/1786\n\tconst configToTest = typeof viewConfig == 'function' ? viewConfig( viewItem ) : viewConfig;\n\n\tif ( typeof configToTest == 'object' && !getViewElementNameFromConfig( configToTest ) ) {\n\t\treturn false;\n\t}\n\n\treturn !configToTest.classes && !configToTest.attributes && !configToTest.styles;\n}\n\n// Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// If any node on the given range has already defined an attribute with the same name, its value will not be updated.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\nfunction setAttributeOn( modelRange, modelAttribute, shallow, conversionApi ) {\n\tlet result = false;\n\n\t// Set attribute on each item in range according to Schema.\n\tfor ( const node of Array.from( modelRange.getItems( { shallow } ) ) ) {\n\t\t// Skip if not allowed.\n\t\tif ( !conversionApi.schema.checkAttribute( node, modelAttribute.key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Mark the node as consumed even if the attribute will not be updated because it's in a valid context (schema)\n\t\t// and would be converted if the attribute wouldn't be present. See #8921.\n\t\tresult = true;\n\n\t\t// Do not override the attribute if it's already present.\n\t\tif ( node.hasAttribute( modelAttribute.key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversionApi.writer.setAttribute( modelAttribute.key, modelAttribute.value, node );\n\t}\n\n\treturn result;\n}\n\n// Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\nfunction normalizeElementToMarkerConfig( config ) {\n\tconst oldModel = config.model;\n\n\tconfig.model = ( viewElement, conversionApi ) => {\n\t\tconst markerName = typeof oldModel == 'string' ? oldModel : oldModel( viewElement, conversionApi );\n\n\t\treturn conversionApi.writer.createElement( '$marker', { 'data-name': markerName } );\n\t};\n}\n\n// Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastDataToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\nfunction normalizeDataToMarkerConfig( config, type ) {\n\tconst configForElements = {};\n\n\t// Upcast <markerGroup-start> and <markerGroup-end> elements.\n\tconfigForElements.view = config.view + '-' + type;\n\n\tconfigForElements.model = ( viewElement, conversionApi ) => {\n\t\tconst viewName = viewElement.getAttribute( 'name' );\n\t\tconst markerName = config.model( viewName, conversionApi );\n\n\t\treturn conversionApi.writer.createElement( '$marker', { 'data-name': markerName } );\n\t};\n\n\treturn configForElements;\n}\n"]}]}