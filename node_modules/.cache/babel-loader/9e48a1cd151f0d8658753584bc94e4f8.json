{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubWFwLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjEsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL2NvbnZlcnNpb24vbW9kZWxjb25zdW1hYmxlCiAqLwppbXBvcnQgVGV4dFByb3h5IGZyb20gJy4uL21vZGVsL3RleHRwcm94eSc7Ci8qKgogKiBNYW5hZ2VzIGEgbGlzdCBvZiBjb25zdW1hYmxlIHZhbHVlcyBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW1zfS4KICoKICogQ29uc3VtYWJsZXMgYXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgbW9kZWwuIEEgbW9kZWwgaXRlbSBjYW4gYmUgYnJva2VuIGRvd24gaW50byBzaW5ndWxhciBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUKICogdGFrZW4gaW50byBjb25zaWRlcmF0aW9uIHdoZW4gY29udmVydGluZyB0aGF0IGl0ZW0uCiAqCiAqIGBNb2RlbENvbnN1bWFibGVgIGlzIHVzZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfSB3aGlsZSBhbmFseXppbmcgY2hhbmdlZAogKiBwYXJ0cyBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCB0aGUgZG9jdW1lbnR9LiBUaGUgYWRkZWQgLyBjaGFuZ2VkIC8gcmVtb3ZlZCBtb2RlbCBpdGVtcyBhcmUgYnJva2VuIGRvd24KICogaW50byBzaW5ndWxhciBwcm9wZXJ0aWVzICh0aGUgaXRlbSBpdHNlbGYgYW5kIGl0J3MgYXR0cmlidXRlcykuIEFsbCB0aG9zZSBwYXJ0cyBhcmUgc2F2ZWQgaW4gYE1vZGVsQ29uc3VtYWJsZWAuIFRoZW4sCiAqIGR1cmluZyBjb252ZXJzaW9uLCB3aGVuIGdpdmVuIHBhcnQgb2YgbW9kZWwgaXRlbSBpcyBjb252ZXJ0ZWQgKGkuZS4gdGhlIHZpZXcgZWxlbWVudCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSB2aWV3LAogKiBidXQgd2l0aG91dCBhdHRyaWJ1dGVzKSwgY29uc3VtYWJsZSB2YWx1ZSBpcyByZW1vdmVkIGZyb20gYE1vZGVsQ29uc3VtYWJsZWAuCiAqCiAqIEZvciBtb2RlbCBpdGVtcywgYE1vZGVsQ29uc3VtYWJsZWAgc3RvcmVzIGNvbnN1bWFibGUgdmFsdWVzIG9mIG9uZSBvZiBmb2xsb3dpbmcgdHlwZXM6IGBpbnNlcnRgLCBgYWRkYXR0cmlidXRlOjxhdHRyaWJ1dGVLZXk+YCwKICogYGNoYW5nZWF0dHJpYnV0ZXM6PGF0dHJpYnV0ZUtleT5gLCBgcmVtb3ZlYXR0cmlidXRlczo8YXR0cmlidXRlS2V5PmAuCiAqCiAqIEluIG1vc3QgY2FzZXMsIGl0IGlzIGVub3VnaCB0byBsZXQge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfQogKiBnYXRoZXIgY29uc3VtYWJsZSB2YWx1ZXMsIHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gdXNlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbW9kZWxjb25zdW1hYmxlfk1vZGVsQ29uc3VtYWJsZSNhZGQgYWRkIG1ldGhvZH0gZGlyZWN0bHkuCiAqIEhvd2V2ZXIsIGl0IGlzIGltcG9ydGFudCB0byB1bmRlcnN0YW5kIGhvdyBjb25zdW1hYmxlIHZhbHVlcyBjYW4gYmUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tb2RlbGNvbnN1bWFibGV+TW9kZWxDb25zdW1hYmxlI2NvbnN1bWUgY29uc3VtZWR9LgogKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnMgZGVmYXVsdCBkb3duY2FzdCBjb252ZXJ0ZXJzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4KICoKICogS2VlcCBpbiBtaW5kLCB0aGF0IG9uZSBjb252ZXJzaW9uIGV2ZW50IG1heSBoYXZlIG11bHRpcGxlIGNhbGxiYWNrcyAoY29udmVydGVycykgYXR0YWNoZWQgdG8gaXQuIEVhY2ggb2YgdGhvc2UgaXMKICogYWJsZSB0byBjb252ZXJ0IG9uZSBvciBtb3JlIHBhcnRzIG9mIHRoZSBtb2RlbC4gSG93ZXZlciwgd2hlbiBvbmUgb2YgdGhvc2UgY2FsbGJhY2tzIGFjdHVhbGx5IGNvbnZlcnRzCiAqIHNvbWV0aGluZywgb3RoZXIgc2hvdWxkIG5vdCwgYmVjYXVzZSB0aGV5IHdvdWxkIGR1cGxpY2F0ZSB0aGUgcmVzdWx0cy4gVXNpbmcgYE1vZGVsQ29uc3VtYWJsZWAgaGVscHMgYXZvaWRpbmcKICogdGhpcyBzaXR1YXRpb24sIGJlY2F1c2UgY2FsbGJhY2tzIHNob3VsZCBvbmx5IGNvbnZlcnQgdGhvc2UgdmFsdWVzLCB3aGljaCB3ZXJlIG5vdCB5ZXQgY29uc3VtZWQgZnJvbSBgTW9kZWxDb25zdW1hYmxlYC4KICoKICogQ29uc3VtaW5nIG11bHRpcGxlIHZhbHVlcyBpbiBhIHNpbmdsZSBjYWxsYmFjazoKICoKICoJCS8vIENvbnZlcnRlciBmb3IgY3VzdG9tIGBpbWFnZWAgZWxlbWVudCB0aGF0IG1pZ2h0IGhhdmUgYSBgY2FwdGlvbmAgZWxlbWVudCBpbnNpZGUgd2hpY2ggY2hhbmdlcwogKgkJLy8gaG93IHRoZSBpbWFnZSBpcyBkaXNwbGF5ZWQgaW4gdGhlIHZpZXc6CiAqCQkvLwogKgkJLy8gTW9kZWw6CiAqCQkvLwogKgkJLy8gW2ltYWdlXQogKgkJLy8gICDilJTilIAgW2NhcHRpb25dCiAqCQkvLyAgICAgICDilJTilIAgZm9vCiAqCQkvLwogKgkJLy8gVmlldzoKICoJCS8vCiAqCQkvLyA8ZmlndXJlPgogKgkJLy8gICDilJzilIAgPGltZyAvPgogKgkJLy8gICDilJTilIAgPGNhcHRpb24+CiAqCQkvLyAgICAgICDilJTilIAgZm9vCiAqCQltb2RlbENvbnZlcnNpb25EaXNwYXRjaGVyLm9uKCAnaW5zZXJ0OmltYWdlJywgKCBldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkgKSA9PiB7CiAqCQkJLy8gRmlyc3QsIGNvbnN1bWUgdGhlIGBpbWFnZWAgZWxlbWVudC4KICoJCQljb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZSggZGF0YS5pdGVtLCAnaW5zZXJ0JyApOwogKgogKgkJCS8vIEp1c3QgY3JlYXRlIG5vcm1hbCBpbWFnZSBlbGVtZW50IGZvciB0aGUgdmlldy4KICoJCQkvLyBNYXliZSBpdCB3aWxsIGJlICJkZWNvcmF0ZWQiIGxhdGVyLgogKgkJCWNvbnN0IHZpZXdJbWFnZSA9IG5ldyBWaWV3RWxlbWVudCggJ2ltZycgKTsKICoJCQljb25zdCBpbnNlcnRQb3NpdGlvbiA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1Bvc2l0aW9uKCBkYXRhLnJhbmdlLnN0YXJ0ICk7CiAqCQkJY29uc3Qgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOwogKgogKgkJCS8vIENoZWNrIGlmIHRoZSBgaW1hZ2VgIGVsZW1lbnQgaGFzIGNoaWxkcmVuLgogKgkJCWlmICggZGF0YS5pdGVtLmNoaWxkQ291bnQgPiAwICkgewogKgkJCQljb25zdCBtb2RlbENhcHRpb24gPSBkYXRhLml0ZW0uZ2V0Q2hpbGQoIDAgKTsKICoKICoJCQkJLy8gYG1vZGVsQ2FwdGlvbmAgaW5zZXJ0aW9uIGNoYW5nZSBpcyBjb25zdW1lZCBmcm9tIGNvbnN1bWFibGUgdmFsdWVzLgogKgkJCQkvLyBJdCB3aWxsIG5vdCBiZSBjb252ZXJ0ZWQgYnkgb3RoZXIgY29udmVydGVycywgYnV0IGl0J3MgY2hpbGRyZW4gKHByb2JhYmx5IHNvbWUgdGV4dCkgd2lsbCBiZS4KICoJCQkJLy8gVGhyb3VnaCBtYXBwaW5nLCBjb252ZXJ0ZXJzIGZvciB0ZXh0IHdpbGwga25vdyB3aGVyZSB0byBpbnNlcnQgY29udGVudHMgb2YgYG1vZGVsQ2FwdGlvbmAuCiAqCQkJCWlmICggY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoIG1vZGVsQ2FwdGlvbiwgJ2luc2VydCcgKSApIHsKICoJCQkJCWNvbnN0IHZpZXdDYXB0aW9uID0gbmV3IFZpZXdFbGVtZW50KCAnZmlnY2FwdGlvbicgKTsKICoKICoJCQkJCWNvbnN0IHZpZXdJbWFnZUhvbGRlciA9IG5ldyBWaWV3RWxlbWVudCggJ2ZpZ3VyZScsIG51bGwsIFsgdmlld0ltYWdlLCB2aWV3Q2FwdGlvbiBdICk7CiAqCiAqCQkJCQljb252ZXJzaW9uQXBpLm1hcHBlci5iaW5kRWxlbWVudHMoIG1vZGVsQ2FwdGlvbiwgdmlld0NhcHRpb24gKTsKICoJCQkJCWNvbnZlcnNpb25BcGkubWFwcGVyLmJpbmRFbGVtZW50cyggZGF0YS5pdGVtLCB2aWV3SW1hZ2VIb2xkZXIgKTsKICoJCQkJCXZpZXdXcml0ZXIuaW5zZXJ0KCBpbnNlcnRQb3NpdGlvbiwgdmlld0ltYWdlSG9sZGVyICk7CiAqCQkJCX0KICoJCQl9IGVsc2UgewogKgkJCQljb252ZXJzaW9uQXBpLm1hcHBlci5iaW5kRWxlbWVudHMoIGRhdGEuaXRlbSwgdmlld0ltYWdlICk7CiAqCQkJCXZpZXdXcml0ZXIuaW5zZXJ0KCBpbnNlcnRQb3NpdGlvbiwgdmlld0ltYWdlICk7CiAqCQkJfQogKgogKgkJCWV2dC5zdG9wKCk7CiAqCQl9ICk7CiAqLwoKdmFyIE1vZGVsQ29uc3VtYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBlbXB0eSBjb25zdW1hYmxlcyBsaXN0LgogICAqLwogIGZ1bmN0aW9uIE1vZGVsQ29uc3VtYWJsZSgpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RlbENvbnN1bWFibGUpOwoKICAgIC8qKgogICAgICogQ29udGFpbnMgbGlzdCBvZiBjb25zdW1hYmxlIHZhbHVlcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7TWFwfSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbW9kZWxjb25zdW1hYmxlfk1vZGVsQ29uc3VtYWJsZSNfY29uc3VtYWJsZQogICAgICovCiAgICB0aGlzLl9jb25zdW1hYmxlID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBGb3IgZWFjaCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5fSBhZGRlZCB0byBgTW9kZWxDb25zdW1hYmxlYCwgdGhpcyByZWdpc3RyeSBob2xkcyBwYXJlbnQKICAgICAqIG9mIHRoYXQgYFRleHRQcm94eWAgYW5kIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBvZiB0aGF0IGBUZXh0UHJveHlgLiBUaGlzIGFsbG93cyBpZGVudGlmaWNhdGlvbiBvZiBgVGV4dFByb3h5YAogICAgICogaW5zdGFuY2VzIHRoYXQgcG9pbnRzIHRvIHRoZSBzYW1lIHBhcnQgb2YgdGhlIG1vZGVsIGJ1dCBhcmUgZGlmZmVyZW50IGluc3RhbmNlcy4gRWFjaCBkaXN0aW5jdCBgVGV4dFByb3h5YAogICAgICogaXMgZ2l2ZW4gdW5pcXVlIGBTeW1ib2xgIHdoaWNoIGlzIHRoZW4gcmVnaXN0ZXJlZCBhcyBjb25zdW1hYmxlLiBUaGlzIHByb2Nlc3MgaXMgdHJhbnNwYXJlbnQgZm9yIGBNb2RlbENvbnN1bWFibGVgCiAgICAgKiBBUEkgdXNlciBiZWNhdXNlIHdoZW5ldmVyIGBUZXh0UHJveHlgIGlzIGFkZGVkLCB0ZXN0ZWQsIGNvbnN1bWVkIG9yIHJldmVydGVkLCBpbnRlcm5hbCBtZWNoYW5pc21zIG9mCiAgICAgKiBgTW9kZWxDb25zdW1hYmxlYCB0cmFuc2xhdGVzIGBUZXh0UHJveHlgIHRvIHRoYXQgdW5pcXVlIGBTeW1ib2xgLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtNYXB9IG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tb2RlbGNvbnN1bWFibGV+TW9kZWxDb25zdW1hYmxlI190ZXh0UHJveHlSZWdpc3RyeQogICAgICovCgogICAgdGhpcy5fdGV4dFByb3h5UmVnaXN0cnkgPSBuZXcgTWFwKCk7CiAgfQogIC8qKgogICAqIEFkZHMgYSBjb25zdW1hYmxlIHZhbHVlIHRvIHRoZSBjb25zdW1hYmxlcyBsaXN0IGFuZCBsaW5rcyBpdCB3aXRoIGdpdmVuIG1vZGVsIGl0ZW0uCiAgICoKICAgKgkJbW9kZWxDb25zdW1hYmxlLmFkZCggbW9kZWxFbGVtZW50LCAnaW5zZXJ0JyApOyAvLyBBZGQgYG1vZGVsRWxlbWVudGAgaW5zZXJ0aW9uIGNoYW5nZSB0byBjb25zdW1hYmxlIHZhbHVlcy4KICAgKgkJbW9kZWxDb25zdW1hYmxlLmFkZCggbW9kZWxFbGVtZW50LCAnYWRkQXR0cmlidXRlOmJvbGQnICk7IC8vIEFkZCBgYm9sZGAgYXR0cmlidXRlIGluc2VydGlvbiBvbiBgbW9kZWxFbGVtZW50YCBjaGFuZ2UuCiAgICoJCW1vZGVsQ29uc3VtYWJsZS5hZGQoIG1vZGVsRWxlbWVudCwgJ3JlbW92ZUF0dHJpYnV0ZTpib2xkJyApOyAvLyBBZGQgYGJvbGRgIGF0dHJpYnV0ZSByZW1vdmFsIG9uIGBtb2RlbEVsZW1lbnRgIGNoYW5nZS4KICAgKgkJbW9kZWxDb25zdW1hYmxlLmFkZCggbW9kZWxTZWxlY3Rpb24sICdzZWxlY3Rpb24nICk7IC8vIEFkZCBgbW9kZWxTZWxlY3Rpb25gIHRvIGNvbnN1bWFibGUgdmFsdWVzLgogICAqCQltb2RlbENvbnN1bWFibGUuYWRkKCBtb2RlbFJhbmdlLCAncmFuZ2UnICk7IC8vIEFkZCBgbW9kZWxSYW5nZWAgdG8gY29uc3VtYWJsZSB2YWx1ZXMuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpdGVtCiAgICogTW9kZWwgaXRlbSwgcmFuZ2Ugb3Igc2VsZWN0aW9uIHRoYXQgaGFzIHRoZSBjb25zdW1hYmxlLgogICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIENvbnN1bWFibGUgdHlwZS4gV2lsbCBiZSBub3JtYWxpemVkIHRvIGEgcHJvcGVyIGZvcm0sIHRoYXQgaXMgZWl0aGVyIGA8d29yZD5gIG9yIGA8cGFydD46PHBhcnQ+YC4KICAgKiBTZWNvbmQgY29sb24gYW5kIGV2ZXJ5dGhpbmcgYWZ0ZXIgd2lsbCBiZSBjdXQuIFBhc3NpbmcgZXZlbnQgbmFtZSBpcyBhIHNhZmUgYW5kIGdvb2QgcHJhY3RpY2UuCiAgICovCgoKICBfY3JlYXRlQ2xhc3MoTW9kZWxDb25zdW1hYmxlLCBbewogICAga2V5OiAiYWRkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoaXRlbSwgdHlwZSkgewogICAgICB0eXBlID0gX25vcm1hbGl6ZUNvbnN1bWFibGVUeXBlKHR5cGUpOwoKICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0UHJveHkpIHsKICAgICAgICBpdGVtID0gdGhpcy5fZ2V0U3ltYm9sRm9yVGV4dFByb3h5KGl0ZW0pOwogICAgICB9CgogICAgICBpZiAoIXRoaXMuX2NvbnN1bWFibGUuaGFzKGl0ZW0pKSB7CiAgICAgICAgdGhpcy5fY29uc3VtYWJsZS5zZXQoaXRlbSwgbmV3IE1hcCgpKTsKICAgICAgfQoKICAgICAgdGhpcy5fY29uc3VtYWJsZS5nZXQoaXRlbSkuc2V0KHR5cGUsIHRydWUpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGdpdmVuIGNvbnN1bWFibGUgdmFsdWUgZnJvbSBnaXZlbiBtb2RlbCBpdGVtLgogICAgICoKICAgICAqCQltb2RlbENvbnN1bWFibGUuY29uc3VtZSggbW9kZWxFbGVtZW50LCAnaW5zZXJ0JyApOyAvLyBSZW1vdmUgYG1vZGVsRWxlbWVudGAgaW5zZXJ0aW9uIGNoYW5nZSBmcm9tIGNvbnN1bWFibGUgdmFsdWVzLgogICAgICoJCW1vZGVsQ29uc3VtYWJsZS5jb25zdW1lKCBtb2RlbEVsZW1lbnQsICdhZGRBdHRyaWJ1dGU6Ym9sZCcgKTsgLy8gUmVtb3ZlIGBib2xkYCBhdHRyaWJ1dGUgaW5zZXJ0aW9uIG9uIGBtb2RlbEVsZW1lbnRgIGNoYW5nZS4KICAgICAqCQltb2RlbENvbnN1bWFibGUuY29uc3VtZSggbW9kZWxFbGVtZW50LCAncmVtb3ZlQXR0cmlidXRlOmJvbGQnICk7IC8vIFJlbW92ZSBgYm9sZGAgYXR0cmlidXRlIHJlbW92YWwgb24gYG1vZGVsRWxlbWVudGAgY2hhbmdlLgogICAgICoJCW1vZGVsQ29uc3VtYWJsZS5jb25zdW1lKCBtb2RlbFNlbGVjdGlvbiwgJ3NlbGVjdGlvbicgKTsgLy8gUmVtb3ZlIGBtb2RlbFNlbGVjdGlvbmAgZnJvbSBjb25zdW1hYmxlIHZhbHVlcy4KICAgICAqCQltb2RlbENvbnN1bWFibGUuY29uc3VtZSggbW9kZWxSYW5nZSwgJ3JhbmdlJyApOyAvLyBSZW1vdmUgJ21vZGVsUmFuZ2UnIGZyb20gY29uc3VtYWJsZSB2YWx1ZXMuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gaXRlbQogICAgICogTW9kZWwgaXRlbSwgcmFuZ2Ugb3Igc2VsZWN0aW9uIGZyb20gd2hpY2ggY29uc3VtYWJsZSB3aWxsIGJlIGNvbnN1bWVkLgogICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQ29uc3VtYWJsZSB0eXBlLiBXaWxsIGJlIG5vcm1hbGl6ZWQgdG8gYSBwcm9wZXIgZm9ybSwgdGhhdCBpcyBlaXRoZXIgYDx3b3JkPmAgb3IgYDxwYXJ0Pjo8cGFydD5gLgogICAgICogU2Vjb25kIGNvbG9uIGFuZCBldmVyeXRoaW5nIGFmdGVyIHdpbGwgYmUgY3V0LiBQYXNzaW5nIGV2ZW50IG5hbWUgaXMgYSBzYWZlIGFuZCBnb29kIHByYWN0aWNlLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBjb25zdW1hYmxlIHZhbHVlIHdhcyBhdmFpbGFibGUgYW5kIHdhcyBjb25zdW1lZCwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29uc3VtZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShpdGVtLCB0eXBlKSB7CiAgICAgIHR5cGUgPSBfbm9ybWFsaXplQ29uc3VtYWJsZVR5cGUodHlwZSk7CgogICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHRQcm94eSkgewogICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRTeW1ib2xGb3JUZXh0UHJveHkoaXRlbSk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnRlc3QoaXRlbSwgdHlwZSkpIHsKICAgICAgICB0aGlzLl9jb25zdW1hYmxlLmdldChpdGVtKS5zZXQodHlwZSwgZmFsc2UpOwoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVGVzdHMgd2hldGhlciB0aGVyZSBpcyBhIGNvbnN1bWFibGUgdmFsdWUgb2YgZ2l2ZW4gdHlwZSBjb25uZWN0ZWQgd2l0aCBnaXZlbiBtb2RlbCBpdGVtLgogICAgICoKICAgICAqCQltb2RlbENvbnN1bWFibGUudGVzdCggbW9kZWxFbGVtZW50LCAnaW5zZXJ0JyApOyAvLyBDaGVjayBmb3IgYG1vZGVsRWxlbWVudGAgaW5zZXJ0aW9uIGNoYW5nZS4KICAgICAqCQltb2RlbENvbnN1bWFibGUudGVzdCggbW9kZWxFbGVtZW50LCAnYWRkQXR0cmlidXRlOmJvbGQnICk7IC8vIENoZWNrIGZvciBgYm9sZGAgYXR0cmlidXRlIGluc2VydGlvbiBvbiBgbW9kZWxFbGVtZW50YCBjaGFuZ2UuCiAgICAgKgkJbW9kZWxDb25zdW1hYmxlLnRlc3QoIG1vZGVsRWxlbWVudCwgJ3JlbW92ZUF0dHJpYnV0ZTpib2xkJyApOyAvLyBDaGVjayBmb3IgYGJvbGRgIGF0dHJpYnV0ZSByZW1vdmFsIG9uIGBtb2RlbEVsZW1lbnRgIGNoYW5nZS4KICAgICAqCQltb2RlbENvbnN1bWFibGUudGVzdCggbW9kZWxTZWxlY3Rpb24sICdzZWxlY3Rpb24nICk7IC8vIENoZWNrIGlmIGBtb2RlbFNlbGVjdGlvbmAgaXMgY29uc3VtYWJsZS4KICAgICAqCQltb2RlbENvbnN1bWFibGUudGVzdCggbW9kZWxSYW5nZSwgJ3JhbmdlJyApOyAvLyBDaGVjayBpZiBgbW9kZWxSYW5nZWAgaXMgY29uc3VtYWJsZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpdGVtCiAgICAgKiBNb2RlbCBpdGVtLCByYW5nZSBvciBzZWxlY3Rpb24gdG8gYmUgdGVzdGVkLgogICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQ29uc3VtYWJsZSB0eXBlLiBXaWxsIGJlIG5vcm1hbGl6ZWQgdG8gYSBwcm9wZXIgZm9ybSwgdGhhdCBpcyBlaXRoZXIgYDx3b3JkPmAgb3IgYDxwYXJ0Pjo8cGFydD5gLgogICAgICogU2Vjb25kIGNvbG9uIGFuZCBldmVyeXRoaW5nIGFmdGVyIHdpbGwgYmUgY3V0LiBQYXNzaW5nIGV2ZW50IG5hbWUgaXMgYSBzYWZlIGFuZCBnb29kIHByYWN0aWNlLgogICAgICogQHJldHVybnMge251bGx8Qm9vbGVhbn0gYG51bGxgIGlmIHN1Y2ggY29uc3VtYWJsZSB3YXMgbmV2ZXIgYWRkZWQsIGBmYWxzZWAgaWYgdGhlIGNvbnN1bWFibGUgdmFsdWVzIHdhcwogICAgICogYWxyZWFkeSBjb25zdW1lZCBvciBgdHJ1ZWAgaWYgaXQgd2FzIGFkZGVkIGFuZCBub3QgY29uc3VtZWQgeWV0LgogICAgICovCgogIH0sIHsKICAgIGtleTogInRlc3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRlc3QoaXRlbSwgdHlwZSkgewogICAgICB0eXBlID0gX25vcm1hbGl6ZUNvbnN1bWFibGVUeXBlKHR5cGUpOwoKICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0UHJveHkpIHsKICAgICAgICBpdGVtID0gdGhpcy5fZ2V0U3ltYm9sRm9yVGV4dFByb3h5KGl0ZW0pOwogICAgICB9CgogICAgICB2YXIgaXRlbUNvbnN1bWFibGVzID0gdGhpcy5fY29uc3VtYWJsZS5nZXQoaXRlbSk7CgogICAgICBpZiAoaXRlbUNvbnN1bWFibGVzID09PSB1bmRlZmluZWQpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgdmFyIHZhbHVlID0gaXRlbUNvbnN1bWFibGVzLmdldCh0eXBlKTsKCiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIHJldHVybiB2YWx1ZTsKICAgIH0KICAgIC8qKgogICAgICogUmV2ZXJ0cyBjb25zdW1pbmcgb2YgY29uc3VtYWJsZSB2YWx1ZS4KICAgICAqCiAgICAgKgkJbW9kZWxDb25zdW1hYmxlLnJldmVydCggbW9kZWxFbGVtZW50LCAnaW5zZXJ0JyApOyAvLyBSZXZlcnQgY29uc3VtaW5nIGBtb2RlbEVsZW1lbnRgIGluc2VydGlvbiBjaGFuZ2UuCiAgICAgKgkJbW9kZWxDb25zdW1hYmxlLnJldmVydCggbW9kZWxFbGVtZW50LCAnYWRkQXR0cmlidXRlOmJvbGQnICk7IC8vIFJldmVydCBjb25zdW1pbmcgYGJvbGRgIGF0dHJpYnV0ZSBpbnNlcnQgZnJvbSBgbW9kZWxFbGVtZW50YC4KICAgICAqCQltb2RlbENvbnN1bWFibGUucmV2ZXJ0KCBtb2RlbEVsZW1lbnQsICdyZW1vdmVBdHRyaWJ1dGU6Ym9sZCcgKTsgLy8gUmV2ZXJ0IGNvbnN1bWluZyBgYm9sZGAgYXR0cmlidXRlIHJlbW92ZSBmcm9tIGBtb2RlbEVsZW1lbnRgLgogICAgICoJCW1vZGVsQ29uc3VtYWJsZS5yZXZlcnQoIG1vZGVsU2VsZWN0aW9uLCAnc2VsZWN0aW9uJyApOyAvLyBSZXZlcnQgY29uc3VtaW5nIGBtb2RlbFNlbGVjdGlvbmAuCiAgICAgKgkJbW9kZWxDb25zdW1hYmxlLnJldmVydCggbW9kZWxSYW5nZSwgJ3JhbmdlJyApOyAvLyBSZXZlcnQgY29uc3VtaW5nIGBtb2RlbFJhbmdlYC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpdGVtCiAgICAgKiBNb2RlbCBpdGVtLCByYW5nZSBvciBzZWxlY3Rpb24gdG8gYmUgcmV2ZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBDb25zdW1hYmxlIHR5cGUuCiAgICAgKiBAcmV0dXJucyB7bnVsbHxCb29sZWFufSBgdHJ1ZWAgaWYgY29uc3VtYWJsZSBoYXMgYmVlbiByZXZlcnNlZCwgYGZhbHNlYCBvdGhlcndpc2UuIGBudWxsYCBpZiB0aGUgY29uc3VtYWJsZSBoYXMKICAgICAqIG5ldmVyIGJlZW4gYWRkZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmV2ZXJ0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnQoaXRlbSwgdHlwZSkgewogICAgICB0eXBlID0gX25vcm1hbGl6ZUNvbnN1bWFibGVUeXBlKHR5cGUpOwoKICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0UHJveHkpIHsKICAgICAgICBpdGVtID0gdGhpcy5fZ2V0U3ltYm9sRm9yVGV4dFByb3h5KGl0ZW0pOwogICAgICB9CgogICAgICB2YXIgdGVzdCA9IHRoaXMudGVzdChpdGVtLCB0eXBlKTsKCiAgICAgIGlmICh0ZXN0ID09PSBmYWxzZSkgewogICAgICAgIHRoaXMuX2NvbnN1bWFibGUuZ2V0KGl0ZW0pLnNldCh0eXBlLCB0cnVlKTsKCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0gZWxzZSBpZiAodGVzdCA9PT0gdHJ1ZSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgYSB1bmlxdWUgc3ltYm9sIGZvciBwYXNzZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eX0gaW5zdGFuY2UuIEFsbCBgVGV4dFByb3h5YCBpbnN0YW5jZXMgdGhhdAogICAgICogaGF2ZSBzYW1lIHBhcmVudCwgc2FtZSBzdGFydCBpbmRleCBhbmQgc2FtZSBlbmQgaW5kZXggd2lsbCBnZXQgdGhlIHNhbWUgc3ltYm9sLgogICAgICoKICAgICAqIFVzZWQgaW50ZXJuYWxseSB0byBjb3JyZWN0bHkgY29uc3VtZSBgVGV4dFByb3h5YCBpbnN0YW5jZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5fSB0ZXh0UHJveHkgYFRleHRQcm94eWAgaW5zdGFuY2UgdG8gZ2V0IGEgc3ltYm9sIGZvci4KICAgICAqIEByZXR1cm5zIHtTeW1ib2x9IFN5bWJvbCByZXByZXNlbnRpbmcgYWxsIGVxdWFsIGluc3RhbmNlcyBvZiBgVGV4dFByb3h5YC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0U3ltYm9sRm9yVGV4dFByb3h5IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3ltYm9sRm9yVGV4dFByb3h5KHRleHRQcm94eSkgewogICAgICB2YXIgc3ltYm9sID0gbnVsbDsKCiAgICAgIHZhciBzdGFydE1hcCA9IHRoaXMuX3RleHRQcm94eVJlZ2lzdHJ5LmdldCh0ZXh0UHJveHkuc3RhcnRPZmZzZXQpOwoKICAgICAgaWYgKHN0YXJ0TWFwKSB7CiAgICAgICAgdmFyIGVuZE1hcCA9IHN0YXJ0TWFwLmdldCh0ZXh0UHJveHkuZW5kT2Zmc2V0KTsKCiAgICAgICAgaWYgKGVuZE1hcCkgewogICAgICAgICAgc3ltYm9sID0gZW5kTWFwLmdldCh0ZXh0UHJveHkucGFyZW50KTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICghc3ltYm9sKSB7CiAgICAgICAgc3ltYm9sID0gdGhpcy5fYWRkU3ltYm9sRm9yVGV4dFByb3h5KHRleHRQcm94eS5zdGFydE9mZnNldCwgdGV4dFByb3h5LmVuZE9mZnNldCwgdGV4dFByb3h5LnBhcmVudCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBzeW1ib2w7CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgYSBzeW1ib2wgZm9yIGdpdmVuIHByb3BlcnRpZXMgdGhhdCBjaGFyYWN0ZXJpemVzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eX0gaW5zdGFuY2UuCiAgICAgKgogICAgICogVXNlZCBpbnRlcm5hbGx5IHRvIGNvcnJlY3RseSBjb25zdW1lIGBUZXh0UHJveHlgIGluc3RhbmNlcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0SW5kZXggVGV4dCBwcm94eSBzdGFydCBpbmRleCBpbiBpdCdzIHBhcmVudC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRJbmRleCBUZXh0IHByb3h5IGVuZCBpbmRleCBpbiBpdCdzIHBhcmVudC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudCBUZXh0IHByb3h5IHBhcmVudC4KICAgICAqIEByZXR1cm5zIHtTeW1ib2x9IFN5bWJvbCBnZW5lcmF0ZWQgZm9yIGdpdmVuIHByb3BlcnRpZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2FkZFN5bWJvbEZvclRleHRQcm94eSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFN5bWJvbEZvclRleHRQcm94eShzdGFydCwgZW5kLCBwYXJlbnQpIHsKICAgICAgdmFyIHN5bWJvbCA9IFN5bWJvbCgndGV4dFByb3h5U3ltYm9sJyk7CiAgICAgIHZhciBzdGFydE1hcCwgZW5kTWFwOwogICAgICBzdGFydE1hcCA9IHRoaXMuX3RleHRQcm94eVJlZ2lzdHJ5LmdldChzdGFydCk7CgogICAgICBpZiAoIXN0YXJ0TWFwKSB7CiAgICAgICAgc3RhcnRNYXAgPSBuZXcgTWFwKCk7CgogICAgICAgIHRoaXMuX3RleHRQcm94eVJlZ2lzdHJ5LnNldChzdGFydCwgc3RhcnRNYXApOwogICAgICB9CgogICAgICBlbmRNYXAgPSBzdGFydE1hcC5nZXQoZW5kKTsKCiAgICAgIGlmICghZW5kTWFwKSB7CiAgICAgICAgZW5kTWFwID0gbmV3IE1hcCgpOwogICAgICAgIHN0YXJ0TWFwLnNldChlbmQsIGVuZE1hcCk7CiAgICAgIH0KCiAgICAgIGVuZE1hcC5zZXQocGFyZW50LCBzeW1ib2wpOwogICAgICByZXR1cm4gc3ltYm9sOwogICAgfQogIH1dKTsKCiAgcmV0dXJuIE1vZGVsQ29uc3VtYWJsZTsKfSgpOyAvLyBSZXR1cm5zIGEgbm9ybWFsaXplZCBjb25zdW1hYmxlIHR5cGUgbmFtZSBmcm9tIGdpdmVuIHN0cmluZy4gQSBub3JtYWxpemVkIGNvbnN1bWFibGUgdHlwZSBuYW1lIGlzIGEgc3RyaW5nIHRoYXQgaGFzCi8vIGF0IG1vc3Qgb25lIGNvbG9uLCBmb3IgZXhhbXBsZTogYGluc2VydGAgb3IgYGFkZE1hcmtlcjpoaWdobGlnaHRgLiBJZiBzdHJpbmcgdG8gbm9ybWFsaXplIGhhcyBtb3JlICJwYXJ0cyIgKG1vcmUgY29sb25zKSwKLy8gdGhlIG90aGVyIHBhcnRzIGFyZSBkcm9wcGVkLCBmb3IgZXhhbXBsZTogYGFkZGF0dHJpYnV0ZTpib2xkOiR0ZXh0YCAtPiBgYWRkYXR0cmlidXRlczpib2xkYC4KLy8KLy8gQHBhcmFtIHtTdHJpbmd9IHR5cGUgQ29uc3VtYWJsZSB0eXBlLgovLyBAcmV0dXJucyB7U3RyaW5nfSBOb3JtYWxpemVkIGNvbnN1bWFibGUgdHlwZS4KCgpleHBvcnQgeyBNb2RlbENvbnN1bWFibGUgYXMgZGVmYXVsdCB9OwoKZnVuY3Rpb24gX25vcm1hbGl6ZUNvbnN1bWFibGVUeXBlKHR5cGUpIHsKICB2YXIgcGFydHMgPSB0eXBlLnNwbGl0KCc6Jyk7CiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1swXSArICc6JyArIHBhcnRzWzFdIDogcGFydHNbMF07Cn0="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js"],"names":["TextProxy","ModelConsumable","_consumable","Map","_textProxyRegistry","item","type","_normalizeConsumableType","_getSymbolForTextProxy","has","set","get","test","itemConsumables","undefined","value","textProxy","symbol","startMap","startOffset","endMap","endOffset","parent","_addSymbolForTextProxy","start","end","Symbol","parts","split","length"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,SAAP,MAAsB,oBAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,e;AACpB;AACD;AACA;AACC,6BAAc;AAAA;;AACb;AACF;AACA;AACA;AACA;AACA;AACE,SAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,kBAAL,GAA0B,IAAID,GAAJ,EAA1B;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACC,aAAKE,IAAL,EAAWC,IAAX,EAAkB;AACjBA,MAAAA,IAAI,GAAGC,wBAAwB,CAAED,IAAF,CAA/B;;AAEA,UAAKD,IAAI,YAAYL,SAArB,EAAiC;AAChCK,QAAAA,IAAI,GAAG,KAAKG,sBAAL,CAA6BH,IAA7B,CAAP;AACA;;AAED,UAAK,CAAC,KAAKH,WAAL,CAAiBO,GAAjB,CAAsBJ,IAAtB,CAAN,EAAqC;AACpC,aAAKH,WAAL,CAAiBQ,GAAjB,CAAsBL,IAAtB,EAA4B,IAAIF,GAAJ,EAA5B;AACA;;AAED,WAAKD,WAAL,CAAiBS,GAAjB,CAAsBN,IAAtB,EAA6BK,GAA7B,CAAkCJ,IAAlC,EAAwC,IAAxC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/modelconsumable\n */\n\nimport TextProxy from '../model/textproxy';\n\n/**\n * Manages a list of consumable values for {@link module:engine/model/item~Item model items}.\n *\n * Consumables are various aspects of the model. A model item can be broken down into singular properties that might be\n * taken into consideration when converting that item.\n *\n * `ModelConsumable` is used by {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} while analyzing changed\n * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down\n * into singular properties (the item itself and it's attributes). All those parts are saved in `ModelConsumable`. Then,\n * during conversion, when given part of model item is converted (i.e. the view element has been inserted into the view,\n * but without attributes), consumable value is removed from `ModelConsumable`.\n *\n * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addattribute:<attributeKey>`,\n * `changeattributes:<attributeKey>`, `removeattributes:<attributeKey>`.\n *\n * In most cases, it is enough to let {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * gather consumable values, so there is no need to use\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.\n * However, it is important to understand how consumable values can be\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n * See {@link module:engine/conversion/downcasthelpers default downcast converters} for more information.\n *\n * Keep in mind, that one conversion event may have multiple callbacks (converters) attached to it. Each of those is\n * able to convert one or more parts of the model. However, when one of those callbacks actually converts\n * something, other should not, because they would duplicate the results. Using `ModelConsumable` helps avoiding\n * this situation, because callbacks should only convert those values, which were not yet consumed from `ModelConsumable`.\n *\n * Consuming multiple values in a single callback:\n *\n *\t\t// Converter for custom `image` element that might have a `caption` element inside which changes\n *\t\t// how the image is displayed in the view:\n *\t\t//\n *\t\t// Model:\n *\t\t//\n *\t\t// [image]\n *\t\t//   └─ [caption]\n *\t\t//       └─ foo\n *\t\t//\n *\t\t// View:\n *\t\t//\n *\t\t// <figure>\n *\t\t//   ├─ <img />\n *\t\t//   └─ <caption>\n *\t\t//       └─ foo\n *\t\tmodelConversionDispatcher.on( 'insert:image', ( evt, data, conversionApi ) => {\n *\t\t\t// First, consume the `image` element.\n *\t\t\tconversionApi.consumable.consume( data.item, 'insert' );\n *\n *\t\t\t// Just create normal image element for the view.\n *\t\t\t// Maybe it will be \"decorated\" later.\n *\t\t\tconst viewImage = new ViewElement( 'img' );\n *\t\t\tconst insertPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\t\t\tconst viewWriter = conversionApi.writer;\n *\n *\t\t\t// Check if the `image` element has children.\n *\t\t\tif ( data.item.childCount > 0 ) {\n *\t\t\t\tconst modelCaption = data.item.getChild( 0 );\n *\n *\t\t\t\t// `modelCaption` insertion change is consumed from consumable values.\n *\t\t\t\t// It will not be converted by other converters, but it's children (probably some text) will be.\n *\t\t\t\t// Through mapping, converters for text will know where to insert contents of `modelCaption`.\n *\t\t\t\tif ( conversionApi.consumable.consume( modelCaption, 'insert' ) ) {\n *\t\t\t\t\tconst viewCaption = new ViewElement( 'figcaption' );\n *\n *\t\t\t\t\tconst viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );\n *\n *\t\t\t\t\tconversionApi.mapper.bindElements( modelCaption, viewCaption );\n *\t\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImageHolder );\n *\t\t\t\t\tviewWriter.insert( insertPosition, viewImageHolder );\n *\t\t\t\t}\n *\t\t\t} else {\n *\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImage );\n *\t\t\t\tviewWriter.insert( insertPosition, viewImage );\n *\t\t\t}\n *\n *\t\t\tevt.stop();\n *\t\t} );\n */\nexport default class ModelConsumable {\n\t/**\n\t * Creates an empty consumables list.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Contains list of consumable values.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable\n\t\t */\n\t\tthis._consumable = new Map();\n\n\t\t/**\n\t\t * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds parent\n\t\t * of that `TextProxy` and start and end indices of that `TextProxy`. This allows identification of `TextProxy`\n\t\t * instances that points to the same part of the model but are different instances. Each distinct `TextProxy`\n\t\t * is given unique `Symbol` which is then registered as consumable. This process is transparent for `ModelConsumable`\n\t\t * API user because whenever `TextProxy` is added, tested, consumed or reverted, internal mechanisms of\n\t\t * `ModelConsumable` translates `TextProxy` to that unique `Symbol`.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry\n\t\t */\n\t\tthis._textProxyRegistry = new Map();\n\t}\n\n\t/**\n\t * Adds a consumable value to the consumables list and links it with given model item.\n\t *\n\t *\t\tmodelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.\n\t *\t\tmodelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.\n\t *\t\tmodelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection that has the consumable.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t */\n\tadd( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tif ( !this._consumable.has( item ) ) {\n\t\t\tthis._consumable.set( item, new Map() );\n\t\t}\n\n\t\tthis._consumable.get( item ).set( type, true );\n\t}\n\n\t/**\n\t * Removes given consumable value from given model item.\n\t *\n\t *\t\tmodelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.\n\t *\t\tmodelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.\n\t *\t\tmodelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection from which consumable will be consumed.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.\n\t */\n\tconsume( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tif ( this.test( item, type ) ) {\n\t\t\tthis._consumable.get( item ).set( type, false );\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Tests whether there is a consumable value of given type connected with given model item.\n\t *\n\t *\t\tmodelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.\n\t *\t\tmodelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.\n\t *\t\tmodelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection to be tested.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was\n\t * already consumed or `true` if it was added and not consumed yet.\n\t */\n\ttest( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tconst itemConsumables = this._consumable.get( item );\n\n\t\tif ( itemConsumables === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst value = itemConsumables.get( type );\n\n\t\tif ( value === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Reverts consuming of consumable value.\n\t *\n\t *\t\tmodelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.\n\t *\t\tmodelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.\n\t *\t\tmodelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.\n\t *\t\tmodelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.\n\t *\t\tmodelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection to be reverted.\n\t * @param {String} type Consumable type.\n\t * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has\n\t * never been added.\n\t */\n\trevert( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tconst test = this.test( item, type );\n\n\t\tif ( test === false ) {\n\t\t\tthis._consumable.get( item ).set( type, true );\n\n\t\t\treturn true;\n\t\t} else if ( test === true ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Gets a unique symbol for passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that\n\t * have same parent, same start index and same end index will get the same symbol.\n\t *\n\t * Used internally to correctly consume `TextProxy` instances.\n\t *\n\t * @private\n\t * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.\n\t * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.\n\t */\n\t_getSymbolForTextProxy( textProxy ) {\n\t\tlet symbol = null;\n\n\t\tconst startMap = this._textProxyRegistry.get( textProxy.startOffset );\n\n\t\tif ( startMap ) {\n\t\t\tconst endMap = startMap.get( textProxy.endOffset );\n\n\t\t\tif ( endMap ) {\n\t\t\t\tsymbol = endMap.get( textProxy.parent );\n\t\t\t}\n\t\t}\n\n\t\tif ( !symbol ) {\n\t\t\tsymbol = this._addSymbolForTextProxy( textProxy.startOffset, textProxy.endOffset, textProxy.parent );\n\t\t}\n\n\t\treturn symbol;\n\t}\n\n\t/**\n\t * Adds a symbol for given properties that characterizes a {@link module:engine/model/textproxy~TextProxy} instance.\n\t *\n\t * Used internally to correctly consume `TextProxy` instances.\n\t *\n\t * @private\n\t * @param {Number} startIndex Text proxy start index in it's parent.\n\t * @param {Number} endIndex Text proxy end index in it's parent.\n\t * @param {module:engine/model/element~Element} parent Text proxy parent.\n\t * @returns {Symbol} Symbol generated for given properties.\n\t */\n\t_addSymbolForTextProxy( start, end, parent ) {\n\t\tconst symbol = Symbol( 'textProxySymbol' );\n\t\tlet startMap, endMap;\n\n\t\tstartMap = this._textProxyRegistry.get( start );\n\n\t\tif ( !startMap ) {\n\t\t\tstartMap = new Map();\n\t\t\tthis._textProxyRegistry.set( start, startMap );\n\t\t}\n\n\t\tendMap = startMap.get( end );\n\n\t\tif ( !endMap ) {\n\t\t\tendMap = new Map();\n\t\t\tstartMap.set( end, endMap );\n\t\t}\n\n\t\tendMap.set( parent, symbol );\n\n\t\treturn symbol;\n\t}\n}\n\n// Returns a normalized consumable type name from given string. A normalized consumable type name is a string that has\n// at most one colon, for example: `insert` or `addMarker:highlight`. If string to normalize has more \"parts\" (more colons),\n// the other parts are dropped, for example: `addattribute:bold:$text` -> `addattributes:bold`.\n//\n// @param {String} type Consumable type.\n// @returns {String} Normalized consumable type.\nfunction _normalizeConsumableType( type ) {\n\tconst parts = type.split( ':' );\n\n\treturn parts.length > 1 ? parts[ 0 ] + ':' + parts[ 1 ] : parts[ 0 ];\n}\n"]}]}