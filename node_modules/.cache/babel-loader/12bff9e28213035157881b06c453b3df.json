{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIGZyb20gIi9ob21lL2VrZWJlcmF0L1lhbmRleC5EaXNrL1Byb2plbGVyaW0vQmVuaW1Qcm9qZWxlcmltL3dlYnNpdGVtL3dlYnNpdGVtLXdlYi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyCiAqLwppbXBvcnQgVmlld0NvbnN1bWFibGUgZnJvbSAnLi92aWV3Y29uc3VtYWJsZSc7CmltcG9ydCBNb2RlbFJhbmdlIGZyb20gJy4uL21vZGVsL3JhbmdlJzsKaW1wb3J0IE1vZGVsUG9zaXRpb24gZnJvbSAnLi4vbW9kZWwvcG9zaXRpb24nOwppbXBvcnQgeyBTY2hlbWFDb250ZXh0IH0gZnJvbSAnLi4vbW9kZWwvc2NoZW1hJzsKaW1wb3J0IHsgaXNQYXJhZ3JhcGhhYmxlLCB3cmFwSW5QYXJhZ3JhcGggfSBmcm9tICcuLi9tb2RlbC91dGlscy9hdXRvcGFyYWdyYXBoaW5nJzsKaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7CmltcG9ydCBFbWl0dGVyTWl4aW4gZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvZW1pdHRlcm1peGluJzsKaW1wb3J0IG1peCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9taXgnOwovKioKICogVXBjYXN0IGRpc3BhdGNoZXIgaXMgYSBjZW50cmFsIHBvaW50IG9mIHRoZSB2aWV3LXRvLW1vZGVsIGNvbnZlcnNpb24sIHdoaWNoIGlzIGEgcHJvY2VzcyBvZgogKiBjb252ZXJ0aW5nIGEgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgdmlldyBkb2N1bWVudCBmcmFnbWVudH0gb3IKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fSBpbnRvIGEgY29ycmVjdCBtb2RlbCBzdHJ1Y3R1cmUuCiAqCiAqIER1cmluZyB0aGUgY29udmVyc2lvbiBwcm9jZXNzLCB0aGUgZGlzcGF0Y2hlciBmaXJlcyBldmVudHMgZm9yIGFsbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZSB2aWV3IG5vZGVzfQogKiBmcm9tIHRoZSBjb252ZXJ0ZWQgdmlldyBkb2N1bWVudCBmcmFnbWVudC4KICogU3BlY2lhbCBjYWxsYmFja3MgY2FsbGVkICJjb252ZXJ0ZXJzIiBzaG91bGQgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBvcmRlciB0byBjb252ZXJ0IHRoZSB2aWV3IG5vZGVzLgogKgogKiBUaGUgc2Vjb25kIHBhcmFtZXRlciBvZiB0aGUgY2FsbGJhY2sgaXMgdGhlIGBkYXRhYCBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAqCiAqICogYGRhdGEudmlld0l0ZW1gIGNvbnRhaW5zIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgdmlldyBub2RlfSBvciBhCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IHZpZXcgZG9jdW1lbnQgZnJhZ21lbnR9CiAqIHRoYXQgaXMgY29udmVydGVkIGF0IHRoZSBtb21lbnQgYW5kIG1pZ2h0IGJlIGhhbmRsZWQgYnkgdGhlIGNhbGxiYWNrLgogKiAqIGBkYXRhLm1vZGVsUmFuZ2VgIGlzIHVzZWQgdG8gcG9pbnQgdG8gdGhlIHJlc3VsdAogKiBvZiB0aGUgY3VycmVudCBjb252ZXJzaW9uIChlLmcuIHRoZSBlbGVtZW50IHRoYXQgaXMgYmVpbmcgaW5zZXJ0ZWQpCiAqIGFuZCBpcyBhbHdheXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gd2hlbiB0aGUgY29udmVyc2lvbiBzdWNjZWVkcy4KICogKiBgZGF0YS5tb2RlbEN1cnNvcmAgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0gb24gd2hpY2ggdGhlIGNvbnZlcnRlciBzaG91bGQgaW5zZXJ0CiAqIHRoZSBuZXdseSBjcmVhdGVkIGl0ZW1zLgogKgogKiBUaGUgdGhpcmQgcGFyYW1ldGVyIG9mIHRoZSBjYWxsYmFjayBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0KICogd2hpY2ggcHJvdmlkZXMgYWRkaXRpb25hbCB0b29scyBmb3IgY29udmVydGVycy4KICoKICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgY29udmVyc2lvbiBpbiB0aGUgZm9sbG93aW5nIGd1aWRlczoKICoKICogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvZGVlcC1kaXZlL2NvbnZlcnNpb24vY29udmVyc2lvbi1pbnRyb2R1Y3Rpb24gQWR2YW5jZWQgY29udmVyc2lvbiBjb25jZXB0cyAmbWRhc2g7IGF0dHJpYnV0ZXN9CiAqICoge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2RlZXAtZGl2ZS9jb252ZXJzaW9uL2N1c3RvbS1lbGVtZW50LWNvbnZlcnNpb24gQ3VzdG9tIGVsZW1lbnQgY29udmVyc2lvbn0KICoKICogRXhhbXBsZXMgb2YgZXZlbnQtYmFzZWQgY29udmVydGVyczoKICoKICoJCS8vIEEgY29udmVydGVyIGZvciBsaW5rcyAoPGE+KS4KICoJCWVkaXRvci5kYXRhLnVwY2FzdERpc3BhdGNoZXIub24oICdlbGVtZW50OmEnLCAoIGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSApID0+IHsKICoJCQlpZiAoIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKCBkYXRhLnZpZXdJdGVtLCB7IG5hbWU6IHRydWUsIGF0dHJpYnV0ZXM6IFsgJ2hyZWYnIF0gfSApICkgewogKgkJCQkvLyBUaGUgPGE+IGVsZW1lbnQgaXMgaW5saW5lIGFuZCBpcyByZXByZXNlbnRlZCBieSBhbiBhdHRyaWJ1dGUgaW4gdGhlIG1vZGVsLgogKgkJCQkvLyBUaGlzIGlzIHdoeSB5b3UgbmVlZCB0byBjb252ZXJ0IG9ubHkgY2hpbGRyZW4uCiAqCQkJCWNvbnN0IHsgbW9kZWxSYW5nZSB9ID0gY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4oIGRhdGEudmlld0l0ZW0sIGRhdGEubW9kZWxDdXJzb3IgKTsKICoKICoJCQkJZm9yICggbGV0IGl0ZW0gb2YgbW9kZWxSYW5nZS5nZXRJdGVtcygpICkgewogKgkJCQkJaWYgKCBjb252ZXJzaW9uQXBpLnNjaGVtYS5jaGVja0F0dHJpYnV0ZSggaXRlbSwgJ2xpbmtIcmVmJyApICkgewogKgkJCQkJCWNvbnZlcnNpb25BcGkud3JpdGVyLnNldEF0dHJpYnV0ZSggJ2xpbmtIcmVmJywgZGF0YS52aWV3SXRlbS5nZXRBdHRyaWJ1dGUoICdocmVmJyApLCBpdGVtICk7CiAqCQkJCQl9CiAqCQkJCX0KICoJCQl9CiAqCQl9ICk7CiAqCiAqCQkvLyBDb252ZXJ0IDxwPiBlbGVtZW50J3MgZm9udC1zaXplIHN0eWxlLgogKgkJLy8gTm90ZTogWW91IHNob3VsZCB1c2UgYSBsb3ctcHJpb3JpdHkgb2JzZXJ2ZXIgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQKICoJCS8vIGl0IGlzIGV4ZWN1dGVkIGFmdGVyIHRoZSBlbGVtZW50LXRvLWVsZW1lbnQgY29udmVydGVyLgogKgkJZWRpdG9yLmRhdGEudXBjYXN0RGlzcGF0Y2hlci5vbiggJ2VsZW1lbnQ6cCcsICggZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpICkgPT4gewogKgkJCWNvbnN0IHsgY29uc3VtYWJsZSwgc2NoZW1hLCB3cml0ZXIgfSA9IGNvbnZlcnNpb25BcGk7CiAqCiAqCQkJaWYgKCAhY29uc3VtYWJsZS5jb25zdW1lKCBkYXRhLnZpZXdJdGVtLCB7IHN0eWxlOiAnZm9udC1zaXplJyB9ICkgKSB7CiAqCQkJCXJldHVybjsKICoJCQl9CiAqCiAqCQkJY29uc3QgZm9udFNpemUgPSBkYXRhLnZpZXdJdGVtLmdldFN0eWxlKCAnZm9udC1zaXplJyApOwogKgogKgkJCS8vIERvIG5vdCBnbyBmb3IgdGhlIG1vZGVsIGVsZW1lbnQgYWZ0ZXIgZGF0YS5tb2RlbEN1cnNvciBiZWNhdXNlIGl0IG1pZ2h0IGhhcHBlbgogKgkJCS8vIHRoYXQgYSBzaW5nbGUgdmlldyBlbGVtZW50IHdhcyBjb252ZXJ0ZWQgdG8gbXVsdGlwbGUgbW9kZWwgZWxlbWVudHMuIEdldCBhbGwgb2YgdGhlbS4KICoJCQlmb3IgKCBjb25zdCBpdGVtIG9mIGRhdGEubW9kZWxSYW5nZS5nZXRJdGVtcyggeyBzaGFsbG93OiB0cnVlIH0gKSApIHsKICoJCQkJaWYgKCBzY2hlbWEuY2hlY2tBdHRyaWJ1dGUoIGl0ZW0sICdmb250U2l6ZScgKSApIHsKICoJCQkJCXdyaXRlci5zZXRBdHRyaWJ1dGUoICdmb250U2l6ZScsIGZvbnRTaXplLCBpdGVtICk7CiAqCQkJCX0KICoJCQl9CiAqCQl9LCB7IHByaW9yaXR5OiAnbG93JyB9ICk7CiAqCiAqCQkvLyBDb252ZXJ0IGFsbCBlbGVtZW50cyB3aGljaCBoYXZlIG5vIGN1c3RvbSBjb252ZXJ0ZXIgaW50byBhIHBhcmFncmFwaCAoYXV0b3BhcmFncmFwaGluZykuCiAqCQllZGl0b3IuZGF0YS51cGNhc3REaXNwYXRjaGVyLm9uKCAnZWxlbWVudCcsICggZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpICkgPT4gewogKgkJCS8vIENoZWNrIGlmIGFuIGVsZW1lbnQgY2FuIGJlIGNvbnZlcnRlZC4KICoJCQlpZiAoICFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUudGVzdCggZGF0YS52aWV3SXRlbSwgeyBuYW1lOiBkYXRhLnZpZXdJdGVtLm5hbWUgfSApICkgewogKgkJCQkvLyBXaGVuIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBjb25zdW1lZCBieSBoaWdoZXIgcHJpb3JpdHkgY29udmVydGVycywgZG8gbm90aGluZy4KICoJCQkJcmV0dXJuOwogKgkJCX0KICoKICoJCQljb25zdCBwYXJhZ3JhcGggPSBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVFbGVtZW50KCAncGFyYWdyYXBoJyApOwogKgogKgkJCS8vIFRyeSB0byBzYWZlbHkgaW5zZXJ0IGEgcGFyYWdyYXBoIGF0IHRoZSBtb2RlbCBjdXJzb3IgLSBpdCB3aWxsIGZpbmQgYW4gYWxsb3dlZCBwYXJlbnQgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuCiAqCQkJaWYgKCAhY29udmVyc2lvbkFwaS5zYWZlSW5zZXJ0KCBwYXJhZ3JhcGgsIGRhdGEubW9kZWxDdXJzb3IgKSApIHsKICoJCQkJLy8gV2hlbiBhbiBlbGVtZW50IHdhcyBub3QgaW5zZXJ0ZWQsIGl0IG1lYW5zIHRoYXQgeW91IGNhbm5vdCBpbnNlcnQgYSBwYXJhZ3JhcGggYXQgdGhpcyBwb3NpdGlvbi4KICoJCQkJcmV0dXJuOwogKgkJCX0KICoKICoJCQkvLyBDb25zdW1lIHRoZSBpbnNlcnRlZCBlbGVtZW50LgogKgkJCWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKCBkYXRhLnZpZXdJdGVtLCB7IG5hbWU6IGRhdGEudmlld0l0ZW0ubmFtZSB9ICkgKTsKICoKICoJCQkvLyBDb252ZXJ0IHRoZSBjaGlsZHJlbiB0byBhIHBhcmFncmFwaC4KICoJCQljb25zdCB7IG1vZGVsUmFuZ2UgfSA9IGNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKCBkYXRhLnZpZXdJdGVtLCAgcGFyYWdyYXBoICkgKTsKICoKICoJCQkvLyBVcGRhdGUgYG1vZGVsUmFuZ2VgIGFuZCBgbW9kZWxDdXJzb3JgIGluIHRoZSBgZGF0YWAgYXMgYSBjb252ZXJzaW9uIHJlc3VsdC4KICoJCQljb252ZXJzaW9uQXBpLnVwZGF0ZUNvbnZlcnNpb25SZXN1bHQoIHBhcmFncmFwaCwgZGF0YSApOwogKgkJfSwgeyBwcmlvcml0eTogJ2xvdycgfSApOwogKgogKiBAbWl4ZXMgbW9kdWxlOnV0aWxzL2VtaXR0ZXJtaXhpbn5FbWl0dGVyTWl4aW4KICogQGZpcmVzIHZpZXdDbGVhbnVwCiAqIEBmaXJlcyBlbGVtZW50CiAqIEBmaXJlcyB0ZXh0CiAqIEBmaXJlcyBkb2N1bWVudEZyYWdtZW50CiAqLwoKdmFyIFVwY2FzdERpc3BhdGNoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYW4gdXBjYXN0IGRpc3BhdGNoZXIgdGhhdCBvcGVyYXRlcyB1c2luZyB0aGUgcGFzc2VkIEFQSS4KICAgKgogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaQogICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udmVyc2lvbkFwaV0gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZvciBhbiBpbnRlcmZhY2UgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBldmVudHMgZmlyZWQKICAgKiBieSB0aGUgdXBjYXN0IGRpc3BhdGNoZXIuCiAgICovCiAgZnVuY3Rpb24gVXBjYXN0RGlzcGF0Y2hlcigpIHsKICAgIHZhciBjb252ZXJzaW9uQXBpID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXBjYXN0RGlzcGF0Y2hlcik7CgogICAgLyoqCiAgICAgKiBUaGUgbGlzdCBvZiBlbGVtZW50cyB0aGF0IHdlcmUgY3JlYXRlZCBkdXJpbmcgc3BsaXR0aW5nLgogICAgICoKICAgICAqIEFmdGVyIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MgdGhlIGxpc3QgaXMgY2xlYXJlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge01hcC48bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQsQXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50Pj59CiAgICAgKi8KICAgIHRoaXMuX3NwbGl0UGFydHMgPSBuZXcgTWFwKCk7CiAgICAvKioKICAgICAqIFRoZSBsaXN0IG9mIGN1cnNvciBwYXJlbnQgZWxlbWVudHMgdGhhdCB3ZXJlIGNyZWF0ZWQgZHVyaW5nIHNwbGl0dGluZy4KICAgICAqCiAgICAgKiBBZnRlciB0aGUgY29udmVyc2lvbiBwcm9jZXNzIHRoZSBsaXN0IGlzIGNsZWFyZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtNYXAuPG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50LEFycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudD4+fQogICAgICovCgogICAgdGhpcy5fY3Vyc29yUGFyZW50cyA9IG5ldyBNYXAoKTsKICAgIC8qKgogICAgICogVGhlIHBvc2l0aW9uIGluIHRoZSB0ZW1wb3Jhcnkgc3RydWN0dXJlIHdoZXJlIHRoZSBjb252ZXJ0ZWQgY29udGVudCBpcyBpbnNlcnRlZC4gVGhlIHN0cnVjdHVyZSByZWZsZWN0cyB0aGUgY29udGV4dCBvZgogICAgICogdGhlIHRhcmdldCBwb3NpdGlvbiB3aGVyZSB0aGUgY29udGVudCB3aWxsIGJlIGluc2VydGVkLiBUaGlzIHByb3BlcnR5IGlzIGJ1aWx0IGJhc2VkIG9uIHRoZSBjb250ZXh0IHBhcmFtZXRlciBvZiB0aGUKICAgICAqIGNvbnZlcnQgbWV0aG9kLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbnxudWxsfQogICAgICovCgogICAgdGhpcy5fbW9kZWxDdXJzb3IgPSBudWxsOwogICAgLyoqCiAgICAgKiBBbiBpbnRlcmZhY2UgcGFzc2VkIGJ5IHRoZSBkaXNwYXRjaGVyIHRvIHRoZSBldmVudCBjYWxsYmFja3MuCiAgICAgKgogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0KICAgICAqLwoKICAgIHRoaXMuY29udmVyc2lvbkFwaSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnZlcnNpb25BcGkpOyAvLyBUaGUgYmVsb3cgbWV0aG9kcyBhcmUgYm91bmQgdG8gdGhpcyBgVXBjYXN0RGlzcGF0Y2hlcmAgaW5zdGFuY2UgYW5kIHNldCBvbiBgY29udmVyc2lvbkFwaWAuCiAgICAvLyBUaGlzIHdheSBvbmx5IGEgcGFydCBvZiBgVXBjYXN0RGlzcGF0Y2hlcmAgQVBJIGlzIGV4cG9zZWQuCgogICAgdGhpcy5jb252ZXJzaW9uQXBpLmNvbnZlcnRJdGVtID0gdGhpcy5fY29udmVydEl0ZW0uYmluZCh0aGlzKTsKICAgIHRoaXMuY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4gPSB0aGlzLl9jb252ZXJ0Q2hpbGRyZW4uYmluZCh0aGlzKTsKICAgIHRoaXMuY29udmVyc2lvbkFwaS5zYWZlSW5zZXJ0ID0gdGhpcy5fc2FmZUluc2VydC5iaW5kKHRoaXMpOwogICAgdGhpcy5jb252ZXJzaW9uQXBpLnVwZGF0ZUNvbnZlcnNpb25SZXN1bHQgPSB0aGlzLl91cGRhdGVDb252ZXJzaW9uUmVzdWx0LmJpbmQodGhpcyk7IC8vIEFkdmFuY2VkIEFQSSAtIHVzZSBvbmx5IGlmIGN1c3RvbSBwb3NpdGlvbiBoYW5kbGluZyBpcyBuZWVkZWQuCgogICAgdGhpcy5jb252ZXJzaW9uQXBpLnNwbGl0VG9BbGxvd2VkUGFyZW50ID0gdGhpcy5fc3BsaXRUb0FsbG93ZWRQYXJlbnQuYmluZCh0aGlzKTsKICAgIHRoaXMuY29udmVyc2lvbkFwaS5nZXRTcGxpdFBhcnRzID0gdGhpcy5fZ2V0U3BsaXRQYXJ0cy5iaW5kKHRoaXMpOwogIH0KICAvKioKICAgKiBTdGFydHMgdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4gVGhlIGVudHJ5IHBvaW50IGZvciB0aGUgY29udmVyc2lvbi4KICAgKgogICAqIEBmaXJlcyBlbGVtZW50CiAgICogQGZpcmVzIHRleHQKICAgKiBAZmlyZXMgZG9jdW1lbnRGcmFnbWVudAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3SXRlbQogICAqIFRoZSBwYXJ0IG9mIHRoZSB2aWV3IHRvIGJlIGNvbnZlcnRlZC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyIEFuIGluc3RhbmNlIG9mIHRoZSBtb2RlbCB3cml0ZXIuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0RGVmaW5pdGlvbn0gW2NvbnRleHQ9Wyckcm9vdCddXSBFbGVtZW50cyB3aWxsIGJlIGNvbnZlcnRlZCBhY2NvcmRpbmcgdG8gdGhpcyBjb250ZXh0LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gTW9kZWwgZGF0YSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgdGhlIGNvbnZlcnNpb24gcHJvY2VzcwogICAqIHdyYXBwZWQgaW4gYERvY3VtZW50RnJhZ21lbnRgLiBDb252ZXJ0ZWQgbWFya2VyIGVsZW1lbnRzIHdpbGwgYmUgc2V0IGFzIHRoZSBkb2N1bWVudCBmcmFnbWVudCdzCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50I21hcmtlcnMgc3RhdGljIG1hcmtlcnMgbWFwfS4KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhVcGNhc3REaXNwYXRjaGVyLCBbewogICAga2V5OiAiY29udmVydCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydCh2aWV3SXRlbSwgd3JpdGVyKSB7CiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbJyRyb290J107CiAgICAgIHRoaXMuZmlyZSgndmlld0NsZWFudXAnLCB2aWV3SXRlbSk7IC8vIENyZWF0ZSBjb250ZXh0IHRyZWUgYW5kIHNldCBwb3NpdGlvbiBpbiB0aGUgdG9wIGVsZW1lbnQuCiAgICAgIC8vIEl0ZW1zIHdpbGwgYmUgY29udmVydGVkIGFjY29yZGluZyB0byB0aGlzIHBvc2l0aW9uLgoKICAgICAgdGhpcy5fbW9kZWxDdXJzb3IgPSBjcmVhdGVDb250ZXh0VHJlZShjb250ZXh0LCB3cml0ZXIpOyAvLyBTdG9yZSB3cml0ZXIgaW4gY29udmVyc2lvbiBhcyBhIGNvbnZlcnNpb24gQVBJCiAgICAgIC8vIHRvIGJlIHN1cmUgdGhhdCBjb252ZXJzaW9uIHByb2Nlc3Mgd2lsbCB1c2UgdGhlIHNhbWUgYmF0Y2guCgogICAgICB0aGlzLmNvbnZlcnNpb25BcGkud3JpdGVyID0gd3JpdGVyOyAvLyBDcmVhdGUgY29uc3VtYWJsZSB2YWx1ZXMgbGlzdCBmb3IgY29udmVyc2lvbiBwcm9jZXNzLgoKICAgICAgdGhpcy5jb252ZXJzaW9uQXBpLmNvbnN1bWFibGUgPSBWaWV3Q29uc3VtYWJsZS5jcmVhdGVGcm9tKHZpZXdJdGVtKTsgLy8gQ3VzdG9tIGRhdGEgc3RvcmVkIGJ5IGNvbnZlcnRlciBmb3IgY29udmVyc2lvbiBwcm9jZXNzLgoKICAgICAgdGhpcy5jb252ZXJzaW9uQXBpLnN0b3JlID0ge307IC8vIERvIHRoZSBjb252ZXJzaW9uLgoKICAgICAgdmFyIF90aGlzJF9jb252ZXJ0SXRlbSA9IHRoaXMuX2NvbnZlcnRJdGVtKHZpZXdJdGVtLCB0aGlzLl9tb2RlbEN1cnNvciksCiAgICAgICAgICBtb2RlbFJhbmdlID0gX3RoaXMkX2NvbnZlcnRJdGVtLm1vZGVsUmFuZ2U7IC8vIENvbnZlcnNpb24gcmVzdWx0IGlzIGFsd2F5cyBhIGRvY3VtZW50IGZyYWdtZW50IHNvIGxldCdzIGNyZWF0ZSBpdC4KCgogICAgICB2YXIgZG9jdW1lbnRGcmFnbWVudCA9IHdyaXRlci5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7IC8vIFdoZW4gdGhlcmUgaXMgYSBjb252ZXJzaW9uIHJlc3VsdC4KCiAgICAgIGlmIChtb2RlbFJhbmdlKSB7CiAgICAgICAgLy8gUmVtb3ZlIGFsbCBlbXB0eSBlbGVtZW50cyB0aGF0IHdlcmUgY3JlYXRlIHdoaWxlIHNwbGl0dGluZy4KICAgICAgICB0aGlzLl9yZW1vdmVFbXB0eUVsZW1lbnRzKCk7IC8vIE1vdmUgYWxsIGl0ZW1zIHRoYXQgd2VyZSBjb252ZXJ0ZWQgaW4gY29udGV4dCB0cmVlIHRvIHRoZSBkb2N1bWVudCBmcmFnbWVudC4KCgogICAgICAgIGZvciAodmFyIF9pID0gMCwgX0FycmF5JGZyb20gPSBBcnJheS5mcm9tKHRoaXMuX21vZGVsQ3Vyc29yLnBhcmVudC5nZXRDaGlsZHJlbigpKTsgX2kgPCBfQXJyYXkkZnJvbS5sZW5ndGg7IF9pKyspIHsKICAgICAgICAgIHZhciBpdGVtID0gX0FycmF5JGZyb21bX2ldOwogICAgICAgICAgd3JpdGVyLmFwcGVuZChpdGVtLCBkb2N1bWVudEZyYWdtZW50KTsKICAgICAgICB9IC8vIEV4dHJhY3QgdGVtcG9yYXJ5IG1hcmtlcnMgZWxlbWVudHMgZnJvbSBtb2RlbCBhbmQgc2V0IGFzIHN0YXRpYyBtYXJrZXJzIGNvbGxlY3Rpb24uCgoKICAgICAgICBkb2N1bWVudEZyYWdtZW50Lm1hcmtlcnMgPSBleHRyYWN0TWFya2Vyc0Zyb21Nb2RlbEZyYWdtZW50KGRvY3VtZW50RnJhZ21lbnQsIHdyaXRlcik7CiAgICAgIH0gLy8gQ2xlYXIgY29udGV4dCBwb3NpdGlvbi4KCgogICAgICB0aGlzLl9tb2RlbEN1cnNvciA9IG51bGw7IC8vIENsZWFyIHNwbGl0IGVsZW1lbnRzICYgcGFyZW50cyBsaXN0cy4KCiAgICAgIHRoaXMuX3NwbGl0UGFydHMuY2xlYXIoKTsKCiAgICAgIHRoaXMuX2N1cnNvclBhcmVudHMuY2xlYXIoKTsgLy8gQ2xlYXIgY29udmVyc2lvbiBBUEkuCgoKICAgICAgdGhpcy5jb252ZXJzaW9uQXBpLndyaXRlciA9IG51bGw7CiAgICAgIHRoaXMuY29udmVyc2lvbkFwaS5zdG9yZSA9IG51bGw7IC8vIFJldHVybiBmcmFnbWVudCBhcyBjb252ZXJzaW9uIHJlc3VsdC4KCiAgICAgIHJldHVybiBkb2N1bWVudEZyYWdtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpI2NvbnZlcnRJdGVtCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NvbnZlcnRJdGVtIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udmVydEl0ZW0odmlld0l0ZW0sIG1vZGVsQ3Vyc29yKSB7CiAgICAgIHZhciBkYXRhID0gT2JqZWN0LmFzc2lnbih7CiAgICAgICAgdmlld0l0ZW06IHZpZXdJdGVtLAogICAgICAgIG1vZGVsQ3Vyc29yOiBtb2RlbEN1cnNvciwKICAgICAgICBtb2RlbFJhbmdlOiBudWxsCiAgICAgIH0pOwoKICAgICAgaWYgKHZpZXdJdGVtLmlzKCdlbGVtZW50JykpIHsKICAgICAgICB0aGlzLmZpcmUoJ2VsZW1lbnQ6JyArIHZpZXdJdGVtLm5hbWUsIGRhdGEsIHRoaXMuY29udmVyc2lvbkFwaSk7CiAgICAgIH0gZWxzZSBpZiAodmlld0l0ZW0uaXMoJyR0ZXh0JykpIHsKICAgICAgICB0aGlzLmZpcmUoJ3RleHQnLCBkYXRhLCB0aGlzLmNvbnZlcnNpb25BcGkpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuZmlyZSgnZG9jdW1lbnRGcmFnbWVudCcsIGRhdGEsIHRoaXMuY29udmVyc2lvbkFwaSk7CiAgICAgIH0gLy8gSGFuZGxlIGluY29ycmVjdCBjb252ZXJzaW9uIHJlc3VsdC4KCgogICAgICBpZiAoZGF0YS5tb2RlbFJhbmdlICYmICEoZGF0YS5tb2RlbFJhbmdlIGluc3RhbmNlb2YgTW9kZWxSYW5nZSkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBJbmNvcnJlY3QgY29udmVyc2lvbiByZXN1bHQgd2FzIGRyb3BwZWQuCiAgICAgICAgICoKICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSBNb2RlbCByYW5nZX0gc2hvdWxkIGJlIGEgY29udmVyc2lvbiByZXN1bHQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy1jb252ZXJzaW9uLWRpc3BhdGNoZXItaW5jb3JyZWN0LXJlc3VsdAogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LWNvbnZlcnNpb24tZGlzcGF0Y2hlci1pbmNvcnJlY3QtcmVzdWx0JywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHJldHVybiB7CiAgICAgICAgbW9kZWxSYW5nZTogZGF0YS5tb2RlbFJhbmdlLAogICAgICAgIG1vZGVsQ3Vyc29yOiBkYXRhLm1vZGVsQ3Vyc29yCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIEBwcml2YXRlCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGkjY29udmVydENoaWxkcmVuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NvbnZlcnRDaGlsZHJlbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnZlcnRDaGlsZHJlbih2aWV3SXRlbSwgZWxlbWVudE9yTW9kZWxDdXJzb3IpIHsKICAgICAgdmFyIG5leHRNb2RlbEN1cnNvciA9IGVsZW1lbnRPck1vZGVsQ3Vyc29yLmlzKCdwb3NpdGlvbicpID8gZWxlbWVudE9yTW9kZWxDdXJzb3IgOiBNb2RlbFBvc2l0aW9uLl9jcmVhdGVBdChlbGVtZW50T3JNb2RlbEN1cnNvciwgMCk7CiAgICAgIHZhciBtb2RlbFJhbmdlID0gbmV3IE1vZGVsUmFuZ2UobmV4dE1vZGVsQ3Vyc29yKTsKCiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9BcnJheSRmcm9tMiA9IEFycmF5LmZyb20odmlld0l0ZW0uZ2V0Q2hpbGRyZW4oKSk7IF9pMiA8IF9BcnJheSRmcm9tMi5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgdmFyIHZpZXdDaGlsZCA9IF9BcnJheSRmcm9tMltfaTJdOwoKICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY29udmVydEl0ZW0odmlld0NoaWxkLCBuZXh0TW9kZWxDdXJzb3IpOwoKICAgICAgICBpZiAocmVzdWx0Lm1vZGVsUmFuZ2UgaW5zdGFuY2VvZiBNb2RlbFJhbmdlKSB7CiAgICAgICAgICBtb2RlbFJhbmdlLmVuZCA9IHJlc3VsdC5tb2RlbFJhbmdlLmVuZDsKICAgICAgICAgIG5leHRNb2RlbEN1cnNvciA9IHJlc3VsdC5tb2RlbEN1cnNvcjsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiB7CiAgICAgICAgbW9kZWxSYW5nZTogbW9kZWxSYW5nZSwKICAgICAgICBtb2RlbEN1cnNvcjogbmV4dE1vZGVsQ3Vyc29yCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIEBwcml2YXRlCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGkjc2FmZUluc2VydAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9zYWZlSW5zZXJ0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfc2FmZUluc2VydChtb2RlbEVsZW1lbnQsIHBvc2l0aW9uKSB7CiAgICAgIC8vIEZpbmQgYWxsb3dlZCBwYXJlbnQgZm9yIGVsZW1lbnQgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gaW5zZXJ0LgogICAgICAvLyBJZiBjdXJyZW50IHBhcmVudCBkb2VzIG5vdCBhbGxvdyB0byBpbnNlcnQgZWxlbWVudCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgZG9lcwogICAgICAvLyB0aGVuIHNwbGl0IG5vZGVzIHRvIGFsbG93ZWQgcGFyZW50LgogICAgICB2YXIgc3BsaXRSZXN1bHQgPSB0aGlzLl9zcGxpdFRvQWxsb3dlZFBhcmVudChtb2RlbEVsZW1lbnQsIHBvc2l0aW9uKTsgLy8gV2hlbiB0aGVyZSBpcyBubyBzcGxpdCByZXN1bHQgaXQgbWVhbnMgdGhhdCB3ZSBjYW4ndCBpbnNlcnQgZWxlbWVudCB0byBtb2RlbCB0cmVlLCBzbyBsZXQncyBza2lwIGl0LgoKCiAgICAgIGlmICghc3BsaXRSZXN1bHQpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gSW5zZXJ0IGVsZW1lbnQgb24gYWxsb3dlZCBwb3NpdGlvbi4KCgogICAgICB0aGlzLmNvbnZlcnNpb25BcGkud3JpdGVyLmluc2VydChtb2RlbEVsZW1lbnQsIHNwbGl0UmVzdWx0LnBvc2l0aW9uKTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIEBwcml2YXRlCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGkjdXBkYXRlQ29udmVyc2lvblJlc3VsdAogICAgICovCgogIH0sIHsKICAgIGtleTogIl91cGRhdGVDb252ZXJzaW9uUmVzdWx0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQ29udmVyc2lvblJlc3VsdChtb2RlbEVsZW1lbnQsIGRhdGEpIHsKICAgICAgdmFyIHBhcnRzID0gdGhpcy5fZ2V0U3BsaXRQYXJ0cyhtb2RlbEVsZW1lbnQpOwoKICAgICAgdmFyIHdyaXRlciA9IHRoaXMuY29udmVyc2lvbkFwaS53cml0ZXI7IC8vIFNldCBjb252ZXJzaW9uIHJlc3VsdCByYW5nZSAtIG9ubHkgaWYgbm90IHNldCBhbHJlYWR5LgoKICAgICAgaWYgKCFkYXRhLm1vZGVsUmFuZ2UpIHsKICAgICAgICBkYXRhLm1vZGVsUmFuZ2UgPSB3cml0ZXIuY3JlYXRlUmFuZ2Uod3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKG1vZGVsRWxlbWVudCksIHdyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKSk7CiAgICAgIH0KCiAgICAgIHZhciBzYXZlZEN1cnNvclBhcmVudCA9IHRoaXMuX2N1cnNvclBhcmVudHMuZ2V0KG1vZGVsRWxlbWVudCk7IC8vIE5vdyB3ZSBuZWVkIHRvIGNoZWNrIHdoZXJlIHRoZSBgbW9kZWxDdXJzb3JgIHNob3VsZCBiZS4KCgogICAgICBpZiAoc2F2ZWRDdXJzb3JQYXJlbnQpIHsKICAgICAgICAvLyBJZiB3ZSBzcGxpdCBwYXJlbnQgdG8gaW5zZXJ0IG91ciBlbGVtZW50IHRoZW4gd2Ugd2FudCB0byBjb250aW51ZSBjb252ZXJzaW9uIGluIHRoZSBuZXcgcGFydCBvZiB0aGUgc3BsaXQgcGFyZW50LgogICAgICAgIC8vCiAgICAgICAgLy8gYmVmb3JlOiA8YWxsb3dlZD48bm90QWxsb3dlZD5mb29bXTwvbm90QWxsb3dlZD48L2FsbG93ZWQ+CiAgICAgICAgLy8gYWZ0ZXI6ICA8YWxsb3dlZD48bm90QWxsb3dlZD5mb288L25vdEFsbG93ZWQ+IDxjb252ZXJ0ZWQ+PC9jb252ZXJ0ZWQ+IDxub3RBbGxvd2VkPltdPC9ub3RBbGxvd2VkPjwvYWxsb3dlZD4KICAgICAgICBkYXRhLm1vZGVsQ3Vyc29yID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoc2F2ZWRDdXJzb3JQYXJlbnQsIDApOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGNvbnRpbnVlIGFmdGVyIGluc2VydGVkIGVsZW1lbnQuCiAgICAgICAgZGF0YS5tb2RlbEN1cnNvciA9IGRhdGEubW9kZWxSYW5nZS5lbmQ7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQHByaXZhdGUKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaSNzcGxpdFRvQWxsb3dlZFBhcmVudAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9zcGxpdFRvQWxsb3dlZFBhcmVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0VG9BbGxvd2VkUGFyZW50KG5vZGUsIG1vZGVsQ3Vyc29yKSB7CiAgICAgIHZhciBfdGhpcyRjb252ZXJzaW9uQXBpID0gdGhpcy5jb252ZXJzaW9uQXBpLAogICAgICAgICAgc2NoZW1hID0gX3RoaXMkY29udmVyc2lvbkFwaS5zY2hlbWEsCiAgICAgICAgICB3cml0ZXIgPSBfdGhpcyRjb252ZXJzaW9uQXBpLndyaXRlcjsgLy8gVHJ5IHRvIGZpbmQgYWxsb3dlZCBwYXJlbnQuCgogICAgICB2YXIgYWxsb3dlZFBhcmVudCA9IHNjaGVtYS5maW5kQWxsb3dlZFBhcmVudChtb2RlbEN1cnNvciwgbm9kZSk7CgogICAgICBpZiAoYWxsb3dlZFBhcmVudCkgewogICAgICAgIC8vIFdoZW4gY3VycmVudCBwb3NpdGlvbiBwYXJlbnQgYWxsb3dzIHRvIGluc2VydCBub2RlIHRoZW4gcmV0dXJuIHRoaXMgcG9zaXRpb24uCiAgICAgICAgaWYgKGFsbG93ZWRQYXJlbnQgPT09IG1vZGVsQ3Vyc29yLnBhcmVudCkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgcG9zaXRpb246IG1vZGVsQ3Vyc29yCiAgICAgICAgICB9OwogICAgICAgIH0gLy8gV2hlbiBhbGxvd2VkIHBhcmVudCBpcyBpbiBjb250ZXh0IHRyZWUgKGl0J3Mgb3V0c2lkZSB0aGUgY29udmVydGVkIHRyZWUpLgoKCiAgICAgICAgaWYgKHRoaXMuX21vZGVsQ3Vyc29yLnBhcmVudC5nZXRBbmNlc3RvcnMoKS5pbmNsdWRlcyhhbGxvd2VkUGFyZW50KSkgewogICAgICAgICAgYWxsb3dlZFBhcmVudCA9IG51bGw7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoIWFsbG93ZWRQYXJlbnQpIHsKICAgICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSB3cmFwcGVkIHdpdGggYSBwYXJhZ3JhcGggd291bGQgYmUgYWNjZXB0ZWQgYnkgdGhlIHNjaGVtYS4KICAgICAgICBpZiAoIWlzUGFyYWdyYXBoYWJsZShtb2RlbEN1cnNvciwgbm9kZSwgc2NoZW1hKSkgewogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gewogICAgICAgICAgcG9zaXRpb246IHdyYXBJblBhcmFncmFwaChtb2RlbEN1cnNvciwgd3JpdGVyKQogICAgICAgIH07CiAgICAgIH0gLy8gU3BsaXQgZWxlbWVudCB0byBhbGxvd2VkIHBhcmVudC4KCgogICAgICB2YXIgc3BsaXRSZXN1bHQgPSB0aGlzLmNvbnZlcnNpb25BcGkud3JpdGVyLnNwbGl0KG1vZGVsQ3Vyc29yLCBhbGxvd2VkUGFyZW50KTsgLy8gVXNpbmcgdGhlIHJhbmdlIHJldHVybmVkIGJ5IGBtb2RlbC5Xcml0ZXIjc3BsaXRgLCB3ZSB3aWxsIHBhaXIgb3JpZ2luYWwgZWxlbWVudHMgd2l0aCB0aGVpciBzcGxpdCBwYXJ0cy4KICAgICAgLy8KICAgICAgLy8gVGhlIHJhbmdlIHJldHVybmVkIGZyb20gdGhlIHdyaXRlciBzcGFucyAib3ZlciB0aGUgc3BsaXQiIG9yLCBwcmVjaXNlbHkgc2F5aW5nLCBmcm9tIHRoZSBlbmQgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgKHRoZSBvbmUKICAgICAgLy8gdGhhdCBnb3Qgc3BsaXQpIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG90aGVyIHBhcnQgb2YgdGhhdCBlbGVtZW50OgogICAgICAvLwogICAgICAvLyA8bGltaXQ+PGE+PGI+PGM+WFtdWTwvYz48L2I+PGE+PC9saW1pdD4gLT4KICAgICAgLy8gPGxpbWl0PjxhPjxiPjxjPlhbPC9jPjwvYj48L2E+PGE+PGI+PGM+XVk8L2M+PC9iPjwvYT4KICAgICAgLy8KICAgICAgLy8gQWZ0ZXIgdGhlIHNwbGl0IHRoZXJlIGNhbm5vdCBiZSBhbnkgZnVsbCBub2RlIGJldHdlZW4gdGhlIHBvc2l0aW9ucyBpbiBgc3BsaXRSYW5nZWAuIFRoZSBwb3NpdGlvbnMgYXJlIHRvdWNoaW5nLgogICAgICAvLyBBbHNvLCBiZWNhdXNlIG9mIGhvdyBzcGxpdHRpbmcgd29ya3MsIGl0IGlzIGVhc3kgdG8gbm90aWNlLCB0aGF0ICJjbG9zaW5nIHRhZ3MiIGFyZSBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0aGFuICJvcGVuaW5nIHRhZ3MiLgogICAgICAvLyBBbHNvLCBzaW5jZSB3ZSBzcGxpdCBhbGwgdGhvc2UgZWxlbWVudHMsIGVhY2ggb2YgdGhlbSBoYXMgdG8gaGF2ZSB0aGUgb3RoZXIgcGFydC4KICAgICAgLy8KICAgICAgLy8gV2l0aCB0aG9zZSBvYnNlcnZhdGlvbnMgaW4gbWluZCwgd2Ugd2lsbCBwYWlyIHRoZSBvcmlnaW5hbCBlbGVtZW50cyB3aXRoIHRoZWlyIHNwbGl0IHBhcnRzIGJ5IHNhdmluZyAiY2xvc2luZyB0YWdzIiBhbmQgbWF0Y2hpbmcKICAgICAgLy8gdGhlbSB3aXRoICJvcGVuaW5nIHRhZ3MiIGluIHRoZSByZXZlcnNlIG9yZGVyLiBGb3IgdGhhdCB3ZSBjYW4gdXNlIGEgc3RhY2suCgogICAgICB2YXIgc3RhY2sgPSBbXTsKCiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzcGxpdFJlc3VsdC5yYW5nZS5nZXRXYWxrZXIoKSksCiAgICAgICAgICBfc3RlcDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciB0cmVlV2Fsa2VyVmFsdWUgPSBfc3RlcC52YWx1ZTsKCiAgICAgICAgICBpZiAodHJlZVdhbGtlclZhbHVlLnR5cGUgPT0gJ2VsZW1lbnRFbmQnKSB7CiAgICAgICAgICAgIHN0YWNrLnB1c2godHJlZVdhbGtlclZhbHVlLml0ZW0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gVGhlcmUgc2hvdWxkIG5vdCBiZSBhbnkgdGV4dCBub2RlcyBhZnRlciB0aGUgZWxlbWVudCBpcyBzcGxpdCwgc28gdGhlIG9ubHkgb3RoZXIgdmFsdWUgaXMgYGVsZW1lbnRTdGFydGAuCiAgICAgICAgICAgIHZhciBvcmlnaW5hbFBhcnQgPSBzdGFjay5wb3AoKTsKICAgICAgICAgICAgdmFyIHNwbGl0UGFydCA9IHRyZWVXYWxrZXJWYWx1ZS5pdGVtOwoKICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJTcGxpdFBhaXIob3JpZ2luYWxQYXJ0LCBzcGxpdFBhcnQpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IuZigpOwogICAgICB9CgogICAgICB2YXIgY3Vyc29yUGFyZW50ID0gc3BsaXRSZXN1bHQucmFuZ2UuZW5kLnBhcmVudDsKCiAgICAgIHRoaXMuX2N1cnNvclBhcmVudHMuc2V0KG5vZGUsIGN1cnNvclBhcmVudCk7CgogICAgICByZXR1cm4gewogICAgICAgIHBvc2l0aW9uOiBzcGxpdFJlc3VsdC5wb3NpdGlvbiwKICAgICAgICBjdXJzb3JQYXJlbnQ6IGN1cnNvclBhcmVudAogICAgICB9OwogICAgfQogICAgLyoqCiAgICAgKiBSZWdpc3RlcnMgdGhhdCBhIGBzcGxpdFBhcnRgIGVsZW1lbnQgaXMgYSBzcGxpdCBwYXJ0IG9mIHRoZSBgb3JpZ2luYWxQYXJ0YCBlbGVtZW50LgogICAgICoKICAgICAqIFRoZSBkYXRhIHNldCBieSB0aGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHtAbGluayAjX2dldFNwbGl0UGFydHN9IGFuZCB7QGxpbmsgI19yZW1vdmVFbXB0eUVsZW1lbnRzfS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gb3JpZ2luYWxQYXJ0CiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBzcGxpdFBhcnQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcmVnaXN0ZXJTcGxpdFBhaXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3RlclNwbGl0UGFpcihvcmlnaW5hbFBhcnQsIHNwbGl0UGFydCkgewogICAgICBpZiAoIXRoaXMuX3NwbGl0UGFydHMuaGFzKG9yaWdpbmFsUGFydCkpIHsKICAgICAgICB0aGlzLl9zcGxpdFBhcnRzLnNldChvcmlnaW5hbFBhcnQsIFtvcmlnaW5hbFBhcnRdKTsKICAgICAgfQoKICAgICAgdmFyIGxpc3QgPSB0aGlzLl9zcGxpdFBhcnRzLmdldChvcmlnaW5hbFBhcnQpOwoKICAgICAgdGhpcy5fc3BsaXRQYXJ0cy5zZXQoc3BsaXRQYXJ0LCBsaXN0KTsKCiAgICAgIGxpc3QucHVzaChzcGxpdFBhcnQpOwogICAgfQogICAgLyoqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpI2dldFNwbGl0UGFydHMKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0U3BsaXRQYXJ0cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNwbGl0UGFydHMoZWxlbWVudCkgewogICAgICB2YXIgcGFydHM7CgogICAgICBpZiAoIXRoaXMuX3NwbGl0UGFydHMuaGFzKGVsZW1lbnQpKSB7CiAgICAgICAgcGFydHMgPSBbZWxlbWVudF07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcGFydHMgPSB0aGlzLl9zcGxpdFBhcnRzLmdldChlbGVtZW50KTsKICAgICAgfQoKICAgICAgcmV0dXJuIHBhcnRzOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgdGhlcmUgYXJlIGFueSBlbXB0eSBlbGVtZW50cyBjcmVhdGVkIHdoaWxlIHNwbGl0dGluZyBhbmQgcmVtb3ZlcyB0aGVtLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIHdvcmtzIHJlY3Vyc2l2ZWx5IHRvIHJlLWNoZWNrIGVtcHR5IGVsZW1lbnRzIGFnYWluIGFmdGVyIGF0IGxlYXN0IG9uZSBlbGVtZW50IHdhcyByZW1vdmVkIGluIHRoZSBpbml0aWFsIGNhbGwsCiAgICAgKiBhcyBzb21lIGVsZW1lbnRzIG1pZ2h0IGhhdmUgYmVjb21lIGVtcHR5IGFmdGVyIG90aGVyIGVtcHR5IGVsZW1lbnRzIHdlcmUgcmVtb3ZlZCBmcm9tIHRoZW0uCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcmVtb3ZlRW1wdHlFbGVtZW50cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUVtcHR5RWxlbWVudHMoKSB7CiAgICAgIHZhciBhbnlSZW1vdmVkID0gZmFsc2U7CgogICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX3NwbGl0UGFydHMua2V5cygpKSwKICAgICAgICAgIF9zdGVwMjsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBlbGVtZW50ID0gX3N0ZXAyLnZhbHVlOwoKICAgICAgICAgIGlmIChlbGVtZW50LmlzRW1wdHkpIHsKICAgICAgICAgICAgdGhpcy5jb252ZXJzaW9uQXBpLndyaXRlci5yZW1vdmUoZWxlbWVudCk7CgogICAgICAgICAgICB0aGlzLl9zcGxpdFBhcnRzLmRlbGV0ZShlbGVtZW50KTsKCiAgICAgICAgICAgIGFueVJlbW92ZWQgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7CiAgICAgIH0KCiAgICAgIGlmIChhbnlSZW1vdmVkKSB7CiAgICAgICAgdGhpcy5fcmVtb3ZlRW1wdHlFbGVtZW50cygpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEZpcmVkIGJlZm9yZSB0aGUgZmlyc3QgY29udmVyc2lvbiBldmVudCwgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdXBjYXN0ICh2aWV3LXRvLW1vZGVsIGNvbnZlcnNpb24pIHByb2Nlc3MuCiAgICAgKgogICAgICogQGV2ZW50IHZpZXdDbGVhbnVwCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0KICAgICAqIHZpZXdJdGVtIEEgcGFydCBvZiB0aGUgdmlldyB0byBiZSBjb252ZXJ0ZWQuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEZpcmVkIHdoZW4gYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGlzIGNvbnZlcnRlZC4KICAgICAqCiAgICAgKiBgZWxlbWVudGAgaXMgYSBuYW1lc3BhY2UgZXZlbnQgZm9yIGEgY2xhc3Mgb2YgZXZlbnRzLiBOYW1lcyBvZiBhY3R1YWxseSBjYWxsZWQgZXZlbnRzIGZvbGxvdyB0aGUgcGF0dGVybiBvZgogICAgICogYGVsZW1lbnQ6PGVsZW1lbnROYW1lPmAgd2hlcmUgYGVsZW1lbnROYW1lYCBpcyB0aGUgbmFtZSBvZiB0aGUgY29udmVydGVkIGVsZW1lbnQuIFRoaXMgd2F5IGxpc3RlbmVycyBtYXkgbGlzdGVuIHRvCiAgICAgKiBhIGNvbnZlcnNpb24gb2YgYWxsIG9yIGp1c3Qgc3BlY2lmaWMgZWxlbWVudHMuCiAgICAgKgogICAgICogQGV2ZW50IGVsZW1lbnQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkRhdGF9IGRhdGEgVGhlIGNvbnZlcnNpb24gZGF0YS4gS2VlcCBpbiBtaW5kIHRoYXQgdGhpcyBvYmplY3QgaXMKICAgICAqIHNoYXJlZCBieSByZWZlcmVuY2UgYmV0d2VlbiBhbGwgY2FsbGJhY2tzIHRoYXQgd2lsbCBiZSBjYWxsZWQuIFRoaXMgbWVhbnMgdGhhdCBjYWxsYmFja3MgY2FuIG92ZXJyaWRlIHZhbHVlcyBpZiBuZWVkZWQsIGFuZCB0aGVzZQogICAgICogdmFsdWVzIHdpbGwgYmUgYXZhaWxhYmxlIGluIG90aGVyIGNhbGxiYWNrcy4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0gY29udmVyc2lvbkFwaSBDb252ZXJzaW9uIHV0aWxpdGllcyB0byBiZSB1c2VkIGJ5IHRoZQogICAgICogY2FsbGJhY2suCiAgICAgKi8KCiAgICAvKioKICAgICAqIEZpcmVkIHdoZW4gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gaXMgY29udmVydGVkLgogICAgICoKICAgICAqIEBldmVudCB0ZXh0CiAgICAgKiBAc2VlICNldmVudDplbGVtZW50CiAgICAgKi8KCiAgICAvKioKICAgICAqIEZpcmVkIHdoZW4gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gaXMgY29udmVydGVkLgogICAgICoKICAgICAqIEBldmVudCBkb2N1bWVudEZyYWdtZW50CiAgICAgKiBAc2VlICNldmVudDplbGVtZW50CiAgICAgKi8KCiAgfV0pOwoKICByZXR1cm4gVXBjYXN0RGlzcGF0Y2hlcjsKfSgpOwoKZXhwb3J0IHsgVXBjYXN0RGlzcGF0Y2hlciBhcyBkZWZhdWx0IH07Cm1peChVcGNhc3REaXNwYXRjaGVyLCBFbWl0dGVyTWl4aW4pOyAvLyBUcmF2ZXJzZXMgZ2l2ZW4gbW9kZWwgaXRlbSBhbmQgc2VhcmNoZXMgZWxlbWVudHMgd2hpY2ggbWFya3MgbWFya2VyIHJhbmdlLiBGb3VuZCBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbQovLyBEb2N1bWVudEZyYWdtZW50IGJ1dCBwYXRoIG9mIHRoaXMgZWxlbWVudCBpcyBzdG9yZWQgaW4gYSBNYXAgd2hpY2ggaXMgdGhlbiByZXR1cm5lZC4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV9IG1vZGVsSXRlbSBGcmFnbWVudCBvZiBtb2RlbC4KLy8gQHJldHVybnMge01hcDxTdHJpbmcsIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBMaXN0IG9mIHN0YXRpYyBtYXJrZXJzLgoKZnVuY3Rpb24gZXh0cmFjdE1hcmtlcnNGcm9tTW9kZWxGcmFnbWVudChtb2RlbEl0ZW0sIHdyaXRlcikgewogIHZhciBtYXJrZXJFbGVtZW50cyA9IG5ldyBTZXQoKTsKICB2YXIgbWFya2VycyA9IG5ldyBNYXAoKTsgLy8gQ3JlYXRlIE1vZGVsVHJlZVdhbGtlci4KCiAgdmFyIHJhbmdlID0gTW9kZWxSYW5nZS5fY3JlYXRlSW4obW9kZWxJdGVtKS5nZXRJdGVtcygpOyAvLyBXYWxrIHRocm91Z2ggRG9jdW1lbnRGcmFnbWVudCBhbmQgY29sbGVjdCBtYXJrZXIgZWxlbWVudHMuCgoKICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJhbmdlKSwKICAgICAgX3N0ZXAzOwoKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHsKICAgICAgdmFyIGl0ZW0gPSBfc3RlcDMudmFsdWU7CgogICAgICAvLyBDaGVjayBpZiBjdXJyZW50IGVsZW1lbnQgaXMgYSBtYXJrZXIuCiAgICAgIGlmIChpdGVtLm5hbWUgPT0gJyRtYXJrZXInKSB7CiAgICAgICAgbWFya2VyRWxlbWVudHMuYWRkKGl0ZW0pOwogICAgICB9CiAgICB9IC8vIFdhbGsgdGhyb3VnaCBjb2xsZWN0ZWQgbWFya2VyIGVsZW1lbnRzIHN0b3JlIGl0cyBwYXRoIGFuZCByZW1vdmUgaXRzIGZyb20gdGhlIERvY3VtZW50RnJhZ21lbnQuCgogIH0gY2F0Y2ggKGVycikgewogICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvcjMuZigpOwogIH0KCiAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihtYXJrZXJFbGVtZW50cyksCiAgICAgIF9zdGVwNDsKCiAgdHJ5IHsKICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7CiAgICAgIHZhciBtYXJrZXJFbGVtZW50ID0gX3N0ZXA0LnZhbHVlOwogICAgICB2YXIgbWFya2VyTmFtZSA9IG1hcmtlckVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW5hbWUnKTsKICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHdyaXRlci5jcmVhdGVQb3NpdGlvbkJlZm9yZShtYXJrZXJFbGVtZW50KTsgLy8gV2hlbiBtYXJrZXIgb2YgZ2l2ZW4gbmFtZSBpcyBub3Qgc3RvcmVkIGl0IG1lYW5zIHRoYXQgd2UgaGF2ZSBmb3VuZCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByYW5nZS4KCiAgICAgIGlmICghbWFya2Vycy5oYXMobWFya2VyTmFtZSkpIHsKICAgICAgICBtYXJrZXJzLnNldChtYXJrZXJOYW1lLCBuZXcgTW9kZWxSYW5nZShjdXJyZW50UG9zaXRpb24uY2xvbmUoKSkpOyAvLyBPdGhlcndpc2UgaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIGZvdW5kIGVuZCBvZiB0aGUgbWFya2VyIHJhbmdlLgogICAgICB9IGVsc2UgewogICAgICAgIG1hcmtlcnMuZ2V0KG1hcmtlck5hbWUpLmVuZCA9IGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpOwogICAgICB9IC8vIFJlbW92ZSBtYXJrZXIgZWxlbWVudCBmcm9tIERvY3VtZW50RnJhZ21lbnQuCgoKICAgICAgd3JpdGVyLnJlbW92ZShtYXJrZXJFbGVtZW50KTsKICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvcjQuZShlcnIpOwogIH0gZmluYWxseSB7CiAgICBfaXRlcmF0b3I0LmYoKTsKICB9CgogIHJldHVybiBtYXJrZXJzOwp9IC8vIENyZWF0ZXMgbW9kZWwgZnJhZ21lbnQgYWNjb3JkaW5nIHRvIGdpdmVuIGNvbnRleHQgYW5kIHJldHVybnMgcG9zaXRpb24gaW4gdGhlIGJvdHRvbSAodGhlIGRlZXBlc3QpIGVsZW1lbnQuCgoKZnVuY3Rpb24gY3JlYXRlQ29udGV4dFRyZWUoY29udGV4dERlZmluaXRpb24sIHdyaXRlcikgewogIHZhciBwb3NpdGlvbjsKCiAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihuZXcgU2NoZW1hQ29udGV4dChjb250ZXh0RGVmaW5pdGlvbikpLAogICAgICBfc3RlcDU7CgogIHRyeSB7CiAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykgewogICAgICB2YXIgaXRlbSA9IF9zdGVwNS52YWx1ZTsKICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTsKCiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaXRlbS5nZXRBdHRyaWJ1dGVLZXlzKCkpLAogICAgICAgICAgX3N0ZXA2OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGtleSA9IF9zdGVwNi52YWx1ZTsKICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGl0ZW0uZ2V0QXR0cmlidXRlKGtleSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I2LmYoKTsKICAgICAgfQoKICAgICAgdmFyIGN1cnJlbnQgPSB3cml0ZXIuY3JlYXRlRWxlbWVudChpdGVtLm5hbWUsIGF0dHJpYnV0ZXMpOwoKICAgICAgaWYgKHBvc2l0aW9uKSB7CiAgICAgICAgd3JpdGVyLmFwcGVuZChjdXJyZW50LCBwb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHBvc2l0aW9uID0gTW9kZWxQb3NpdGlvbi5fY3JlYXRlQXQoY3VycmVudCwgMCk7CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfaXRlcmF0b3I1LmUoZXJyKTsKICB9IGZpbmFsbHkgewogICAgX2l0ZXJhdG9yNS5mKCk7CiAgfQoKICByZXR1cm4gcG9zaXRpb247Cn0KLyoqCiAqIEEgc2V0IG9mIGNvbnZlcnNpb24gdXRpbGl0aWVzIGF2YWlsYWJsZSBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyIG9mIHRoZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciB1cGNhc3QgZGlzcGF0Y2hlcn0ncyBldmVudHMuCiAqCiAqIEBpbnRlcmZhY2UgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaQogKi8KCi8qKgogKiBTdGFydHMgdGhlIGNvbnZlcnNpb24gb2YgYSBnaXZlbiBpdGVtIGJ5IGZpcmluZyBhbiBhcHByb3ByaWF0ZSBldmVudC4KICoKICogRXZlcnkgZmlyZWQgZXZlbnQgaXMgcGFzc2VkIChhcyB0aGUgZmlyc3QgcGFyYW1ldGVyKSBhbiBvYmplY3Qgd2l0aCB0aGUgYG1vZGVsUmFuZ2VgIHByb3BlcnR5LiBFdmVyeSBldmVudCBtYXkgc2V0IGFuZC9vcgogKiBtb2RpZnkgdGhhdCBwcm9wZXJ0eS4gV2hlbiBhbGwgY2FsbGJhY2tzIGFyZSBkb25lLCB0aGUgZmluYWwgdmFsdWUgb2YgdGhlIGBtb2RlbFJhbmdlYCBwcm9wZXJ0eSBpcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC4KICogVGhlIGBtb2RlbFJhbmdlYCBtdXN0IGJlIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UgbW9kZWwgcmFuZ2V9IG9yIGBudWxsYCAoYXMgc2V0IGJ5IGRlZmF1bHQpLgogKgogKiBAbWV0aG9kICNjb252ZXJ0SXRlbQogKiBAZmlyZXMgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDplbGVtZW50CiAqIEBmaXJlcyBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2V2ZW50OnRleHQKICogQGZpcmVzIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjZXZlbnQ6ZG9jdW1lbnRGcmFnbWVudAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IHZpZXdJdGVtIEl0ZW0gdG8gY29udmVydC4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBtb2RlbEN1cnNvciBUaGUgY29udmVyc2lvbiBwb3NpdGlvbi4KICogQHJldHVybnMge09iamVjdH0gcmVzdWx0IFRoZSBjb252ZXJzaW9uIHJlc3VsdC4KICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0gcmVzdWx0Lm1vZGVsUmFuZ2UgVGhlIG1vZGVsIHJhbmdlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgaXRlbSBjb252ZXJzaW9uLAogKiBjcmVhdGVkIGFuZCBtb2RpZmllZCBieSBjYWxsYmFja3MgYXR0YWNoZWQgdG8gdGhlIGZpcmVkIGV2ZW50LCBvciBgbnVsbGAgaWYgdGhlIGNvbnZlcnNpb24gcmVzdWx0IHdhcyBpbmNvcnJlY3QuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSByZXN1bHQubW9kZWxDdXJzb3IgVGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBjb252ZXJzaW9uIHNob3VsZCBiZSBjb250aW51ZWQuCiAqLwoKLyoqCiAqIFN0YXJ0cyB0aGUgY29udmVyc2lvbiBvZiBhbGwgY2hpbGRyZW4gb2YgYSBnaXZlbiBpdGVtIGJ5IGZpcmluZyBhcHByb3ByaWF0ZSBldmVudHMgZm9yIGFsbCB0aGUgY2hpbGRyZW4uCiAqCiAqIEBtZXRob2QgI2NvbnZlcnRDaGlsZHJlbgogKiBAZmlyZXMgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDplbGVtZW50CiAqIEBmaXJlcyBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2V2ZW50OnRleHQKICogQGZpcmVzIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjZXZlbnQ6ZG9jdW1lbnRGcmFnbWVudAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IHZpZXdJdGVtIEFuIGVsZW1lbnQgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGNvbnZlcnRlZC4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwb3NpdGlvbk9yRWxlbWVudCBBIHBvc2l0aW9uIG9yIGFuIGVsZW1lbnQgb2YKICogdGhlIGNvbnZlcnNpb24uCiAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3VsdCBUaGUgY29udmVyc2lvbiByZXN1bHQuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByZXN1bHQubW9kZWxSYW5nZSBUaGUgbW9kZWwgcmFuZ2UgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiB0aGUgY29udmVyc2lvbiBvZiBhbGwgY2hpbGRyZW4KICogb2YgdGhlIGdpdmVuIGl0ZW0uIFdoZW4gbm8gY2hpbGQgd2FzIGNvbnZlcnRlZCwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC4KICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHJlc3VsdC5tb2RlbEN1cnNvciBUaGUgcG9zaXRpb24gd2hlcmUgdGhlIGNvbnZlcnNpb24gc2hvdWxkIGJlIGNvbnRpbnVlZC4KICovCgovKioKICogU2FmZWx5IGluc2VydHMgYW4gZWxlbWVudCB0byB0aGUgZG9jdW1lbnQsIGNoZWNraW5nIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hIHNjaGVtYX0gdG8gZmluZCBhbiBhbGxvd2VkIHBhcmVudCBmb3IKICogYW4gZWxlbWVudCB0aGF0IHlvdSBhcmUgZ29pbmcgdG8gaW5zZXJ0LCBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbi4gSWYgdGhlIGN1cnJlbnQgcGFyZW50IGRvZXMgbm90IGFsbG93IHRvIGluc2VydCB0aGUgZWxlbWVudAogKiBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgZG9lcywgdGhlbiBzcGxpdHMgdGhlIG5vZGVzIHRvIGFsbG93ZWQgcGFyZW50LgogKgogKiBJZiB0aGUgc2NoZW1hIGFsbG93cyB0byBpbnNlcnQgdGhlIG5vZGUgaW4gYSBnaXZlbiBwb3NpdGlvbiwgbm90aGluZyBpcyBzcGxpdC4KICoKICogSWYgaXQgd2FzIG5vdCBwb3NzaWJsZSB0byBmaW5kIGFuIGFsbG93ZWQgcGFyZW50LCBgZmFsc2VgIGlzIHJldHVybmVkIGFuZCBub3RoaW5nIGlzIHNwbGl0LgogKgogKiBPdGhlcndpc2UsIGFuY2VzdG9ycyBhcmUgc3BsaXQuCiAqCiAqIEZvciBpbnN0YW5jZSwgaWYgYDxpbWFnZT5gIGlzIG5vdCBhbGxvd2VkIGluIGA8cGFyYWdyYXBoPmAgYnV0IGlzIGFsbG93ZWQgaW4gYCRyb290YDoKICoKICoJCTxwYXJhZ3JhcGg+Zm9vW11iYXI8L3BhcmFncmFwaD4KICoKICoJCS0+IHNhZmUgaW5zZXJ0IGZvciBgPGltYWdlPmAgd2lsbCBzcGxpdCAtPgogKgogKgkJPHBhcmFncmFwaD5mb288L3BhcmFncmFwaD5bXTxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+CiAqCiAqIEV4YW1wbGUgdXNhZ2U6CiAqCiAqCQljb25zdCBteUVsZW1lbnQgPSBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVFbGVtZW50KCAnbXlFbGVtZW50JyApOwogKgogKgkJaWYgKCAhY29udmVyc2lvbkFwaS5zYWZlSW5zZXJ0KCBteUVsZW1lbnQsIGRhdGEubW9kZWxDdXJzb3IgKSApIHsKICoJCQlyZXR1cm47CiAqCQl9CiAqCiAqIFRoZSBzcGxpdCByZXN1bHQgaXMgc2F2ZWQgYW5kIHtAbGluayAjdXBkYXRlQ29udmVyc2lvblJlc3VsdH0gc2hvdWxkIGJlIHVzZWQgdG8gdXBkYXRlIHRoZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkRhdGEgY29udmVyc2lvbiBkYXRhfS4KICoKICogQG1ldGhvZCAjc2FmZUluc2VydAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlIFRoZSBub2RlIHRvIGluc2VydC4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gd2hlcmUgYW4gZWxlbWVudCBpcyBnb2luZyB0byBiZSBpbnNlcnRlZC4KICogQHJldHVybnMge0Jvb2xlYW59IFRoZSBzcGxpdCByZXN1bHQuIElmIGl0IHdhcyBub3QgcG9zc2libGUgdG8gZmluZCBhbiBhbGxvd2VkIHBvc2l0aW9uLCBgZmFsc2VgIGlzIHJldHVybmVkLgogKi8KCi8qKgogKiBVcGRhdGVzIHRoZSBjb252ZXJzaW9uIHJlc3VsdCBhbmQgc2V0cyBhIHByb3BlciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkRhdGEjbW9kZWxSYW5nZX0gYW5kCiAqIHRoZSBuZXh0IHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uRGF0YSNtb2RlbEN1cnNvcn0gYWZ0ZXIgdGhlIGNvbnZlcnNpb24uCiAqIFVzZWQgdG9nZXRoZXIgd2l0aCB7QGxpbmsgI3NhZmVJbnNlcnR9LCBpdCBlbmFibGVzIHlvdSB0byBlYXNpbHkgY29udmVydCBlbGVtZW50cyB3aXRob3V0IHdvcnJ5aW5nIGlmIHRoZSBub2RlIHdhcyBzcGxpdAogKiBkdXJpbmcgdGhlIGNvbnZlcnNpb24gb2YgaXRzIGNoaWxkcmVuLgogKgogKiBBIHVzYWdlIGV4YW1wbGUgaW4gY29udmVydGVyIGNvZGU6CiAqCiAqCQljb25zdCBteUVsZW1lbnQgPSBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVFbGVtZW50KCAnbXlFbGVtZW50JyApOwogKgogKgkJaWYgKCAhY29udmVyc2lvbkFwaS5zYWZlSW5zZXJ0KCBteUVsZW1lbnQsIGRhdGEubW9kZWxDdXJzb3IgKSApIHsKICoJCQlyZXR1cm47CiAqCQl9CiAqCiAqCQkvLyBDaGlsZHJlbiBjb252ZXJzaW9uIG1heSBzcGxpdCBgbXlFbGVtZW50YC4KICoJCWNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKCBkYXRhLnZpZXdJdGVtLCBteUVsZW1lbnQgKTsKICoKICoJCWNvbnZlcnNpb25BcGkudXBkYXRlQ29udmVyc2lvblJlc3VsdCggbXlFbGVtZW50LCBkYXRhICk7CiAqCiAqIEBtZXRob2QgI3VwZGF0ZUNvbnZlcnNpb25SZXN1bHQKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25EYXRhfSBkYXRhIENvbnZlcnNpb24gZGF0YS4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpfSBjb252ZXJzaW9uQXBpIENvbnZlcnNpb24gdXRpbGl0aWVzIHRvIGJlIHVzZWQgYnkgdGhlIGNhbGxiYWNrLgogKi8KCi8qKgogKiBDaGVja3MgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfSB0byBmaW5kIGFuIGFsbG93ZWQgcGFyZW50IGZvciBhbiBlbGVtZW50IHRoYXQgaXMgZ29pbmcgdG8gYmUgaW5zZXJ0ZWQKICogc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIHRoZSBjdXJyZW50IHBhcmVudCBkb2VzIG5vdCBhbGxvdyBpbnNlcnRpbmcgYW4gZWxlbWVudCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgZG9lcywgdGhlIG1ldGhvZAogKiBzcGxpdHMgbm9kZXMgdG8gYWxsb3dlZCBwYXJlbnQuCiAqCiAqIElmIHRoZSBzY2hlbWEgYWxsb3dzIGluc2VydGluZyB0aGUgbm9kZSBpbiB0aGUgZ2l2ZW4gcG9zaXRpb24sIG5vdGhpbmcgaXMgc3BsaXQgYW5kIGFuIG9iamVjdCB3aXRoIHRoYXQgcG9zaXRpb24gaXMgcmV0dXJuZWQuCiAqCiAqIElmIGl0IHdhcyBub3QgcG9zc2libGUgdG8gZmluZCBhbiBhbGxvd2VkIHBhcmVudCwgYG51bGxgIGlzIHJldHVybmVkIGFuZCBub3RoaW5nIGlzIHNwbGl0LgogKgogKiBPdGhlcndpc2UsIGFuY2VzdG9ycyBhcmUgc3BsaXQgYW5kIGFuIG9iamVjdCB3aXRoIGEgcG9zaXRpb24gYW5kIHRoZSBjb3B5IG9mIHRoZSBzcGxpdCBlbGVtZW50IGlzIHJldHVybmVkLgogKgogKiBGb3IgaW5zdGFuY2UsIGlmIGA8aW1hZ2U+YCBpcyBub3QgYWxsb3dlZCBpbiBgPHBhcmFncmFwaD5gIGJ1dCBpcyBhbGxvd2VkIGluIGAkcm9vdGA6CiAqCiAqCQk8cGFyYWdyYXBoPmZvb1tdYmFyPC9wYXJhZ3JhcGg+CiAqCiAqCQktPiBzcGxpdCBmb3IgYDxpbWFnZT5gIC0+CiAqCiAqCQk8cGFyYWdyYXBoPmZvbzwvcGFyYWdyYXBoPltdPHBhcmFncmFwaD5iYXI8L3BhcmFncmFwaD4KICoKICogSW4gdGhlIGV4YW1wbGUgYWJvdmUsIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIGA8cGFyYWdyYXBoPmAgZWxlbWVudHMgd2lsbCBiZSByZXR1cm5lZCBhcyBgcG9zaXRpb25gIGFuZCB0aGUgc2Vjb25kIGBwYXJhZ3JhcGhgCiAqIGFzIGBjdXJzb3JQYXJlbnRgLgogKgogKiAqKk5vdGU6KiogVGhpcyBpcyBhbiBhZHZhbmNlZCBtZXRob2QuIEZvciBtb3N0IGNhc2VzIHtAbGluayAjc2FmZUluc2VydH0gYW5kIHtAbGluayAjdXBkYXRlQ29udmVyc2lvblJlc3VsdH0gc2hvdWxkIGJlIHVzZWQuCiAqCiAqIEBtZXRob2QgI3NwbGl0VG9BbGxvd2VkUGFyZW50CiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBlbGVtZW50IGlzIGdvaW5nIHRvIGJlIGluc2VydGVkLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlIFRoZSBub2RlIHRvIGluc2VydC4KICogQHJldHVybnMge09iamVjdHxudWxsfSBUaGUgc3BsaXQgcmVzdWx0LiBJZiBpdCB3YXMgbm90IHBvc3NpYmxlIHRvIGZpbmQgYW4gYWxsb3dlZCBwb3NpdGlvbiwgYG51bGxgIGlzIHJldHVybmVkLgogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gVGhlIHBvc2l0aW9uIGJldHdlZW4gc3BsaXQgZWxlbWVudHMuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gW2N1cnNvclBhcmVudF0gVGhlIGVsZW1lbnQgaW5zaWRlIHdoaWNoIHRoZSBjdXJzb3Igc2hvdWxkIGJlIHBsYWNlZCB0bwogKiBjb250aW51ZSB0aGUgY29udmVyc2lvbi4gV2hlbiB0aGUgZWxlbWVudCBpcyBub3QgZGVmaW5lZCBpdCBtZWFucyB0aGF0IHRoZXJlIHdhcyBubyBzcGxpdC4KICovCgovKioKICogUmV0dXJucyBhbGwgdGhlIHNwbGl0IHBhcnRzIG9mIHRoZSBnaXZlbiBgZWxlbWVudGAgdGhhdCB3ZXJlIGNyZWF0ZWQgZHVyaW5nIHVwY2FzdGluZyB0aHJvdWdoIHVzaW5nIHtAbGluayAjc3BsaXRUb0FsbG93ZWRQYXJlbnR9LgogKiBJdCBlbmFibGVzIHlvdSB0byBlYXNpbHkgdHJhY2sgdGhlc2UgZWxlbWVudHMgYW5kIGNvbnRpbnVlIHByb2Nlc3NpbmcgdGhlbSBhZnRlciB0aGV5IGFyZSBzcGxpdCBkdXJpbmcgdGhlIGNvbnZlcnNpb24gb2YgdGhlaXIgY2hpbGRyZW4uCiAqCiAqCQk8cGFyYWdyYXBoPkZvbzxpbWFnZSAvPmJhcjxpbWFnZSAvPmJhejwvcGFyYWdyYXBoPiAtPgogKgkJPHBhcmFncmFwaD5Gb288L3BhcmFncmFwaD48aW1hZ2UgLz48cGFyYWdyYXBoPmJhcjwvcGFyYWdyYXBoPjxpbWFnZSAvPjxwYXJhZ3JhcGg+YmF6PC9wYXJhZ3JhcGg+CiAqCiAqIEZvciBhIHJlZmVyZW5jZSB0byBhbnkgb2YgYWJvdmUgcGFyYWdyYXBocywgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFsbCB0aHJlZSBwYXJhZ3JhcGhzICh0aGUgb3JpZ2luYWwgZWxlbWVudCBpbmNsdWRlZCksCiAqIHNvcnRlZCBpbiB0aGUgb3JkZXIgb2YgdGhlaXIgY3JlYXRpb24gKHRoZSBvcmlnaW5hbCBlbGVtZW50IGlzIHRoZSBmaXJzdCBvbmUpLgogKgogKiBJZiB0aGUgZ2l2ZW4gYGVsZW1lbnRgIHdhcyBub3Qgc3BsaXQsIGFuIGFycmF5IHdpdGggYSBzaW5nbGUgZWxlbWVudCBpcyByZXR1cm5lZC4KICoKICogQSB1c2FnZSBleGFtcGxlIGluIHRoZSBjb252ZXJ0ZXIgY29kZToKICoKICoJCWNvbnN0IG15RWxlbWVudCA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdteUVsZW1lbnQnICk7CiAqCiAqCQkvLyBDaGlsZHJlbiBjb252ZXJzaW9uIG1heSBzcGxpdCBgbXlFbGVtZW50YC4KICoJCWNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKCBkYXRhLnZpZXdJdGVtLCBkYXRhLm1vZGVsQ3Vyc29yICk7CiAqCiAqCQljb25zdCBzcGxpdFBhcnRzID0gY29udmVyc2lvbkFwaS5nZXRTcGxpdFBhcnRzKCBteUVsZW1lbnQgKTsKICoJCWNvbnN0IGxhc3RTcGxpdFBhcnQgPSBzcGxpdFBhcnRzWyBzcGxpdFBhcnRzLmxlbmd0aCAtIDEgXTsKICoKICoJCS8vIFNldHRpbmcgYGRhdGEubW9kZWxSYW5nZWAgYmFzaW5nIG9uIHNwbGl0IHBhcnRzOgogKgkJZGF0YS5tb2RlbFJhbmdlID0gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUmFuZ2UoCiAqCQkJY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUG9zaXRpb25CZWZvcmUoIG15RWxlbWVudCApLAogKgkJCWNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQWZ0ZXIoIGxhc3RTcGxpdFBhcnQgKQogKgkJKTsKICoKICoJCS8vIFNldHRpbmcgYGRhdGEubW9kZWxDdXJzb3JgIHRvIGNvbnRpbnVlIGFmdGVyIHRoZSBsYXN0IHNwbGl0IGVsZW1lbnQ6CiAqCQlkYXRhLm1vZGVsQ3Vyc29yID0gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUG9zaXRpb25BZnRlciggbGFzdFNwbGl0UGFydCApOwogKgogKiAqKlRpcDoqKiBJZiB5b3UgYXJlIHVuYWJsZSB0byBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGVsZW1lbnQgKGZvciBleGFtcGxlIGJlY2F1c2UgdGhlIGNvZGUgaXMgc3BsaXQgaW50byBtdWx0aXBsZSBjb252ZXJ0ZXJzCiAqIG9yIGV2ZW4gY2xhc3NlcykgYnV0IGl0IGhhcyBhbHJlYWR5IGJlZW4gY29udmVydGVkLCB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYGRhdGEubW9kZWxSYW5nZWAuIFRoaXMgaXMgYSBjb21tb24KICogc2l0dWF0aW9uIGlmIGFuIGF0dHJpYnV0ZSBjb252ZXJ0ZXIgaXMgc2VwYXJhdGVkIGZyb20gYW4gZWxlbWVudCBjb252ZXJ0ZXIuCiAqCiAqICoqTm90ZToqKiBUaGlzIGlzIGFuIGFkdmFuY2VkIG1ldGhvZC4gRm9yIG1vc3QgY2FzZXMge0BsaW5rICNzYWZlSW5zZXJ0fSBhbmQge0BsaW5rICN1cGRhdGVDb252ZXJzaW9uUmVzdWx0fSBzaG91bGQgYmUgdXNlZC4KICoKICogQG1ldGhvZCAjZ2V0U3BsaXRQYXJ0cwogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQ+fQogKi8KCi8qKgogKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBwYXJ0cyBvZiB0aGUgcHJvY2Vzc2VkIHZpZXcgaXRlbSBhcmUgc3RpbGwgd2FpdGluZyB0byBiZSBoYW5kbGVkLiBBZnRlciBhIHBpZWNlIG9mIHZpZXcgaXRlbQogKiB3YXMgY29udmVydGVkLCBhbiBhcHByb3ByaWF0ZSBjb25zdW1hYmxlIHZhbHVlIHNob3VsZCBiZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3ZpZXdjb25zdW1hYmxlflZpZXdDb25zdW1hYmxlI2NvbnN1bWUgY29uc3VtZWR9LgogKgogKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0NvbnN1bWFibGV9ICNjb25zdW1hYmxlCiAqLwoKLyoqCiAqIEN1c3RvbSBkYXRhIHN0b3JlZCBieSBjb252ZXJ0ZXJzIGZvciB0aGUgY29udmVyc2lvbiBwcm9jZXNzLiBDdXN0b20gcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdCBjYW4gYmUgZGVmaW5lZCBhbmQgdXNlIHRvCiAqIHBhc3MgcGFyYW1ldGVycyBiZXR3ZWVuIGNvbnZlcnRlcnMuCiAqCiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBwcm9wZXJ0eSBhbmQgdGhlIGBkYXRhYCBwYXJhbWV0ZXIgb2YKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjZXZlbnQ6ZWxlbWVudH0gaXMgdGhhdCB0aGUgYGRhdGFgIHBhcmFtZXRlcnMgYWxsb3cgeW91CiAqIHRvIHBhc3MgcGFyYW1ldGVycyB3aXRoaW4gYSBzaW5nbGUgZXZlbnQgYW5kIGBzdG9yZWAgd2l0aGluIHRoZSB3aG9sZSBjb252ZXJzaW9uLgogKgogKiBAbWVtYmVyIHtPYmplY3R9ICNzdG9yZQogKi8KCi8qKgogKiBUaGUgbW9kZWwncyBzY2hlbWEgaW5zdGFuY2UuCiAqCiAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYX0gI3NjaGVtYQogKi8KCi8qKgogKiBUaGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gaW5zdGFuY2UgdXNlZCB0byBtYW5pcHVsYXRlIHRoZSBkYXRhIGR1cmluZyBjb252ZXJzaW9uLgogKgogKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9ICN3cml0ZXIKICovCgovKioKICogQ29udmVyc2lvbiBkYXRhLgogKgogKiAqKk5vdGU6KiogS2VlcCBpbiBtaW5kIHRoYXQgdGhpcyBvYmplY3QgaXMgc2hhcmVkIGJ5IHJlZmVyZW5jZSBiZXR3ZWVuIGFsbCBjb252ZXJzaW9uIGNhbGxiYWNrcyB0aGF0IHdpbGwgYmUgY2FsbGVkLgogKiBUaGlzIG1lYW5zIHRoYXQgY2FsbGJhY2tzIGNhbiBvdmVycmlkZSB2YWx1ZXMgaWYgbmVlZGVkLCBhbmQgdGhlc2UgdmFsdWVzIHdpbGwgYmUgYXZhaWxhYmxlIGluIG90aGVyIGNhbGxiYWNrcy4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkRhdGEKICoKICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtfSB2aWV3SXRlbSBUaGUgY29udmVydGVkIGl0ZW0uCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gbW9kZWxDdXJzb3IgVGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBjb252ZXJ0ZXIgc2hvdWxkIHN0YXJ0IGNoYW5nZXMuCiAqIENoYW5nZSB0aGlzIHZhbHVlIGZvciB0aGUgbmV4dCBjb252ZXJ0ZXIgdG8gdGVsbCB3aGVyZSB0aGUgY29udmVyc2lvbiBzaG91bGQgY29udGludWUuCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gW21vZGVsUmFuZ2VdIFRoZSBjdXJyZW50IHN0YXRlIG9mIGNvbnZlcnNpb24gcmVzdWx0LiBFdmVyeSBjaGFuZ2UgdG8KICogdGhlIGNvbnZlcnRlZCBlbGVtZW50IHNob3VsZCBiZSByZWZsZWN0ZWQgYnkgc2V0dGluZyBvciBtb2RpZnlpbmcgdGhpcyBwcm9wZXJ0eS4KICov"},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js"],"names":["ViewConsumable","ModelRange","ModelPosition","SchemaContext","isParagraphable","wrapInParagraph","CKEditorError","EmitterMixin","mix","UpcastDispatcher","conversionApi","_splitParts","Map","_cursorParents","_modelCursor","Object","assign","convertItem","_convertItem","bind","convertChildren","_convertChildren","safeInsert","_safeInsert","updateConversionResult","_updateConversionResult","splitToAllowedParent","_splitToAllowedParent","getSplitParts","_getSplitParts","viewItem","writer","context","fire","createContextTree","consumable","createFrom","store","modelRange","documentFragment","createDocumentFragment","_removeEmptyElements","Array","from","parent","getChildren","item","append","markers","extractMarkersFromModelFragment","clear","modelCursor","data","is","name","elementOrModelCursor","nextModelCursor","_createAt","viewChild","result","end","modelElement","position","splitResult","insert","parts","createRange","createPositionBefore","createPositionAfter","length","savedCursorParent","get","createPositionAt","node","schema","allowedParent","findAllowedParent","getAncestors","includes","split","stack","range","getWalker","treeWalkerValue","type","push","originalPart","pop","splitPart","_registerSplitPair","cursorParent","set","has","list","element","anyRemoved","keys","isEmpty","remove","delete","modelItem","markerElements","Set","_createIn","getItems","add","markerElement","markerName","getAttribute","currentPosition","clone","contextDefinition","attributes","getAttributeKeys","key","current","createElement"],"mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,OAAOC,UAAP,MAAuB,gBAAvB;AACA,OAAOC,aAAP,MAA0B,mBAA1B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,eAAT,EAA0BC,eAA1B,QAAiD,iCAAjD;AAEA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,gB;AACpB;AACD;AACA;AACA;AACA;AACA;AACA;AACC,8BAAkC;AAAA,QAArBC,aAAqB,uEAAL,EAAK;;AAAA;;AACjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,cAAL,GAAsB,IAAID,GAAJ,EAAtB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKE,YAAL,GAAoB,IAApB;AAEA;AACF;AACA;AACA;AACA;;AACE,SAAKJ,aAAL,GAAqBK,MAAM,CAACC,MAAP,CAAe,EAAf,EAAmBN,aAAnB,CA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AAI,CAACmE,gBAAL,EAHyC;AAAA;;AAAA;AAG5D,+DAA6C;AAAA,cAAjCC,GAAiC;AAC5CF,UAAAA,UAAU,CAAEE,GAAF,CAAV,GAAoBpE,IAAI,CAAC8D,YAAL,CAAmBM,GAAnB,CAApB;AACA;AAL2D;AAAA;AAAA;AAAA;AAAA;;AAO5D,UAAMC,OAAO,GAAGpF,MAAM,CAACqF,aAAP,CAAsBtE,IAAI,CAACQ,IAA3B,EAAiC0D,UAAjC,CAAhB;;AAEA,UAAKlD,QAAL,EAAgB;AACf/B,QAAAA,MAAM,CAACgB,MAAP,CAAeoE,OAAf,EAAwBrD,QAAxB;AACA;;AAEDA,MAAAA,QAAQ,GAAG5D,aAAa,CAACuD,SAAd,CAAyB0D,OAAzB,EAAkC,CAAlC,CAAX;AACA;AAjBsD;AAAA;AAAA;AAAA;AAAA;;AAmBvD,SAAOrD,QAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\n\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema';\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Upcast dispatcher is a central point of the view-to-model conversion, which is a process of\n * converting a given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element view element} into a correct model structure.\n *\n * During the conversion process, the dispatcher fires events for all {@link module:engine/view/node~Node view nodes}\n * from the converted view document fragment.\n * Special callbacks called \"converters\" should listen to these events in order to convert the view nodes.\n *\n * The second parameter of the callback is the `data` object with the following properties:\n *\n * * `data.viewItem` contains a {@link module:engine/view/node~Node view node} or a\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback.\n * * `data.modelRange` is used to point to the result\n * of the current conversion (e.g. the element that is being inserted)\n * and is always a {@link module:engine/model/range~Range} when the conversion succeeds.\n * * `data.modelCursor` is a {@link module:engine/model/position~Position position} on which the converter should insert\n * the newly created items.\n *\n * The third parameter of the callback is an instance of {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n * which provides additional tools for converters.\n *\n * You can read more about conversion in the following guides:\n *\n * * {@glink framework/guides/deep-dive/conversion/conversion-introduction Advanced conversion concepts &mdash; attributes}\n * * {@glink framework/guides/deep-dive/conversion/custom-element-conversion Custom element conversion}\n *\n * Examples of event-based converters:\n *\n *\t\t// A converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// The <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why you need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p> element's font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it is executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Do not go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into a paragraph (autoparagraphing).\n *\t\teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *\t\t\t// Check if an element can be converted.\n *\t\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *\t\t\t\t// When an element is already consumed by higher priority converters, do nothing.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *\t\t\t// Try to safely insert a paragraph at the model cursor - it will find an allowed parent for the current element.\n *\t\t\tif ( !conversionApi.safeInsert( paragraph, data.modelCursor ) ) {\n *\t\t\t\t// When an element was not inserted, it means that you cannot insert a paragraph at this position.\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Consume the inserted element.\n *\t\t\tconversionApi.consumable.consume( data.viewItem, { name: data.viewItem.name } ) );\n *\n *\t\t\t// Convert the children to a paragraph.\n *\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem,  paragraph ) );\n *\n *\t\t\t// Update `modelRange` and `modelCursor` in the `data` as a conversion result.\n *\t\t\tconversionApi.updateConversionResult( paragraph, data );\n *\t\t}, { priority: 'low' } );\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\nexport default class UpcastDispatcher {\n\t/**\n\t * Creates an upcast dispatcher that operates using the passed API.\n\t *\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n\t * @param {Object} [conversionApi] Additional properties for an interface that will be passed to events fired\n\t * by the upcast dispatcher.\n\t */\n\tconstructor( conversionApi = {} ) {\n\t\t/**\n\t\t * The list of elements that were created during splitting.\n\t\t *\n\t\t * After the conversion process the list is cleared.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n\t\t */\n\t\tthis._splitParts = new Map();\n\n\t\t/**\n\t\t * The list of cursor parent elements that were created during splitting.\n\t\t *\n\t\t * After the conversion process the list is cleared.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n\t\t */\n\t\tthis._cursorParents = new Map();\n\n\t\t/**\n\t\t * The position in the temporary structure where the converted content is inserted. The structure reflects the context of\n\t\t * the target position where the content will be inserted. This property is built based on the context parameter of the\n\t\t * convert method.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/position~Position|null}\n\t\t */\n\t\tthis._modelCursor = null;\n\n\t\t/**\n\t\t * An interface passed by the dispatcher to the event callbacks.\n\t\t *\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n\t\t */\n\t\tthis.conversionApi = Object.assign( {}, conversionApi );\n\n\t\t// The below methods are bound to this `UpcastDispatcher` instance and set on `conversionApi`.\n\t\t// This way only a part of `UpcastDispatcher` API is exposed.\n\t\tthis.conversionApi.convertItem = this._convertItem.bind( this );\n\t\tthis.conversionApi.convertChildren = this._convertChildren.bind( this );\n\t\tthis.conversionApi.safeInsert = this._safeInsert.bind( this );\n\t\tthis.conversionApi.updateConversionResult = this._updateConversionResult.bind( this );\n\t\t// Advanced API - use only if custom position handling is needed.\n\t\tthis.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind( this );\n\t\tthis.conversionApi.getSplitParts = this._getSplitParts.bind( this );\n\t}\n\n\t/**\n\t * Starts the conversion process. The entry point for the conversion.\n\t *\n\t * @fires element\n\t * @fires text\n\t * @fires documentFragment\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n\t * The part of the view to be converted.\n\t * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is the result of the conversion process\n\t * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t */\n\tconvert( viewItem, writer, context = [ '$root' ] ) {\n\t\tthis.fire( 'viewCleanup', viewItem );\n\n\t\t// Create context tree and set position in the top element.\n\t\t// Items will be converted according to this position.\n\t\tthis._modelCursor = createContextTree( context, writer );\n\n\t\t// Store writer in conversion as a conversion API\n\t\t// to be sure that conversion process will use the same batch.\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create consumable values list for conversion process.\n\t\tthis.conversionApi.consumable = ViewConsumable.createFrom( viewItem );\n\n\t\t// Custom data stored by converter for conversion process.\n\t\tthis.conversionApi.store = {};\n\n\t\t// Do the conversion.\n\t\tconst { modelRange } = this._convertItem( viewItem, this._modelCursor );\n\n\t\t// Conversion result is always a document fragment so let's create it.\n\t\tconst documentFragment = writer.createDocumentFragment();\n\n\t\t// When there is a conversion result.\n\t\tif ( modelRange ) {\n\t\t\t// Remove all empty elements that were create while splitting.\n\t\t\tthis._removeEmptyElements();\n\n\t\t\t// Move all items that were converted in context tree to the document fragment.\n\t\t\tfor ( const item of Array.from( this._modelCursor.parent.getChildren() ) ) {\n\t\t\t\twriter.append( item, documentFragment );\n\t\t\t}\n\n\t\t\t// Extract temporary markers elements from model and set as static markers collection.\n\t\t\tdocumentFragment.markers = extractMarkersFromModelFragment( documentFragment, writer );\n\t\t}\n\n\t\t// Clear context position.\n\t\tthis._modelCursor = null;\n\n\t\t// Clear split elements & parents lists.\n\t\tthis._splitParts.clear();\n\t\tthis._cursorParents.clear();\n\n\t\t// Clear conversion API.\n\t\tthis.conversionApi.writer = null;\n\t\tthis.conversionApi.store = null;\n\n\t\t// Return fragment as conversion result.\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n\t */\n\t_convertItem( viewItem, modelCursor ) {\n\t\tconst data = Object.assign( { viewItem, modelCursor, modelRange: null } );\n\n\t\tif ( viewItem.is( 'element' ) ) {\n\t\t\tthis.fire( 'element:' + viewItem.name, data, this.conversionApi );\n\t\t} else if ( viewItem.is( '$text' ) ) {\n\t\t\tthis.fire( 'text', data, this.conversionApi );\n\t\t} else {\n\t\t\tthis.fire( 'documentFragment', data, this.conversionApi );\n\t\t}\n\n\t\t// Handle incorrect conversion result.\n\t\tif ( data.modelRange && !( data.modelRange instanceof ModelRange ) ) {\n\t\t\t/**\n\t\t\t * Incorrect conversion result was dropped.\n\t\t\t *\n\t\t\t * {@link module:engine/model/range~Range Model range} should be a conversion result.\n\t\t\t *\n\t\t\t * @error view-conversion-dispatcher-incorrect-result\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-conversion-dispatcher-incorrect-result', this );\n\t\t}\n\n\t\treturn { modelRange: data.modelRange, modelCursor: data.modelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n\t */\n\t_convertChildren( viewItem, elementOrModelCursor ) {\n\t\tlet nextModelCursor = elementOrModelCursor.is( 'position' ) ?\n\t\t\telementOrModelCursor : ModelPosition._createAt( elementOrModelCursor, 0 );\n\n\t\tconst modelRange = new ModelRange( nextModelCursor );\n\n\t\tfor ( const viewChild of Array.from( viewItem.getChildren() ) ) {\n\t\t\tconst result = this._convertItem( viewChild, nextModelCursor );\n\n\t\t\tif ( result.modelRange instanceof ModelRange ) {\n\t\t\t\tmodelRange.end = result.modelRange.end;\n\t\t\t\tnextModelCursor = result.modelCursor;\n\t\t\t}\n\t\t}\n\n\t\treturn { modelRange, modelCursor: nextModelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert\n\t */\n\t_safeInsert( modelElement, position ) {\n\t\t// Find allowed parent for element that we are going to insert.\n\t\t// If current parent does not allow to insert element but one of the ancestors does\n\t\t// then split nodes to allowed parent.\n\t\tconst splitResult = this._splitToAllowedParent( modelElement, position );\n\n\t\t// When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\t\tif ( !splitResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Insert element on allowed position.\n\t\tthis.conversionApi.writer.insert( modelElement, splitResult.position );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult\n\t */\n\t_updateConversionResult( modelElement, data ) {\n\t\tconst parts = this._getSplitParts( modelElement );\n\n\t\tconst writer = this.conversionApi.writer;\n\n\t\t// Set conversion result range - only if not set already.\n\t\tif ( !data.modelRange ) {\n\t\t\tdata.modelRange = writer.createRange(\n\t\t\t\twriter.createPositionBefore( modelElement ),\n\t\t\t\twriter.createPositionAfter( parts[ parts.length - 1 ] )\n\t\t\t);\n\t\t}\n\n\t\tconst savedCursorParent = this._cursorParents.get( modelElement );\n\n\t\t// Now we need to check where the `modelCursor` should be.\n\t\tif ( savedCursorParent ) {\n\t\t\t// If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n\t\t\t//\n\t\t\t// before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n\t\t\t// after:  <allowed><notAllowed>foo</notAllowed> <converted></converted> <notAllowed>[]</notAllowed></allowed>\n\n\t\t\tdata.modelCursor = writer.createPositionAt( savedCursorParent, 0 );\n\t\t} else {\n\t\t\t// Otherwise just continue after inserted element.\n\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n\t */\n\t_splitToAllowedParent( node, modelCursor ) {\n\t\tconst { schema, writer } = this.conversionApi;\n\n\t\t// Try to find allowed parent.\n\t\tlet allowedParent = schema.findAllowedParent( modelCursor, node );\n\n\t\tif ( allowedParent ) {\n\t\t\t// When current position parent allows to insert node then return this position.\n\t\t\tif ( allowedParent === modelCursor.parent ) {\n\t\t\t\treturn { position: modelCursor };\n\t\t\t}\n\n\t\t\t// When allowed parent is in context tree (it's outside the converted tree).\n\t\t\tif ( this._modelCursor.parent.getAncestors().includes( allowedParent ) ) {\n\t\t\t\tallowedParent = null;\n\t\t\t}\n\t\t}\n\n\t\tif ( !allowedParent ) {\n\t\t\t// Check if the node wrapped with a paragraph would be accepted by the schema.\n\t\t\tif ( !isParagraphable( modelCursor, node, schema ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tposition: wrapInParagraph( modelCursor, writer )\n\t\t\t};\n\t\t}\n\n\t\t// Split element to allowed parent.\n\t\tconst splitResult = this.conversionApi.writer.split( modelCursor, allowedParent );\n\n\t\t// Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n\t\t//\n\t\t// The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n\t\t// that got split) to the beginning of the other part of that element:\n\t\t//\n\t\t// <limit><a><b><c>X[]Y</c></b><a></limit> ->\n\t\t// <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n\t\t//\n\t\t// After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n\t\t// Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n\t\t// Also, since we split all those elements, each of them has to have the other part.\n\t\t//\n\t\t// With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n\t\t// them with \"opening tags\" in the reverse order. For that we can use a stack.\n\t\tconst stack = [];\n\n\t\tfor ( const treeWalkerValue of splitResult.range.getWalker() ) {\n\t\t\tif ( treeWalkerValue.type == 'elementEnd' ) {\n\t\t\t\tstack.push( treeWalkerValue.item );\n\t\t\t} else {\n\t\t\t\t// There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n\t\t\t\tconst originalPart = stack.pop();\n\t\t\t\tconst splitPart = treeWalkerValue.item;\n\n\t\t\t\tthis._registerSplitPair( originalPart, splitPart );\n\t\t\t}\n\t\t}\n\n\t\tconst cursorParent = splitResult.range.end.parent;\n\t\tthis._cursorParents.set( node, cursorParent );\n\n\t\treturn {\n\t\t\tposition: splitResult.position,\n\t\t\tcursorParent\n\t\t};\n\t}\n\n\t/**\n\t * Registers that a `splitPart` element is a split part of the `originalPart` element.\n\t *\n\t * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} originalPart\n\t * @param {module:engine/model/element~Element} splitPart\n\t */\n\t_registerSplitPair( originalPart, splitPart ) {\n\t\tif ( !this._splitParts.has( originalPart ) ) {\n\t\t\tthis._splitParts.set( originalPart, [ originalPart ] );\n\t\t}\n\n\t\tconst list = this._splitParts.get( originalPart );\n\n\t\tthis._splitParts.set( splitPart, list );\n\t\tlist.push( splitPart );\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n\t */\n\t_getSplitParts( element ) {\n\t\tlet parts;\n\n\t\tif ( !this._splitParts.has( element ) ) {\n\t\t\tparts = [ element ];\n\t\t} else {\n\t\t\tparts = this._splitParts.get( element );\n\t\t}\n\n\t\treturn parts;\n\t}\n\n\t/**\n\t * Checks if there are any empty elements created while splitting and removes them.\n\t *\n\t * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n\t * as some elements might have become empty after other empty elements were removed from them.\n\t *\n\t * @private\n\t */\n\t_removeEmptyElements() {\n\t\tlet anyRemoved = false;\n\n\t\tfor ( const element of this._splitParts.keys() ) {\n\t\t\tif ( element.isEmpty ) {\n\t\t\t\tthis.conversionApi.writer.remove( element );\n\t\t\t\tthis._splitParts.delete( element );\n\n\t\t\t\tanyRemoved = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( anyRemoved ) {\n\t\t\tthis._removeEmptyElements();\n\t\t}\n\t}\n\n\t/**\n\t * Fired before the first conversion event, at the beginning of the upcast (view-to-model conversion) process.\n\t *\n\t * @event viewCleanup\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n\t * viewItem A part of the view to be converted.\n\t */\n\n\t/**\n\t * Fired when an {@link module:engine/view/element~Element} is converted.\n\t *\n\t * `element` is a namespace event for a class of events. Names of actually called events follow the pattern of\n\t * `element:<elementName>` where `elementName` is the name of the converted element. This way listeners may listen to\n\t * a conversion of all or just specific elements.\n\t *\n\t * @event element\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastConversionData} data The conversion data. Keep in mind that this object is\n\t * shared by reference between all callbacks that will be called. This means that callbacks can override values if needed, and these\n\t * values will be available in other callbacks.\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by the\n\t * callback.\n\t */\n\n\t/**\n\t * Fired when a {@link module:engine/view/text~Text} is converted.\n\t *\n\t * @event text\n\t * @see #event:element\n\t */\n\n\t/**\n\t * Fired when a {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n\t *\n\t * @event documentFragment\n\t * @see #event:element\n\t */\n}\n\nmix( UpcastDispatcher, EmitterMixin );\n\n// Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\nfunction extractMarkersFromModelFragment( modelItem, writer ) {\n\tconst markerElements = new Set();\n\tconst markers = new Map();\n\n\t// Create ModelTreeWalker.\n\tconst range = ModelRange._createIn( modelItem ).getItems();\n\n\t// Walk through DocumentFragment and collect marker elements.\n\tfor ( const item of range ) {\n\t\t// Check if current element is a marker.\n\t\tif ( item.name == '$marker' ) {\n\t\t\tmarkerElements.add( item );\n\t\t}\n\t}\n\n\t// Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\tfor ( const markerElement of markerElements ) {\n\t\tconst markerName = markerElement.getAttribute( 'data-name' );\n\t\tconst currentPosition = writer.createPositionBefore( markerElement );\n\n\t\t// When marker of given name is not stored it means that we have found the beginning of the range.\n\t\tif ( !markers.has( markerName ) ) {\n\t\t\tmarkers.set( markerName, new ModelRange( currentPosition.clone() ) );\n\t\t// Otherwise is means that we have found end of the marker range.\n\t\t} else {\n\t\t\tmarkers.get( markerName ).end = currentPosition.clone();\n\t\t}\n\n\t\t// Remove marker element from DocumentFragment.\n\t\twriter.remove( markerElement );\n\t}\n\n\treturn markers;\n}\n\n// Creates model fragment according to given context and returns position in the bottom (the deepest) element.\nfunction createContextTree( contextDefinition, writer ) {\n\tlet position;\n\n\tfor ( const item of new SchemaContext( contextDefinition ) ) {\n\t\tconst attributes = {};\n\n\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\tattributes[ key ] = item.getAttribute( key );\n\t\t}\n\n\t\tconst current = writer.createElement( item.name, attributes );\n\n\t\tif ( position ) {\n\t\t\twriter.append( current, position );\n\t\t}\n\n\t\tposition = ModelPosition._createAt( current, 0 );\n\t}\n\n\treturn position;\n}\n\n/**\n * A set of conversion utilities available as the third parameter of the\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher upcast dispatcher}'s events.\n *\n * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi\n */\n\n/**\n * Starts the conversion of a given item by firing an appropriate event.\n *\n * Every fired event is passed (as the first parameter) an object with the `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of the `modelRange` property is returned by this method.\n * The `modelRange` must be a {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor The conversion position.\n * @returns {Object} result The conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange The model range containing the result of the item conversion,\n * created and modified by callbacks attached to the fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor The position where the conversion should be continued.\n */\n\n/**\n * Starts the conversion of all children of a given item by firing appropriate events for all the children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem An element whose children should be converted.\n * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrElement A position or an element of\n * the conversion.\n * @returns {Object} result The conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange The model range containing the results of the conversion of all children\n * of the given item. When no child was converted, the range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor The position where the conversion should be continued.\n */\n\n/**\n * Safely inserts an element to the document, checking the {@link module:engine/model/schema~Schema schema} to find an allowed parent for\n * an element that you are going to insert, starting from the given position. If the current parent does not allow to insert the element\n * but one of the ancestors does, then splits the nodes to allowed parent.\n *\n * If the schema allows to insert the node in a given position, nothing is split.\n *\n * If it was not possible to find an allowed parent, `false` is returned and nothing is split.\n *\n * Otherwise, ancestors are split.\n *\n * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *\t\t-> safe insert for `<image>` will split ->\n *\n *\t\t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * Example usage:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\tif ( !conversionApi.safeInsert( myElement, data.modelCursor ) ) {\n *\t\t\treturn;\n *\t\t}\n *\n * The split result is saved and {@link #updateConversionResult} should be used to update the\n * {@link module:engine/conversion/upcastdispatcher~UpcastConversionData conversion data}.\n *\n * @method #safeInsert\n * @param {module:engine/model/node~Node} node The node to insert.\n * @param {module:engine/model/position~Position} position The position where an element is going to be inserted.\n * @returns {Boolean} The split result. If it was not possible to find an allowed position, `false` is returned.\n */\n\n/**\n * Updates the conversion result and sets a proper {@link module:engine/conversion/upcastdispatcher~UpcastConversionData#modelRange} and\n * the next {@link module:engine/conversion/upcastdispatcher~UpcastConversionData#modelCursor} after the conversion.\n * Used together with {@link #safeInsert}, it enables you to easily convert elements without worrying if the node was split\n * during the conversion of its children.\n *\n * A usage example in converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\tif ( !conversionApi.safeInsert( myElement, data.modelCursor ) ) {\n *\t\t\treturn;\n *\t\t}\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( data.viewItem, myElement );\n *\n *\t\tconversionApi.updateConversionResult( myElement, data );\n *\n * @method #updateConversionResult\n * @param {module:engine/model/element~Element} element\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionData} data Conversion data.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by the callback.\n */\n\n/**\n * Checks the {@link module:engine/model/schema~Schema schema} to find an allowed parent for an element that is going to be inserted\n * starting from the given position. If the current parent does not allow inserting an element but one of the ancestors does, the method\n * splits nodes to allowed parent.\n *\n * If the schema allows inserting the node in the given position, nothing is split and an object with that position is returned.\n *\n * If it was not possible to find an allowed parent, `null` is returned and nothing is split.\n *\n * Otherwise, ancestors are split and an object with a position and the copy of the split element is returned.\n *\n * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *\t\t-> split for `<image>` ->\n *\n *\t\t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the example above, the position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * **Note:** This is an advanced method. For most cases {@link #safeInsert} and {@link #updateConversionResult} should be used.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position The position where the element is going to be inserted.\n * @param {module:engine/model/node~Node} node The node to insert.\n * @returns {Object|null} The split result. If it was not possible to find an allowed position, `null` is returned.\n * @returns {module:engine/model/position~Position} The position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] The element inside which the cursor should be placed to\n * continue the conversion. When the element is not defined it means that there was no split.\n */\n\n/**\n * Returns all the split parts of the given `element` that were created during upcasting through using {@link #splitToAllowedParent}.\n * It enables you to easily track these elements and continue processing them after they are split during the conversion of their children.\n *\n *\t\t<paragraph>Foo<image />bar<image />baz</paragraph> ->\n *\t\t<paragraph>Foo</paragraph><image /><paragraph>bar</paragraph><image /><paragraph>baz</paragraph>\n *\n * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),\n * sorted in the order of their creation (the original element is the first one).\n *\n * If the given `element` was not split, an array with a single element is returned.\n *\n * A usage example in the converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\tconst splitParts = conversionApi.getSplitParts( myElement );\n *\t\tconst lastSplitPart = splitParts[ splitParts.length - 1 ];\n *\n *\t\t// Setting `data.modelRange` basing on split parts:\n *\t\tdata.modelRange = conversionApi.writer.createRange(\n *\t\t\tconversionApi.writer.createPositionBefore( myElement ),\n *\t\t\tconversionApi.writer.createPositionAfter( lastSplitPart )\n *\t\t);\n *\n *\t\t// Setting `data.modelCursor` to continue after the last split element:\n *\t\tdata.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );\n *\n * **Tip:** If you are unable to get a reference to the original element (for example because the code is split into multiple converters\n * or even classes) but it has already been converted, you may want to check the first element in `data.modelRange`. This is a common\n * situation if an attribute converter is separated from an element converter.\n *\n * **Note:** This is an advanced method. For most cases {@link #safeInsert} and {@link #updateConversionResult} should be used.\n *\n * @method #getSplitParts\n * @param {module:engine/model/element~Element} element\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\n/**\n * Stores information about what parts of the processed view item are still waiting to be handled. After a piece of view item\n * was converted, an appropriate consumable value should be\n * {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable\n */\n\n/**\n * Custom data stored by converters for the conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and the `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that the `data` parameters allow you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @member {Object} #store\n */\n\n/**\n * The model's schema instance.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/model/writer~Writer} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/model/writer~Writer} #writer\n */\n\n/**\n * Conversion data.\n *\n * **Note:** Keep in mind that this object is shared by reference between all conversion callbacks that will be called.\n * This means that callbacks can override values if needed, and these values will be available in other callbacks.\n *\n * @typedef {Object} module:engine/conversion/upcastdispatcher~UpcastConversionData\n *\n * @property {module:engine/view/item~Item} viewItem The converted item.\n * @property {module:engine/model/position~Position} modelCursor The position where the converter should start changes.\n * Change this value for the next converter to tell where the conversion should continue.\n * @property {module:engine/model/range~Range} [modelRange] The current state of conversion result. Every change to\n * the converted element should be reflected by setting or modifying this property.\n */\n"]}]}