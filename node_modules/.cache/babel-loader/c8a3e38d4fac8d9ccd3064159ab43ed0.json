{"remainingRequest":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js?{}!/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js","dependencies":[{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90eXBlb2YgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YiOwppbXBvcnQgX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIgZnJvbSAiL2hvbWUvZWtlYmVyYXQvWWFuZGV4LkRpc2svUHJvamVsZXJpbS9CZW5pbVByb2plbGVyaW0vd2Vic2l0ZW0vd2Vic2l0ZW0td2ViL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKaW1wb3J0IF9pbmhlcml0cyBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzIjsKaW1wb3J0IF9jcmVhdGVTdXBlciBmcm9tICIvaG9tZS9la2ViZXJhdC9ZYW5kZXguRGlzay9Qcm9qZWxlcmltL0JlbmltUHJvamVsZXJpbS93ZWJzaXRlbS93ZWJzaXRlbS13ZWIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZVN1cGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zZXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMSwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQ29udGFpbnMgZG93bmNhc3QgKG1vZGVsLXRvLXZpZXcpIGNvbnZlcnRlcnMgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcn0uCiAqCiAqIEBtb2R1bGUgZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzCiAqLwppbXBvcnQgTW9kZWxSYW5nZSBmcm9tICcuLi9tb2RlbC9yYW5nZSc7CmltcG9ydCBNb2RlbFNlbGVjdGlvbiBmcm9tICcuLi9tb2RlbC9zZWxlY3Rpb24nOwppbXBvcnQgTW9kZWxFbGVtZW50IGZyb20gJy4uL21vZGVsL2VsZW1lbnQnOwppbXBvcnQgVmlld0F0dHJpYnV0ZUVsZW1lbnQgZnJvbSAnLi4vdmlldy9hdHRyaWJ1dGVlbGVtZW50JzsKaW1wb3J0IERvY3VtZW50U2VsZWN0aW9uIGZyb20gJy4uL21vZGVsL2RvY3VtZW50c2VsZWN0aW9uJzsKaW1wb3J0IENvbnZlcnNpb25IZWxwZXJzIGZyb20gJy4vY29udmVyc2lvbmhlbHBlcnMnOwppbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gtZXMnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IHRvQXJyYXkgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvdG9hcnJheSc7Ci8qKgogKiBEb3duY2FzdCBjb252ZXJzaW9uIGhlbHBlciBmdW5jdGlvbnMuCiAqCiAqIEBleHRlbmRzIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9uaGVscGVyc35Db252ZXJzaW9uSGVscGVycwogKi8KCnZhciBEb3duY2FzdEhlbHBlcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db252ZXJzaW9uSGVscGVycykgewogIF9pbmhlcml0cyhEb3duY2FzdEhlbHBlcnMsIF9Db252ZXJzaW9uSGVscGVycyk7CgogIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRG93bmNhc3RIZWxwZXJzKTsKCiAgZnVuY3Rpb24gRG93bmNhc3RIZWxwZXJzKCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvd25jYXN0SGVscGVycyk7CgogICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogIH0KCiAgX2NyZWF0ZUNsYXNzKERvd25jYXN0SGVscGVycywgW3sKICAgIGtleTogImVsZW1lbnRUb0VsZW1lbnQiLAogICAgdmFsdWU6CiAgICAvKioKICAgICAqIE1vZGVsIGVsZW1lbnQgdG8gdmlldyBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIGNyZWF0aW5nIGEgdmlldyBlbGVtZW50LiBGb3IgZXhhbXBsZSwgbW9kZWwgYDxwYXJhZ3JhcGg+Rm9vPC9wYXJhZ3JhcGg+YCBiZWNvbWVzIGA8cD5Gb288L3A+YCBpbiB0aGUgdmlldy4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ3BhcmFncmFwaCcsCiAgICAgKgkJCXZpZXc6ICdwJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ3BhcmFncmFwaCcsCiAgICAgKgkJCXZpZXc6ICdkaXYnLAogICAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5lbGVtZW50VG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnZmFuY3lQYXJhZ3JhcGgnLAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAncCcsCiAgICAgKgkJCQljbGFzc2VzOiAnZmFuY3knCiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmVsZW1lbnRUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdoZWFkaW5nJywKICAgICAqCQkJdmlldzogKCBtb2RlbEVsZW1lbnQsIGNvbnZlcnNpb25BcGkgKSA9PiB7CiAgICAgKgkJCQljb25zdCB7IHdyaXRlciB9ID0gY29udmVyc2lvbkFwaTsKICAgICAqCiAgICAgKgkJCQlyZXR1cm4gd3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdoJyArIG1vZGVsRWxlbWVudC5nZXRBdHRyaWJ1dGUoICdsZXZlbCcgKSApOwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIFRoZSBlbGVtZW50LXRvLWVsZW1lbnQgY29udmVyc2lvbiBzdXBwb3J0cyB0aGUgcmVjb252ZXJzaW9uIG1lY2hhbmlzbS4gVGhpcyBpcyBoZWxwZnVsIGluIHRoZSBjb252ZXJzaW9uIHRvIGNvbXBsZXggdmlldyBzdHJ1Y3R1cmVzCiAgICAgKiB3aGVyZSBtdWx0aXBsZSBhdG9taWMgZWxlbWVudC10by1lbGVtZW50IGFuZCBhdHRyaWJ1dGUtdG8tYXR0cmlidXRlIG9yIGF0dHJpYnV0ZS10by1lbGVtZW50IGNvdWxkIGJlIHVzZWQuIEJ5IHNwZWNpZnlpbmcKICAgICAqIGB0cmlnZ2VyQnkoKWAgZXZlbnRzIHlvdSBjYW4gdHJpZ2dlciByZWNvbnZlcnRpbmcgdGhlIG1vZGVsIHRvIGZ1bGwgdmlldyB0cmVlIHN0cnVjdHVyZXMgYXQgb25jZS4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ2NvbXBsZXgnLAogICAgICoJCQl2aWV3OiAoIG1vZGVsRWxlbWVudCwgY29udmVyc2lvbkFwaSApID0+IGNyZWF0ZUNvbXBsZXhWaWV3RnJvbU1vZGVsKCBtb2RlbEVsZW1lbnQsIGNvbnZlcnNpb25BcGkgKSwKICAgICAqCQkJdHJpZ2dlckJ5OiB7CiAgICAgKgkJCQlhdHRyaWJ1dGVzOiBbICdmb28nLCAnYmFyJyBdLAogICAgICoJCQkJY2hpbGRyZW46IFsgJ3Nsb3QnIF0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqCiAgICAgKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBlbGVtZW50LXRvLWVsZW1lbnQgY29udmVyc2lvbiBpbiB0aGUKICAgICAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvY29udmVyc2lvbi9jdXN0b20tZWxlbWVudC1jb252ZXJzaW9uIEN1c3RvbSBlbGVtZW50IGNvbnZlcnNpb259IGd1aWRlLgogICAgICoKICAgICAqIEBtZXRob2QgI2VsZW1lbnRUb0VsZW1lbnQKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgogICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5tb2RlbCBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgZWxlbWVudCB0byBjb252ZXJ0LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb258RnVuY3Rpb259IGNvbmZpZy52aWV3IEEgdmlldyBlbGVtZW50IGRlZmluaXRpb24gb3IgYSBmdW5jdGlvbgogICAgICogdGhhdCB0YWtlcyB0aGUgbW9kZWwgZWxlbWVudCBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpIGRvd25jYXN0IGNvbnZlcnNpb24gQVBJfQogICAgICogYXMgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIHZpZXcgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy50cmlnZ2VyQnldIFJlY29udmVyc2lvbiB0cmlnZ2Vycy4gQXQgbGVhc3Qgb25lIHRyaWdnZXIgbXVzdCBiZSBkZWZpbmVkLgogICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gY29uZmlnLnRyaWdnZXJCeS5hdHRyaWJ1dGVzIFRoZSBuYW1lIG9mIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlcyB3aG9zZSBjaGFuZ2Ugd2lsbCB0cmlnZ2VyIGVsZW1lbnQKICAgICAqIHJlY29udmVyc2lvbi4KICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGNvbmZpZy50cmlnZ2VyQnkuY2hpbGRyZW4gVGhlIG5hbWUgb2YgZGlyZWN0IGNoaWxkcmVuIHdob3NlIGFkZGluZyBvciByZW1vdmluZyB3aWxsIHRyaWdnZXIgZWxlbWVudAogICAgICogcmVjb252ZXJzaW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzfQogICAgICovCiAgICBmdW5jdGlvbiBlbGVtZW50VG9FbGVtZW50KGNvbmZpZykgewogICAgICByZXR1cm4gdGhpcy5hZGQoZG93bmNhc3RFbGVtZW50VG9FbGVtZW50KGNvbmZpZykpOwogICAgfQogICAgLyoqCiAgICAgKiBNb2RlbCBhdHRyaWJ1dGUgdG8gdmlldyBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIHdyYXBwaW5nIHZpZXcgbm9kZXMgd2l0aCBhIHZpZXcgYXR0cmlidXRlIGVsZW1lbnQuIEZvciBleGFtcGxlLCBhIG1vZGVsIHRleHQgbm9kZSB3aXRoCiAgICAgKiBgIkZvbyJgIGFzIGRhdGEgYW5kIHRoZSBgYm9sZGAgYXR0cmlidXRlIGJlY29tZXMgYDxzdHJvbmc+Rm9vPC9zdHJvbmc+YCBpbiB0aGUgdmlldy4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICAgKgkJCXZpZXc6ICdzdHJvbmcnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdib2xkJywKICAgICAqCQkJdmlldzogJ2InLAogICAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdpbnZlcnQnLAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQljbGFzc2VzOiBbICdmb250LWxpZ2h0JywgJ2JnLWRhcmsnIF0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQlrZXk6ICdmb250U2l6ZScsCiAgICAgKgkJCQl2YWx1ZXM6IFsgJ2JpZycsICdzbWFsbCcgXQogICAgICoJCQl9LAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQliaWc6IHsKICAgICAqCQkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQkJc3R5bGVzOiB7CiAgICAgKgkJCQkJCSdmb250LXNpemUnOiAnMS4yZW0nCiAgICAgKgkJCQkJfQogICAgICoJCQkJfSwKICAgICAqCQkJCXNtYWxsOiB7CiAgICAgKgkJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQknZm9udC1zaXplJzogJzAuOGVtJwogICAgICoJCQkJCX0KICAgICAqCQkJCX0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICAgKgkJCXZpZXc6ICggbW9kZWxBdHRyaWJ1dGVWYWx1ZSwgY29udmVyc2lvbkFwaSApID0+IHsKICAgICAqCQkJCWNvbnN0IHsgd3JpdGVyIH0gPSBjb252ZXJzaW9uQXBpOwogICAgICoKICAgICAqCQkJCXJldHVybiB3cml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCggJ3NwYW4nLCB7CiAgICAgKgkJCQkJc3R5bGU6ICdmb250LXdlaWdodDonICsgbW9kZWxBdHRyaWJ1dGVWYWx1ZQogICAgICoJCQkJfSApOwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6IHsKICAgICAqCQkJCWtleTogJ2NvbG9yJywKICAgICAqCQkJCW5hbWU6ICckdGV4dCcKICAgICAqCQkJfSwKICAgICAqCQkJdmlldzogKCBtb2RlbEF0dHJpYnV0ZVZhbHVlLCBjb252ZXJzaW9uQXBpICkgPT4gewogICAgICoJCQkJY29uc3QgeyB3cml0ZXIgfSA9IGNvbnZlcnNpb25BcGk7CiAgICAgKgogICAgICoJCQkJcmV0dXJuIHdyaXRlci5jcmVhdGVBdHRyaWJ1dGVFbGVtZW50KCAnc3BhbicsIHsKICAgICAqCQkJCQlzdHlsZTogJ2NvbG9yOicgKyBtb2RlbEF0dHJpYnV0ZVZhbHVlCiAgICAgKgkJCQl9ICk7CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjYXR0cmlidXRlVG9FbGVtZW50CiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnLm1vZGVsIFRoZSBrZXkgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb252ZXJ0IGZyb20gb3IgYSBgeyBrZXksIHZhbHVlcyB9YCBvYmplY3QuIGB2YWx1ZXNgIGlzIGFuIGFycmF5CiAgICAgKiBvZiBgU3RyaW5nYHMgd2l0aCBwb3NzaWJsZSB2YWx1ZXMgaWYgdGhlIG1vZGVsIGF0dHJpYnV0ZSBpcyBhbiBlbnVtZXJhYmxlLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb258RnVuY3Rpb258T2JqZWN0fSBjb25maWcudmlldyBBIHZpZXcgZWxlbWVudCBkZWZpbml0aW9uIG9yIGEgZnVuY3Rpb24KICAgICAqIHRoYXQgdGFrZXMgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSBhbmQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0Q29udmVyc2lvbkFwaSBkb3duY2FzdCBjb252ZXJzaW9uIEFQSX0gYXMgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIHZpZXcKICAgICAqIGF0dHJpYnV0ZSBlbGVtZW50LiBJZiBgY29uZmlnLm1vZGVsLnZhbHVlc2AgaXMgZ2l2ZW4sIGBjb25maWcudmlld2Agc2hvdWxkIGJlIGFuIG9iamVjdCBhc3NpZ25pbmcgdmFsdWVzIGZyb20gYGNvbmZpZy5tb2RlbC52YWx1ZXNgCiAgICAgKiB0byB2aWV3IGVsZW1lbnQgZGVmaW5pdGlvbnMgb3IgZnVuY3Rpb25zLgogICAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzfQogICAgICovCgogIH0sIHsKICAgIGtleTogImF0dHJpYnV0ZVRvRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlVG9FbGVtZW50KGNvbmZpZykgewogICAgICByZXR1cm4gdGhpcy5hZGQoZG93bmNhc3RBdHRyaWJ1dGVUb0VsZW1lbnQoY29uZmlnKSk7CiAgICB9CiAgICAvKioKICAgICAqIE1vZGVsIGF0dHJpYnV0ZSB0byB2aWV3IGF0dHJpYnV0ZSBjb252ZXJzaW9uIGhlbHBlci4KICAgICAqCiAgICAgKiBUaGlzIGNvbnZlcnNpb24gcmVzdWx0cyBpbiBhZGRpbmcgYW4gYXR0cmlidXRlIHRvIGEgdmlldyBub2RlLCBiYXNpbmcgb24gYW4gYXR0cmlidXRlIGZyb20gYSBtb2RlbCBub2RlLiBGb3IgZXhhbXBsZSwKICAgICAqIGA8aW1hZ2Ugc3JjPSdmb28uanBnJz48L2ltYWdlPmAgaXMgY29udmVydGVkIHRvIGA8aW1nIHNyYz0nZm9vLmpwZyc+PC9pbWc+YC4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJbW9kZWw6ICdzb3VyY2UnLAogICAgICoJCQl2aWV3OiAnc3JjJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJbW9kZWw6ICdzb3VyY2UnLAogICAgICoJCQl2aWV3OiAnaHJlZicsCiAgICAgKgkJCWNvbnZlcnRlclByaW9yaXR5OiAnaGlnaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQluYW1lOiAnaW1hZ2UnLAogICAgICoJCQkJa2V5OiAnc291cmNlJwogICAgICoJCQl9LAogICAgICoJCQl2aWV3OiAnc3JjJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJbW9kZWw6IHsKICAgICAqCQkJCW5hbWU6ICdzdHlsZWQnLAogICAgICoJCQkJdmFsdWVzOiBbICdkYXJrJywgJ2xpZ2h0JyBdCiAgICAgKgkJCX0sCiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCWRhcms6IHsKICAgICAqCQkJCQlrZXk6ICdjbGFzcycsCiAgICAgKgkJCQkJdmFsdWU6IFsgJ3N0eWxlZCcsICdzdHlsZWQtZGFyaycgXQogICAgICoJCQkJfSwKICAgICAqCQkJCWxpZ2h0OiB7CiAgICAgKgkJCQkJa2V5OiAnY2xhc3MnLAogICAgICoJCQkJCXZhbHVlOiBbICdzdHlsZWQnLCAnc3R5bGVkLWxpZ2h0JyBdCiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCW1vZGVsOiAnc3R5bGVkJywKICAgICAqCQkJdmlldzogbW9kZWxBdHRyaWJ1dGVWYWx1ZSA9PiAoIHsKICAgICAqCQkJCWtleTogJ2NsYXNzJywKICAgICAqCQkJCXZhbHVlOiAnc3R5bGVkLScgKyBtb2RlbEF0dHJpYnV0ZVZhbHVlCiAgICAgKgkJCX0gKQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiAqKk5vdGUqKjogRG93bmNhc3RpbmcgdG8gYSBzdHlsZSBwcm9wZXJ0eSByZXF1aXJlcyBwcm92aWRpbmcgYHZhbHVlYCBhcyBhbiBvYmplY3Q6CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCW1vZGVsOiAnbGluZUhlaWdodCcsCiAgICAgKgkJCXZpZXc6IG1vZGVsQXR0cmlidXRlVmFsdWUgPT4gKCB7CiAgICAgKgkJCQlrZXk6ICdzdHlsZScsCiAgICAgKgkJCQl2YWx1ZTogewogICAgICoJCQkJCSdsaW5lLWhlaWdodCc6IG1vZGVsQXR0cmlidXRlVmFsdWUsCiAgICAgKgkJCQkJJ2JvcmRlci1ib3R0b20nOiAnMXB4IGRvdHRlZCAjYmEyJwogICAgICoJCQkJfQogICAgICoJCQl9ICkKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjYXR0cmlidXRlVG9BdHRyaWJ1dGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcubW9kZWwgVGhlIGtleSBvZiB0aGUgYXR0cmlidXRlIHRvIGNvbnZlcnQgZnJvbSBvciBhIGB7IGtleSwgdmFsdWVzLCBbIG5hbWUgXSB9YCBvYmplY3QgZGVzY3JpYmluZwogICAgICogdGhlIGF0dHJpYnV0ZSBrZXksIHBvc3NpYmxlIHZhbHVlcyBhbmQsIG9wdGlvbmFsbHksIGFuIGVsZW1lbnQgbmFtZSB0byBjb252ZXJ0IGZyb20uCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IGNvbmZpZy52aWV3IEEgdmlldyBhdHRyaWJ1dGUga2V5LCBvciBhIGB7IGtleSwgdmFsdWUgfWAgb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcwogICAgICogdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpIGRvd25jYXN0IGNvbnZlcnNpb24gQVBJfQogICAgICogYXMgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIGB7IGtleSwgdmFsdWUgfWAgb2JqZWN0LiBJZiBga2V5YCBpcyBgJ2NsYXNzJ2AsIGB2YWx1ZWAgY2FuIGJlIGEgYFN0cmluZ2Agb3IgYW4KICAgICAqIGFycmF5IG9mIGBTdHJpbmdgcy4gSWYgYGtleWAgaXMgYCdzdHlsZSdgLCBgdmFsdWVgIGlzIGFuIG9iamVjdCB3aXRoIGtleS12YWx1ZSBwYWlycy4gSW4gb3RoZXIgY2FzZXMsIGB2YWx1ZWAgaXMgYSBgU3RyaW5nYC4KICAgICAqIElmIGBjb25maWcubW9kZWwudmFsdWVzYCBpcyBzZXQsIGBjb25maWcudmlld2Agc2hvdWxkIGJlIGFuIG9iamVjdCBhc3NpZ25pbmcgdmFsdWVzIGZyb20gYGNvbmZpZy5tb2RlbC52YWx1ZXNgIHRvCiAgICAgKiBgeyBrZXksIHZhbHVlIH1gIG9iamVjdHMgb3IgYSBmdW5jdGlvbnMuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnN9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYXR0cmlidXRlVG9BdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZVRvQXR0cmlidXRlKGNvbmZpZykgewogICAgICByZXR1cm4gdGhpcy5hZGQoZG93bmNhc3RBdHRyaWJ1dGVUb0F0dHJpYnV0ZShjb25maWcpKTsKICAgIH0KICAgIC8qKgogICAgICogTW9kZWwgbWFya2VyIHRvIHZpZXcgZWxlbWVudCBjb252ZXJzaW9uIGhlbHBlci4KICAgICAqCiAgICAgKiAqKk5vdGUqKjogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgb25seSBmb3IgZWRpdGluZyBkb3duY2FzdC4gRm9yIGRhdGEgZG93bmNhc3QsIHVzZQogICAgICoge0BsaW5rICNtYXJrZXJUb0RhdGEgYCNtYXJrZXJUb0RhdGEoKWB9IHRoYXQgcHJvZHVjZXMgdmFsaWQgSFRNTCBkYXRhLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIGNyZWF0aW5nIGEgdmlldyBlbGVtZW50IG9uIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBjb252ZXJ0ZWQgbWFya2VyLiBJZiB0aGUgY29udmVydGVkIG1hcmtlcgogICAgICogaXMgY29sbGFwc2VkLCBvbmx5IG9uZSBlbGVtZW50IGlzIGNyZWF0ZWQuIEZvciBleGFtcGxlLCBtb2RlbCBtYXJrZXIgc2V0IGxpa2UgdGhpczogYDxwYXJhZ3JhcGg+RltvbyBiXWFyPC9wYXJhZ3JhcGg+YAogICAgICogYmVjb21lcyBgPHA+RjxzcGFuIGRhdGEtbWFya2VyPSJzZWFyY2giPjwvc3Bhbj5vbyBiPHNwYW4gZGF0YS1tYXJrZXI9InNlYXJjaCI+PC9zcGFuPmFyPC9wPmAgaW4gdGhlIHZpZXcuCiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2VkaXRpbmdEb3duY2FzdCcgKS5tYXJrZXJUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdzZWFyY2gnLAogICAgICoJCQl2aWV3OiAnbWFya2VyLXNlYXJjaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2VkaXRpbmdEb3duY2FzdCcgKS5tYXJrZXJUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdzZWFyY2gnLAogICAgICoJCQl2aWV3OiAnc2VhcmNoLXJlc3VsdCcsCiAgICAgKgkJCWNvbnZlcnRlclByaW9yaXR5OiAnaGlnaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2VkaXRpbmdEb3duY2FzdCcgKS5tYXJrZXJUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdzZWFyY2gnLAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQlhdHRyaWJ1dGVzOiB7CiAgICAgKgkJCQkJJ2RhdGEtbWFya2VyJzogJ3NlYXJjaCcKICAgICAqCQkJCX0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZWRpdGluZ0Rvd25jYXN0JyApLm1hcmtlclRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ3NlYXJjaCcsCiAgICAgKgkJCXZpZXc6ICggbWFya2VyRGF0YSwgY29udmVyc2lvbkFwaSApID0+IHsKICAgICAqCQkJCWNvbnN0IHsgd3JpdGVyIH0gPSBjb252ZXJzaW9uQXBpOwogICAgICoKICAgICAqCQkJCXJldHVybiB3cml0ZXIuY3JlYXRlVUlFbGVtZW50KCAnc3BhbicsIHsKICAgICAqCQkJCQknZGF0YS1tYXJrZXInOiAnc2VhcmNoJywKICAgICAqCQkJCQknZGF0YS1zdGFydCc6IG1hcmtlckRhdGEuaXNPcGVuaW5nCiAgICAgKgkJCQl9ICk7CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgYXMgdGhlIGBjb25maWcudmlld2AgcGFyYW1ldGVyLCBpdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYm90aCBib3VuZGFyeSBlbGVtZW50cy4gVGhlIGZ1bmN0aW9uCiAgICAgKiByZWNlaXZlcyB0aGUgYGRhdGFgIG9iamVjdCBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpIGRvd25jYXN0IGNvbnZlcnNpb24gQVBJfQogICAgICogYXMgYSBwYXJhbWV0ZXJzIGFuZCBzaG91bGQgcmV0dXJuIGFuIGluc3RhbmNlIG9mIHRoZQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50IHZpZXcgVUkgZWxlbWVudH0uIFRoZSBgZGF0YWAgb2JqZWN0IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpIGBjb252ZXJzaW9uQXBpYH0gYXJlIHBhc3NlZCBmcm9tCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXIjZXZlbnQ6YWRkTWFya2VyfS4gQWRkaXRpb25hbGx5LAogICAgICogdGhlIGBkYXRhLmlzT3BlbmluZ2AgcGFyYW1ldGVyIGlzIHBhc3NlZCwgd2hpY2ggaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhlIG1hcmtlciBzdGFydCBib3VuZGFyeSBlbGVtZW50LCBhbmQgYGZhbHNlYCB0bwogICAgICogdGhlIG1hcmtlciBlbmQgYm91bmRhcnkgZWxlbWVudC4KICAgICAqCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqCiAgICAgKiBAbWV0aG9kICNtYXJrZXJUb0VsZW1lbnQKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgogICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5tb2RlbCBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgbWFya2VyIChvciBtb2RlbCBtYXJrZXIgZ3JvdXApIHRvIGNvbnZlcnQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbnxGdW5jdGlvbn0gY29uZmlnLnZpZXcgQSB2aWV3IGVsZW1lbnQgZGVmaW5pdGlvbiBvciBhIGZ1bmN0aW9uIHRoYXQKICAgICAqIHRha2VzIHRoZSBtb2RlbCBtYXJrZXIgZGF0YSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpIGRvd25jYXN0IGNvbnZlcnNpb24gQVBJfQogICAgICogYXMgYSBwYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGEgdmlldyBVSSBlbGVtZW50LgogICAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzfQogICAgICovCgogIH0sIHsKICAgIGtleTogIm1hcmtlclRvRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya2VyVG9FbGVtZW50KGNvbmZpZykgewogICAgICByZXR1cm4gdGhpcy5hZGQoZG93bmNhc3RNYXJrZXJUb0VsZW1lbnQoY29uZmlnKSk7CiAgICB9CiAgICAvKioKICAgICAqIE1vZGVsIG1hcmtlciB0byBoaWdobGlnaHQgY29udmVyc2lvbiBoZWxwZXIuCiAgICAgKgogICAgICogVGhpcyBjb252ZXJzaW9uIHJlc3VsdHMgaW4gY3JlYXRpbmcgYSBoaWdobGlnaHQgb24gdmlldyBub2Rlcy4gRm9yIHRoaXMga2luZCBvZiBjb252ZXJzaW9uLAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+SGlnaGxpZ2h0RGVzY3JpcHRvcn0gc2hvdWxkIGJlIHByb3ZpZGVkLgogICAgICoKICAgICAqIEZvciB0ZXh0IG5vZGVzLCBhIGA8c3Bhbj5gIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBpcyBjcmVhdGVkIGFuZCBpdCB3cmFwcyBhbGwgdGV4dCBub2RlcwogICAgICogaW4gdGhlIGNvbnZlcnRlZCBtYXJrZXIgcmFuZ2UuIEZvciBleGFtcGxlLCBhIG1vZGVsIG1hcmtlciBzZXQgbGlrZSB0aGlzOiBgPHBhcmFncmFwaD5GW29vIGJdYXI8L3BhcmFncmFwaD5gIGJlY29tZXMKICAgICAqIGA8cD5GPHNwYW4gY2xhc3M9ImNvbW1lbnQiPm9vIGI8L3NwYW4+YXI8L3A+YCBpbiB0aGUgdmlldy4KICAgICAqCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudH0gbWF5IHByb3ZpZGUgYSBjdXN0b20gd2F5IG9mIGhhbmRsaW5nIGhpZ2hsaWdodC4gTW9zdCBvZnRlbiwKICAgICAqIHRoZSBlbGVtZW50IGl0c2VsZiBpcyBnaXZlbiBjbGFzc2VzIGFuZCBhdHRyaWJ1dGVzIGRlc2NyaWJlZCBpbiB0aGUgaGlnaGxpZ2h0IGRlc2NyaXB0b3IgKGluc3RlYWQgb2YgYmVpbmcgd3JhcHBlZCBpbiBgPHNwYW4+YCkuCiAgICAgKiBGb3IgZXhhbXBsZSwgYSBtb2RlbCBtYXJrZXIgc2V0IGxpa2UgdGhpczogYFs8aW1hZ2Ugc3JjPSJmb28uanBnIj48L2ltYWdlPl1gIGJlY29tZXMgYDxpbWcgc3JjPSJmb28uanBnIiBjbGFzcz0iY29tbWVudCI+PC9pbWc+YAogICAgICogaW4gdGhlIHZpZXcuCiAgICAgKgogICAgICogRm9yIGNvbnRhaW5lciBlbGVtZW50cywgdGhlIGNvbnZlcnNpb24gaXMgdHdvLXN0ZXAuIFdoaWxlIHRoZSBjb252ZXJ0ZXIgcHJvY2Vzc2VzIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvciBhbmQgcGFzc2VzIGl0CiAgICAgKiB0byBhIGNvbnRhaW5lciBlbGVtZW50LCBpdCBpcyB0aGUgY29udGFpbmVyIGVsZW1lbnQgaW5zdGFuY2UgaXRzZWxmIHRoYXQgYXBwbGllcyB2YWx1ZXMgZnJvbSB0aGUgaGlnaGxpZ2h0IGRlc2NyaXB0b3IuCiAgICAgKiBTbywgaW4gYSBzZW5zZSwgdGhlIGNvbnZlcnRlciB0YWtlcyBjYXJlIG9mIHN0YXRpbmcgd2hhdCBzaG91bGQgYmUgYXBwbGllZCBvbiB3aGF0LCB3aGlsZSB0aGUgZWxlbWVudCBkZWNpZGVzIGhvdyB0byBhcHBseSB0aGF0LgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5tYXJrZXJUb0hpZ2hsaWdodCggeyBtb2RlbDogJ2NvbW1lbnQnLCB2aWV3OiB7IGNsYXNzZXM6ICdjb21tZW50JyB9IH0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkubWFya2VyVG9IaWdobGlnaHQoIHsKICAgICAqCQkJbW9kZWw6ICdjb21tZW50JywKICAgICAqCQkJdmlldzogeyBjbGFzc2VzOiAnY29tbWVudCcgfSwKICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkubWFya2VyVG9IaWdobGlnaHQoIHsKICAgICAqCQkJbW9kZWw6ICdjb21tZW50JywKICAgICAqCQkJdmlldzogKCBkYXRhLCBjb252ZXJzaW9uQXBpICkgPT4gewogICAgICoJCQkJLy8gQXNzdW1pbmcgdGhhdCB0aGUgbWFya2VyIG5hbWUgaXMgaW4gYSBmb3JtIG9mIGNvbW1lbnQ6Y29tbWVudFR5cGU6Y29tbWVudElkLgogICAgICoJCQkJY29uc3QgWyAsIGNvbW1lbnRUeXBlLCBjb21tZW50SWQgXSA9IGRhdGEubWFya2VyTmFtZS5zcGxpdCggJzonICk7CiAgICAgKgogICAgICoJCQkJcmV0dXJuIHsKICAgICAqCQkJCQljbGFzc2VzOiBbICdjb21tZW50JywgJ2NvbW1lbnQtJyArIGNvbW1lbnRUeXBlIF0sCiAgICAgKgkJCQkJYXR0cmlidXRlczogeyAnZGF0YS1jb21tZW50LWlkJzogY29tbWVudElkIH0KICAgICAqCQkJCX07CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgYXMgdGhlIGBjb25maWcudmlld2AgcGFyYW1ldGVyLCBpdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGhpZ2hsaWdodCBkZXNjcmlwdG9yLiBUaGUgZnVuY3Rpb24KICAgICAqIHJlY2VpdmVzIHRoZSBgZGF0YWAgb2JqZWN0IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdENvbnZlcnNpb25BcGkgZG93bmNhc3QgY29udmVyc2lvbiBBUEl9CiAgICAgKiBhcyBhIHBhcmFtZXRlcnMgYW5kIHNob3VsZCByZXR1cm4gYQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+SGlnaGxpZ2h0RGVzY3JpcHRvciBoaWdobGlnaHQgZGVzY3JpcHRvcn0uCiAgICAgKiBUaGUgYGRhdGFgIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwYXNzZWQgZnJvbSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXIjZXZlbnQ6YWRkTWFya2VyfS4KICAgICAqCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqCiAgICAgKiBAbWV0aG9kICNtYXJrZXJUb0hpZ2hsaWdodAogICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLm1vZGVsIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCBtYXJrZXIgKG9yIG1vZGVsIG1hcmtlciBncm91cCkgdG8gY29udmVydC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yfEZ1bmN0aW9ufSBjb25maWcudmlldyBBIGhpZ2hsaWdodCBkZXNjcmlwdG9yCiAgICAgKiB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgaGlnaGxpZ2h0aW5nIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgbW9kZWwgbWFya2VyIGRhdGEgYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdENvbnZlcnNpb25BcGkgZG93bmNhc3QgY29udmVyc2lvbiBBUEl9IGFzIGEgcGFyYW1ldGVycwogICAgICogYW5kIHJldHVybnMgYSBoaWdobGlnaHQgZGVzY3JpcHRvci4KICAgICAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb25maWcuY29udmVydGVyUHJpb3JpdHk9J25vcm1hbCddIENvbnZlcnRlciBwcmlvcml0eS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVyc30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJtYXJrZXJUb0hpZ2hsaWdodCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya2VyVG9IaWdobGlnaHQoY29uZmlnKSB7CiAgICAgIHJldHVybiB0aGlzLmFkZChkb3duY2FzdE1hcmtlclRvSGlnaGxpZ2h0KGNvbmZpZykpOwogICAgfQogICAgLyoqCiAgICAgKiBNb2RlbCBtYXJrZXIgY29udmVydGVyIGZvciBkYXRhIGRvd25jYXN0LgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiBjcmVhdGVzIGEgcmVwcmVzZW50YXRpb24gZm9yIG1vZGVsIG1hcmtlciBib3VuZGFyaWVzIGluIHRoZSB2aWV3OgogICAgICoKICAgICAqICogSWYgdGhlIG1hcmtlciBib3VuZGFyeSBpcyBhdCBhIHBvc2l0aW9uIHdoZXJlIHRleHQgbm9kZXMgYXJlIGFsbG93ZWQsIHRoZW4gYSB2aWV3IGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHRhZyBuYW1lCiAgICAgKiBhbmQgYG5hbWVgIGF0dHJpYnV0ZSBpcyBhZGRlZCBhdCB0aGlzIHBvc2l0aW9uLgogICAgICogKiBJbiBvdGhlciBjYXNlcywgYSBzcGVjaWZpZWQgYXR0cmlidXRlIGlzIHNldCBvbiBhIHZpZXcgZWxlbWVudCB0aGF0IGlzIGJlZm9yZSBvciBhZnRlciB0aGUgbWFya2VyIGJvdW5kYXJ5LgogICAgICoKICAgICAqIFR5cGljYWxseSwgbWFya2VyIG5hbWVzIHVzZSB0aGUgYGdyb3VwOnVuaXF1ZUlkOm90aGVyRGF0YWAgY29udmVudGlvbi4gRm9yIGV4YW1wbGU6IGBjb21tZW50OmUzNHpmazlrMm40NTlkZjUzc2psMzQ6engzMmNgLgogICAgICogVGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBjb252ZXJzaW9uIGlzIHRoYXQgdGhlIGZpcnN0IHBhcnQgaXMgdGhlIGBncm91cGAgcGFydCBhbmQgdGhlIHJlc3Qgb2YKICAgICAqIHRoZSBtYXJrZXIgbmFtZSBiZWNvbWVzIHRoZSBgbmFtZWAgcGFydC4KICAgICAqCiAgICAgKiBUYWcgYW5kIGF0dHJpYnV0ZSBuYW1lcyBhbmQgdmFsdWVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgbWFya2VyIG5hbWU6CiAgICAgKgogICAgICogKiBUZW1wbGF0ZXMgZm9yIGF0dHJpYnV0ZXMgYXJlIGBkYXRhLVtncm91cF0tc3RhcnQtYmVmb3JlPSJbbmFtZV0iYCwgYGRhdGEtW2dyb3VwXS1zdGFydC1hZnRlcj0iW25hbWVdImAsCiAgICAgKiBgZGF0YS1bZ3JvdXBdLWVuZC1iZWZvcmU9IltuYW1lXSJgIGFuZCBgZGF0YS1bZ3JvdXBdLWVuZC1hZnRlcj0iW25hbWVdImAuCiAgICAgKiAqIFRlbXBsYXRlcyBmb3IgdmlldyBlbGVtZW50cyBhcmUgYDxbZ3JvdXBdLXN0YXJ0IG5hbWU9IltuYW1lXSI+YCBhbmQgYDxbZ3JvdXBdLWVuZCBuYW1lPSJbbmFtZV0iPmAuCiAgICAgKgogICAgICogQXR0cmlidXRlcyBtYXJrIHdoZXRoZXIgdGhlIGdpdmVuIG1hcmtlcidzIHN0YXJ0IG9yIGVuZCBib3VuZGFyeSBpcyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGdpdmVuIGVsZW1lbnQuCiAgICAgKiBBdHRyaWJ1dGVzIGBkYXRhLVtncm91cF0tc3RhcnQtYmVmb3JlYCBhbmQgYGRhdGEtW2dyb3VwXS1lbmQtYWZ0ZXJgIGFyZSBmYXZvcmVkLgogICAgICogVGhlIG90aGVyIHR3byBhcmUgdXNlZCB3aGVuIHRoZSBmb3JtZXIgdHdvIGNhbm5vdCBiZSB1c2VkLgogICAgICoKICAgICAqIFRoZSBjb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24gY2FuIHRha2UgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZ2VuZXJhdGUgZGlmZmVyZW50IGdyb3VwIGFuZCBuYW1lIHBhcnRzLgogICAgICogSWYgc3VjaCBmdW5jdGlvbiBpcyBzZXQgYXMgdGhlIGBjb25maWcudmlld2AgcGFyYW1ldGVyLCBpdCBpcyBwYXNzZWQgYSBtYXJrZXIgbmFtZSBhbmQgaXQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIG9iamVjdCB3aXRoIHR3bwogICAgICogcHJvcGVydGllczogYGdyb3VwYCBhbmQgYG5hbWVgLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCB0aGUgY29udmVyc2lvbiB3aWxsIG5vdCB0YWtlIHBsYWNlLgogICAgICoKICAgICAqIEJhc2ljIHVzYWdlOgogICAgICoKICAgICAqCQkvLyBVc2luZyB0aGUgZGVmYXVsdCBjb252ZXJzaW9uLgogICAgICoJCS8vIEluIHRoaXMgY2FzZSwgYWxsIG1hcmtlcnMgd2hvc2UgbmFtZSBzdGFydHMgd2l0aCAnY29tbWVudDonIHdpbGwgYmUgY29udmVydGVkLgogICAgICoJCS8vIFRoZSBgZ3JvdXBgIHBhcmFtZXRlciB3aWxsIGJlIHNldCB0byBgY29tbWVudGAuCiAgICAgKgkJLy8gVGhlIGBuYW1lYCBwYXJhbWV0ZXIgd2lsbCBiZSB0aGUgcmVzdCBvZiB0aGUgbWFya2VyIG5hbWUgKHdpdGhvdXQgYDpgKS4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkYXRhRG93bmNhc3QnICkubWFya2VyVG9EYXRhKCB7CiAgICAgKgkJCW1vZGVsOiAnY29tbWVudCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQW4gZXhhbXBsZSBvZiBhIHZpZXcgdGhhdCBtYXkgYmUgZ2VuZXJhdGVkIGJ5IHRoaXMgY29udmVyc2lvbiAoYXNzdW1pbmcgYSBtYXJrZXIgd2l0aCB0aGUgbmFtZSBgY29tbWVudDpjb21tZW50SWQ6dWlkYCBtYXJrZWQKICAgICAqIGJ5IGBbXWApOgogICAgICoKICAgICAqCQkvLyBNb2RlbDoKICAgICAqCQk8cGFyYWdyYXBoPkZvb1tiYXI8L3BhcmFncmFwaD4KICAgICAqCQk8aW1hZ2Ugc3JjPSJhYmMuanBnIj48L2ltYWdlPl0KICAgICAqCiAgICAgKgkJLy8gVmlldzoKICAgICAqCQk8cD5Gb288Y29tbWVudC1zdGFydCBuYW1lPSJjb21tZW50SWQ6dWlkIj48L2NvbW1lbnQtc3RhcnQ+YmFyPC9wPgogICAgICoJCTxmaWd1cmUgZGF0YS1jb21tZW50LWVuZC1hZnRlcj0iY29tbWVudElkOnVpZCIgY2xhc3M9ImltYWdlIj48aW1nIHNyYz0iYWJjLmpwZyIgLz48L2ZpZ3VyZT4KICAgICAqCiAgICAgKiBJbiB0aGUgZXhhbXBsZSBhYm92ZSwgdGhlIGNvbW1lbnQgc3RhcnRzIGJlZm9yZSAiYmFyIiBhbmQgZW5kcyBhZnRlciB0aGUgaW1hZ2UuCiAgICAgKgogICAgICogSWYgdGhlIGBuYW1lYCBwYXJ0IGlzIGVtcHR5LCB0aGUgZm9sbG93aW5nIHZpZXcgbWF5IGJlIGdlbmVyYXRlZDoKICAgICAqCiAgICAgKgkJPHA+Rm9vIDxteU1hcmtlci1zdGFydD48L215TWFya2VyLXN0YXJ0PmJhcjwvcD4KICAgICAqCQk8ZmlndXJlIGRhdGEtbXlNYXJrZXItZW5kLWFmdGVyPSIiIGNsYXNzPSJpbWFnZSI+PGltZyBzcmM9ImFiYy5qcGciIC8+PC9maWd1cmU+CiAgICAgKgogICAgICogKipOb3RlOioqIEEgc2l0dWF0aW9uIHdoZXJlIHNvbWUgbWFya2VycyBoYXZlIHRoZSBgbmFtZWAgcGFydCBhbmQgc29tZSBkbyBub3QgaGF2ZSBpdCBpcyBpbmNvcnJlY3QgYW5kIHNob3VsZCBiZSBhdm9pZGVkLgogICAgICoKICAgICAqIEV4YW1wbGVzIHdoZXJlIGBkYXRhLWdyb3VwLXN0YXJ0LWFmdGVyYCBhbmQgYGRhdGEtZ3JvdXAtZW5kLWJlZm9yZWAgYXJlIHVzZWQ6CiAgICAgKgogICAgICoJCS8vIE1vZGVsOgogICAgICoJCTxibG9ja1F1b3RlPltdPHBhcmFncmFwaD5Gb288L3BhcmFncmFwaD48L2Jsb2NrUXVvdGU+CiAgICAgKgogICAgICogCQkvLyBWaWV3OgogICAgICoJCTxibG9ja3F1b3RlPjxwIGRhdGEtZ3JvdXAtZW5kLWJlZm9yZT0ibmFtZSIgZGF0YS1ncm91cC1zdGFydC1iZWZvcmU9Im5hbWUiPkZvbzwvcD48L2Jsb2NrcXVvdGU+CiAgICAgKgogICAgICogU2ltaWxhcmx5LCB3aGVuIGEgbWFya2VyIGlzIGNvbGxhcHNlZCBhZnRlciB0aGUgbGFzdCBlbGVtZW50OgogICAgICoKICAgICAqCQkvLyBNb2RlbDoKICAgICAqCQk8YmxvY2tRdW90ZT48cGFyYWdyYXBoPkZvbzwvcGFyYWdyYXBoPltdPC9ibG9ja1F1b3RlPgogICAgICoKICAgICAqCQkvLyBWaWV3OgogICAgICoJCTxibG9ja3F1b3RlPjxwIGRhdGEtZ3JvdXAtZW5kLWFmdGVyPSJuYW1lIiBkYXRhLWdyb3VwLXN0YXJ0LWFmdGVyPSJuYW1lIj5Gb288L3A+PC9ibG9ja3F1b3RlPgogICAgICoKICAgICAqIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIG1hcmtlcnMgZnJvbSB0aGUgc2FtZSBncm91cCBzdG9yZWQgaW4gdGhlIHNhbWUgYXR0cmlidXRlIG9mIHRoZSBzYW1lIGVsZW1lbnQsIHRoZWlyCiAgICAgKiBuYW1lIHBhcnRzIGFyZSBwdXQgdG9nZXRoZXIgaW4gdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgZm9yIGV4YW1wbGU6IGBkYXRhLWdyb3VwLXN0YXJ0LWJlZm9yZT0ibmFtZTEsbmFtZTIsbmFtZTMiYC4KICAgICAqCiAgICAgKiBPdGhlciBleGFtcGxlcyBvZiB1c2FnZToKICAgICAqCiAgICAgKgkJLy8gVXNpbmcgYSBjdXN0b20gZnVuY3Rpb24gd2hpY2ggaXMgdGhlIHNhbWUgYXMgdGhlIGRlZmF1bHQgY29udmVyc2lvbjoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkYXRhRG93bmNhc3QnICkubWFya2VyVG9EYXRhKCB7CiAgICAgKgkJCW1vZGVsOiAnY29tbWVudCcKICAgICAqCQkJdmlldzogbWFya2VyTmFtZSA9PiAoIHsKICAgICAqCQkJCWdyb3VwOiAnY29tbWVudCcsCiAgICAgKgkJCQluYW1lOiBtYXJrZXJOYW1lLnN1YnN0ciggOCApIC8vIFJlbW92ZXMgJ2NvbW1lbnQ6JyBwYXJ0LgogICAgICoJCQl9ICkKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIFVzaW5nIHRoZSBjb252ZXJ0ZXIgcHJpb3JpdHk6CiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZGF0YURvd25jYXN0JyApLm1hcmtlclRvRGF0YSggewogICAgICoJCQltb2RlbDogJ2NvbW1lbnQnCiAgICAgKgkJCXZpZXc6IG1hcmtlck5hbWUgPT4gKCB7CiAgICAgKgkJCQlncm91cDogJ2NvbW1lbnQnLAogICAgICoJCQkJbmFtZTogbWFya2VyTmFtZS5zdWJzdHIoIDggKSAvLyBSZW1vdmVzICdjb21tZW50OicgcGFydC4KICAgICAqCQkJfSApLAogICAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqIFRoaXMga2luZCBvZiBjb252ZXJzaW9uIGlzIHVzZWZ1bCBmb3Igc2F2aW5nIGRhdGEgaW50byB0aGUgZGF0YWJhc2UsIHNvIGl0IHNob3VsZCBiZSB1c2VkIGluIHRoZSBkYXRhIGNvbnZlcnNpb24gcGlwZWxpbmUuCiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjbWFya2VyVG9EYXRhCiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubW9kZWwgVGhlIG5hbWUgb2YgdGhlIG1vZGVsIG1hcmtlciAob3IgbW9kZWwgbWFya2VyIGdyb3VwKSB0byBjb252ZXJ0LgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy52aWV3XSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIG1vZGVsIG1hcmtlciBuYW1lIGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpIGRvd25jYXN0IGNvbnZlcnNpb24gQVBJfSBhcyBhIHBhcmFtZXRlcnMKICAgICAqIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBgZ3JvdXBgIGFuZCBgbmFtZWAgcHJvcGVydGllcy4KICAgICAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb25maWcuY29udmVydGVyUHJpb3JpdHk9J25vcm1hbCddIENvbnZlcnRlciBwcmlvcml0eS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVyc30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJtYXJrZXJUb0RhdGEiLAogICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtlclRvRGF0YShjb25maWcpIHsKICAgICAgcmV0dXJuIHRoaXMuYWRkKGRvd25jYXN0TWFya2VyVG9EYXRhKGNvbmZpZykpOwogICAgfQogIH1dKTsKCiAgcmV0dXJuIERvd25jYXN0SGVscGVyczsKfShDb252ZXJzaW9uSGVscGVycyk7Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGRlZmF1bHQgZG93bmNhc3QgY29udmVydGVyIGZvciB0ZXh0IGluc2VydGlvbiBjaGFuZ2VzLgogKgogKiBUaGUgY29udmVydGVyIGF1dG9tYXRpY2FsbHkgY29uc3VtZXMgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgZnJvbSB0aGUgY29uc3VtYWJsZXMgbGlzdCBhbmQgc3RvcHMgdGhlIGV2ZW50IChzZWUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfSkuCiAqCiAqCQltb2RlbERpc3BhdGNoZXIub24oICdpbnNlcnQ6JHRleHQnLCBpbnNlcnRUZXh0KCkgKTsKICoKICogQHJldHVybnMge0Z1bmN0aW9ufSBJbnNlcnQgdGV4dCBldmVudCBjb252ZXJ0ZXIuCiAqLwoKCmV4cG9ydCB7IERvd25jYXN0SGVscGVycyBhcyBkZWZhdWx0IH07CmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRUZXh0KCkgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEuaXRlbSwgJ2luc2VydCcpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOwogICAgdmFyIHZpZXdQb3NpdGlvbiA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1Bvc2l0aW9uKGRhdGEucmFuZ2Uuc3RhcnQpOwogICAgdmFyIHZpZXdUZXh0ID0gdmlld1dyaXRlci5jcmVhdGVUZXh0KGRhdGEuaXRlbS5kYXRhKTsKICAgIHZpZXdXcml0ZXIuaW5zZXJ0KHZpZXdQb3NpdGlvbiwgdmlld1RleHQpOwogIH07Cn0KLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgZGVmYXVsdCBkb3duY2FzdCBjb252ZXJ0ZXIgZm9yIG5vZGUgcmVtb3ZlIGNoYW5nZXMuCiAqCiAqCQltb2RlbERpc3BhdGNoZXIub24oICdyZW1vdmUnLCByZW1vdmUoKSApOwogKgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJlbW92ZSBldmVudCBjb252ZXJ0ZXIuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZSgpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgLy8gRmluZCB2aWV3IHJhbmdlIHN0YXJ0IHBvc2l0aW9uIGJ5IG1hcHBpbmcgbW9kZWwgcG9zaXRpb24gYXQgd2hpY2ggdGhlIHJlbW92ZSBoYXBwZW5lZC4KICAgIHZhciB2aWV3U3RhcnQgPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b1ZpZXdQb3NpdGlvbihkYXRhLnBvc2l0aW9uKTsKICAgIHZhciBtb2RlbEVuZCA9IGRhdGEucG9zaXRpb24uZ2V0U2hpZnRlZEJ5KGRhdGEubGVuZ3RoKTsKICAgIHZhciB2aWV3RW5kID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UG9zaXRpb24obW9kZWxFbmQsIHsKICAgICAgaXNQaGFudG9tOiB0cnVlCiAgICB9KTsKICAgIHZhciB2aWV3UmFuZ2UgPSBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVSYW5nZSh2aWV3U3RhcnQsIHZpZXdFbmQpOyAvLyBUcmltIHRoZSByYW5nZSB0byByZW1vdmUgaW4gY2FzZSBzb21lIFVJIGVsZW1lbnRzIGFyZSBvbiB0aGUgdmlldyByYW5nZSBib3VuZGFyaWVzLgoKICAgIHZhciByZW1vdmVkID0gY29udmVyc2lvbkFwaS53cml0ZXIucmVtb3ZlKHZpZXdSYW5nZS5nZXRUcmltbWVkKCkpOyAvLyBBZnRlciB0aGUgcmFuZ2UgaXMgcmVtb3ZlZCwgdW5iaW5kIGFsbCB2aWV3IGVsZW1lbnRzIGZyb20gdGhlIG1vZGVsLgogICAgLy8gUmFuZ2UgaW5zaWRlIHZpZXcgZG9jdW1lbnQgZnJhZ21lbnQgaXMgdXNlZCB0byB1bmJpbmQgZGVlcGx5LgoKICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVSYW5nZUluKHJlbW92ZWQpLmdldEl0ZW1zKCkpLAogICAgICAgIF9zdGVwOwoKICAgIHRyeSB7CiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7CiAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7CiAgICAgICAgY29udmVyc2lvbkFwaS5tYXBwZXIudW5iaW5kVmlld0VsZW1lbnQoY2hpbGQpOwogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2l0ZXJhdG9yLmUoZXJyKTsKICAgIH0gZmluYWxseSB7CiAgICAgIF9pdGVyYXRvci5mKCk7CiAgICB9CiAgfTsKfQovKioKICogQ3JlYXRlcyBhIGA8c3Bhbj5gIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IHZpZXcgYXR0cmlidXRlIGVsZW1lbnR9IGZyb20gdGhlIGluZm9ybWF0aW9uCiAqIHByb3ZpZGVkIGJ5IHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yIGhpZ2hsaWdodCBkZXNjcmlwdG9yfSBvYmplY3QuIElmIGEgcHJpb3JpdHkKICogaXMgbm90IHByb3ZpZGVkIGluIHRoZSBkZXNjcmlwdG9yLCB0aGUgZGVmYXVsdCBwcmlvcml0eSB3aWxsIGJlIHVzZWQuCiAqCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyfSB3cml0ZXIKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkhpZ2hsaWdodERlc2NyaXB0b3J9IGRlc2NyaXB0b3IKICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9CiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXdFbGVtZW50RnJvbUhpZ2hsaWdodERlc2NyaXB0b3Iod3JpdGVyLCBkZXNjcmlwdG9yKSB7CiAgdmFyIHZpZXdFbGVtZW50ID0gd3JpdGVyLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoJ3NwYW4nLCBkZXNjcmlwdG9yLmF0dHJpYnV0ZXMpOwoKICBpZiAoZGVzY3JpcHRvci5jbGFzc2VzKSB7CiAgICB2aWV3RWxlbWVudC5fYWRkQ2xhc3MoZGVzY3JpcHRvci5jbGFzc2VzKTsKICB9CgogIGlmIChkZXNjcmlwdG9yLnByaW9yaXR5KSB7CiAgICB2aWV3RWxlbWVudC5fcHJpb3JpdHkgPSBkZXNjcmlwdG9yLnByaW9yaXR5OwogIH0KCiAgdmlld0VsZW1lbnQuX2lkID0gZGVzY3JpcHRvci5pZDsKICByZXR1cm4gdmlld0VsZW1lbnQ7Cn0KLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgY29udmVydGVyIHdoaWNoIGNvbnZlcnRzIGEgbm9uLWNvbGxhcHNlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uIG1vZGVsIHNlbGVjdGlvbn0KICogdG8gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9uIHZpZXcgc2VsZWN0aW9ufS4gVGhlIGNvbnZlcnRlciBjb25zdW1lcyBhcHByb3ByaWF0ZQogKiB2YWx1ZSBmcm9tIHRoZSBgY29uc3VtYWJsZWAgb2JqZWN0IGFuZCBtYXBzIG1vZGVsIHBvc2l0aW9ucyBmcm9tIHRoZSBzZWxlY3Rpb24gdG8gdmlldyBwb3NpdGlvbnMuCiAqCiAqCQltb2RlbERpc3BhdGNoZXIub24oICdzZWxlY3Rpb24nLCBjb252ZXJ0UmFuZ2VTZWxlY3Rpb24oKSApOwogKgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFNlbGVjdGlvbiBjb252ZXJ0ZXIuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSYW5nZVNlbGVjdGlvbigpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIHNlbGVjdGlvbiA9IGRhdGEuc2VsZWN0aW9uOwoKICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGlmICghY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoc2VsZWN0aW9uLCAnc2VsZWN0aW9uJykpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciB2aWV3UmFuZ2VzID0gW107CgogICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzZWxlY3Rpb24uZ2V0UmFuZ2VzKCkpLAogICAgICAgIF9zdGVwMjsKCiAgICB0cnkgewogICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykgewogICAgICAgIHZhciByYW5nZSA9IF9zdGVwMi52YWx1ZTsKICAgICAgICB2YXIgdmlld1JhbmdlID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UmFuZ2UocmFuZ2UpOwogICAgICAgIHZpZXdSYW5nZXMucHVzaCh2aWV3UmFuZ2UpOwogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICB9IGZpbmFsbHkgewogICAgICBfaXRlcmF0b3IyLmYoKTsKICAgIH0KCiAgICBjb252ZXJzaW9uQXBpLndyaXRlci5zZXRTZWxlY3Rpb24odmlld1JhbmdlcywgewogICAgICBiYWNrd2FyZDogc2VsZWN0aW9uLmlzQmFja3dhcmQKICAgIH0pOwogIH07Cn0KLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgY29udmVydGVyIHdoaWNoIGNvbnZlcnRzIGEgY29sbGFwc2VkIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb24gbW9kZWwgc2VsZWN0aW9ufSB0bwogKiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb24gdmlldyBzZWxlY3Rpb259LiBUaGUgY29udmVydGVyIGNvbnN1bWVzIGFwcHJvcHJpYXRlCiAqIHZhbHVlIGZyb20gdGhlIGBjb25zdW1hYmxlYCBvYmplY3QsIG1hcHMgdGhlIG1vZGVsIHNlbGVjdGlvbiBwb3NpdGlvbiB0byB0aGUgdmlldyBwb3NpdGlvbiBhbmQgYnJlYWtzCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50c30gYXQgdGhlIHNlbGVjdGlvbiBwb3NpdGlvbi4KICoKICoJCW1vZGVsRGlzcGF0Y2hlci5vbiggJ3NlbGVjdGlvbicsIGNvbnZlcnRDb2xsYXBzZWRTZWxlY3Rpb24oKSApOwogKgogKiBBbiBleGFtcGxlIG9mIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSBhbmQgYWZ0ZXIgY29udmVydGluZyB0aGUgY29sbGFwc2VkIHNlbGVjdGlvbjoKICoKICoJCSAgIDxwPjxzdHJvbmc+Zl5vbzxzdHJvbmc+YmFyPC9wPgogKgkJLT4gPHA+PHN0cm9uZz5mPC9zdHJvbmc+XjxzdHJvbmc+b288L3N0cm9uZz5iYXI8L3A+CiAqCiAqIEJ5IGJyZWFraW5nIGF0dHJpYnV0ZSBlbGVtZW50cyBsaWtlIGA8c3Ryb25nPmAsIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBjb3JyZWN0IGVsZW1lbnQuIFRoZW4sIHdoZW4gdGhlIHNlbGVjdGlvbiBhdHRyaWJ1dGUgaXMKICogY29udmVydGVkLCBicm9rZW4gYXR0cmlidXRlcyBtaWdodCBiZSBtZXJnZWQgYWdhaW4sIG9yIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgc2VsZWN0aW9uIGlzIG1heSBiZSB3cmFwcGVkCiAqIHdpdGggZGlmZmVyZW50LCBhcHByb3ByaWF0ZSBhdHRyaWJ1dGUgZWxlbWVudHMuCiAqCiAqIFNlZSBhbHNvIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfmNsZWFyQXR0cmlidXRlc30gd2hpY2ggZG9lcyBhIGNsZWFuLXVwCiAqIGJ5IG1lcmdpbmcgYXR0cmlidXRlcy4KICoKICogQHJldHVybnMge0Z1bmN0aW9ufSBTZWxlY3Rpb24gY29udmVydGVyLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Q29sbGFwc2VkU2VsZWN0aW9uKCkgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICB2YXIgc2VsZWN0aW9uID0gZGF0YS5zZWxlY3Rpb247CgogICAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGlmICghY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoc2VsZWN0aW9uLCAnc2VsZWN0aW9uJykpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciB2aWV3V3JpdGVyID0gY29udmVyc2lvbkFwaS53cml0ZXI7CiAgICB2YXIgbW9kZWxQb3NpdGlvbiA9IHNlbGVjdGlvbi5nZXRGaXJzdFBvc2l0aW9uKCk7CiAgICB2YXIgdmlld1Bvc2l0aW9uID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UG9zaXRpb24obW9kZWxQb3NpdGlvbik7CiAgICB2YXIgYnJva2VuUG9zaXRpb24gPSB2aWV3V3JpdGVyLmJyZWFrQXR0cmlidXRlcyh2aWV3UG9zaXRpb24pOwogICAgdmlld1dyaXRlci5zZXRTZWxlY3Rpb24oYnJva2VuUG9zaXRpb24pOwogIH07Cn0KLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgY29udmVydGVyIHdoaWNoIGNsZWFycyBhcnRpZmFjdHMgYWZ0ZXIgdGhlIHByZXZpb3VzCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb24gbW9kZWwgc2VsZWN0aW9ufSBjb252ZXJzaW9uLiBJdCByZW1vdmVzIGFsbCBlbXB0eQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCB2aWV3IGF0dHJpYnV0ZSBlbGVtZW50c30gYW5kIG1lcmdlcyBzaWJsaW5nIGF0dHJpYnV0ZXMgYXQgYWxsIHN0YXJ0IGFuZCBlbmQKICogcG9zaXRpb25zIG9mIGFsbCByYW5nZXMuCiAqCiAqCQkgICA8cD48c3Ryb25nPl48L3N0cm9uZz48L3A+CiAqCQktPiA8cD5ePC9wPgogKgogKgkJICAgPHA+PHN0cm9uZz5mb288L3N0cm9uZz5ePHN0cm9uZz5iYXI8L3N0cm9uZz5iYXI8L3A+CiAqCQktPiA8cD48c3Ryb25nPmZvb15iYXI8c3Ryb25nPmJhcjwvcD4KICoKICoJCSAgIDxwPjxzdHJvbmc+Zm9vPC9zdHJvbmc+PGVtPl48L2VtPjxzdHJvbmc+YmFyPC9zdHJvbmc+YmFyPC9wPgogKgkJLT4gPHA+PHN0cm9uZz5mb29eYmFyPHN0cm9uZz5iYXI8L3A+CiAqCiAqIFRoaXMgbGlzdGVuZXIgc2hvdWxkIGJlIGFzc2lnbmVkIGJlZm9yZSBhbnkgY29udmVydGVyIGZvciB0aGUgbmV3IHNlbGVjdGlvbjoKICoKICoJCW1vZGVsRGlzcGF0Y2hlci5vbiggJ3NlbGVjdGlvbicsIGNsZWFyQXR0cmlidXRlcygpICk7CiAqCiAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35jb252ZXJ0Q29sbGFwc2VkU2VsZWN0aW9ufQogKiB3aGljaCBkb2VzIHRoZSBvcHBvc2l0ZSBieSBicmVha2luZyBhdHRyaWJ1dGVzIGluIHRoZSBzZWxlY3Rpb24gcG9zaXRpb24uCiAqCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gU2VsZWN0aW9uIGNvbnZlcnRlci4KICovCgpleHBvcnQgZnVuY3Rpb24gY2xlYXJBdHRyaWJ1dGVzKCkgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICB2YXIgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOwogICAgdmFyIHZpZXdTZWxlY3Rpb24gPSB2aWV3V3JpdGVyLmRvY3VtZW50LnNlbGVjdGlvbjsKCiAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHZpZXdTZWxlY3Rpb24uZ2V0UmFuZ2VzKCkpLAogICAgICAgIF9zdGVwMzsKCiAgICB0cnkgewogICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykgewogICAgICAgIHZhciByYW5nZSA9IF9zdGVwMy52YWx1ZTsKCiAgICAgICAgLy8gTm90IGNvbGxhcHNlZCBzZWxlY3Rpb24gc2hvdWxkIG5vdCBoYXZlIGFydGlmYWN0cy4KICAgICAgICBpZiAocmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgICAgIC8vIFBvc2l0aW9uIG1pZ2h0IGJlIGluIHRoZSBub2RlIHJlbW92ZWQgYnkgdGhlIHZpZXcgd3JpdGVyLgogICAgICAgICAgaWYgKHJhbmdlLmVuZC5wYXJlbnQuaXNBdHRhY2hlZCgpKSB7CiAgICAgICAgICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLm1lcmdlQXR0cmlidXRlcyhyYW5nZS5zdGFydCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2l0ZXJhdG9yMy5lKGVycik7CiAgICB9IGZpbmFsbHkgewogICAgICBfaXRlcmF0b3IzLmYoKTsKICAgIH0KCiAgICB2aWV3V3JpdGVyLnNldFNlbGVjdGlvbihudWxsKTsKICB9Owp9Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciB3aGljaCBjb252ZXJ0cyBzZXQvY2hhbmdlL3JlbW92ZSBhdHRyaWJ1dGUgY2hhbmdlcyBmcm9tIHRoZSBtb2RlbCB0byB0aGUgdmlldy4KICogSXQgY2FuIGFsc28gYmUgdXNlZCB0byBjb252ZXJ0IHNlbGVjdGlvbiBhdHRyaWJ1dGVzLiBJbiB0aGF0IGNhc2UsIGFuIGVtcHR5IGF0dHJpYnV0ZSBlbGVtZW50IHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlCiAqIHNlbGVjdGlvbiB3aWxsIGJlIHB1dCBpbnNpZGUgaXQuCiAqCiAqIEF0dHJpYnV0ZXMgZnJvbSB0aGUgbW9kZWwgYXJlIGNvbnZlcnRlZCB0byBhIHZpZXcgZWxlbWVudCB0aGF0IHdpbGwgYmUgd3JhcHBpbmcgdGhlc2UgdmlldyBub2RlcyB0aGF0IGFyZSBib3VuZCB0bwogKiBtb2RlbCBlbGVtZW50cyBoYXZpbmcgdGhlIGdpdmVuIGF0dHJpYnV0ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGF0dHJpYnV0ZXMgbGlrZSBgYm9sZGAgdGhhdCBtYXkgYmUgc2V0IG9uIHRleHQgbm9kZXMgaW4gdGhlIG1vZGVsCiAqIGJ1dCBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gZWxlbWVudCBpbiB0aGUgdmlldzoKICoKICoJCVtwYXJhZ3JhcGhdICAgICAgICAgICAgICBNT0RFTCA9PT09PiBWSUVXICAgICAgICA8cD4KICoJCQl8LSBhIHtib2xkOiB0cnVlfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0gPGI+CiAqCQkJfC0gYiB7Ym9sZDogdHJ1ZX0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICB8LSBhYgogKgkJCXwtIGMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8LSBjCiAqCiAqIFBhc3NlZCBgRnVuY3Rpb25gIHdpbGwgYmUgcHJvdmlkZWQgd2l0aCB0aGUgYXR0cmlidXRlIHZhbHVlIGFuZCB0aGVuIGFsbCB0aGUgcGFyYW1ldGVycyBvZiB0aGUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyI2V2ZW50OmF0dHJpYnV0ZSBgYXR0cmlidXRlYCBldmVudH0uCiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIGZ1bmN0aW9uIHJldHVybnMgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9LgogKiBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiB3aWxsIGJlIHRoZSB3cmFwcGluZyBlbGVtZW50LgogKiBXaGVuIHRoZSBwcm92aWRlZCBgRnVuY3Rpb25gIGRvZXMgbm90IHJldHVybiBhbnkgZWxlbWVudCwgbm8gY29udmVyc2lvbiB3aWxsIHRha2UgcGxhY2UuCiAqCiAqIFRoZSBjb252ZXJ0ZXIgYXV0b21hdGljYWxseSBjb25zdW1lcyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmcm9tIHRoZSBjb25zdW1hYmxlcyBsaXN0IGFuZCBzdG9wcyB0aGUgZXZlbnQgKHNlZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ9KS4KICoKICoJCW1vZGVsRGlzcGF0Y2hlci5vbiggJ2F0dHJpYnV0ZTpib2xkJywgd3JhcCggKCBtb2RlbEF0dHJpYnV0ZVZhbHVlLCB7IHdyaXRlciB9ICkgPT4gewogKgkJCXJldHVybiB3cml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCggJ3N0cm9uZycgKTsKICoJCX0gKTsKICoKICogQHByb3RlY3RlZAogKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbGVtZW50Q3JlYXRvciBGdW5jdGlvbiByZXR1cm5pbmcgYSB2aWV3IGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHdyYXBwaW5nLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFNldC9jaGFuZ2UgYXR0cmlidXRlIGNvbnZlcnRlci4KICovCgpleHBvcnQgZnVuY3Rpb24gd3JhcChlbGVtZW50Q3JlYXRvcikgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICAvLyBSZWNyZWF0ZSBjdXJyZW50IHdyYXBwaW5nIG5vZGUuIEl0IHdpbGwgYmUgdXNlZCB0byB1bndyYXAgdmlldyByYW5nZSBpZiB0aGUgYXR0cmlidXRlIHZhbHVlIGhhcyBjaGFuZ2VkCiAgICAvLyBvciB0aGUgYXR0cmlidXRlIHdhcyByZW1vdmVkLgogICAgdmFyIG9sZFZpZXdFbGVtZW50ID0gZWxlbWVudENyZWF0b3IoZGF0YS5hdHRyaWJ1dGVPbGRWYWx1ZSwgY29udmVyc2lvbkFwaSk7IC8vIENyZWF0ZSBub2RlIHRvIHdyYXAgd2l0aC4KCiAgICB2YXIgbmV3Vmlld0VsZW1lbnQgPSBlbGVtZW50Q3JlYXRvcihkYXRhLmF0dHJpYnV0ZU5ld1ZhbHVlLCBjb252ZXJzaW9uQXBpKTsKCiAgICBpZiAoIW9sZFZpZXdFbGVtZW50ICYmICFuZXdWaWV3RWxlbWVudCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLml0ZW0sIGV2dC5uYW1lKSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIHZpZXdXcml0ZXIgPSBjb252ZXJzaW9uQXBpLndyaXRlcjsKICAgIHZhciB2aWV3U2VsZWN0aW9uID0gdmlld1dyaXRlci5kb2N1bWVudC5zZWxlY3Rpb247CgogICAgaWYgKGRhdGEuaXRlbSBpbnN0YW5jZW9mIE1vZGVsU2VsZWN0aW9uIHx8IGRhdGEuaXRlbSBpbnN0YW5jZW9mIERvY3VtZW50U2VsZWN0aW9uKSB7CiAgICAgIC8vIFNlbGVjdGlvbiBhdHRyaWJ1dGUgY29udmVyc2lvbi4KICAgICAgdmlld1dyaXRlci53cmFwKHZpZXdTZWxlY3Rpb24uZ2V0Rmlyc3RSYW5nZSgpLCBuZXdWaWV3RWxlbWVudCk7CiAgICB9IGVsc2UgewogICAgICAvLyBOb2RlIGF0dHJpYnV0ZSBjb252ZXJzaW9uLgogICAgICB2YXIgdmlld1JhbmdlID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UmFuZ2UoZGF0YS5yYW5nZSk7IC8vIEZpcnN0LCB1bndyYXAgdGhlIHJhbmdlIGZyb20gY3VycmVudCB3cmFwcGVyLgoKICAgICAgaWYgKGRhdGEuYXR0cmlidXRlT2xkVmFsdWUgIT09IG51bGwgJiYgb2xkVmlld0VsZW1lbnQpIHsKICAgICAgICB2aWV3UmFuZ2UgPSB2aWV3V3JpdGVyLnVud3JhcCh2aWV3UmFuZ2UsIG9sZFZpZXdFbGVtZW50KTsKICAgICAgfQoKICAgICAgaWYgKGRhdGEuYXR0cmlidXRlTmV3VmFsdWUgIT09IG51bGwgJiYgbmV3Vmlld0VsZW1lbnQpIHsKICAgICAgICB2aWV3V3JpdGVyLndyYXAodmlld1JhbmdlLCBuZXdWaWV3RWxlbWVudCk7CiAgICAgIH0KICAgIH0KICB9Owp9Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciB3aGljaCBjb252ZXJ0cyBub2RlIGluc2VydGlvbiBjaGFuZ2VzIGZyb20gdGhlIG1vZGVsIHRvIHRoZSB2aWV3LgogKiBUaGUgZnVuY3Rpb24gcGFzc2VkIHdpbGwgYmUgcHJvdmlkZWQgd2l0aCBhbGwgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGRpc3BhdGNoZXIncwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXIjZXZlbnQ6aW5zZXJ0IGBpbnNlcnRgIGV2ZW50fS4KICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgZnVuY3Rpb24gcmV0dXJucyBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0uCiAqIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW5zZXJ0ZWQgaW50byB0aGUgdmlldy4KICoKICogVGhlIGNvbnZlcnRlciBhdXRvbWF0aWNhbGx5IGNvbnN1bWVzIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZyb20gdGhlIGNvbnN1bWFibGVzIGxpc3QsIHN0b3BzIHRoZSBldmVudCAoc2VlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcn0pIGFuZCBiaW5kcyB0aGUgbW9kZWwgYW5kIHZpZXcgZWxlbWVudHMuCiAqCiAqCQlkb3duY2FzdERpc3BhdGNoZXIub24oCiAqCQkJJ2luc2VydDpteUVsZW0nLAogKgkJCWluc2VydEVsZW1lbnQoICggbW9kZWxJdGVtLCB7IHdyaXRlciB9ICkgPT4gewogKgkJCQljb25zdCB0ZXh0ID0gd3JpdGVyLmNyZWF0ZVRleHQoICdteVRleHQnICk7CiAqCQkJCWNvbnN0IG15RWxlbSA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAnbXlFbGVtJywgeyBteUF0dHI6ICdteS0nICsgbW9kZWxJdGVtLmdldEF0dHJpYnV0ZSggJ215QXR0cicgKSB9LCB0ZXh0ICk7CiAqCiAqCQkJCS8vIERvIHNvbWV0aGluZyBmYW5jeSB3aXRoIGBteUVsZW1gIHVzaW5nIGBtb2RlbEl0ZW1gIG9yIG90aGVyIHBhcmFtZXRlcnMuCiAqCiAqCQkJCXJldHVybiBteUVsZW07CiAqCQkJfQogKgkJKSApOwogKgogKiBAcHJvdGVjdGVkCiAqIEBwYXJhbSB7RnVuY3Rpb259IGVsZW1lbnRDcmVhdG9yIEZ1bmN0aW9uIHJldHVybmluZyBhIHZpZXcgZWxlbWVudCwgd2hpY2ggd2lsbCBiZSBpbnNlcnRlZC4KICogQHJldHVybnMge0Z1bmN0aW9ufSBJbnNlcnQgZWxlbWVudCBldmVudCBjb252ZXJ0ZXIuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGluc2VydEVsZW1lbnQoZWxlbWVudENyZWF0b3IpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIHZpZXdFbGVtZW50ID0gZWxlbWVudENyZWF0b3IoZGF0YS5pdGVtLCBjb252ZXJzaW9uQXBpKTsKCiAgICBpZiAoIXZpZXdFbGVtZW50KSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEuaXRlbSwgJ2luc2VydCcpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgdmlld1Bvc2l0aW9uID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UG9zaXRpb24oZGF0YS5yYW5nZS5zdGFydCk7CiAgICBjb252ZXJzaW9uQXBpLm1hcHBlci5iaW5kRWxlbWVudHMoZGF0YS5pdGVtLCB2aWV3RWxlbWVudCk7CiAgICBjb252ZXJzaW9uQXBpLndyaXRlci5pbnNlcnQodmlld1Bvc2l0aW9uLCB2aWV3RWxlbWVudCk7CiAgfTsKfQovKioKICogRnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBjb252ZXJ0ZXIgd2hpY2ggY29udmVydHMgbWFya2VyIGFkZGluZyBjaGFuZ2UgdG8gdGhlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCB2aWV3IFVJIGVsZW1lbnR9LgogKgogKiBUaGUgdmlldyBVSSBlbGVtZW50IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdmlldyBkZXBlbmRzIG9uIHRoZSBwYXNzZWQgcGFyYW1ldGVyLiBTZWUge0BsaW5rIH5pbnNlcnRFbGVtZW50fS4KICogSW4gY2FzZSBvZiBhIG5vbi1jb2xsYXBzZWQgcmFuZ2UsIHRoZSBVSSBlbGVtZW50IHdpbGwgbm90IHdyYXAgbm9kZXMgYnV0IHNlcGFyYXRlIGVsZW1lbnRzIHdpbGwgYmUgcGxhY2VkIGF0IHRoZSBiZWdpbm5pbmcKICogYW5kIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLgogKgogKiBUaGlzIGNvbnZlcnRlciBiaW5kcyBjcmVhdGVkIFVJIGVsZW1lbnRzIHdpdGggdGhlIG1hcmtlciBuYW1lIHVzaW5nIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciNiaW5kRWxlbWVudFRvTWFya2VyfS4KICoKICogQHByb3RlY3RlZAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fEZ1bmN0aW9ufSBlbGVtZW50Q3JlYXRvciBBIHZpZXcgVUkgZWxlbWVudCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdmlldyBlbGVtZW50CiAqIHRoYXQgd2lsbCBiZSBpbnNlcnRlZC4KICogQHJldHVybnMge0Z1bmN0aW9ufSBJbnNlcnQgZWxlbWVudCBldmVudCBjb252ZXJ0ZXIuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGluc2VydFVJRWxlbWVudChlbGVtZW50Q3JlYXRvcikgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICAvLyBDcmVhdGUgdHdvIHZpZXcgZWxlbWVudHMuIE9uZSB3aWxsIGJlIGluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgbWFya2VyLCBvbmUgYXQgdGhlIGVuZC4KICAgIC8vIElmIG1hcmtlciBpcyBjb2xsYXBzZWQsIG9ubHkgIm9wZW5pbmciIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZC4KICAgIGRhdGEuaXNPcGVuaW5nID0gdHJ1ZTsKICAgIHZhciB2aWV3U3RhcnRFbGVtZW50ID0gZWxlbWVudENyZWF0b3IoZGF0YSwgY29udmVyc2lvbkFwaSk7CiAgICBkYXRhLmlzT3BlbmluZyA9IGZhbHNlOwogICAgdmFyIHZpZXdFbmRFbGVtZW50ID0gZWxlbWVudENyZWF0b3IoZGF0YSwgY29udmVyc2lvbkFwaSk7CgogICAgaWYgKCF2aWV3U3RhcnRFbGVtZW50IHx8ICF2aWV3RW5kRWxlbWVudCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIG1hcmtlclJhbmdlID0gZGF0YS5tYXJrZXJSYW5nZTsgLy8gTWFya2VyIHRoYXQgaXMgY29sbGFwc2VkIGhhcyBjb25zdW1hYmxlIGJ1aWxkIGRpZmZlcmVudGx5IHRoYXQgbm9uLWNvbGxhcHNlZCBvbmUuCiAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgYGFkZE1hcmtlcmAgZXZlbnQgZGVzY3JpcHRpb24uCiAgICAvLyBJZiBtYXJrZXIncyByYW5nZSBpcyBjb2xsYXBzZWQgLSBjaGVjayBpZiBpdCBjYW4gYmUgY29uc3VtZWQuCgogICAgaWYgKG1hcmtlclJhbmdlLmlzQ29sbGFwc2VkICYmICFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShtYXJrZXJSYW5nZSwgZXZ0Lm5hbWUpKSB7CiAgICAgIHJldHVybjsKICAgIH0gLy8gSWYgbWFya2VyJ3MgcmFuZ2UgaXMgbm90IGNvbGxhcHNlZCAtIGNvbnN1bWUgYWxsIGl0ZW1zIGluc2lkZS4KCgogICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihtYXJrZXJSYW5nZSksCiAgICAgICAgX3N0ZXA0OwoKICAgIHRyeSB7CiAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7CiAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXA0LnZhbHVlOwoKICAgICAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKHZhbHVlLml0ZW0sIGV2dC5uYW1lKSkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9pdGVyYXRvcjQuZShlcnIpOwogICAgfSBmaW5hbGx5IHsKICAgICAgX2l0ZXJhdG9yNC5mKCk7CiAgICB9CgogICAgdmFyIG1hcHBlciA9IGNvbnZlcnNpb25BcGkubWFwcGVyOwogICAgdmFyIHZpZXdXcml0ZXIgPSBjb252ZXJzaW9uQXBpLndyaXRlcjsgLy8gQWRkICJvcGVuaW5nIiBlbGVtZW50LgoKICAgIHZpZXdXcml0ZXIuaW5zZXJ0KG1hcHBlci50b1ZpZXdQb3NpdGlvbihtYXJrZXJSYW5nZS5zdGFydCksIHZpZXdTdGFydEVsZW1lbnQpOwogICAgY29udmVyc2lvbkFwaS5tYXBwZXIuYmluZEVsZW1lbnRUb01hcmtlcih2aWV3U3RhcnRFbGVtZW50LCBkYXRhLm1hcmtlck5hbWUpOyAvLyBBZGQgImNsb3NpbmciIGVsZW1lbnQgb25seSBpZiByYW5nZSBpcyBub3QgY29sbGFwc2VkLgoKICAgIGlmICghbWFya2VyUmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgdmlld1dyaXRlci5pbnNlcnQobWFwcGVyLnRvVmlld1Bvc2l0aW9uKG1hcmtlclJhbmdlLmVuZCksIHZpZXdFbmRFbGVtZW50KTsKICAgICAgY29udmVyc2lvbkFwaS5tYXBwZXIuYmluZEVsZW1lbnRUb01hcmtlcih2aWV3RW5kRWxlbWVudCwgZGF0YS5tYXJrZXJOYW1lKTsKICAgIH0KCiAgICBldnQuc3RvcCgpOwogIH07Cn0gLy8gRnVuY3Rpb24gZmFjdG9yeSB0aGF0IHJldHVybnMgYSBkZWZhdWx0IGRvd25jYXN0IGNvbnZlcnRlciBmb3IgcmVtb3ZpbmcgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgVUkgZWxlbWVudH0KLy8gYmFzZWQgb24gbWFya2VyIHJlbW92ZSBjaGFuZ2UuCi8vCi8vIFRoaXMgY29udmVydGVyIHVuYmluZHMgZWxlbWVudHMgZnJvbSB0aGUgbWFya2VyIG5hbWUuCi8vCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gUmVtb3ZlZCBVSSBlbGVtZW50IGNvbnZlcnRlci4KCmZ1bmN0aW9uIHJlbW92ZVVJRWxlbWVudCgpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIGVsZW1lbnRzID0gY29udmVyc2lvbkFwaS5tYXBwZXIubWFya2VyTmFtZVRvRWxlbWVudHMoZGF0YS5tYXJrZXJOYW1lKTsKCiAgICBpZiAoIWVsZW1lbnRzKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGVsZW1lbnRzKSwKICAgICAgICBfc3RlcDU7CgogICAgdHJ5IHsKICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHsKICAgICAgICB2YXIgZWxlbWVudCA9IF9zdGVwNS52YWx1ZTsKICAgICAgICBjb252ZXJzaW9uQXBpLm1hcHBlci51bmJpbmRFbGVtZW50RnJvbU1hcmtlck5hbWUoZWxlbWVudCwgZGF0YS5tYXJrZXJOYW1lKTsKICAgICAgICBjb252ZXJzaW9uQXBpLndyaXRlci5jbGVhcihjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVSYW5nZU9uKGVsZW1lbnQpLCBlbGVtZW50KTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9pdGVyYXRvcjUuZShlcnIpOwogICAgfSBmaW5hbGx5IHsKICAgICAgX2l0ZXJhdG9yNS5mKCk7CiAgICB9CgogICAgY29udmVyc2lvbkFwaS53cml0ZXIuY2xlYXJDbG9uZWRFbGVtZW50c0dyb3VwKGRhdGEubWFya2VyTmFtZSk7CiAgICBldnQuc3RvcCgpOwogIH07Cn0gLy8gRnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBkZWZhdWx0IGNvbnZlcnRlciBmb3IgbW9kZWwgbWFya2Vycy4KLy8KLy8gU2VlIHtAbGluayBEb3duY2FzdEhlbHBlcnMjbWFya2VyVG9EYXRhfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiB3aGF0IHR5cGUgb2YgdmlldyBpcyBnZW5lcmF0ZWQuCi8vCi8vIFRoaXMgY29udmVydGVyIGJpbmRzIGNyZWF0ZWQgVUkgZWxlbWVudHMgYW5kIGFmZmVjdGVkIHZpZXcgZWxlbWVudHMgd2l0aCB0aGUgbWFya2VyIG5hbWUKLy8gdXNpbmcge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyI2JpbmRFbGVtZW50VG9NYXJrZXJ9LgovLwovLyBAcmV0dXJucyB7RnVuY3Rpb259IEFkZCBtYXJrZXIgY29udmVydGVyLgoKCmZ1bmN0aW9uIGluc2VydE1hcmtlckRhdGEodmlld0NyZWF0b3IpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIHZpZXdNYXJrZXJEYXRhID0gdmlld0NyZWF0b3IoZGF0YS5tYXJrZXJOYW1lLCBjb252ZXJzaW9uQXBpKTsKCiAgICBpZiAoIXZpZXdNYXJrZXJEYXRhKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgbWFya2VyUmFuZ2UgPSBkYXRhLm1hcmtlclJhbmdlOwoKICAgIGlmICghY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUobWFya2VyUmFuZ2UsIGV2dC5uYW1lKSkgewogICAgICByZXR1cm47CiAgICB9IC8vIEFkZGluZyBjbG9zaW5nIGRhdGEgZmlyc3QgdG8ga2VlcCB0aGUgcHJvcGVyIG9yZGVyIGluIHRoZSB2aWV3LgoKCiAgICBoYW5kbGVNYXJrZXJCb3VuZGFyeShtYXJrZXJSYW5nZSwgZmFsc2UsIGNvbnZlcnNpb25BcGksIGRhdGEsIHZpZXdNYXJrZXJEYXRhKTsKICAgIGhhbmRsZU1hcmtlckJvdW5kYXJ5KG1hcmtlclJhbmdlLCB0cnVlLCBjb252ZXJzaW9uQXBpLCBkYXRhLCB2aWV3TWFya2VyRGF0YSk7CiAgICBldnQuc3RvcCgpOwogIH07Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBgaW5zZXJ0TWFya2VyRGF0YSgpYCB0aGF0IG1hcmtzIGEgbWFya2VyIGJvdW5kYXJ5IGF0IHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGdpdmVuIGByYW5nZWAuCgoKZnVuY3Rpb24gaGFuZGxlTWFya2VyQm91bmRhcnkocmFuZ2UsIGlzU3RhcnQsIGNvbnZlcnNpb25BcGksIGRhdGEsIHZpZXdNYXJrZXJEYXRhKSB7CiAgdmFyIG1vZGVsUG9zaXRpb24gPSBpc1N0YXJ0ID8gcmFuZ2Uuc3RhcnQgOiByYW5nZS5lbmQ7CiAgdmFyIGNhbkluc2VydEVsZW1lbnQgPSBjb252ZXJzaW9uQXBpLnNjaGVtYS5jaGVja0NoaWxkKG1vZGVsUG9zaXRpb24sICckdGV4dCcpOwoKICBpZiAoY2FuSW5zZXJ0RWxlbWVudCkgewogICAgdmFyIHZpZXdQb3NpdGlvbiA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1Bvc2l0aW9uKG1vZGVsUG9zaXRpb24pOwogICAgaW5zZXJ0TWFya2VyQXNFbGVtZW50KHZpZXdQb3NpdGlvbiwgaXNTdGFydCwgY29udmVyc2lvbkFwaSwgZGF0YSwgdmlld01hcmtlckRhdGEpOwogIH0gZWxzZSB7CiAgICB2YXIgbW9kZWxFbGVtZW50OwogICAgdmFyIGlzQmVmb3JlOyAvLyBJZiBwb3NzaWJsZSwgd2Ugd2FudCB0byBhZGQgYGRhdGEtZ3JvdXAtc3RhcnQtYmVmb3JlYCBhbmQgYGRhdGEtZ3JvdXAtZW5kLWFmdGVyYCBhdHRyaWJ1dGVzLgogICAgLy8gQmVsb3cgYGlmYCBpcyBjb25zdHJ1Y3RlZCBpbiBhIHdheSB0aGF0IHdpbGwgZmF2b3IgYWRkaW5nIHRoZXNlIGF0dHJpYnV0ZXMuCiAgICAvLwogICAgLy8gQWxzbywgSSBhc3N1bWUgdGhhdCB0aGVyZSB3aWxsIGJlIGFsd2F5cyBhbiBlbGVtZW50IGVpdGhlciBhZnRlciBvciBiZWZvcmUgdGhlIHBvc2l0aW9uLgogICAgLy8gSWYgbm90LCB0aGVuIGl0IGlzIGEgY2FzZSB3aGVuIHdlIGFyZSBub3QgaW4gYSBwb3NpdGlvbiB3aGVyZSB0ZXh0IGlzIGFsbG93ZWQgYW5kIGFsc28gdGhlcmUgYXJlIG5vIGVsZW1lbnRzIGFyb3VuZC4uLgoKICAgIGlmIChpc1N0YXJ0ICYmIG1vZGVsUG9zaXRpb24ubm9kZUFmdGVyIHx8ICFpc1N0YXJ0ICYmICFtb2RlbFBvc2l0aW9uLm5vZGVCZWZvcmUpIHsKICAgICAgbW9kZWxFbGVtZW50ID0gbW9kZWxQb3NpdGlvbi5ub2RlQWZ0ZXI7CiAgICAgIGlzQmVmb3JlID0gdHJ1ZTsKICAgIH0gZWxzZSB7CiAgICAgIG1vZGVsRWxlbWVudCA9IG1vZGVsUG9zaXRpb24ubm9kZUJlZm9yZTsKICAgICAgaXNCZWZvcmUgPSBmYWxzZTsKICAgIH0KCiAgICB2YXIgdmlld0VsZW1lbnQgPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b1ZpZXdFbGVtZW50KG1vZGVsRWxlbWVudCk7CiAgICBpbnNlcnRNYXJrZXJBc0F0dHJpYnV0ZSh2aWV3RWxlbWVudCwgaXNTdGFydCwgaXNCZWZvcmUsIGNvbnZlcnNpb25BcGksIGRhdGEsIHZpZXdNYXJrZXJEYXRhKTsKICB9Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBgaW5zZXJ0TWFya2VyRGF0YSgpYCB0aGF0IG1hcmtzIGEgbWFya2VyIGJvdW5kYXJ5IGluIHRoZSB2aWV3IGFzIGFuIGF0dHJpYnV0ZSBvbiBhIHZpZXcgZWxlbWVudC4KCgpmdW5jdGlvbiBpbnNlcnRNYXJrZXJBc0F0dHJpYnV0ZSh2aWV3RWxlbWVudCwgaXNTdGFydCwgaXNCZWZvcmUsIGNvbnZlcnNpb25BcGksIGRhdGEsIHZpZXdNYXJrZXJEYXRhKSB7CiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSAiZGF0YS0iLmNvbmNhdCh2aWV3TWFya2VyRGF0YS5ncm91cCwgIi0iKS5jb25jYXQoaXNTdGFydCA/ICdzdGFydCcgOiAnZW5kJywgIi0iKS5jb25jYXQoaXNCZWZvcmUgPyAnYmVmb3JlJyA6ICdhZnRlcicpOwogIHZhciBtYXJrZXJOYW1lcyA9IHZpZXdFbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSA/IHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKS5zcGxpdCgnLCcpIDogW107IC8vIEFkZGluZyBtYXJrZXIgbmFtZSBhdCB0aGUgYmVnaW5uaW5nIHRvIGhhdmUgdGhlIHNhbWUgb3JkZXIgaW4gdGhlIGF0dHJpYnV0ZSBhcyB0aGVyZSBpcyB3aXRoIG1hcmtlciBlbGVtZW50cy4KCiAgbWFya2VyTmFtZXMudW5zaGlmdCh2aWV3TWFya2VyRGF0YS5uYW1lKTsKICBjb252ZXJzaW9uQXBpLndyaXRlci5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgbWFya2VyTmFtZXMuam9pbignLCcpLCB2aWV3RWxlbWVudCk7CiAgY29udmVyc2lvbkFwaS5tYXBwZXIuYmluZEVsZW1lbnRUb01hcmtlcih2aWV3RWxlbWVudCwgZGF0YS5tYXJrZXJOYW1lKTsKfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGBpbnNlcnRNYXJrZXJEYXRhKClgIHRoYXQgbWFya3MgYSBtYXJrZXIgYm91bmRhcnkgaW4gdGhlIHZpZXcgYXMgYSBzZXBhcmF0ZSB2aWV3IHVpIGVsZW1lbnQuCgoKZnVuY3Rpb24gaW5zZXJ0TWFya2VyQXNFbGVtZW50KHBvc2l0aW9uLCBpc1N0YXJ0LCBjb252ZXJzaW9uQXBpLCBkYXRhLCB2aWV3TWFya2VyRGF0YSkgewogIHZhciB2aWV3RWxlbWVudE5hbWUgPSAiIi5jb25jYXQodmlld01hcmtlckRhdGEuZ3JvdXAsICItIikuY29uY2F0KGlzU3RhcnQgPyAnc3RhcnQnIDogJ2VuZCcpOwogIHZhciBhdHRycyA9IHZpZXdNYXJrZXJEYXRhLm5hbWUgPyB7CiAgICAnbmFtZSc6IHZpZXdNYXJrZXJEYXRhLm5hbWUKICB9IDogbnVsbDsKICB2YXIgdmlld0VsZW1lbnQgPSBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVVSUVsZW1lbnQodmlld0VsZW1lbnROYW1lLCBhdHRycyk7CiAgY29udmVyc2lvbkFwaS53cml0ZXIuaW5zZXJ0KHBvc2l0aW9uLCB2aWV3RWxlbWVudCk7CiAgY29udmVyc2lvbkFwaS5tYXBwZXIuYmluZEVsZW1lbnRUb01hcmtlcih2aWV3RWxlbWVudCwgZGF0YS5tYXJrZXJOYW1lKTsKfSAvLyBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciBmb3IgcmVtb3ZpbmcgYSBtb2RlbCBtYXJrZXIgZGF0YSBhZGRlZCBieSB0aGUge0BsaW5rICNpbnNlcnRNYXJrZXJEYXRhfSBjb252ZXJ0ZXIuCi8vCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gUmVtb3ZlIG1hcmtlciBjb252ZXJ0ZXIuCgoKZnVuY3Rpb24gcmVtb3ZlTWFya2VyRGF0YSh2aWV3Q3JlYXRvcikgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICB2YXIgdmlld0RhdGEgPSB2aWV3Q3JlYXRvcihkYXRhLm1hcmtlck5hbWUsIGNvbnZlcnNpb25BcGkpOwoKICAgIGlmICghdmlld0RhdGEpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciBlbGVtZW50cyA9IGNvbnZlcnNpb25BcGkubWFwcGVyLm1hcmtlck5hbWVUb0VsZW1lbnRzKGRhdGEubWFya2VyTmFtZSk7CgogICAgaWYgKCFlbGVtZW50cykgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlbGVtZW50cyksCiAgICAgICAgX3N0ZXA2OwoKICAgIHRyeSB7CiAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7CiAgICAgICAgdmFyIGVsZW1lbnQgPSBfc3RlcDYudmFsdWU7CiAgICAgICAgY29udmVyc2lvbkFwaS5tYXBwZXIudW5iaW5kRWxlbWVudEZyb21NYXJrZXJOYW1lKGVsZW1lbnQsIGRhdGEubWFya2VyTmFtZSk7CgogICAgICAgIGlmIChlbGVtZW50LmlzKCdjb250YWluZXJFbGVtZW50JykpIHsKICAgICAgICAgIHJlbW92ZU1hcmtlckZyb21BdHRyaWJ1dGUoImRhdGEtIi5jb25jYXQodmlld0RhdGEuZ3JvdXAsICItc3RhcnQtYmVmb3JlIiksIGVsZW1lbnQpOwogICAgICAgICAgcmVtb3ZlTWFya2VyRnJvbUF0dHJpYnV0ZSgiZGF0YS0iLmNvbmNhdCh2aWV3RGF0YS5ncm91cCwgIi1zdGFydC1hZnRlciIpLCBlbGVtZW50KTsKICAgICAgICAgIHJlbW92ZU1hcmtlckZyb21BdHRyaWJ1dGUoImRhdGEtIi5jb25jYXQodmlld0RhdGEuZ3JvdXAsICItZW5kLWJlZm9yZSIpLCBlbGVtZW50KTsKICAgICAgICAgIHJlbW92ZU1hcmtlckZyb21BdHRyaWJ1dGUoImRhdGEtIi5jb25jYXQodmlld0RhdGEuZ3JvdXAsICItZW5kLWFmdGVyIiksIGVsZW1lbnQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb252ZXJzaW9uQXBpLndyaXRlci5jbGVhcihjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVSYW5nZU9uKGVsZW1lbnQpLCBlbGVtZW50KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gY2F0Y2ggKGVycikgewogICAgICBfaXRlcmF0b3I2LmUoZXJyKTsKICAgIH0gZmluYWxseSB7CiAgICAgIF9pdGVyYXRvcjYuZigpOwogICAgfQoKICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLmNsZWFyQ2xvbmVkRWxlbWVudHNHcm91cChkYXRhLm1hcmtlck5hbWUpOwogICAgZXZ0LnN0b3AoKTsKCiAgICBmdW5jdGlvbiByZW1vdmVNYXJrZXJGcm9tQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGVsZW1lbnQpIHsKICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7CiAgICAgICAgdmFyIG1hcmtlck5hbWVzID0gbmV3IFNldChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKS5zcGxpdCgnLCcpKTsKICAgICAgICBtYXJrZXJOYW1lcy5kZWxldGUodmlld0RhdGEubmFtZSk7CgogICAgICAgIGlmIChtYXJrZXJOYW1lcy5zaXplID09IDApIHsKICAgICAgICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBlbGVtZW50KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29udmVyc2lvbkFwaS53cml0ZXIuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIEFycmF5LmZyb20obWFya2VyTmFtZXMpLmpvaW4oJywnKSwgZWxlbWVudCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfTsKfSAvLyBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciB3aGljaCBjb252ZXJ0cyBzZXQvY2hhbmdlL3JlbW92ZSBhdHRyaWJ1dGUgY2hhbmdlcyBmcm9tIHRoZSBtb2RlbCB0byB0aGUgdmlldy4KLy8KLy8gQXR0cmlidXRlcyBmcm9tIHRoZSBtb2RlbCBhcmUgY29udmVydGVkIHRvIHRoZSB2aWV3IGVsZW1lbnQgYXR0cmlidXRlcyBpbiB0aGUgdmlldy4gWW91IG1heSBwcm92aWRlIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIGdlbmVyYXRlCi8vIGEga2V5LXZhbHVlIGF0dHJpYnV0ZSBwYWlyIHRvIGFkZC9jaGFuZ2UvcmVtb3ZlLiBJZiBub3QgcHJvdmlkZWQsIG1vZGVsIGF0dHJpYnV0ZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdmlldyBlbGVtZW50Ci8vIGF0dHJpYnV0ZXMgb24gYSBvbmUtdG8tb25lIGJhc2lzLgovLwovLyAqTm90ZToqKiBUaGUgcHJvdmlkZWQgYXR0cmlidXRlIGNyZWF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYGtleWAgZm9yIGEgZ2l2ZW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLgovLwovLyBUaGUgY29udmVydGVyIGF1dG9tYXRpY2FsbHkgY29uc3VtZXMgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgZnJvbSB0aGUgY29uc3VtYWJsZXMgbGlzdCBhbmQgc3RvcHMgdGhlIGV2ZW50IChzZWUKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfSkuCi8vCi8vCQltb2RlbERpc3BhdGNoZXIub24oICdhdHRyaWJ1dGU6Y3VzdG9tQXR0cjpteUVsZW0nLCBjaGFuZ2VBdHRyaWJ1dGUoICggdmFsdWUsIGRhdGEgKSA9PiB7Ci8vCQkJLy8gQ2hhbmdlIGF0dHJpYnV0ZSBrZXkgZnJvbSBgY3VzdG9tQXR0cmAgdG8gYGNsYXNzYCBpbiB0aGUgdmlldy4KLy8JCQljb25zdCBrZXkgPSAnY2xhc3MnOwovLwkJCWxldCB2YWx1ZSA9IGRhdGEuYXR0cmlidXRlTmV3VmFsdWU7Ci8vCi8vCQkJLy8gRm9yY2UgYXR0cmlidXRlIHZhbHVlIHRvICdlbXB0eScgaWYgdGhlIG1vZGVsIGVsZW1lbnQgaXMgZW1wdHkuCi8vCQkJaWYgKCBkYXRhLml0ZW0uY2hpbGRDb3VudCA9PT0gMCApIHsKLy8JCQkJdmFsdWUgPSAnZW1wdHknOwovLwkJCX0KLy8KLy8JCQkvLyBSZXR1cm4gdGhlIGtleS12YWx1ZSBwYWlyLgovLwkJCXJldHVybiB7IGtleSwgdmFsdWUgfTsKLy8JCX0gKSApOwovLwovLyBAcGFyYW0ge0Z1bmN0aW9ufSBbYXR0cmlidXRlQ3JlYXRvcl0gRnVuY3Rpb24gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiBga2V5YCBhbmQgYHZhbHVlYCwgd2hpY2gKLy8gcmVwcmVzZW50IHRoZSBhdHRyaWJ1dGUga2V5IGFuZCBhdHRyaWJ1dGUgdmFsdWUgdG8gYmUgc2V0IG9uIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fS4KLy8gVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYW5kIGFkZGl0aW9uYWwgZGF0YSBhYm91dCB0aGUgY2hhbmdlIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLgovLyBAcmV0dXJucyB7RnVuY3Rpb259IFNldC9jaGFuZ2UgYXR0cmlidXRlIGNvbnZlcnRlci4KCgpmdW5jdGlvbiBjaGFuZ2VBdHRyaWJ1dGUoYXR0cmlidXRlQ3JlYXRvcikgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICB2YXIgb2xkQXR0cmlidXRlID0gYXR0cmlidXRlQ3JlYXRvcihkYXRhLmF0dHJpYnV0ZU9sZFZhbHVlLCBjb252ZXJzaW9uQXBpKTsKICAgIHZhciBuZXdBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVDcmVhdG9yKGRhdGEuYXR0cmlidXRlTmV3VmFsdWUsIGNvbnZlcnNpb25BcGkpOwoKICAgIGlmICghb2xkQXR0cmlidXRlICYmICFuZXdBdHRyaWJ1dGUpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGlmICghY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS5pdGVtLCBldnQubmFtZSkpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciB2aWV3RWxlbWVudCA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld0VsZW1lbnQoZGF0YS5pdGVtKTsKICAgIHZhciB2aWV3V3JpdGVyID0gY29udmVyc2lvbkFwaS53cml0ZXI7IC8vIElmIG1vZGVsIGl0ZW0gY2Fubm90IGJlIG1hcHBlZCB0byBhIHZpZXcgZWxlbWVudCwgaXQgbWVhbnMgaXRlbSBpcyBub3QgYW4gYEVsZW1lbnRgIGluc3RhbmNlIGJ1dCBhIGBUZXh0UHJveHlgIG5vZGUuCiAgICAvLyBPbmx5IGVsZW1lbnRzIGNhbiBoYXZlIGF0dHJpYnV0ZXMgaW4gYSB2aWV3IHNvIGRvIG5vdCBwcm9jZWVkIGZvciBhbnl0aGluZyBlbHNlICgjMTU4NykuCgogICAgaWYgKCF2aWV3RWxlbWVudCkgewogICAgICAvKioKICAgICAgICogVGhpcyBlcnJvciBvY2N1cnMgd2hlbiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHRwcm94eX5UZXh0UHJveHkgdGV4dCBub2RlJ3N9IGF0dHJpYnV0ZSBpcyB0byBiZSBkb3duY2FzdGVkCiAgICAgICAqIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2F0dHJpYnV0ZVRvQXR0cmlidXRlIGBBdHRyaWJ1dGUgdG8gQXR0cmlidXRlIGNvbnZlcnRlcmB9LgogICAgICAgKiBJbiBtb3N0IGNhc2VzIGl0IGlzIGNhdXNlZCBieSBjb252ZXJ0ZXJzIG1pc2NvbmZpZ3VyYXRpb24gd2hlbiBvbmx5ICJnZW5lcmljIiBjb252ZXJ0ZXIgaXMgZGVmaW5lZDoKICAgICAgICoKICAgICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgICAqCQkJbW9kZWw6ICdhdHRyaWJ1dGUtbmFtZScsCiAgICAgICAqCQkJdmlldzogJ2F0dHJpYnV0ZS1uYW1lJwogICAgICAgKgkJfSApICk7CiAgICAgICAqCiAgICAgICAqIGFuZCBnaXZlbiBhdHRyaWJ1dGUgaXMgdXNlZCBvbiB0ZXh0IG5vZGUsIGZvciBleGFtcGxlOgogICAgICAgKgogICAgICAgKgkJbW9kZWwuY2hhbmdlKCB3cml0ZXIgPT4gewogICAgICAgKgkJCXdyaXRlci5pbnNlcnRUZXh0KCAnRm9vJywgeyAnYXR0cmlidXRlLW5hbWUnOiAnYmFyJyB9LCBwYXJlbnQsIDAgKTsKICAgICAgICoJCX0gKTsKICAgICAgICoKICAgICAgICogSW4gc3VjaCBjYXNlcywgdG8gY29udmVydCB0aGUgc2FtZSBhdHRyaWJ1dGUgZm9yIGJvdGgge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fQogICAgICAgKiBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eSBgVGV4dGB9IG5vZGVzLCB0ZXh0IHNwZWNpZmljCiAgICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2F0dHJpYnV0ZVRvRWxlbWVudCBgQXR0cmlidXRlIHRvIEVsZW1lbnQgY29udmVydGVyYH0KICAgICAgICogd2l0aCBoaWdoZXIge0BsaW5rIG1vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nIHByaW9yaXR5fSBtdXN0IGFsc28gYmUgZGVmaW5lZDoKICAgICAgICoKICAgICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmF0dHJpYnV0ZVRvRWxlbWVudCggewogICAgICAgKgkJCW1vZGVsOiB7CiAgICAgICAqCQkJCWtleTogJ2F0dHJpYnV0ZS1uYW1lJywKICAgICAgICoJCQkJbmFtZTogJyR0ZXh0JwogICAgICAgKgkJCX0sCiAgICAgICAqCQkJdmlldzogKCB2YWx1ZSwgeyB3cml0ZXIgfSApID0+IHsKICAgICAgICoJCQkJcmV0dXJuIHdyaXRlci5jcmVhdGVBdHRyaWJ1dGVFbGVtZW50KCAnc3BhbicsIHsgJ2F0dHJpYnV0ZS1uYW1lJzogdmFsdWUgfSApOwogICAgICAgKgkJCX0sCiAgICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICAgKgkJfSApICk7CiAgICAgICAqCiAgICAgICAqIEBlcnJvciBjb252ZXJzaW9uLWF0dHJpYnV0ZS10by1hdHRyaWJ1dGUtb24tdGV4dAogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2NvbnZlcnNpb24tYXR0cmlidXRlLXRvLWF0dHJpYnV0ZS1vbi10ZXh0JywgW2RhdGEsIGNvbnZlcnNpb25BcGldKTsKICAgIH0gLy8gRmlyc3QgcmVtb3ZlIHRoZSBvbGQgYXR0cmlidXRlIGlmIHRoZXJlIHdhcyBvbmUuCgoKICAgIGlmIChkYXRhLmF0dHJpYnV0ZU9sZFZhbHVlICE9PSBudWxsICYmIG9sZEF0dHJpYnV0ZSkgewogICAgICBpZiAob2xkQXR0cmlidXRlLmtleSA9PSAnY2xhc3MnKSB7CiAgICAgICAgdmFyIGNsYXNzZXMgPSB0b0FycmF5KG9sZEF0dHJpYnV0ZS52YWx1ZSk7CgogICAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY2xhc3NlcyksCiAgICAgICAgICAgIF9zdGVwNzsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBfc3RlcDcudmFsdWU7CiAgICAgICAgICAgIHZpZXdXcml0ZXIucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lLCB2aWV3RWxlbWVudCk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKG9sZEF0dHJpYnV0ZS5rZXkgPT0gJ3N0eWxlJykgewogICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2xkQXR0cmlidXRlLnZhbHVlKTsKCiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfa2V5cyA9IGtleXM7IF9pIDwgX2tleXMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICB2YXIga2V5ID0gX2tleXNbX2ldOwogICAgICAgICAgdmlld1dyaXRlci5yZW1vdmVTdHlsZShrZXksIHZpZXdFbGVtZW50KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmlld1dyaXRlci5yZW1vdmVBdHRyaWJ1dGUob2xkQXR0cmlidXRlLmtleSwgdmlld0VsZW1lbnQpOwogICAgICB9CiAgICB9IC8vIFRoZW4gc2V0IHRoZSBuZXcgYXR0cmlidXRlLgoKCiAgICBpZiAoZGF0YS5hdHRyaWJ1dGVOZXdWYWx1ZSAhPT0gbnVsbCAmJiBuZXdBdHRyaWJ1dGUpIHsKICAgICAgaWYgKG5ld0F0dHJpYnV0ZS5rZXkgPT0gJ2NsYXNzJykgewogICAgICAgIHZhciBfY2xhc3NlcyA9IHRvQXJyYXkobmV3QXR0cmlidXRlLnZhbHVlKTsKCiAgICAgICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihfY2xhc3NlcyksCiAgICAgICAgICAgIF9zdGVwODsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lID0gX3N0ZXA4LnZhbHVlOwogICAgICAgICAgICB2aWV3V3JpdGVyLmFkZENsYXNzKF9jbGFzc05hbWUsIHZpZXdFbGVtZW50KTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjguZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3I4LmYoKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAobmV3QXR0cmlidXRlLmtleSA9PSAnc3R5bGUnKSB7CiAgICAgICAgdmFyIF9rZXlzMiA9IE9iamVjdC5rZXlzKG5ld0F0dHJpYnV0ZS52YWx1ZSk7CgogICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9rZXlzMyA9IF9rZXlzMjsgX2kyIDwgX2tleXMzLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICAgIHZhciBfa2V5ID0gX2tleXMzW19pMl07CiAgICAgICAgICB2aWV3V3JpdGVyLnNldFN0eWxlKF9rZXksIG5ld0F0dHJpYnV0ZS52YWx1ZVtfa2V5XSwgdmlld0VsZW1lbnQpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB2aWV3V3JpdGVyLnNldEF0dHJpYnV0ZShuZXdBdHRyaWJ1dGUua2V5LCBuZXdBdHRyaWJ1dGUudmFsdWUsIHZpZXdFbGVtZW50KTsKICAgICAgfQogICAgfQogIH07Cn0gLy8gRnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBjb252ZXJ0ZXIgd2hpY2ggY29udmVydHMgdGhlIHRleHQgaW5zaWRlIG1hcmtlcidzIHJhbmdlLiBUaGUgY29udmVydGVyIHdyYXBzIHRoZSB0ZXh0IHdpdGgKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGNyZWF0ZWQgZnJvbSB0aGUgcHJvdmlkZWQgZGVzY3JpcHRvci4KLy8gU2VlIHtsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+Y3JlYXRlVmlld0VsZW1lbnRGcm9tSGlnaGxpZ2h0RGVzY3JpcHRvcn0uCi8vCi8vIEl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gY29udmVydCB0aGUgc2VsZWN0aW9uIHRoYXQgaXMgaW5zaWRlIGEgbWFya2VyLiBJbiB0aGF0IGNhc2UsIGFuIGVtcHR5IGF0dHJpYnV0ZSBlbGVtZW50IHdpbGwgYmUKLy8gY3JlYXRlZCBhbmQgdGhlIHNlbGVjdGlvbiB3aWxsIGJlIHB1dCBpbnNpZGUgaXQuCi8vCi8vIElmIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvciBkb2VzIG5vdCBwcm92aWRlIHRoZSBgcHJpb3JpdHlgIHByb3BlcnR5LCBgMTBgIHdpbGwgYmUgdXNlZC4KLy8KLy8gSWYgdGhlIGhpZ2hsaWdodCBkZXNjcmlwdG9yIGRvZXMgbm90IHByb3ZpZGUgdGhlIGBpZGAgcHJvcGVydHksIHRoZSBuYW1lIG9mIHRoZSBtYXJrZXIgd2lsbCBiZSB1c2VkLgovLwovLyBUaGlzIGNvbnZlcnRlciBiaW5kcyB0aGUgY3JlYXRlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVuc30gd2l0aCB0aGUgbWFya2VyIG5hbWUKLy8gdXNpbmcgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciNiaW5kRWxlbWVudFRvTWFya2VyfSBtZXRob2QuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yfEZ1bmN0aW9ufSBoaWdobGlnaHREZXNjcmlwdG9yCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0KCgpmdW5jdGlvbiBoaWdobGlnaHRUZXh0KGhpZ2hsaWdodERlc2NyaXB0b3IpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgaWYgKCFkYXRhLml0ZW0pIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGlmICghKGRhdGEuaXRlbSBpbnN0YW5jZW9mIE1vZGVsU2VsZWN0aW9uIHx8IGRhdGEuaXRlbSBpbnN0YW5jZW9mIERvY3VtZW50U2VsZWN0aW9uKSAmJiAhZGF0YS5pdGVtLmlzKCckdGV4dFByb3h5JykpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciBkZXNjcmlwdG9yID0gcHJlcGFyZURlc2NyaXB0b3IoaGlnaGxpZ2h0RGVzY3JpcHRvciwgZGF0YSwgY29udmVyc2lvbkFwaSk7CgogICAgaWYgKCFkZXNjcmlwdG9yKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEuaXRlbSwgZXZ0Lm5hbWUpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOwogICAgdmFyIHZpZXdFbGVtZW50ID0gY3JlYXRlVmlld0VsZW1lbnRGcm9tSGlnaGxpZ2h0RGVzY3JpcHRvcih2aWV3V3JpdGVyLCBkZXNjcmlwdG9yKTsKICAgIHZhciB2aWV3U2VsZWN0aW9uID0gdmlld1dyaXRlci5kb2N1bWVudC5zZWxlY3Rpb247CgogICAgaWYgKGRhdGEuaXRlbSBpbnN0YW5jZW9mIE1vZGVsU2VsZWN0aW9uIHx8IGRhdGEuaXRlbSBpbnN0YW5jZW9mIERvY3VtZW50U2VsZWN0aW9uKSB7CiAgICAgIHZpZXdXcml0ZXIud3JhcCh2aWV3U2VsZWN0aW9uLmdldEZpcnN0UmFuZ2UoKSwgdmlld0VsZW1lbnQsIHZpZXdTZWxlY3Rpb24pOwogICAgfSBlbHNlIHsKICAgICAgdmFyIHZpZXdSYW5nZSA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1JhbmdlKGRhdGEucmFuZ2UpOwogICAgICB2YXIgcmFuZ2VBZnRlcldyYXAgPSB2aWV3V3JpdGVyLndyYXAodmlld1JhbmdlLCB2aWV3RWxlbWVudCk7CgogICAgICB2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJhbmdlQWZ0ZXJXcmFwLmdldEl0ZW1zKCkpLAogICAgICAgICAgX3N0ZXA5OwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykgewogICAgICAgICAgdmFyIGVsZW1lbnQgPSBfc3RlcDkudmFsdWU7CgogICAgICAgICAgaWYgKGVsZW1lbnQuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSAmJiBlbGVtZW50LmlzU2ltaWxhcih2aWV3RWxlbWVudCkpIHsKICAgICAgICAgICAgY29udmVyc2lvbkFwaS5tYXBwZXIuYmluZEVsZW1lbnRUb01hcmtlcihlbGVtZW50LCBkYXRhLm1hcmtlck5hbWUpOyAvLyBPbmUgYXR0cmlidXRlIGVsZW1lbnQgaXMgZW5vdWdoLCBiZWNhdXNlIGFsbCBvZiB0aGVtIGFyZSBib3VuZCB0b2dldGhlciBieSB0aGUgdmlldyB3cml0ZXIuCiAgICAgICAgICAgIC8vIE1hcHBlciB1c2VzIHRoaXMgYmluZGluZyB0byBnZXQgYWxsIHRoZSBlbGVtZW50cyBubyBtYXR0ZXIgaG93IG1hbnkgb2YgdGhlbSBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgbWFwcGVyLgoKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3I5LmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3I5LmYoKTsKICAgICAgfQogICAgfQogIH07Cn0gLy8gQ29udmVydGVyIGZ1bmN0aW9uIGZhY3RvcnkuIEl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBhcHBsaWVzIHRoZSBtYXJrZXIncyBoaWdobGlnaHQgdG8gYW4gZWxlbWVudCBpbnNpZGUgdGhlIG1hcmtlcidzIHJhbmdlLgovLwovLyBUaGUgY29udmVydGVyIGNoZWNrcyBpZiBhbiBlbGVtZW50IGhhcyB0aGUgYGFkZEhpZ2hsaWdodGAgZnVuY3Rpb24gc3RvcmVkIGFzIGEKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQjX3NldEN1c3RvbVByb3BlcnR5IGN1c3RvbSBwcm9wZXJ0eX0gYW5kLCBpZiBzbywgdXNlcyBpdCB0byBhcHBseSB0aGUgaGlnaGxpZ2h0LgovLyBJbiBzdWNoIGNhc2UgdGhlIGNvbnZlcnRlciB3aWxsIGNvbnN1bWUgYWxsIGVsZW1lbnQncyBjaGlsZHJlbiwgYXNzdW1pbmcgdGhhdCB0aGV5IHdlcmUgaGFuZGxlZCBieSB0aGUgZWxlbWVudCBpdHNlbGYuCi8vCi8vIFdoZW4gdGhlIGBhZGRIaWdobGlnaHRgIGN1c3RvbSBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCwgdGhlIGVsZW1lbnQgaXMgbm90IGNvbnZlcnRlZCBpbiBhbnkgc3BlY2lhbCB3YXkuCi8vIFRoaXMgbWVhbnMgdGhhdCBjb252ZXJ0ZXJzIHdpbGwgcHJvY2VlZCB0byBjb252ZXJ0IHRoZSBlbGVtZW50J3MgY2hpbGQgbm9kZXMuCi8vCi8vIElmIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvciBkb2VzIG5vdCBwcm92aWRlIHRoZSBgcHJpb3JpdHlgIHByb3BlcnR5LCBgMTBgIHdpbGwgYmUgdXNlZC4KLy8KLy8gSWYgdGhlIGhpZ2hsaWdodCBkZXNjcmlwdG9yIGRvZXMgbm90IHByb3ZpZGUgdGhlIGBpZGAgcHJvcGVydHksIHRoZSBuYW1lIG9mIHRoZSBtYXJrZXIgd2lsbCBiZSB1c2VkLgovLwovLyBUaGlzIGNvbnZlcnRlciBiaW5kcyBhbHRlcmVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IGNvbnRhaW5lciBlbGVtZW50c30gd2l0aCB0aGUgbWFya2VyIG5hbWUgdXNpbmcKLy8gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciNiaW5kRWxlbWVudFRvTWFya2VyfSBtZXRob2QuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yfEZ1bmN0aW9ufSBoaWdobGlnaHREZXNjcmlwdG9yCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0KCgpmdW5jdGlvbiBoaWdobGlnaHRFbGVtZW50KGhpZ2hsaWdodERlc2NyaXB0b3IpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgaWYgKCFkYXRhLml0ZW0pIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGlmICghKGRhdGEuaXRlbSBpbnN0YW5jZW9mIE1vZGVsRWxlbWVudCkpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciBkZXNjcmlwdG9yID0gcHJlcGFyZURlc2NyaXB0b3IoaGlnaGxpZ2h0RGVzY3JpcHRvciwgZGF0YSwgY29udmVyc2lvbkFwaSk7CgogICAgaWYgKCFkZXNjcmlwdG9yKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS50ZXN0KGRhdGEuaXRlbSwgZXZ0Lm5hbWUpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgdmlld0VsZW1lbnQgPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b1ZpZXdFbGVtZW50KGRhdGEuaXRlbSk7CgogICAgaWYgKHZpZXdFbGVtZW50ICYmIHZpZXdFbGVtZW50LmdldEN1c3RvbVByb3BlcnR5KCdhZGRIaWdobGlnaHQnKSkgewogICAgICAvLyBDb25zdW1lIGVsZW1lbnQgaXRzZWxmLgogICAgICBjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLml0ZW0sIGV2dC5uYW1lKTsgLy8gQ29uc3VtZSBhbGwgY2hpbGRyZW4gbm9kZXMuCgogICAgICB2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihNb2RlbFJhbmdlLl9jcmVhdGVJbihkYXRhLml0ZW0pKSwKICAgICAgICAgIF9zdGVwMTA7CgogICAgICB0cnkgewogICAgICAgIGZvciAoX2l0ZXJhdG9yMTAucygpOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uKCkpLmRvbmU7KSB7CiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDEwLnZhbHVlOwogICAgICAgICAgY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUodmFsdWUuaXRlbSwgZXZ0Lm5hbWUpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMTAuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjEwLmYoKTsKICAgICAgfQoKICAgICAgdmlld0VsZW1lbnQuZ2V0Q3VzdG9tUHJvcGVydHkoJ2FkZEhpZ2hsaWdodCcpKHZpZXdFbGVtZW50LCBkZXNjcmlwdG9yLCBjb252ZXJzaW9uQXBpLndyaXRlcik7CiAgICAgIGNvbnZlcnNpb25BcGkubWFwcGVyLmJpbmRFbGVtZW50VG9NYXJrZXIodmlld0VsZW1lbnQsIGRhdGEubWFya2VyTmFtZSk7CiAgICB9CiAgfTsKfSAvLyBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciB3aGljaCBjb252ZXJ0cyB0aGUgcmVtb3ZpbmcgbW9kZWwgbWFya2VyIHRvIHRoZSB2aWV3LgovLwovLyBCb3RoIHRleHQgbm9kZXMgYW5kIGVsZW1lbnRzIGFyZSBoYW5kbGVkIGJ5IHRoaXMgY29udmVydGVyIGJ1dCB0aGV5IGFyZSBoYW5kbGVkIGEgYml0IGRpZmZlcmVudGx5LgovLwovLyBUZXh0IG5vZGVzIGFyZSB1bndyYXBwZWQgdXNpbmcgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50fSBjcmVhdGVkIGZyb20gdGhlCi8vIHByb3ZpZGVkIGhpZ2hsaWdodCBkZXNjcmlwdG9yLiBTZWUge2xpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yfS4KLy8KLy8gRm9yIGVsZW1lbnRzLCB0aGUgY29udmVydGVyIGNoZWNrcyBpZiBhbiBlbGVtZW50IGhhcyB0aGUgYHJlbW92ZUhpZ2hsaWdodGAgZnVuY3Rpb24gc3RvcmVkIGFzIGEKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQjX3NldEN1c3RvbVByb3BlcnR5IGN1c3RvbSBwcm9wZXJ0eX0uIElmIHNvLCBpdCB1c2VzIGl0IHRvIHJlbW92ZSB0aGUgaGlnaGxpZ2h0LgovLyBJbiBzdWNoIGNhc2UsIHRoZSBjaGlsZHJlbiBvZiB0aGF0IGVsZW1lbnQgd2lsbCBub3QgYmUgY29udmVydGVkLgovLwovLyBXaGVuIGByZW1vdmVIaWdobGlnaHRgIGlzIG5vdCBwcmVzZW50LCB0aGUgZWxlbWVudCBpcyBub3QgY29udmVydGVkIGluIGFueSBzcGVjaWFsIHdheS4KLy8gVGhlIGNvbnZlcnRlciB3aWxsIHByb2NlZWQgdG8gY29udmVydCB0aGUgZWxlbWVudCdzIGNoaWxkIG5vZGVzIGluc3RlYWQuCi8vCi8vIElmIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvciBkb2VzIG5vdCBwcm92aWRlIHRoZSBgcHJpb3JpdHlgIHByb3BlcnR5LCBgMTBgIHdpbGwgYmUgdXNlZC4KLy8KLy8gSWYgdGhlIGhpZ2hsaWdodCBkZXNjcmlwdG9yIGRvZXMgbm90IHByb3ZpZGUgdGhlIGBpZGAgcHJvcGVydHksIHRoZSBuYW1lIG9mIHRoZSBtYXJrZXIgd2lsbCBiZSB1c2VkLgovLwovLyBUaGlzIGNvbnZlcnRlciB1bmJpbmRzIGVsZW1lbnRzIGZyb20gdGhlIG1hcmtlciBuYW1lLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+SGlnaGxpZ2h0RGVzY3JpcHRvcnxGdW5jdGlvbn0gaGlnaGxpZ2h0RGVzY3JpcHRvcgovLyBAcmV0dXJucyB7RnVuY3Rpb259CgoKZnVuY3Rpb24gcmVtb3ZlSGlnaGxpZ2h0KGhpZ2hsaWdodERlc2NyaXB0b3IpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgLy8gVGhpcyBjb252ZXJzaW9uIG1ha2VzIHNlbnNlIG9ubHkgZm9yIG5vbi1jb2xsYXBzZWQgcmFuZ2UuCiAgICBpZiAoZGF0YS5tYXJrZXJSYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIGRlc2NyaXB0b3IgPSBwcmVwYXJlRGVzY3JpcHRvcihoaWdobGlnaHREZXNjcmlwdG9yLCBkYXRhLCBjb252ZXJzaW9uQXBpKTsKCiAgICBpZiAoIWRlc2NyaXB0b3IpIHsKICAgICAgcmV0dXJuOwogICAgfSAvLyBWaWV3IGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdW53cmFwIGBBdHRyaWJ1dGVFbGVtZW50YHMuCgoKICAgIHZhciB2aWV3SGlnaGxpZ2h0RWxlbWVudCA9IGNyZWF0ZVZpZXdFbGVtZW50RnJvbUhpZ2hsaWdodERlc2NyaXB0b3IoY29udmVyc2lvbkFwaS53cml0ZXIsIGRlc2NyaXB0b3IpOyAvLyBHZXQgYWxsIGVsZW1lbnRzIGJvdW5kIHdpdGggZ2l2ZW4gbWFya2VyIG5hbWUuCgogICAgdmFyIGVsZW1lbnRzID0gY29udmVyc2lvbkFwaS5tYXBwZXIubWFya2VyTmFtZVRvRWxlbWVudHMoZGF0YS5tYXJrZXJOYW1lKTsKCiAgICBpZiAoIWVsZW1lbnRzKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlbGVtZW50cyksCiAgICAgICAgX3N0ZXAxMTsKCiAgICB0cnkgewogICAgICBmb3IgKF9pdGVyYXRvcjExLnMoKTsgIShfc3RlcDExID0gX2l0ZXJhdG9yMTEubigpKS5kb25lOykgewogICAgICAgIHZhciBlbGVtZW50ID0gX3N0ZXAxMS52YWx1ZTsKICAgICAgICBjb252ZXJzaW9uQXBpLm1hcHBlci51bmJpbmRFbGVtZW50RnJvbU1hcmtlck5hbWUoZWxlbWVudCwgZGF0YS5tYXJrZXJOYW1lKTsKCiAgICAgICAgaWYgKGVsZW1lbnQuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSkgewogICAgICAgICAgY29udmVyc2lvbkFwaS53cml0ZXIudW53cmFwKGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVJhbmdlT24oZWxlbWVudCksIHZpZXdIaWdobGlnaHRFbGVtZW50KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gaWYgZWxlbWVudC5pcyggJ2NvbnRhaW5lckVsZW1lbnQnICkuCiAgICAgICAgICBlbGVtZW50LmdldEN1c3RvbVByb3BlcnR5KCdyZW1vdmVIaWdobGlnaHQnKShlbGVtZW50LCBkZXNjcmlwdG9yLmlkLCBjb252ZXJzaW9uQXBpLndyaXRlcik7CiAgICAgICAgfQogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2l0ZXJhdG9yMTEuZShlcnIpOwogICAgfSBmaW5hbGx5IHsKICAgICAgX2l0ZXJhdG9yMTEuZigpOwogICAgfQoKICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLmNsZWFyQ2xvbmVkRWxlbWVudHNHcm91cChkYXRhLm1hcmtlck5hbWUpOwogICAgZXZ0LnN0b3AoKTsKICB9Owp9IC8vIE1vZGVsIGVsZW1lbnQgdG8gdmlldyBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5Eb3duY2FzdEhlbHBlcnMjZWxlbWVudFRvRWxlbWVudCBgLmVsZW1lbnRUb0VsZW1lbnQoKWAgZG93bmNhc3QgaGVscGVyfSBmb3IgZXhhbXBsZXMgYW5kIGNvbmZpZyBwYXJhbXMgZGVzY3JpcHRpb24uCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgovLyBAcGFyYW0ge1N0cmluZ30gY29uZmlnLm1vZGVsCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnRkZWZpbml0aW9ufkVsZW1lbnREZWZpbml0aW9ufEZ1bmN0aW9ufSBjb25maWcudmlldwovLyBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy50cmlnZ2VyQnldCi8vIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtjb25maWcudHJpZ2dlckJ5LmF0dHJpYnV0ZXNdCi8vIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtjb25maWcudHJpZ2dlckJ5LmNoaWxkcmVuXQovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIGRvd25jYXN0RWxlbWVudFRvRWxlbWVudChjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICBjb25maWcudmlldyA9IG5vcm1hbGl6ZVRvRWxlbWVudENvbmZpZyhjb25maWcudmlldywgJ2NvbnRhaW5lcicpOwogIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2hlcikgewogICAgZGlzcGF0Y2hlci5vbignaW5zZXJ0OicgKyBjb25maWcubW9kZWwsIGluc2VydEVsZW1lbnQoY29uZmlnLnZpZXcpLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwoKICAgIGlmIChjb25maWcudHJpZ2dlckJ5KSB7CiAgICAgIGlmIChjb25maWcudHJpZ2dlckJ5LmF0dHJpYnV0ZXMpIHsKICAgICAgICB2YXIgX2l0ZXJhdG9yMTIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb25maWcudHJpZ2dlckJ5LmF0dHJpYnV0ZXMpLAogICAgICAgICAgICBfc3RlcDEyOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yIChfaXRlcmF0b3IxMi5zKCk7ICEoX3N0ZXAxMiA9IF9pdGVyYXRvcjEyLm4oKSkuZG9uZTspIHsKICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUtleSA9IF9zdGVwMTIudmFsdWU7CgogICAgICAgICAgICBkaXNwYXRjaGVyLl9tYXBSZWNvbnZlcnNpb25UcmlnZ2VyRXZlbnQoY29uZmlnLm1vZGVsLCAiYXR0cmlidXRlOiIuY29uY2F0KGF0dHJpYnV0ZUtleSwgIjoiKS5jb25jYXQoY29uZmlnLm1vZGVsKSk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfaXRlcmF0b3IxMi5lKGVycik7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIF9pdGVyYXRvcjEyLmYoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmIChjb25maWcudHJpZ2dlckJ5LmNoaWxkcmVuKSB7CiAgICAgICAgdmFyIF9pdGVyYXRvcjEzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoY29uZmlnLnRyaWdnZXJCeS5jaGlsZHJlbiksCiAgICAgICAgICAgIF9zdGVwMTM7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjEzLnMoKTsgIShfc3RlcDEzID0gX2l0ZXJhdG9yMTMubigpKS5kb25lOykgewogICAgICAgICAgICB2YXIgY2hpbGROYW1lID0gX3N0ZXAxMy52YWx1ZTsKCiAgICAgICAgICAgIGRpc3BhdGNoZXIuX21hcFJlY29udmVyc2lvblRyaWdnZXJFdmVudChjb25maWcubW9kZWwsICJpbnNlcnQ6Ii5jb25jYXQoY2hpbGROYW1lKSk7CgogICAgICAgICAgICBkaXNwYXRjaGVyLl9tYXBSZWNvbnZlcnNpb25UcmlnZ2VyRXZlbnQoY29uZmlnLm1vZGVsLCAicmVtb3ZlOiIuY29uY2F0KGNoaWxkTmFtZSkpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2l0ZXJhdG9yMTMuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3IxMy5mKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfTsKfSAvLyBNb2RlbCBhdHRyaWJ1dGUgdG8gdmlldyBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5Eb3duY2FzdEhlbHBlcnMjYXR0cmlidXRlVG9FbGVtZW50IGAuYXR0cmlidXRlVG9FbGVtZW50KClgIGRvd25jYXN0IGhlbHBlcn0gZm9yIGV4YW1wbGVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcubW9kZWwgVGhlIGtleSBvZiB0aGUgYXR0cmlidXRlIHRvIGNvbnZlcnQgZnJvbSBvciBhIGB7IGtleSwgdmFsdWVzIH1gIG9iamVjdC4gYHZhbHVlc2AgaXMgYW4gYXJyYXkKLy8gb2YgYFN0cmluZ2BzIHdpdGggcG9zc2libGUgdmFsdWVzIGlmIHRoZSBtb2RlbCBhdHRyaWJ1dGUgaXMgYW4gZW51bWVyYWJsZS4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb258RnVuY3Rpb258T2JqZWN0fSBjb25maWcudmlldyBBIHZpZXcgZWxlbWVudCBkZWZpbml0aW9uIG9yIGEgZnVuY3Rpb24KLy8gdGhhdCB0YWtlcyB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyIHZpZXcgZG93bmNhc3Qgd3JpdGVyfQovLyBhcyBwYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGEgdmlldyBhdHRyaWJ1dGUgZWxlbWVudC4gSWYgYGNvbmZpZy5tb2RlbC52YWx1ZXNgIGlzCi8vIGdpdmVuLCBgY29uZmlnLnZpZXdgIHNob3VsZCBiZSBhbiBvYmplY3QgYXNzaWduaW5nIHZhbHVlcyBmcm9tIGBjb25maWcubW9kZWwudmFsdWVzYCB0byB2aWV3IGVsZW1lbnQgZGVmaW5pdGlvbnMgb3IgZnVuY3Rpb25zLgovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gZG93bmNhc3RBdHRyaWJ1dGVUb0VsZW1lbnQoY29uZmlnKSB7CiAgY29uZmlnID0gY2xvbmVEZWVwKGNvbmZpZyk7CiAgdmFyIG1vZGVsS2V5ID0gY29uZmlnLm1vZGVsLmtleSA/IGNvbmZpZy5tb2RlbC5rZXkgOiBjb25maWcubW9kZWw7CiAgdmFyIGV2ZW50TmFtZSA9ICdhdHRyaWJ1dGU6JyArIG1vZGVsS2V5OwoKICBpZiAoY29uZmlnLm1vZGVsLm5hbWUpIHsKICAgIGV2ZW50TmFtZSArPSAnOicgKyBjb25maWcubW9kZWwubmFtZTsKICB9CgogIGlmIChjb25maWcubW9kZWwudmFsdWVzKSB7CiAgICB2YXIgX2l0ZXJhdG9yMTQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb25maWcubW9kZWwudmFsdWVzKSwKICAgICAgICBfc3RlcDE0OwoKICAgIHRyeSB7CiAgICAgIGZvciAoX2l0ZXJhdG9yMTQucygpOyAhKF9zdGVwMTQgPSBfaXRlcmF0b3IxNC5uKCkpLmRvbmU7KSB7CiAgICAgICAgdmFyIG1vZGVsVmFsdWUgPSBfc3RlcDE0LnZhbHVlOwogICAgICAgIGNvbmZpZy52aWV3W21vZGVsVmFsdWVdID0gbm9ybWFsaXplVG9FbGVtZW50Q29uZmlnKGNvbmZpZy52aWV3W21vZGVsVmFsdWVdLCAnYXR0cmlidXRlJyk7CiAgICAgIH0KICAgIH0gY2F0Y2ggKGVycikgewogICAgICBfaXRlcmF0b3IxNC5lKGVycik7CiAgICB9IGZpbmFsbHkgewogICAgICBfaXRlcmF0b3IxNC5mKCk7CiAgICB9CiAgfSBlbHNlIHsKICAgIGNvbmZpZy52aWV3ID0gbm9ybWFsaXplVG9FbGVtZW50Q29uZmlnKGNvbmZpZy52aWV3LCAnYXR0cmlidXRlJyk7CiAgfQoKICB2YXIgZWxlbWVudENyZWF0b3IgPSBnZXRGcm9tQXR0cmlidXRlQ3JlYXRvcihjb25maWcpOwogIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2hlcikgewogICAgZGlzcGF0Y2hlci5vbihldmVudE5hbWUsIHdyYXAoZWxlbWVudENyZWF0b3IpLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwogIH07Cn0gLy8gTW9kZWwgYXR0cmlidXRlIHRvIHZpZXcgYXR0cmlidXRlIGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5Eb3duY2FzdEhlbHBlcnMjYXR0cmlidXRlVG9BdHRyaWJ1dGUgYC5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSgpYCBkb3duY2FzdCBoZWxwZXJ9IGZvciBleGFtcGxlcy4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnLm1vZGVsIFRoZSBrZXkgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb252ZXJ0IGZyb20gb3IgYSBgeyBrZXksIHZhbHVlcywgWyBuYW1lIF0gfWAgb2JqZWN0IGRlc2NyaWJpbmcKLy8gdGhlIGF0dHJpYnV0ZSBrZXksIHBvc3NpYmxlIHZhbHVlcyBhbmQsIG9wdGlvbmFsbHksIGFuIGVsZW1lbnQgbmFtZSB0byBjb252ZXJ0IGZyb20uCi8vIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gY29uZmlnLnZpZXcgQSB2aWV3IGF0dHJpYnV0ZSBrZXksIG9yIGEgYHsga2V5LCB2YWx1ZSB9YCBvYmplY3Qgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzCi8vIHRoZSBtb2RlbCBhdHRyaWJ1dGUgdmFsdWUgYW5kIHJldHVybnMgYSBgeyBrZXksIHZhbHVlIH1gIG9iamVjdC4gSWYgYGtleWAgaXMgYCdjbGFzcydgLCBgdmFsdWVgIGNhbiBiZSBhIGBTdHJpbmdgIG9yIGFuCi8vIGFycmF5IG9mIGBTdHJpbmdgcy4gSWYgYGtleWAgaXMgYCdzdHlsZSdgLCBgdmFsdWVgIGlzIGFuIG9iamVjdCB3aXRoIGtleS12YWx1ZSBwYWlycy4gSW4gb3RoZXIgY2FzZXMsIGB2YWx1ZWAgaXMgYSBgU3RyaW5nYC4KLy8gSWYgYGNvbmZpZy5tb2RlbC52YWx1ZXNgIGlzIHNldCwgYGNvbmZpZy52aWV3YCBzaG91bGQgYmUgYW4gb2JqZWN0IGFzc2lnbmluZyB2YWx1ZXMgZnJvbSBgY29uZmlnLm1vZGVsLnZhbHVlc2AgdG8KLy8gYHsga2V5LCB2YWx1ZSB9YCBvYmplY3RzIG9yIGEgZnVuY3Rpb25zLgovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gZG93bmNhc3RBdHRyaWJ1dGVUb0F0dHJpYnV0ZShjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICB2YXIgbW9kZWxLZXkgPSBjb25maWcubW9kZWwua2V5ID8gY29uZmlnLm1vZGVsLmtleSA6IGNvbmZpZy5tb2RlbDsKICB2YXIgZXZlbnROYW1lID0gJ2F0dHJpYnV0ZTonICsgbW9kZWxLZXk7CgogIGlmIChjb25maWcubW9kZWwubmFtZSkgewogICAgZXZlbnROYW1lICs9ICc6JyArIGNvbmZpZy5tb2RlbC5uYW1lOwogIH0KCiAgaWYgKGNvbmZpZy5tb2RlbC52YWx1ZXMpIHsKICAgIHZhciBfaXRlcmF0b3IxNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNvbmZpZy5tb2RlbC52YWx1ZXMpLAogICAgICAgIF9zdGVwMTU7CgogICAgdHJ5IHsKICAgICAgZm9yIChfaXRlcmF0b3IxNS5zKCk7ICEoX3N0ZXAxNSA9IF9pdGVyYXRvcjE1Lm4oKSkuZG9uZTspIHsKICAgICAgICB2YXIgbW9kZWxWYWx1ZSA9IF9zdGVwMTUudmFsdWU7CiAgICAgICAgY29uZmlnLnZpZXdbbW9kZWxWYWx1ZV0gPSBub3JtYWxpemVUb0F0dHJpYnV0ZUNvbmZpZyhjb25maWcudmlld1ttb2RlbFZhbHVlXSk7CiAgICAgIH0KICAgIH0gY2F0Y2ggKGVycikgewogICAgICBfaXRlcmF0b3IxNS5lKGVycik7CiAgICB9IGZpbmFsbHkgewogICAgICBfaXRlcmF0b3IxNS5mKCk7CiAgICB9CiAgfSBlbHNlIHsKICAgIGNvbmZpZy52aWV3ID0gbm9ybWFsaXplVG9BdHRyaWJ1dGVDb25maWcoY29uZmlnLnZpZXcpOwogIH0KCiAgdmFyIGVsZW1lbnRDcmVhdG9yID0gZ2V0RnJvbUF0dHJpYnV0ZUNyZWF0b3IoY29uZmlnKTsKICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsKICAgIGRpc3BhdGNoZXIub24oZXZlbnROYW1lLCBjaGFuZ2VBdHRyaWJ1dGUoZWxlbWVudENyZWF0b3IpLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwogIH07Cn0gLy8gTW9kZWwgbWFya2VyIHRvIHZpZXcgZWxlbWVudCBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+RG93bmNhc3RIZWxwZXJzI21hcmtlclRvRWxlbWVudCBgLm1hcmtlclRvRWxlbWVudCgpYCBkb3duY2FzdCBoZWxwZXJ9IGZvciBleGFtcGxlcy4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubW9kZWwgVGhlIG5hbWUgb2YgdGhlIG1vZGVsIG1hcmtlciAob3IgbW9kZWwgbWFya2VyIGdyb3VwKSB0byBjb252ZXJ0LgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbnxGdW5jdGlvbn0gY29uZmlnLnZpZXcgQSB2aWV3IGVsZW1lbnQgZGVmaW5pdGlvbiBvciBhIGZ1bmN0aW9uCi8vIHRoYXQgdGFrZXMgdGhlIG1vZGVsIG1hcmtlciBkYXRhIGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGEgdmlldyBVSSBlbGVtZW50LgovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gZG93bmNhc3RNYXJrZXJUb0VsZW1lbnQoY29uZmlnKSB7CiAgY29uZmlnID0gY2xvbmVEZWVwKGNvbmZpZyk7CiAgY29uZmlnLnZpZXcgPSBub3JtYWxpemVUb0VsZW1lbnRDb25maWcoY29uZmlnLnZpZXcsICd1aScpOwogIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2hlcikgewogICAgZGlzcGF0Y2hlci5vbignYWRkTWFya2VyOicgKyBjb25maWcubW9kZWwsIGluc2VydFVJRWxlbWVudChjb25maWcudmlldyksIHsKICAgICAgcHJpb3JpdHk6IGNvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eSB8fCAnbm9ybWFsJwogICAgfSk7CiAgICBkaXNwYXRjaGVyLm9uKCdyZW1vdmVNYXJrZXI6JyArIGNvbmZpZy5tb2RlbCwgcmVtb3ZlVUlFbGVtZW50KGNvbmZpZy52aWV3KSwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdub3JtYWwnCiAgICB9KTsKICB9Owp9IC8vIE1vZGVsIG1hcmtlciB0byB2aWV3IGRhdGEgY29udmVyc2lvbiBoZWxwZXIuCi8vCi8vIFNlZSB7QGxpbmsgfkRvd25jYXN0SGVscGVycyNtYXJrZXJUb0RhdGEgYG1hcmtlclRvRGF0YSgpYCBkb3duY2FzdCBoZWxwZXJ9IHRvIGxlYXJuIG1vcmUuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcKLy8gQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5tb2RlbAovLyBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLnZpZXddCi8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb25maWcuY29udmVydGVyUHJpb3JpdHk9J25vcm1hbCddCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gZG93bmNhc3RNYXJrZXJUb0RhdGEoY29uZmlnKSB7CiAgY29uZmlnID0gY2xvbmVEZWVwKGNvbmZpZyk7CiAgdmFyIGdyb3VwID0gY29uZmlnLm1vZGVsOyAvLyBEZWZhdWx0IGNvbnZlcnNpb24uCgogIGlmICghY29uZmlnLnZpZXcpIHsKICAgIGNvbmZpZy52aWV3ID0gZnVuY3Rpb24gKG1hcmtlck5hbWUpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBncm91cDogZ3JvdXAsCiAgICAgICAgbmFtZTogbWFya2VyTmFtZS5zdWJzdHIoY29uZmlnLm1vZGVsLmxlbmd0aCArIDEpCiAgICAgIH07CiAgICB9OwogIH0KCiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7CiAgICBkaXNwYXRjaGVyLm9uKCdhZGRNYXJrZXI6JyArIGdyb3VwLCBpbnNlcnRNYXJrZXJEYXRhKGNvbmZpZy52aWV3KSwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdub3JtYWwnCiAgICB9KTsKICAgIGRpc3BhdGNoZXIub24oJ3JlbW92ZU1hcmtlcjonICsgZ3JvdXAsIHJlbW92ZU1hcmtlckRhdGEoY29uZmlnLnZpZXcpLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwogIH07Cn0gLy8gTW9kZWwgbWFya2VyIHRvIGhpZ2hsaWdodCBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+RG93bmNhc3RIZWxwZXJzI21hcmtlclRvRWxlbWVudCBgLm1hcmtlclRvRWxlbWVudCgpYCBkb3duY2FzdCBoZWxwZXJ9IGZvciBleGFtcGxlcy4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubW9kZWwgVGhlIG5hbWUgb2YgdGhlIG1vZGVsIG1hcmtlciAob3IgbW9kZWwgbWFya2VyIGdyb3VwKSB0byBjb252ZXJ0LgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+SGlnaGxpZ2h0RGVzY3JpcHRvcnxGdW5jdGlvbn0gY29uZmlnLnZpZXcgQSBoaWdobGlnaHQgZGVzY3JpcHRvcgovLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgaGlnaGxpZ2h0aW5nIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgbW9kZWwgbWFya2VyIGRhdGEgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYSBoaWdobGlnaHQgZGVzY3JpcHRvci4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIGRvd25jYXN0TWFya2VyVG9IaWdobGlnaHQoY29uZmlnKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7CiAgICBkaXNwYXRjaGVyLm9uKCdhZGRNYXJrZXI6JyArIGNvbmZpZy5tb2RlbCwgaGlnaGxpZ2h0VGV4dChjb25maWcudmlldyksIHsKICAgICAgcHJpb3JpdHk6IGNvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eSB8fCAnbm9ybWFsJwogICAgfSk7CiAgICBkaXNwYXRjaGVyLm9uKCdhZGRNYXJrZXI6JyArIGNvbmZpZy5tb2RlbCwgaGlnaGxpZ2h0RWxlbWVudChjb25maWcudmlldyksIHsKICAgICAgcHJpb3JpdHk6IGNvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eSB8fCAnbm9ybWFsJwogICAgfSk7CiAgICBkaXNwYXRjaGVyLm9uKCdyZW1vdmVNYXJrZXI6JyArIGNvbmZpZy5tb2RlbCwgcmVtb3ZlSGlnaGxpZ2h0KGNvbmZpZy52aWV3KSwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdub3JtYWwnCiAgICB9KTsKICB9Owp9IC8vIFRha2VzIGBjb25maWcudmlld2AsIGFuZCBpZiBpdCBpcyBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnRkZWZpbml0aW9ufkVsZW1lbnREZWZpbml0aW9ufSwgY29udmVydHMgaXQKLy8gdG8gYSBmdW5jdGlvbiAoYmVjYXVzZSBsb3dlciBsZXZlbCBjb252ZXJ0ZXJzIGFjY2VwdCBvbmx5IGVsZW1lbnQgY3JlYXRvciBmdW5jdGlvbnMpLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbnxGdW5jdGlvbn0gdmlldyBWaWV3IGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7J2NvbnRhaW5lcid8J2F0dHJpYnV0ZSd8J3VpJ30gdmlld0VsZW1lbnRUeXBlIFZpZXcgZWxlbWVudCB0eXBlIHRvIGNyZWF0ZS4KLy8gQHJldHVybnMge0Z1bmN0aW9ufSBFbGVtZW50IGNyZWF0b3IgZnVuY3Rpb24gdG8gdXNlIGluIGxvd2VyIGxldmVsIGNvbnZlcnRlcnMuCgoKZnVuY3Rpb24gbm9ybWFsaXplVG9FbGVtZW50Q29uZmlnKHZpZXcsIHZpZXdFbGVtZW50VHlwZSkgewogIGlmICh0eXBlb2YgdmlldyA9PSAnZnVuY3Rpb24nKSB7CiAgICAvLyBJZiBgdmlld2AgaXMgYWxyZWFkeSBhIGZ1bmN0aW9uLCBkb24ndCBkbyBhbnl0aGluZy4KICAgIHJldHVybiB2aWV3OwogIH0KCiAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlbERhdGEsIGNvbnZlcnNpb25BcGkpIHsKICAgIHJldHVybiBjcmVhdGVWaWV3RWxlbWVudEZyb21EZWZpbml0aW9uKHZpZXcsIGNvbnZlcnNpb25BcGksIHZpZXdFbGVtZW50VHlwZSk7CiAgfTsKfSAvLyBDcmVhdGVzIGEgdmlldyBlbGVtZW50IGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb259IGFuZCBjbGFzcy4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb259IHZpZXdFbGVtZW50RGVmaW5pdGlvbgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlcn0gdmlld1dyaXRlcgovLyBAcGFyYW0geydjb250YWluZXInfCdhdHRyaWJ1dGUnfCd1aSd9IHZpZXdFbGVtZW50VHlwZQovLyBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0KCgpmdW5jdGlvbiBjcmVhdGVWaWV3RWxlbWVudEZyb21EZWZpbml0aW9uKHZpZXdFbGVtZW50RGVmaW5pdGlvbiwgY29udmVyc2lvbkFwaSwgdmlld0VsZW1lbnRUeXBlKSB7CiAgaWYgKHR5cGVvZiB2aWV3RWxlbWVudERlZmluaXRpb24gPT0gJ3N0cmluZycpIHsKICAgIC8vIElmIGB2aWV3RWxlbWVudERlZmluaXRpb25gIGlzIGdpdmVuIGFzIGEgYFN0cmluZ2AsIG5vcm1hbGl6ZSBpdCB0byBhbiBvYmplY3Qgd2l0aCBgbmFtZWAgcHJvcGVydHkuCiAgICB2aWV3RWxlbWVudERlZmluaXRpb24gPSB7CiAgICAgIG5hbWU6IHZpZXdFbGVtZW50RGVmaW5pdGlvbgogICAgfTsKICB9CgogIHZhciBlbGVtZW50OwogIHZhciB2aWV3V3JpdGVyID0gY29udmVyc2lvbkFwaS53cml0ZXI7CiAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3RWxlbWVudERlZmluaXRpb24uYXR0cmlidXRlcyk7CgogIGlmICh2aWV3RWxlbWVudFR5cGUgPT0gJ2NvbnRhaW5lcicpIHsKICAgIGVsZW1lbnQgPSB2aWV3V3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQodmlld0VsZW1lbnREZWZpbml0aW9uLm5hbWUsIGF0dHJpYnV0ZXMpOwogIH0gZWxzZSBpZiAodmlld0VsZW1lbnRUeXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICB2YXIgb3B0aW9ucyA9IHsKICAgICAgcHJpb3JpdHk6IHZpZXdFbGVtZW50RGVmaW5pdGlvbi5wcmlvcml0eSB8fCBWaWV3QXR0cmlidXRlRWxlbWVudC5ERUZBVUxUX1BSSU9SSVRZCiAgICB9OwogICAgZWxlbWVudCA9IHZpZXdXcml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCh2aWV3RWxlbWVudERlZmluaXRpb24ubmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucyk7CiAgfSBlbHNlIHsKICAgIC8vICd1aScuCiAgICBlbGVtZW50ID0gdmlld1dyaXRlci5jcmVhdGVVSUVsZW1lbnQodmlld0VsZW1lbnREZWZpbml0aW9uLm5hbWUsIGF0dHJpYnV0ZXMpOwogIH0KCiAgaWYgKHZpZXdFbGVtZW50RGVmaW5pdGlvbi5zdHlsZXMpIHsKICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmlld0VsZW1lbnREZWZpbml0aW9uLnN0eWxlcyk7CgogICAgZm9yICh2YXIgX2kzID0gMCwgX2tleXM0ID0ga2V5czsgX2kzIDwgX2tleXM0Lmxlbmd0aDsgX2kzKyspIHsKICAgICAgdmFyIGtleSA9IF9rZXlzNFtfaTNdOwogICAgICB2aWV3V3JpdGVyLnNldFN0eWxlKGtleSwgdmlld0VsZW1lbnREZWZpbml0aW9uLnN0eWxlc1trZXldLCBlbGVtZW50KTsKICAgIH0KICB9CgogIGlmICh2aWV3RWxlbWVudERlZmluaXRpb24uY2xhc3NlcykgewogICAgdmFyIGNsYXNzZXMgPSB2aWV3RWxlbWVudERlZmluaXRpb24uY2xhc3NlczsKCiAgICBpZiAodHlwZW9mIGNsYXNzZXMgPT0gJ3N0cmluZycpIHsKICAgICAgdmlld1dyaXRlci5hZGRDbGFzcyhjbGFzc2VzLCBlbGVtZW50KTsKICAgIH0gZWxzZSB7CiAgICAgIHZhciBfaXRlcmF0b3IxNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNsYXNzZXMpLAogICAgICAgICAgX3N0ZXAxNjsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IxNi5zKCk7ICEoX3N0ZXAxNiA9IF9pdGVyYXRvcjE2Lm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBfc3RlcDE2LnZhbHVlOwogICAgICAgICAgdmlld1dyaXRlci5hZGRDbGFzcyhjbGFzc05hbWUsIGVsZW1lbnQpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMTYuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvcjE2LmYoKTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIGVsZW1lbnQ7Cn0KCmZ1bmN0aW9uIGdldEZyb21BdHRyaWJ1dGVDcmVhdG9yKGNvbmZpZykgewogIGlmIChjb25maWcubW9kZWwudmFsdWVzKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGVsQXR0cmlidXRlVmFsdWUsIGNvbnZlcnNpb25BcGkpIHsKICAgICAgdmFyIHZpZXcgPSBjb25maWcudmlld1ttb2RlbEF0dHJpYnV0ZVZhbHVlXTsKCiAgICAgIGlmICh2aWV3KSB7CiAgICAgICAgcmV0dXJuIHZpZXcobW9kZWxBdHRyaWJ1dGVWYWx1ZSwgY29udmVyc2lvbkFwaSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfTsKICB9IGVsc2UgewogICAgcmV0dXJuIGNvbmZpZy52aWV3OwogIH0KfSAvLyBUYWtlcyB0aGUgY29uZmlndXJhdGlvbiwgYWRkcyBkZWZhdWx0IHBhcmFtZXRlcnMgaWYgdGhleSBkbyBub3QgZXhpc3QgYW5kIG5vcm1hbGl6ZXMgb3RoZXIgcGFyYW1ldGVycyB0byBiZSB1c2VkIGluIGRvd25jYXN0IGNvbnZlcnRlcnMKLy8gZm9yIGdlbmVyYXRpbmcgYSB2aWV3IGF0dHJpYnV0ZS4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IHZpZXcgVmlldyBjb25maWd1cmF0aW9uLgoKCmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXR0cmlidXRlQ29uZmlnKHZpZXcpIHsKICBpZiAodHlwZW9mIHZpZXcgPT0gJ3N0cmluZycpIHsKICAgIHJldHVybiBmdW5jdGlvbiAobW9kZWxBdHRyaWJ1dGVWYWx1ZSkgewogICAgICByZXR1cm4gewogICAgICAgIGtleTogdmlldywKICAgICAgICB2YWx1ZTogbW9kZWxBdHRyaWJ1dGVWYWx1ZQogICAgICB9OwogICAgfTsKICB9IGVsc2UgaWYgKF90eXBlb2YodmlldykgPT0gJ29iamVjdCcpIHsKICAgIC8vIHsga2V5LCB2YWx1ZSwgLi4uIH0KICAgIGlmICh2aWV3LnZhbHVlKSB7CiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIHZpZXc7CiAgICAgIH07CiAgICB9IC8vIHsga2V5LCAuLi4gfQogICAgZWxzZSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlbEF0dHJpYnV0ZVZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBrZXk6IHZpZXcua2V5LAogICAgICAgICAgICB2YWx1ZTogbW9kZWxBdHRyaWJ1dGVWYWx1ZQogICAgICAgICAgfTsKICAgICAgICB9OwogICAgICB9CiAgfSBlbHNlIHsKICAgIC8vIGZ1bmN0aW9uLgogICAgcmV0dXJuIHZpZXc7CiAgfQp9IC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgYGhpZ2hsaWdodGAuIFByZXBhcmVzIHRoZSBhY3R1YWwgZGVzY3JpcHRvciBvYmplY3QgdXNpbmcgdmFsdWUgcGFzc2VkIHRvIHRoZSBjb252ZXJ0ZXIuCgoKZnVuY3Rpb24gcHJlcGFyZURlc2NyaXB0b3IoaGlnaGxpZ2h0RGVzY3JpcHRvciwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogIC8vIElmIHBhc3NlZCBkZXNjcmlwdG9yIGlzIGEgY3JlYXRvciBmdW5jdGlvbiwgY2FsbCBpdC4gSWYgbm90LCBqdXN0IHVzZSBwYXNzZWQgdmFsdWUuCiAgdmFyIGRlc2NyaXB0b3IgPSB0eXBlb2YgaGlnaGxpZ2h0RGVzY3JpcHRvciA9PSAnZnVuY3Rpb24nID8gaGlnaGxpZ2h0RGVzY3JpcHRvcihkYXRhLCBjb252ZXJzaW9uQXBpKSA6IGhpZ2hsaWdodERlc2NyaXB0b3I7CgogIGlmICghZGVzY3JpcHRvcikgewogICAgcmV0dXJuIG51bGw7CiAgfSAvLyBBcHBseSBkZWZhdWx0IGRlc2NyaXB0b3IgcHJpb3JpdHkuCgoKICBpZiAoIWRlc2NyaXB0b3IucHJpb3JpdHkpIHsKICAgIGRlc2NyaXB0b3IucHJpb3JpdHkgPSAxMDsKICB9IC8vIERlZmF1bHQgZGVzY3JpcHRvciBpZCBpcyBtYXJrZXIgbmFtZS4KCgogIGlmICghZGVzY3JpcHRvci5pZCkgewogICAgZGVzY3JpcHRvci5pZCA9IGRhdGEubWFya2VyTmFtZTsKICB9CgogIHJldHVybiBkZXNjcmlwdG9yOwp9Ci8qKgogKiBBbiBvYmplY3QgZGVzY3JpYmluZyBob3cgdGhlIG1hcmtlciBoaWdobGlnaHQgc2hvdWxkIGJlIHJlcHJlc2VudGVkIGluIHRoZSB2aWV3LgogKgogKiBFYWNoIHRleHQgbm9kZSBjb250YWluZWQgaW4gYSBoaWdobGlnaHRlZCByYW5nZSB3aWxsIGJlIHdyYXBwZWQgaW4gYSBgPHNwYW4+YAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCB2aWV3IGF0dHJpYnV0ZSBlbGVtZW50fSB3aXRoIENTUyBjbGFzcyhlcyksIGF0dHJpYnV0ZXMgYW5kIGEgcHJpb3JpdHkKICogZGVzY3JpYmVkIGJ5IHRoaXMgb2JqZWN0LgogKgogKiBBZGRpdGlvbmFsbHksIGVhY2gge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgY29udGFpbmVyIGVsZW1lbnR9IGNhbiBoYW5kbGUgZGlzcGxheWluZyB0aGUgaGlnaGxpZ2h0CiAqIHNlcGFyYXRlbHkgYnkgcHJvdmlkaW5nIHRoZSBgYWRkSGlnaGxpZ2h0YCBhbmQgYHJlbW92ZUhpZ2hsaWdodGAgY3VzdG9tIHByb3BlcnRpZXMuIEluIHRoaXMgY2FzZToKICoKICogICogVGhlIGBIaWdobGlnaHREZXNjcmlwdG9yYCBvYmplY3QgaXMgcGFzc2VkIHRvIHRoZSBgYWRkSGlnaGxpZ2h0YCBmdW5jdGlvbiB1cG9uIGNvbnZlcnNpb24gYW5kIHNob3VsZCBiZSB1c2VkIHRvIGFwcGx5IHRoZSBoaWdobGlnaHQgdG8KICogIHRoZSBlbGVtZW50LgogKiAgKiBUaGUgZGVzY3JpcHRvciBgaWRgIGlzIHBhc3NlZCB0byB0aGUgYHJlbW92ZUhpZ2hsaWdodGAgZnVuY3Rpb24gdXBvbiBjb252ZXJzaW9uIGFuZCBzaG91bGQgYmUgdXNlZCB0byByZW1vdmUgdGhlIGhpZ2hsaWdodCB3aXRoIHRoZQogKiAgZ2l2ZW4gSUQgZnJvbSB0aGUgZWxlbWVudC4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yCiAqCiAqIEBwcm9wZXJ0eSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjbGFzc2VzIEEgQ1NTIGNsYXNzIG9yIGFuIGFycmF5IG9mIGNsYXNzZXMgdG8gc2V0LiBJZiB0aGUgZGVzY3JpcHRvciBpcyB1c2VkIHRvCiAqIGNyZWF0ZSBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudH0gb3ZlciB0ZXh0IG5vZGVzLCB0aGVzZSBjbGFzc2VzIHdpbGwgYmUgc2V0CiAqIG9uIHRoYXQgYXR0cmlidXRlIGVsZW1lbnQuIElmIHRoZSBkZXNjcmlwdG9yIGlzIGFwcGxpZWQgdG8gYW4gZWxlbWVudCwgdXN1YWxseSB0aGVzZSBjbGFzc2VzIHdpbGwgYmUgc2V0IG9uIHRoYXQgZWxlbWVudCwgaG93ZXZlciwKICogdGhpcyBkZXBlbmRzIG9uIGhvdyB0aGUgZWxlbWVudCBjb252ZXJ0cyB0aGUgZGVzY3JpcHRvci4KICoKICogQHByb3BlcnR5IHtTdHJpbmd9IFtpZF0gRGVzY3JpcHRvciBpZGVudGlmaWVyLiBJZiBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIHRoZSBjb252ZXJ0ZWQgbWFya2VyJ3MgbmFtZS4KICoKICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwcmlvcml0eV0gRGVzY3JpcHRvciBwcmlvcml0eS4gSWYgbm90IHByb3ZpZGVkLCBpdCBkZWZhdWx0cyB0byBgMTBgLiBJZiB0aGUgZGVzY3JpcHRvciBpcyB1c2VkIHRvIGNyZWF0ZQogKiBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudH0sIGl0IHdpbGwgYmUgdGhhdCBlbGVtZW50J3MKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjcHJpb3JpdHkgcHJpb3JpdHl9LiBJZiB0aGUgZGVzY3JpcHRvciBpcyBhcHBsaWVkIHRvIGFuIGVsZW1lbnQsCiAqIHRoZSBwcmlvcml0eSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGRlc2NyaXB0b3IgaXMgbW9yZSBpbXBvcnRhbnQuCiAqCiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYXR0cmlidXRlc10gQXR0cmlidXRlcyB0byBzZXQuIElmIHRoZSBkZXNjcmlwdG9yIGlzIHVzZWQgdG8gY3JlYXRlCiAqIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50fSBvdmVyIHRleHQgbm9kZXMsIHRoZXNlIGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgb24gdGhhdAogKiBhdHRyaWJ1dGUgZWxlbWVudC4gSWYgdGhlIGRlc2NyaXB0b3IgaXMgYXBwbGllZCB0byBhbiBlbGVtZW50LCB1c3VhbGx5IHRoZXNlIGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgb24gdGhhdCBlbGVtZW50LCBob3dldmVyLAogKiB0aGlzIGRlcGVuZHMgb24gaG93IHRoZSBlbGVtZW50IGNvbnZlcnRzIHRoZSBkZXNjcmlwdG9yLgogKi8="},{"version":3,"sources":["/home/ekeberat/Yandex.Disk/Projelerim/BenimProjelerim/websitem/websitem-web/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js"],"names":["ModelRange","ModelSelection","ModelElement","ViewAttributeElement","DocumentSelection","ConversionHelpers","cloneDeep","CKEditorError","toArray","DowncastHelpers","config","add","downcastElementToElement","downcastAttributeToElement","downcastAttributeToAttribute","downcastMarkerToElement","downcastMarkerToHighlight","downcastMarkerToData","insertText","evt","data","conversionApi","consumable","consume","item","viewWriter","writer","viewPosition","mapper","toViewPosition","range","start","viewText","createText","insert","remove","viewStart","position","modelEnd","getShiftedBy","length","viewEnd","isPhantom","viewRange","createRange","removed","getTrimmed","createRangeIn","getItems","child","unbindViewElement","createViewElementFromHighlightDescriptor","descriptor","viewElement","createAttributeElement","attributes","classes","_addClass","priority","_priority","_id","id","convertRangeSelection","selection","isCollapsed","viewRanges","getRanges","toViewRange","push","setSelection","backward","isBackward","convertCollapsedSelection","modelPosition","getFirstPosition","brokenPosition","breakAttributes","clearAttributes","viewSelection","document","end","parent","isAttached","mergeAttributes","wrap","elementCreator","oldViewElement","attributeOldValue","newViewElement","attributeNewValue","name","getFirstRange","unwrap","insertElement","bindElements","insertUIElement","isOpening","viewStartElement","viewEndElement","markerRange","value","bindElementToMarker","markerName","stop","removeUIElement","elements","markerNameToElements","element","unbindElementFromMarkerName","clear","createRangeOn","clearClonedElementsGroup","insertMarkerData","viewCreator","viewMarkerData","handleMarkerBoundary","isStart","canInsertElement","schema","checkChild","insertMarkerAsElement","modelElement","isBefore","nodeAfter","nodeBefore","toViewElement","insertMarkerAsAttribute","attributeName","group","markerNames","hasAttribute","getAttribute","split","unshift","setAttribute","join","viewElementName","attrs","createUIElement","removeMarkerData","viewData","is","removeMarkerFromAttribute","Set","delete","size","removeAttribute","Array","from","changeAttribute","attributeCreator","oldAttribute","newAttribute","key","className","removeClass","keys","Object","removeStyle","addClass","setStyle","highlightText","highlightDescriptor","prepareDescriptor","rangeAfterWrap","isSimilar","highlightElement","test","getCustomProperty","_createIn","removeHighlight","viewHighlightElement","view","normalizeToElementConfig","dispatcher","on","model","converterPriority","triggerBy","attributeKey","_mapReconversionTriggerEvent","children","childName","modelKey","eventName","values","modelValue","getFromAttributeCreator","normalizeToAttributeConfig","substr","viewElementType","modelData","createViewElementFromDefinition","viewElementDefinition","assign","createContainerElement","options","DEFAULT_PRIORITY","styles","modelAttributeValue"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,gBAAvB;AACA,OAAOC,cAAP,MAA2B,oBAA3B;AACA,OAAOC,YAAP,MAAyB,kBAAzB;AAEA,OAAOC,oBAAP,MAAiC,0BAAjC;AACA,OAAOC,iBAAP,MAA8B,4BAA9B;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;AAEA,SAASC,SAAT,QAA0B,WAA1B;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,OAAP,MAAoB,uCAApB;AAEA;AACA;AACA;AACA;AACA;;IACqBC,e;;;;;;;;;;;;;;AACpB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,8BAAkBC,MAAlB,EAA2B;AAC1B,aAAO,KAAKC,GAAL,CAAUC,wBAAwB,CAAEF,MAAF,CAAlC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,4BAAoBA,MAApB,EAA6B;AAC5B,aAAO,KAAKC,GAAL,CAAUE,0BAA0B,CAAEH,MAAF,CAApC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,8BAAsBA,MAAtB,EAA+B;AAC9B,aAAO,KAAKC,GAAL,CAAUG,4BAA4B,CAAEJ,MAAF,CAAtC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,yBAAiBA,MAAjB,EAA0B;AACzB,aAAO,KAAKC,GAAL,CAAUI,uBAAuB,CAAEL,MAAF,CAAjC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,2BAAmBA,MAAnB,EAA4B;AAC3B,aAAO,KAAKC,GAAL,CAAUK,yBAAyB,CAAEN,MAAF,CAAnC,CAAP;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACC,sBAAcA,MAAd,EAAuB;AACtB,aAAO,KAAKC,GAAL,CAAUM,oBAAoB,CAAEP,MAAF,CAA9B,CAAP;AACA;;;;EAve2CL,iB;AA0e7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;SAnfqBI,e;AAofrB,OAAO,SAASS,UAAT,GAAsB;AAC5B,SAAO,UAAEC,GAAF,EAAOC,IAAP,EAAaC,aAAb,EAAgC;AACtC,QAAK,CAACA,aAAa,CAACC,UAAd,CAAyBC,OAAzB,CAAkCH,IAAI,CAACI,IAAvC,EAA6C,QAA7C,CAAN,EAAgE;AAC/D;AACA;;AAED,QAAMC,UAAU,GAAGJ,aAAa,CAACK,MAAjC;AACA,QAAMC,YAAY,GAAGN,aAAa,CAACO,MAAd,CAAqBC,cAArB,CAAqCT,IAAI,CAACU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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\n\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelElement from '../model/element';\n\nimport ViewAttributeElement from '../view/attributeelement';\nimport DocumentSelection from '../model/documentselection';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n\n/**\n * Downcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class DowncastHelpers extends ConversionHelpers {\n\t/**\n\t * Model element to view element conversion helper.\n\t *\n\t * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'p'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'div',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'fancyParagraph',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'heading',\n\t *\t\t\tview: ( modelElement, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The element-to-element conversion supports the reconversion mechanism. This is helpful in the conversion to complex view structures\n\t * where multiple atomic element-to-element and attribute-to-attribute or attribute-to-element could be used. By specifying\n\t * `triggerBy()` events you can trigger reconverting the model to full view tree structures at once.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'complex',\n\t *\t\t\tview: ( modelElement, conversionApi ) => createComplexViewFromModel( modelElement, conversionApi ),\n\t *\t\t\ttriggerBy: {\n\t *\t\t\t\tattributes: [ 'foo', 'bar' ],\n\t *\t\t\t\tchildren: [ 'slot' ]\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * You can read more about element-to-element conversion in the\n\t * {@glink framework/guides/deep-dive/conversion/custom-element-conversion Custom element conversion} guide.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model element to convert.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n\t * that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as parameters and returns a view container element.\n\t * @param {Object} [config.triggerBy] Reconversion triggers. At least one trigger must be defined.\n\t * @param {Array.<String>} config.triggerBy.attributes The name of the element's attributes whose change will trigger element\n\t * reconversion.\n\t * @param {Array.<String>} config.triggerBy.children The name of direct children whose adding or removing will trigger element\n\t * reconversion.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( downcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * Model attribute to view element conversion helper.\n\t *\n\t * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n\t * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'strong'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'b',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'invert',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalues: [ 'big', 'small' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tbig: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '1.2em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '0.8em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createAttributeElement( 'span', {\n\t *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'color',\n\t *\t\t\t\tname: '$text'\n\t *\t\t\t},\n\t *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createAttributeElement( 'span', {\n\t *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n\t * of `String`s with possible values if the model attribute is an enumerable.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n\t * that takes the model attribute value and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n\t * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`\n\t * to view element definitions or functions.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tattributeToElement( config ) {\n\t\treturn this.add( downcastAttributeToElement( config ) );\n\t}\n\n\t/**\n\t * Model attribute to view attribute conversion helper.\n\t *\n\t * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n\t * `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>`.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tview: 'src'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tview: 'href',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'source'\n\t *\t\t\t},\n\t *\t\t\tview: 'src'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'styled',\n\t *\t\t\t\tvalues: [ 'dark', 'light' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tdark: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n\t *\t\t\t\t},\n\t *\t\t\t\tlight: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'styled',\n\t *\t\t\tview: modelAttributeValue => ( {\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: 'styled-' + modelAttributeValue\n\t *\t\t\t} )\n\t *\t\t} );\n\t *\n\t * **Note**: Downcasting to a style property requires providing `value` as an object:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'lineHeight',\n\t *\t\t\tview: modelAttributeValue => ( {\n\t *\t\t\t\tkey: 'style',\n\t *\t\t\t\tvalue: {\n\t *\t\t\t\t\t'line-height': modelAttributeValue,\n\t *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n\t *\t\t\t\t}\n\t *\t\t\t} )\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n\t * the attribute key, possible values and, optionally, an element name to convert from.\n\t * @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n\t * the model attribute value and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as parameters and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n\t * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n\t * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n\t * `{ key, value }` objects or a functions.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( downcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * Model marker to view element conversion helper.\n\t *\n\t * **Note**: This method should be used only for editing downcast. For data downcast, use\n\t * {@link #markerToData `#markerToData()`} that produces valid HTML data.\n\t *\n\t * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n\t * is collapsed, only one element is created. For example, model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n\t * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: 'marker-search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: 'search-result',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: ( markerData, conversionApi ) => {\n\t *\t\t\t\tconst { writer } = conversionApi;\n\t *\n\t *\t\t\t\treturn writer.createUIElement( 'span', {\n\t *\t\t\t\t\t'data-marker': 'search',\n\t *\t\t\t\t\t'data-start': markerData.isOpening\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n\t * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as a parameters and should return an instance of the\n\t * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n\t * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` to\n\t * the marker end boundary element.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function that\n\t * takes the model marker data and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as a parameters and returns a view UI element.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToElement( config ) {\n\t\treturn this.add( downcastMarkerToElement( config ) );\n\t}\n\n\t/**\n\t * Model marker to highlight conversion helper.\n\t *\n\t * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n\t * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n\t *\n\t * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n\t * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n\t * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n\t *\n\t * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n\t * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n\t * For example, a model marker set like this: `[<image src=\"foo.jpg\"></image>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>`\n\t * in the view.\n\t *\n\t * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n\t * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n\t * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n\t *\t\t\tmodel: 'comment',\n\t *\t\t\tview: { classes: 'comment' },\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n\t *\t\t\tmodel: 'comment',\n\t *\t\t\tview: ( data, conversionApi ) => {\n\t *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType:commentId.\n\t *\t\t\t\tconst [ , commentType, commentId ] = data.markerName.split( ':' );\n\t *\n\t *\t\t\t\treturn {\n\t *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ],\n\t *\t\t\t\t\tattributes: { 'data-comment-id': commentId }\n\t *\t\t\t\t};\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n\t * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n\t * as a parameters and should return a\n\t * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n\t * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToHighlight\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n\t * that will be used for highlighting or a function that takes the model marker data and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters\n\t * and returns a highlight descriptor.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToHighlight( config ) {\n\t\treturn this.add( downcastMarkerToHighlight( config ) );\n\t}\n\n\t/**\n\t * Model marker converter for data downcast.\n\t *\n\t * This conversion creates a representation for model marker boundaries in the view:\n\t *\n\t * * If the marker boundary is at a position where text nodes are allowed, then a view element with the specified tag name\n\t * and `name` attribute is added at this position.\n\t * * In other cases, a specified attribute is set on a view element that is before or after the marker boundary.\n\t *\n\t * Typically, marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.\n\t * The default configuration for this conversion is that the first part is the `group` part and the rest of\n\t * the marker name becomes the `name` part.\n\t *\n\t * Tag and attribute names and values are generated from the marker name:\n\t *\n\t * * Templates for attributes are `data-[group]-start-before=\"[name]\"`, `data-[group]-start-after=\"[name]\"`,\n\t * `data-[group]-end-before=\"[name]\"` and `data-[group]-end-after=\"[name]\"`.\n\t * * Templates for view elements are `<[group]-start name=\"[name]\">` and `<[group]-end name=\"[name]\">`.\n\t *\n\t * Attributes mark whether the given marker's start or end boundary is before or after the given element.\n\t * Attributes `data-[group]-start-before` and `data-[group]-end-after` are favored.\n\t * The other two are used when the former two cannot be used.\n\t *\n\t * The conversion configuration can take a function that will generate different group and name parts.\n\t * If such function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two\n\t * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.\n\t *\n\t * Basic usage:\n\t *\n\t *\t\t// Using the default conversion.\n\t *\t\t// In this case, all markers whose name starts with 'comment:' will be converted.\n\t *\t\t// The `group` parameter will be set to `comment`.\n\t *\t\t// The `name` parameter will be the rest of the marker name (without `:`).\n\t *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n\t *\t\t\tmodel: 'comment'\n\t *\t\t} );\n\t *\n\t * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked\n\t * by `[]`):\n\t *\n\t *\t\t// Model:\n\t *\t\t<paragraph>Foo[bar</paragraph>\n\t *\t\t<image src=\"abc.jpg\"></image>]\n\t *\n\t *\t\t// View:\n\t *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n\t *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n\t *\n\t * In the example above, the comment starts before \"bar\" and ends after the image.\n\t *\n\t * If the `name` part is empty, the following view may be generated:\n\t *\n\t *\t\t<p>Foo <myMarker-start></myMarker-start>bar</p>\n\t *\t\t<figure data-myMarker-end-after=\"\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n\t *\n\t * **Note:** A situation where some markers have the `name` part and some do not have it is incorrect and should be avoided.\n\t *\n\t * Examples where `data-group-start-after` and `data-group-end-before` are used:\n\t *\n\t *\t\t// Model:\n\t *\t\t<blockQuote>[]<paragraph>Foo</paragraph></blockQuote>\n\t *\n\t * \t\t// View:\n\t *\t\t<blockquote><p data-group-end-before=\"name\" data-group-start-before=\"name\">Foo</p></blockquote>\n\t *\n\t * Similarly, when a marker is collapsed after the last element:\n\t *\n\t *\t\t// Model:\n\t *\t\t<blockQuote><paragraph>Foo</paragraph>[]</blockQuote>\n\t *\n\t *\t\t// View:\n\t *\t\t<blockquote><p data-group-end-after=\"name\" data-group-start-after=\"name\">Foo</p></blockquote>\n\t *\n\t * When there are multiple markers from the same group stored in the same attribute of the same element, their\n\t * name parts are put together in the attribute value, for example: `data-group-start-before=\"name1,name2,name3\"`.\n\t *\n\t * Other examples of usage:\n\t *\n\t *\t\t// Using a custom function which is the same as the default conversion:\n\t *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n\t *\t\t\tmodel: 'comment'\n\t *\t\t\tview: markerName => ( {\n\t *\t\t\t\tgroup: 'comment',\n\t *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n\t *\t\t\t} )\n\t *\t\t} );\n\t *\n\t *\t\t// Using the converter priority:\n\t *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n\t *\t\t\tmodel: 'comment'\n\t *\t\t\tview: markerName => ( {\n\t *\t\t\t\tgroup: 'comment',\n\t *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n\t *\t\t\t} ),\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToData\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {Function} [config.view] A function that takes the model marker name and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters\n\t * and returns an object with the `group` and `name` properties.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToData( config ) {\n\t\treturn this.add( downcastMarkerToData( config ) );\n\t}\n}\n\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\nexport function insertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\t\tconst viewText = viewWriter.createText( data.item.data );\n\n\t\tviewWriter.insert( viewPosition, viewText );\n\t};\n}\n\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\nexport function remove() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Find view range start position by mapping model position at which the remove happened.\n\t\tconst viewStart = conversionApi.mapper.toViewPosition( data.position );\n\n\t\tconst modelEnd = data.position.getShiftedBy( data.length );\n\t\tconst viewEnd = conversionApi.mapper.toViewPosition( modelEnd, { isPhantom: true } );\n\n\t\tconst viewRange = conversionApi.writer.createRange( viewStart, viewEnd );\n\n\t\t// Trim the range to remove in case some UI elements are on the view range boundaries.\n\t\tconst removed = conversionApi.writer.remove( viewRange.getTrimmed() );\n\n\t\t// After the range is removed, unbind all view elements from the model.\n\t\t// Range inside view document fragment is used to unbind deeply.\n\t\tfor ( const child of conversionApi.writer.createRangeIn( removed ).getItems() ) {\n\t\t\tconversionApi.mapper.unbindViewElement( child );\n\t\t}\n\t};\n}\n\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If a priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\nexport function createViewElementFromHighlightDescriptor( writer, descriptor ) {\n\tconst viewElement = writer.createAttributeElement( 'span', descriptor.attributes );\n\n\tif ( descriptor.classes ) {\n\t\tviewElement._addClass( descriptor.classes );\n\t}\n\n\tif ( descriptor.priority ) {\n\t\tviewElement._priority = descriptor.priority;\n\t}\n\n\tviewElement._id = descriptor.id;\n\n\treturn viewElement;\n}\n\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\nexport function convertRangeSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( const range of selection.getRanges() ) {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( range );\n\t\t\tviewRanges.push( viewRange );\n\t\t}\n\n\t\tconversionApi.writer.setSelection( viewRanges, { backward: selection.isBackward } );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\nexport function convertCollapsedSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst modelPosition = selection.getFirstPosition();\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( modelPosition );\n\t\tconst brokenPosition = viewWriter.breakAttributes( viewPosition );\n\n\t\tviewWriter.setSelection( brokenPosition );\n\t};\n}\n\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\nexport function clearAttributes() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t// Not collapsed selection should not have artifacts.\n\t\t\tif ( range.isCollapsed ) {\n\t\t\t\t// Position might be in the node removed by the view writer.\n\t\t\t\tif ( range.end.parent.isAttached() ) {\n\t\t\t\t\tconversionApi.writer.mergeAttributes( range.start );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tviewWriter.setSelection( null );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, { writer } ) => {\n *\t\t\treturn writer.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\nexport function wrap( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n\t\t// or the attribute was removed.\n\t\tconst oldViewElement = elementCreator( data.attributeOldValue, conversionApi );\n\n\t\t// Create node to wrap with.\n\t\tconst newViewElement = elementCreator( data.attributeNewValue, conversionApi );\n\n\t\tif ( !oldViewElement && !newViewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\t// Selection attribute conversion.\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), newViewElement );\n\t\t} else {\n\t\t\t// Node attribute conversion.\n\t\t\tlet viewRange = conversionApi.mapper.toViewRange( data.range );\n\n\t\t\t// First, unwrap the range from current wrapper.\n\t\t\tif ( data.attributeOldValue !== null && oldViewElement ) {\n\t\t\t\tviewRange = viewWriter.unwrap( viewRange, oldViewElement );\n\t\t\t}\n\n\t\t\tif ( data.attributeNewValue !== null && newViewElement ) {\n\t\t\t\tviewWriter.wrap( viewRange, newViewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list, stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}) and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, { writer } ) => {\n *\t\t\t\tconst text = writer.createText( 'myText' );\n *\t\t\t\tconst myElem = writer.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewElement = elementCreator( data.item, conversionApi );\n\n\t\tif ( !viewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n\t\tconversionApi.writer.insert( viewPosition, viewElement );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertUIElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Create two view elements. One will be inserted at the beginning of marker, one at the end.\n\t\t// If marker is collapsed, only \"opening\" element will be inserted.\n\t\tdata.isOpening = true;\n\t\tconst viewStartElement = elementCreator( data, conversionApi );\n\n\t\tdata.isOpening = false;\n\t\tconst viewEndElement = elementCreator( data, conversionApi );\n\n\t\tif ( !viewStartElement || !viewEndElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst markerRange = data.markerRange;\n\n\t\t// Marker that is collapsed has consumable build differently that non-collapsed one.\n\t\t// For more information see `addMarker` event description.\n\t\t// If marker's range is collapsed - check if it can be consumed.\n\t\tif ( markerRange.isCollapsed && !conversionApi.consumable.consume( markerRange, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If marker's range is not collapsed - consume all items inside.\n\t\tfor ( const value of markerRange ) {\n\t\t\tif ( !conversionApi.consumable.consume( value.item, evt.name ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst mapper = conversionApi.mapper;\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// Add \"opening\" element.\n\t\tviewWriter.insert( mapper.toViewPosition( markerRange.start ), viewStartElement );\n\t\tconversionApi.mapper.bindElementToMarker( viewStartElement, data.markerName );\n\n\t\t// Add \"closing\" element only if range is not collapsed.\n\t\tif ( !markerRange.isCollapsed ) {\n\t\t\tviewWriter.insert( mapper.toViewPosition( markerRange.end ), viewEndElement );\n\t\t\tconversionApi.mapper.bindElementToMarker( viewEndElement, data.markerName );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n// Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// based on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\nfunction removeUIElement() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\t\t\tconversionApi.writer.clear( conversionApi.writer.createRangeOn( element ), element );\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\t};\n}\n\n// Function factory that creates a default converter for model markers.\n//\n// See {@link DowncastHelpers#markerToData} for more information what type of view is generated.\n//\n// This converter binds created UI elements and affected view elements with the marker name\n// using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n//\n// @returns {Function} Add marker converter.\nfunction insertMarkerData( viewCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewMarkerData = viewCreator( data.markerName, conversionApi );\n\n\t\tif ( !viewMarkerData ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst markerRange = data.markerRange;\n\n\t\tif ( !conversionApi.consumable.consume( markerRange, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Adding closing data first to keep the proper order in the view.\n\t\thandleMarkerBoundary( markerRange, false, conversionApi, data, viewMarkerData );\n\t\thandleMarkerBoundary( markerRange, true, conversionApi, data, viewMarkerData );\n\n\t\tevt.stop();\n\t};\n}\n\n// Helper function for `insertMarkerData()` that marks a marker boundary at the beginning or end of given `range`.\nfunction handleMarkerBoundary( range, isStart, conversionApi, data, viewMarkerData ) {\n\tconst modelPosition = isStart ? range.start : range.end;\n\tconst canInsertElement = conversionApi.schema.checkChild( modelPosition, '$text' );\n\n\tif ( canInsertElement ) {\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( modelPosition );\n\n\t\tinsertMarkerAsElement( viewPosition, isStart, conversionApi, data, viewMarkerData );\n\t} else {\n\t\tlet modelElement;\n\t\tlet isBefore;\n\n\t\t// If possible, we want to add `data-group-start-before` and `data-group-end-after` attributes.\n\t\t// Below `if` is constructed in a way that will favor adding these attributes.\n\t\t//\n\t\t// Also, I assume that there will be always an element either after or before the position.\n\t\t// If not, then it is a case when we are not in a position where text is allowed and also there are no elements around...\n\t\tif ( isStart && modelPosition.nodeAfter || !isStart && !modelPosition.nodeBefore ) {\n\t\t\tmodelElement = modelPosition.nodeAfter;\n\t\t\tisBefore = true;\n\t\t} else {\n\t\t\tmodelElement = modelPosition.nodeBefore;\n\t\t\tisBefore = false;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( modelElement );\n\n\t\tinsertMarkerAsAttribute( viewElement, isStart, isBefore, conversionApi, data, viewMarkerData );\n\t}\n}\n\n// Helper function for `insertMarkerData()` that marks a marker boundary in the view as an attribute on a view element.\nfunction insertMarkerAsAttribute( viewElement, isStart, isBefore, conversionApi, data, viewMarkerData ) {\n\tconst attributeName = `data-${ viewMarkerData.group }-${ isStart ? 'start' : 'end' }-${ isBefore ? 'before' : 'after' }`;\n\n\tconst markerNames = viewElement.hasAttribute( attributeName ) ? viewElement.getAttribute( attributeName ).split( ',' ) : [];\n\n\t// Adding marker name at the beginning to have the same order in the attribute as there is with marker elements.\n\tmarkerNames.unshift( viewMarkerData.name );\n\n\tconversionApi.writer.setAttribute( attributeName, markerNames.join( ',' ), viewElement );\n\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n}\n\n// Helper function for `insertMarkerData()` that marks a marker boundary in the view as a separate view ui element.\nfunction insertMarkerAsElement( position, isStart, conversionApi, data, viewMarkerData ) {\n\tconst viewElementName = `${ viewMarkerData.group }-${ isStart ? 'start' : 'end' }`;\n\n\tconst attrs = viewMarkerData.name ? { 'name': viewMarkerData.name } : null;\n\tconst viewElement = conversionApi.writer.createUIElement( viewElementName, attrs );\n\n\tconversionApi.writer.insert( position, viewElement );\n\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n}\n\n// Function factory that creates a converter for removing a model marker data added by the {@link #insertMarkerData} converter.\n//\n// @returns {Function} Remove marker converter.\nfunction removeMarkerData( viewCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewData = viewCreator( data.markerName, conversionApi );\n\n\t\tif ( !viewData ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\n\t\t\tif ( element.is( 'containerElement' ) ) {\n\t\t\t\tremoveMarkerFromAttribute( `data-${ viewData.group }-start-before`, element );\n\t\t\t\tremoveMarkerFromAttribute( `data-${ viewData.group }-start-after`, element );\n\t\t\t\tremoveMarkerFromAttribute( `data-${ viewData.group }-end-before`, element );\n\t\t\t\tremoveMarkerFromAttribute( `data-${ viewData.group }-end-after`, element );\n\t\t\t} else {\n\t\t\t\tconversionApi.writer.clear( conversionApi.writer.createRangeOn( element ), element );\n\t\t\t}\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\n\t\tfunction removeMarkerFromAttribute( attributeName, element ) {\n\t\t\tif ( element.hasAttribute( attributeName ) ) {\n\t\t\t\tconst markerNames = new Set( element.getAttribute( attributeName ).split( ',' ) );\n\t\t\t\tmarkerNames.delete( viewData.name );\n\n\t\t\t\tif ( markerNames.size == 0 ) {\n\t\t\t\t\tconversionApi.writer.removeAttribute( attributeName, element );\n\t\t\t\t} else {\n\t\t\t\t\tconversionApi.writer.setAttribute( attributeName, Array.from( markerNames ).join( ',' ), element );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\nfunction changeAttribute( attributeCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst oldAttribute = attributeCreator( data.attributeOldValue, conversionApi );\n\t\tconst newAttribute = attributeCreator( data.attributeNewValue, conversionApi );\n\n\t\tif ( !oldAttribute && !newAttribute ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n\t\t// Only elements can have attributes in a view so do not proceed for anything else (#1587).\n\t\tif ( !viewElement ) {\n\t\t\t/**\n\t\t\t * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n\t\t\t * by {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n\t\t\t * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t\t\t *\t\t\tmodel: 'attribute-name',\n\t\t\t *\t\t\tview: 'attribute-name'\n\t\t\t *\t\t} ) );\n\t\t\t *\n\t\t\t * and given attribute is used on text node, for example:\n\t\t\t *\n\t\t\t *\t\tmodel.change( writer => {\n\t\t\t *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n\t\t\t * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n\t\t\t * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n\t\t\t * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t\t\t *\t\t\tmodel: {\n\t\t\t *\t\t\t\tkey: 'attribute-name',\n\t\t\t *\t\t\t\tname: '$text'\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tview: ( value, { writer } ) => {\n\t\t\t *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tconverterPriority: 'high'\n\t\t\t *\t\t} ) );\n\t\t\t *\n\t\t\t * @error conversion-attribute-to-attribute-on-text\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'conversion-attribute-to-attribute-on-text',\n\t\t\t\t[ data, conversionApi ]\n\t\t\t);\n\t\t}\n\n\t\t// First remove the old attribute if there was one.\n\t\tif ( data.attributeOldValue !== null && oldAttribute ) {\n\t\t\tif ( oldAttribute.key == 'class' ) {\n\t\t\t\tconst classes = toArray( oldAttribute.value );\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.removeClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( oldAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( oldAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.removeStyle( key, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.removeAttribute( oldAttribute.key, viewElement );\n\t\t\t}\n\t\t}\n\n\t\t// Then set the new attribute.\n\t\tif ( data.attributeNewValue !== null && newAttribute ) {\n\t\t\tif ( newAttribute.key == 'class' ) {\n\t\t\t\tconst classes = toArray( newAttribute.value );\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.addClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( newAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( newAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.setStyle( key, newAttribute.value[ key ], viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.setAttribute( newAttribute.key, newAttribute.value, viewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightText( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !data.item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) && !data.item.is( '$textProxy' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewElement = createViewElementFromHighlightDescriptor( viewWriter, descriptor );\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), viewElement, viewSelection );\n\t\t} else {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( data.range );\n\t\t\tconst rangeAfterWrap = viewWriter.wrap( viewRange, viewElement );\n\n\t\t\tfor ( const element of rangeAfterWrap.getItems() ) {\n\t\t\t\tif ( element.is( 'attributeElement' ) && element.isSimilar( viewElement ) ) {\n\t\t\t\t\tconversionApi.mapper.bindElementToMarker( element, data.markerName );\n\n\t\t\t\t\t// One attribute element is enough, because all of them are bound together by the view writer.\n\t\t\t\t\t// Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightElement( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !data.item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelElement ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.test( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\n\t\tif ( viewElement && viewElement.getCustomProperty( 'addHighlight' ) ) {\n\t\t\t// Consume element itself.\n\t\t\tconversionApi.consumable.consume( data.item, evt.name );\n\n\t\t\t// Consume all children nodes.\n\t\t\tfor ( const value of ModelRange._createIn( data.item ) ) {\n\t\t\t\tconversionApi.consumable.consume( value.item, evt.name );\n\t\t\t}\n\n\t\t\tviewElement.getCustomProperty( 'addHighlight' )( viewElement, descriptor, conversionApi.writer );\n\n\t\t\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction removeHighlight( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// This conversion makes sense only for non-collapsed range.\n\t\tif ( data.markerRange.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// View element that will be used to unwrap `AttributeElement`s.\n\t\tconst viewHighlightElement = createViewElementFromHighlightDescriptor( conversionApi.writer, descriptor );\n\n\t\t// Get all elements bound with given marker name.\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tconversionApi.writer.unwrap( conversionApi.writer.createRangeOn( element ), viewHighlightElement );\n\t\t\t} else {\n\t\t\t\t// if element.is( 'containerElement' ).\n\t\t\t\telement.getCustomProperty( 'removeHighlight' )( element, descriptor.id, conversionApi.writer );\n\t\t\t}\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\t};\n}\n\n// Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view\n// @param {Object} [config.triggerBy]\n// @param {Array.<String>} [config.triggerBy.attributes]\n// @param {Array.<String>} [config.triggerBy.children]\n// @returns {Function} Conversion helper.\nfunction downcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = normalizeToElementConfig( config.view, 'container' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'insert:' + config.model, insertElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\n\t\tif ( config.triggerBy ) {\n\t\t\tif ( config.triggerBy.attributes ) {\n\t\t\t\tfor ( const attributeKey of config.triggerBy.attributes ) {\n\t\t\t\t\tdispatcher._mapReconversionTriggerEvent( config.model, `attribute:${ attributeKey }:${ config.model }` );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( config.triggerBy.children ) {\n\t\t\t\tfor ( const childName of config.triggerBy.children ) {\n\t\t\t\t\tdispatcher._mapReconversionTriggerEvent( config.model, `insert:${ childName }` );\n\t\t\t\t\tdispatcher._mapReconversionTriggerEvent( config.model, `remove:${ childName }` );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n// that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view attribute element. If `config.model.values` is\n// given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = normalizeToElementConfig( config.view[ modelValue ], 'attribute' );\n\t\t}\n\t} else {\n\t\tconfig.view = normalizeToElementConfig( config.view, 'attribute' );\n\t}\n\n\tconst elementCreator = getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, wrap( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n// the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n// array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = normalizeToAttributeConfig( config.view[ modelValue ] );\n\t\t}\n\t} else {\n\t\tconfig.view = normalizeToAttributeConfig( config.view );\n\t}\n\n\tconst elementCreator = getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, changeAttribute( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = normalizeToElementConfig( config.view, 'ui' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, insertUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to view data conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToData `markerToData()` downcast helper} to learn more.\n//\n// @param {Object} config\n// @param {String} config.model\n// @param {Function} [config.view]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToData( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst group = config.model;\n\n\t// Default conversion.\n\tif ( !config.view ) {\n\t\tconfig.view = markerName => ( {\n\t\t\tgroup,\n\t\t\tname: markerName.substr( config.model.length + 1 )\n\t\t} );\n\t}\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + group, insertMarkerData( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + group, removeMarkerData( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToHighlight( config ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightText( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeHighlight( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\nfunction normalizeToElementConfig( view, viewElementType ) {\n\tif ( typeof view == 'function' ) {\n\t\t// If `view` is already a function, don't do anything.\n\t\treturn view;\n\t}\n\n\treturn ( modelData, conversionApi ) => createViewElementFromDefinition( view, conversionApi, viewElementType );\n}\n\n// Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\nfunction createViewElementFromDefinition( viewElementDefinition, conversionApi, viewElementType ) {\n\tif ( typeof viewElementDefinition == 'string' ) {\n\t\t// If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n\t\tviewElementDefinition = { name: viewElementDefinition };\n\t}\n\n\tlet element;\n\tconst viewWriter = conversionApi.writer;\n\tconst attributes = Object.assign( {}, viewElementDefinition.attributes );\n\n\tif ( viewElementType == 'container' ) {\n\t\telement = viewWriter.createContainerElement( viewElementDefinition.name, attributes );\n\t} else if ( viewElementType == 'attribute' ) {\n\t\tconst options = {\n\t\t\tpriority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n\t\t};\n\n\t\telement = viewWriter.createAttributeElement( viewElementDefinition.name, attributes, options );\n\t} else {\n\t\t// 'ui'.\n\t\telement = viewWriter.createUIElement( viewElementDefinition.name, attributes );\n\t}\n\n\tif ( viewElementDefinition.styles ) {\n\t\tconst keys = Object.keys( viewElementDefinition.styles );\n\n\t\tfor ( const key of keys ) {\n\t\t\tviewWriter.setStyle( key, viewElementDefinition.styles[ key ], element );\n\t\t}\n\t}\n\n\tif ( viewElementDefinition.classes ) {\n\t\tconst classes = viewElementDefinition.classes;\n\n\t\tif ( typeof classes == 'string' ) {\n\t\t\tviewWriter.addClass( classes, element );\n\t\t} else {\n\t\t\tfor ( const className of classes ) {\n\t\t\t\tviewWriter.addClass( className, element );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn element;\n}\n\nfunction getFromAttributeCreator( config ) {\n\tif ( config.model.values ) {\n\t\treturn ( modelAttributeValue, conversionApi ) => {\n\t\t\tconst view = config.view[ modelAttributeValue ];\n\n\t\t\tif ( view ) {\n\t\t\t\treturn view( modelAttributeValue, conversionApi );\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\t} else {\n\t\treturn config.view;\n\t}\n}\n\n// Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\nfunction normalizeToAttributeConfig( view ) {\n\tif ( typeof view == 'string' ) {\n\t\treturn modelAttributeValue => ( { key: view, value: modelAttributeValue } );\n\t} else if ( typeof view == 'object' ) {\n\t\t// { key, value, ... }\n\t\tif ( view.value ) {\n\t\t\treturn () => view;\n\t\t}\n\t\t// { key, ... }\n\t\telse {\n\t\t\treturn modelAttributeValue => ( { key: view.key, value: modelAttributeValue } );\n\t\t}\n\t} else {\n\t\t// function.\n\t\treturn view;\n\t}\n}\n\n// Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\nfunction prepareDescriptor( highlightDescriptor, data, conversionApi ) {\n\t// If passed descriptor is a creator function, call it. If not, just use passed value.\n\tconst descriptor = typeof highlightDescriptor == 'function' ?\n\t\thighlightDescriptor( data, conversionApi ) :\n\t\thighlightDescriptor;\n\n\tif ( !descriptor ) {\n\t\treturn null;\n\t}\n\n\t// Apply default descriptor priority.\n\tif ( !descriptor.priority ) {\n\t\tdescriptor.priority = 10;\n\t}\n\n\t// Default descriptor id is marker name.\n\tif ( !descriptor.id ) {\n\t\tdescriptor.id = data.markerName;\n\t}\n\n\treturn descriptor;\n}\n\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */\n"]}]}